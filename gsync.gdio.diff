diff --git a/.AF051611.employee-wifi.rwc.corp.imvu.com.rc b/.AF051611.employee-wifi.rwc.corp.imvu.com.rc
new file mode 100644
diff --git a/.AF051611.employee-wired.rwc.corp.imvu.com.rc b/.AF051611.employee-wired.rwc.corp.imvu.com.rc
new file mode 100755
diff --git a/.AF051611.employee-wired.rwc.corp.imvu.com.theanorc b/.AF051611.employee-wired.rwc.corp.imvu.com.theanorc
new file mode 100644
--- /dev/null
+++ ./.AF051611.employee-wired.rwc.corp.imvu.com.theanorc
@@ -0,0 +1,7 @@
+[global]
+force_device = False
+device = cpu
+floatX = float32
+
+[cuda]
+root = /usr/local/cuda
diff --git a/.AF051611.local.rc b/.AF051611.local.rc
new file mode 100755
diff --git a/.AF052245.rc b/.AF052245.rc
new file mode 100644
--- /dev/null
+++ ./.AF052245.rc
@@ -0,0 +1,2 @@
+eval `ssh-agent -s`
+ssh-add /Users/yhuang/.ssh/github_id_rsa
diff --git a/.AF052336.rc b/.AF052336.rc
new file mode 100644
--- /dev/null
+++ ./.AF052336.rc
@@ -0,0 +1,3 @@
+eval `ssh-agent -s`
+ssh-add /Users/yhuang/.ssh/github_id_rsa
+~/loadrc/setup_pbpaste-remote.sh
diff --git a/.COH-LC172TVQ6J.rc b/.COH-LC172TVQ6J.rc
new file mode 100644
--- /dev/null
+++ ./.COH-LC172TVQ6J.rc
@@ -0,0 +1,2 @@
+eval `ssh-agent -s`
+ssh-add /Users/ying.huang/.ssh/id_rsa
diff --git a/.MacPro.rc b/.MacPro.rc
new file mode 100755
--- /dev/null
+++ ./.MacPro.rc
@@ -0,0 +1,2 @@
+#!/bin/zsh
+alias restartWifi='$HOME/loadrc/osxrc/restart_wifi.sh'
diff --git a/.MacPro.theanorc b/.MacPro.theanorc
new file mode 100644
--- /dev/null
+++ ./.MacPro.theanorc
@@ -0,0 +1,7 @@
+[global]
+force_device = False
+device = cpu
+floatX = float32
+
+[cuda]
+root = /usr/local/cuda
diff --git a/.androidrc b/.androidrc
deleted file mode 100644
--- ./.androidrc
+++ /dev/null
@@ -1,2 +0,0 @@
-export PATH="$HOME/Android/sdk/tools:$PATH"
-export PATH="$HOME/Android/sdk/platform-tools:$PATH"
diff --git a/.bashrc b/.bashrc
new file mode 100644
--- /dev/null
+++ ./.bashrc
@@ -0,0 +1,150 @@
+# ~/.bashrc: executed by bash(1) for non-login shells.
+# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
+# for examples
+
+# If not running interactively, don't do anything
+[ -z "$PS1" ] && return
+
+# don't put duplicate lines in the history. See bash(1) for more options
+# ... or force ignoredups and ignorespace
+HISTCONTROL=ignoredups:ignorespace
+
+# append to the history file, don't overwrite it
+shopt -s histappend
+
+# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
+HISTSIZE=1000
+HISTFILESIZE=2000
+
+# check the window size after each command and, if necessary,
+# update the values of LINES and COLUMNS.
+shopt -s checkwinsize
+
+# make less more friendly for non-text input files, see lesspipe(1)
+
+[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"
+
+# set variable identifying the chroot you work in (used in the prompt below)
+if [ -z "$debian_chroot" ] && [ -r /etc/debian_chroot ]
+then
+    debian_chroot=$(cat /etc/debian_chroot)
+fi
+
+# set a fancy prompt (non-color, unless we know we "want" color)
+case "$TERM" in
+    xterm-color) color_prompt=yes;;
+esac
+
+# uncomment for a colored prompt, if the terminal has the capability; turned
+# off by default to not distract the user: the focus in a terminal window
+# should be on the output of commands, not on the prompt
+#force_color_prompt=yes
+
+if [ -n "$force_color_prompt" ]
+then
+    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
+        # We have color support; assume it's compliant with Ecma-48
+        # (ISO/IEC-6429). (Lack of such support is extremely rare, and such
+        # a case would tend to support setf rather than setaf.)
+        color_prompt=yes
+    else
+        color_prompt=
+    fi
+fi
+
+if [ "$color_prompt" = yes ]
+then
+    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
+else
+    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
+fi
+unset color_prompt force_color_prompt
+
+# If this is an xterm set the title to user@host:dir
+case "$TERM" in
+    xterm*|rxvt*)
+        PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME}: ${PWD/$HOME/~}\007"'
+        PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
+        ;;
+    *)
+        ;;
+esac
+
+# enable color support of ls and also add handy aliases
+if [ -x /usr/bin/dircolors ]
+then
+    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
+    alias ls='ls --color=auto'
+    #alias dir='dir --color=auto'
+    #alias vdir='vdir --color=auto'
+fi
+
+
+# Alias definitions.
+# You may want to put all your additions into a separate file like
+# ~/.bash_aliases, instead of adding them here directly.
+# See /usr/share/doc/bash-doc/examples in the bash-doc package.
+
+# enable color support of ls and also add handy aliases
+if [ "$TERM" != "dumb" ]
+then
+    eval "`dircolors -b`"
+    alias ls='ls --color=auto'
+    #alias dir='ls --color=auto --format=vertical'
+    #alias vdir='ls --color=auto --format=long'
+fi
+
+# enable programmable completion features (you don't need to enable
+# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
+# sources /etc/bash.bashrc).
+#if [ -f /etc/bash_completion ]
+#then
+#    . /etc/bash_completion
+#fi
+SSH_ENV="$HOME/.ssh/environment"
+
+function start_agent {
+    echo "Initializing new SSH agent..."
+    /usr/bin/ssh-agent | sed 's/^echo/#echo/' > "${SSH_ENV}"
+    echo succeeded
+    chmod 600 "${SSH_ENV}"
+    . "${SSH_ENV}" > /dev/null
+    /usr/bin/ssh-add;
+}
+
+# Source SSH settings, if applicable
+if [ -f "${SSH_ENV}" ]
+then
+    . "${SSH_ENV}" > /dev/null
+    #ps ${SSH_AGENT_PID} doesn't work under cywgin
+    ps -ef | grep ${SSH_AGENT_PID} | grep ssh-agent$ > /dev/null || {
+        start_agent;
+}
+else
+    start_agent;
+fi
+
+#alias for git
+if [ -f ~/.bash_aliases ]
+then
+    . ~/.bash_aliases
+fi
+
+# enable programmable completion features (you don't need to enable
+# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
+# sources /etc/bash.bashrc).
+#if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
+#    . /etc/bash_completion
+#fi
+
+if [ -f ~/.bash_aliases ]
+then
+    . ~/.bash_aliases
+fi
+
+# enable programmable completion features (you don't need to enable
+# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
+# sources /etc/bash.bashrc).
+#if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
+#    . /etc/bash_completion
+#fi
diff --git a/.cohesityrc b/.cohesityrc
new file mode 100644
--- /dev/null
+++ ./.cohesityrc
@@ -0,0 +1,21 @@
+#GO settings for cohesity
+export REPO=restricted
+export SOFTWARE_VERSION=6.5
+export TC_BASE="/home/cohesity/software/toolchain/x86_64-linux"
+export TOP=$HOME/workspace
+export GOROOT=$TC_BASE/$SOFTWARE_VERSION/golang/go
+export GOBIN=$GOROOT/bin
+export GOPATH=$TOP/$REPO/.go:$TOP/$REPO/build/.go:$TOP/$REPO/qa/lib/go_from_protos
+
+GOLANGDIR=$TC_BASE/$SOFTWARE_VERSION/golang
+for dir in `ls $GOLANGDIR`;
+do
+  # GOROOT should not be part of GOPATH. Intellij complains.
+  if [ "$GOLANGDIR/$dir" != "$GOROOT" ]; then
+    export GOPATH=$GOPATH:$GOLANGDIR/$dir
+  fi
+done
+export PATH=$GOBIN:$PATH:$TC_BASE/$SOFTWARE_VERSION/bin
+export CGO_CFLAGS="-I$TOP/$REPO -I$TOP/$REPO/build"
+
+GO3RDPARTY=$TC_BASE/$TC_VERSION/golang/go-martini:$TC_BASE/$TC_VERSION/golang/go-gorilla:$TC_BASE/$TC_VERSION/golang/termbox-go:$TC_BASE/$TC_VERSION/golang/elastigo:$TC_BASE/$TC_VERSION/golang/go-inject
diff --git a/.config/git/gitk b/.config/git/gitk
new file mode 100644
--- /dev/null
+++ ./.config/git/gitk
@@ -0,0 +1,63 @@
+set mainfont {{Lucida Grande} 20}
+set textfont {Monaco 20}
+set uifont {{Lucida Grande} 9 bold}
+set tabstop 8
+set findmergefiles 0
+set maxgraphpct 50
+set maxwidth 16
+set cmitmode patch
+set wrapcomment none
+set autoselect 1
+set autosellen 40
+set showneartags 1
+set maxrefs 20
+set visiblerefs {"master"}
+set hideremotes 0
+set showlocalchanges 1
+set datetimeformat {%Y-%m-%d %H:%M:%S}
+set limitdiffs 1
+set uicolor grey85
+set want_ttk 1
+set bgcolor white
+set fgcolor black
+set uifgcolor black
+set uifgdisabledcolor #999
+set colors {green red blue magenta darkgrey brown orange}
+set diffcolors {red "#00a000" blue}
+set mergecolors {red blue green purple brown "#009090" magenta "#808000" "#009000" "#ff0080" cyan "#b07070" "#70b0f0" "#70f0b0" "#f0b070" "#ff70b0"}
+set markbgcolor #e0e0ff
+set diffcontext 3
+set selectbgcolor gray85
+set foundbgcolor yellow
+set currentsearchhitbgcolor orange
+set extdifftool kdiff3
+set perfile_attrs 0
+set headbgcolor green
+set headfgcolor black
+set headoutlinecolor black
+set remotebgcolor #ffddaa
+set tagbgcolor yellow
+set tagfgcolor black
+set tagoutlinecolor black
+set reflinecolor black
+set filesepbgcolor #aaaaaa
+set filesepfgcolor black
+set linehoverbgcolor #ffff80
+set linehoverfgcolor black
+set linehoveroutlinecolor black
+set mainheadcirclecolor yellow
+set workingfilescirclecolor red
+set indexcirclecolor green
+set circlecolors {white blue gray blue blue}
+set linkfgcolor blue
+set circleoutlinecolor black
+set geometry(main) 2560x1390+0+24
+set geometry(state) zoomed
+set geometry(topwidth) 2560
+set geometry(topheight) 502
+set geometry(pwsash0) "1929 1"
+set geometry(pwsash1) "2296 1"
+set geometry(botwidth) 1434
+set geometry(botheight) 883
+set permviews {}
+set ignorespace 1
diff --git a/.config/nvim/init.vim b/.config/nvim/init.vim
new file mode 100644
--- /dev/null
+++ ./.config/nvim/init.vim
@@ -0,0 +1,3 @@
+set runtimepath^=~/.vim runtimepath+=~/.vim/after
+let &packpath = &runtimepath
+source ~/.vimrc
diff --git a/.dockerignore b/.dockerignore
new file mode 100644
--- /dev/null
+++ ./.dockerignore
@@ -0,0 +1,9 @@
+**.cache
+**.deps
+**/*.bak
+**/*.class
+**/*.diff
+**/*.findresult
+**/*.git**
+**/*.runresult
+**/*.tmp
diff --git a/.dockerrc b/.dockerrc
new file mode 100644
--- /dev/null
+++ ./.dockerrc
@@ -0,0 +1,8 @@
+#alias for docker
+alias cdocker='$HOME/loadrc/dockerrc/cdocker.sh'
+alias cleanDocker='$HOME/loadrc/dockerrc/cleandocker.sh'
+alias dlogs='$HOME/loadrc/dockerrc/dlogs.sh'
+alias dodev='$HOME/loadrc/dockerrc/dockerdev.sh'
+alias edocker='$HOME/loadrc/dockerrc/edocker.sh'
+alias idocker='$HOME/loadrc/dockerrc/idocker.sh'
+alias killDockers='$HOME/loadrc/dockerrc/killDockers.sh'
diff --git a/.envrc b/.envrc
--- ./.envrc
+++ ./.envrc
@@ -1,44 +1,26 @@
-HERITRIX_HOME=/opt/heritrix-1.14.4/
-#JAVA_OPTS=-Xmx1024M
-#JAVA_HOME=/usr/lib/jvm/java-6-openjdk/jre/bin/java
-#CLASSPATH=/media/volgrp/myproject/git/java/lucene/lucene-3.0.1/lucene-core-3.0.1.jar:/media/volgrp/myproject/git/java/lucene/lucene-3.0.1/lucene-demos-3.0.1.jar:/media/volgrp/myproject/git/webapps/luceneweb/WEB-INF/lib/lucene-core-3.0.1.jar:/media/volgrp/myproject/git/webapps/luceneweb/WEB-INF/lib/lucene-demos-3.0.1.jar
-#export CLASSPATH
-
-export GREP_OPTIONS='--color=auto'
-export CLICOLOR=1
-export LSCOLORS=Exfxcxdxbxegedabagacad
-export GREP_COLOR='1;31'
-export  CVSROOT=:pserver:yhuang@cvssrv:/cvs/CVS
-set -o vi
-shopt -s dotglob
+#!/bin/zsh
 
+if [ $(uname) = "Linux" ]
+then
+    export JAVA_HOME=$(readlink -f /usr/bin/javac | sed "s:bin/javac::")
+    . $HOME/loadrc/mdadmrc/check_raid.sh
+fi
 
-#export ACE_PATH=/pcc/lsfqa-trusted/soam_ext/ACE/com_platform_ACE_544_01/lib
-#export ANT_HOME=/pcc/app/apache-ant-1.6.0
-#export DOC_PATH=/pcc/id_trusted/publish/cloud/naegling2.0
-#export DisableJUnit=true
-#export JAVA_HOME=/pcc/lsfqa-trusted/3rdparty/jdk/1.5.0_08/linux-x86
-#export PATH=$JAVA_HOME/bin:$ANT_HOME/bin:$PATH
-#export EGO_SHARED_DIR=cloud_ISF_SS_POC_DROP_4
-#export GUI_TAR_DIR=/pcc/lsfqa-trusted/VMO_ext/vmo_monte/gui
-#export RTM_ADD_ON=/pcc/lsfqa-trusted/rtm_ext/shared/2_0_SS_POC
-#export VMO_MONTE_SHARE_DIR=/pcc/lsfqa-trusted/vmo_monte_ext/shared
-#export MOZILLA_FIVE_HOME=/usr/bin/mozilla
-#JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64/
+RMDISABLE=$HOME/loadrc/."`hostname`".rm.disable
 
-export TZ='America/Los_Angeles';
-export LANGUAGE="en_US:en"
-OS=`uname`
-if [ $OS == "Linux" ]
+if [ -f ${RMDISABLE} ];
 then
-  export JAVA_HOME=$(readlink -f /usr/bin/javac | sed "s:bin/javac::")
-  xmodmap -e "keycode 127 = Menu"
+    alias rm='echo'
 fi
-. $HOME/bashrc/check_raid.sh
+
 export AUTOSSH_POLL=1
-export PATH=~/bin:$PATH
-export HISTCONTROL=ignoreboth:erasedups
-export HISTFILESIZE=
-export HISTSIZE=
-shopt -s histappend
-PROMPT_COMMAND='history -a'
+export CLICOLOR=1
+export EDITOR="nvim"
+export GREP_COLOR='1;31'
+export LANG="en_US.UTF-8"
+export LANGUAGE="en_US:en"
+export LC_ALL="en_US.UTF-8"
+export LSCOLORS=Exfxcxdxbxegedabagacad
+export NC='\033[0;0m' # No Color
+export green='\033[0;32m'
+export red='\033[0;31m'
diff --git a/.gitattributes b/.gitattributes
new file mode 100644
--- /dev/null
+++ ./.gitattributes
@@ -0,0 +1 @@
+.subversion/README.txt  diff=nodiff
diff --git a/.gitconfig_sample b/.gitconfig_sample
new file mode 100644
--- /dev/null
+++ ./.gitconfig_sample
@@ -0,0 +1,19 @@
+[remote "authorVar"]
+    url = urlVar
+    fetch = +refs/heads/*:refs/remotes/authorVar/*
+[remote "origin"]
+    url = git@github.com:huangyingw/repoVar.git
+    fetch = +refs/heads/*:refs/remotes/origin/*
+[push]
+    remote = origin
+[gsync]
+    remote = authorVar
+    target = authorVar/branchVar
+[branch "dev"]
+    remote = origin
+    merge = refs/heads/dev
+[branch "master"]
+    remote = origin
+    merge = refs/heads/master
+[gdif]
+    ignore = *.gdio.diff
diff --git a/.gitignore b/.gitignore
new file mode 100644
--- /dev/null
+++ ./.gitignore
@@ -0,0 +1,21 @@
+*.deb
+*.list
+*.log
+*.pkg
+.passwd
+bashrc/.bash_history
+bashrc/copy_files.log
+bashrc/output
+crontabrc/crontab_file
+files.proj
+gstv.ready
+host_links/ubuntu/home/parallels/.config/smplayer/smplayer.ini
+kvmrc/.ropeproject/
+tmirror.ready
+tosmirror.ready
+var/
+vimrc/.vim/.netrwhist
+vimrc/.vim/autosess/
+vimrc/.vim/spell/en.utf-8.add.spl
+vimrc/.vim/view/
+zerotierrc/crontab_file
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
--- /dev/null
+++ ./.gitmodules
@@ -0,0 +1,269 @@
+[submodule "keys"]
+	path = keys
+	url = git@bitbucket.org:huangyingw/keys.git
+	branch = dev
+[submodule "vimrc/.vim/bundle/swift.vim"]
+	path = vimrc/.vim/bundle/swift.vim
+	url = git@github.com:keith/swift.vim.git
+	branch = master
+[submodule "vimrc/.vim/bundle/indentLine"]
+	path = vimrc/.vim/bundle/indentLine
+	url = git@github.com:Yggdroot/indentLine.git
+	branch = master
+[submodule "vimrc/.vim/bundle/bash-support.vim"]
+	path = vimrc/.vim/bundle/bash-support.vim
+	url = git@bitbucket.org:huangyingw/bash-support.vim.git
+	branch = dev
+[submodule "vimrc/.vim/bundle/vim-docker-compose-syntax"]
+	path = vimrc/.vim/bundle/vim-docker-compose-syntax
+	url = git@github.com:NLKNguyen/vim-docker-compose-syntax.git
+	branch = master
+[submodule "vimrc/.vim/bundle/python-mode"]
+	path = vimrc/.vim/bundle/python-mode
+	url = git@bitbucket.org:huangyingw/python-mode.git
+	branch = dev
+[submodule "vimrc/.vim/bundle/Dockerfile.vim"]
+	path = vimrc/.vim/bundle/Dockerfile.vim
+	url = git@github.com:ekalinin/Dockerfile.vim.git
+	branch = master
+[submodule "vimrc/.vim/bundle/vim-autoformat"]
+	path = vimrc/.vim/bundle/vim-autoformat
+	url = git@bitbucket.org:huangyingw/vim-autoformat.git
+	branch = dev
+[submodule "vimrc/.vim/bundle/vim-gradle"]
+	path = vimrc/.vim/bundle/vim-gradle
+	url = git@github.com:tfnico/vim-gradle.git
+	branch = master
+[submodule "vimrc/.vim/bundle/vim-javascript-syntax"]
+	path = vimrc/.vim/bundle/vim-javascript-syntax
+	url = git@bitbucket.org:huangyingw/vim-javascript-syntax.git
+	branch = dev
+[submodule "vimrc/.vim/bundle/vim-log-syntax"]
+	path = vimrc/.vim/bundle/vim-log-syntax
+	url = git@bitbucket.org:huangyingw/vim-log-syntax.git
+	branch = dev
+[submodule "vimrc/.vim/bundle/vim-rails"]
+	path = vimrc/.vim/bundle/vim-rails
+	url = git@github.com:tpope/vim-rails.git
+	branch = master
+[submodule "vimrc/.vim/bundle/vim-scala"]
+	path = vimrc/.vim/bundle/vim-scala
+	url = git@github.com:derekwyatt/vim-scala.git
+	branch = master
+[submodule "vimrc/.vim/bundle/vundle.vim"]
+	path = vimrc/.vim/bundle/vundle.vim
+	url = git@github.com:VundleVim/Vundle.vim.git
+	branch = master
+[submodule ".ssh"]
+	path = .ssh
+	url = git@bitbucket.org:huangyingw/.ssh.git
+	branch = dev
+[submodule "vimrc/.vim/bundle/delimitMate"]
+	path = vimrc/.vim/bundle/delimitMate
+	url = git@github.com:Raimondi/delimitMate.git
+	branch = master
+[submodule "vimrc/.vim/bundle/vim-anyfold"]
+	path = vimrc/.vim/bundle/vim-anyfold
+	url = git@bitbucket.org:huangyingw/vim-anyfold.git
+	branch = dev
+[submodule "vimrc/.vim/bundle/LargeFile"]
+	path = vimrc/.vim/bundle/LargeFile
+	url = https://github.com/vim-scripts/LargeFile.git
+[submodule "vimrc/.vim/bundle/vim-buffergator"]
+	path = vimrc/.vim/bundle/vim-buffergator
+	url = git@bitbucket.org:huangyingw/vim-buffergator.git
+	branch = dev
+[submodule "vimrc/.vim/bundle/vala.vim"]
+	path = vimrc/.vim/bundle/vala.vim
+	url = git@github.com:arrufat/vala.vim.git
+	branch = master
+[submodule "vimrc/.vim/bundle/asyncrun.vim"]
+	path = vimrc/.vim/bundle/asyncrun.vim
+	url = git@github.com:huangyingw/asyncrun.vim.git
+	branch = dev
+[submodule "vimrc/.vim/bundle/nvim-yarp"]
+	path = vimrc/.vim/bundle/nvim-yarp
+	url = https://github.com/roxma/nvim-yarp.git
+	branch = master
+[submodule "vimrc/.vim/bundle/ncm2"]
+	path = vimrc/.vim/bundle/ncm2
+	url = https://github.com/ncm2/ncm2.git
+	branch = master
+[submodule "vimrc/.vim/bundle/ncm2-bufword"]
+	path = vimrc/.vim/bundle/ncm2-bufword
+	url = https://github.com/ncm2/ncm2-bufword.git
+	branch = master
+[submodule "vimrc/.vim/bundle/ncm2-path"]
+	path = vimrc/.vim/bundle/ncm2-path
+	url = https://github.com/ncm2/ncm2-path.git
+	branch = master
+[submodule "vimrc/.vim/bundle/ncm2-github"]
+	path = vimrc/.vim/bundle/ncm2-github
+	url = https://github.com/ncm2/ncm2-github.git
+	branch = master
+[submodule "vimrc/.vim/bundle/ncm2-tmux"]
+	path = vimrc/.vim/bundle/ncm2-tmux
+	url = https://github.com/ncm2/ncm2-tmux.git
+	branch = master
+[submodule "vimrc/.vim/bundle/ncm2-tagprefix"]
+	path = vimrc/.vim/bundle/ncm2-tagprefix
+	url = https://github.com/ncm2/ncm2-tagprefix.git
+	branch = master
+[submodule "vimrc/.vim/bundle/ncm2-look.vim"]
+	path = vimrc/.vim/bundle/ncm2-look.vim
+	url = https://github.com/filipekiss/ncm2-look.vim.git
+	branch = master
+[submodule "vimrc/.vim/bundle/ncm2-syntax"]
+	path = vimrc/.vim/bundle/ncm2-syntax
+	url = https://github.com/ncm2/ncm2-syntax
+	branch = master
+[submodule "vimrc/.vim/bundle/ncm2-neoinclude"]
+	path = vimrc/.vim/bundle/ncm2-neoinclude
+	url = https://github.com/ncm2/ncm2-neoinclude
+	branch = master
+[submodule "vimrc/.vim/bundle/ncm2-cssomni"]
+	path = vimrc/.vim/bundle/ncm2-cssomni
+	url = https://github.com/ncm2/ncm2-cssomni
+	branch = master
+[submodule "vimrc/.vim/bundle/ncm2-jedi"]
+	path = vimrc/.vim/bundle/ncm2-jedi
+	url = https://github.com/ncm2/ncm2-jedi
+	branch = master
+[submodule "vimrc/.vim/bundle/ncm2-racer"]
+	path = vimrc/.vim/bundle/ncm2-racer
+	url = https://github.com/ncm2/ncm2-racer
+	branch = master
+[submodule "vimrc/.vim/bundle/vimtex"]
+	path = vimrc/.vim/bundle/vimtex
+	url = https://github.com/lervag/vimtex
+	branch = master
+[submodule "vimrc/.vim/bundle/ncm2-vim"]
+	path = vimrc/.vim/bundle/ncm2-vim
+	url = https://github.com/ncm2/ncm2-vim
+	branch = master
+[submodule "vimrc/.vim/bundle/ncm2-go"]
+	path = vimrc/.vim/bundle/ncm2-go
+	url = https://github.com/ncm2/ncm2-go
+	branch = master
+[submodule "vimrc/.vim/bundle/ncm2-snipmate"]
+	path = vimrc/.vim/bundle/ncm2-snipmate
+	url = https://github.com/ncm2/ncm2-snipmate.git
+	branch = master
+[submodule "vimrc/.vim/bundle/ncm2-html-subscope"]
+	path = vimrc/.vim/bundle/ncm2-html-subscope
+	url = https://github.com/ncm2/ncm2-html-subscope.git
+	branch = master
+[submodule "vimrc/.vim/bundle/ncm2-markdown-subscope"]
+	path = vimrc/.vim/bundle/ncm2-markdown-subscope
+	url = https://github.com/ncm2/ncm2-markdown-subscope.git
+	branch = master
+[submodule "vimrc/.vim/bundle/ncm2-rst-subscope"]
+	path = vimrc/.vim/bundle/ncm2-rst-subscope
+	url = https://github.com/ncm2/ncm2-rst-subscope.git
+	branch = master
+[submodule "vimrc/.vim/bundle/ncm2-match-highlight"]
+	path = vimrc/.vim/bundle/ncm2-match-highlight
+	url = https://github.com/ncm2/ncm2-match-highlight
+	branch = master
+[submodule "vimrc/.vim/bundle/ncm2-highprio-pop"]
+	path = vimrc/.vim/bundle/ncm2-highprio-pop
+	url = https://github.com/ncm2/ncm2-highprio-pop
+	branch = master
+[submodule "vimrc/.vim/bundle/tlib_vim"]
+	path = vimrc/.vim/bundle/tlib_vim
+	url = git@github.com:tomtom/tlib_vim.git
+	branch = master
+[submodule "vimrc/.vim/bundle/vim-addon-mw-utils"]
+	path = vimrc/.vim/bundle/vim-addon-mw-utils
+	url = git@github.com:marcweber/vim-addon-mw-utils.git
+	branch = master
+[submodule "vimrc/.vim/bundle/vim-snipmate"]
+	path = vimrc/.vim/bundle/vim-snipmate
+	url = git@github.com:huangyingw/vim-snipmate.git
+[submodule "vimrc/.vim/bundle/neco-syntax"]
+	path = vimrc/.vim/bundle/neco-syntax
+	url = git@github.com:Shougo/neco-syntax.git
+	branch = master
+[submodule "cscope"]
+	path = cscope
+	url = git@github.com:huangyingw/cscope.git
+	branch = dev
+[submodule "jdupes"]
+	path = jdupes
+	url = git@github.com:huangyingw/jdupes.git
+	branch = dev
+[submodule "vimrc/.vim/bundle/neoinclude.vim"]
+	path = vimrc/.vim/bundle/neoinclude.vim
+	url = git@github.com:Shougo/neoinclude.vim.git
+	branch = master
+[submodule "vimrc/.vim/bundle/vim-fugitive"]
+	path = vimrc/.vim/bundle/vim-fugitive
+	url = git@bitbucket.org:huangyingw/vim-fugitive.git
+	branch = dev
+[submodule "vimrc/.vim/bundle/split-term.vim"]
+	path = vimrc/.vim/bundle/split-term.vim
+	url = git@bitbucket.org:huangyingw/split-term.vim.git
+	branch = dev
+[submodule "vimrc/.vim/bundle/neco-vim"]
+	path = vimrc/.vim/bundle/neco-vim
+	url = git@github.com:Shougo/neco-vim.git
+	branch = master
+[submodule "vimrc/.vim/bundle/ncm2-otherbuf"]
+	path = vimrc/.vim/bundle/ncm2-otherbuf
+	url = https://github.com/fgrsnau/ncm2-otherbuf.git
+	branch = master
+[submodule "vimrc/.vim/bundle/vim-pdf"]
+	path = vimrc/.vim/bundle/vim-pdf
+	url = https://github.com/makerj/vim-pdf.git
+	branch = master
+[submodule "oh-my-zsh"]
+	path = oh-my-zsh
+	url = git@github.com:huangyingw/oh-my-zsh.git
+	branch = dev
+[submodule "vimrc/.vim/bundle/tig-explorer.vim"]
+	path = vimrc/.vim/bundle/tig-explorer.vim
+	url = git@github.com:huangyingw/tig-explorer.vim.git
+	branch = dev
+[submodule "vimrc/.vim/bundle/bclose.vim"]
+	path = vimrc/.vim/bundle/bclose.vim
+	url = git@github.com:rbgrouleff/bclose.vim.git
+[submodule "vimrc/.vim/bundle/vim-pbcopy"]
+	path = vimrc/.vim/bundle/vim-pbcopy
+	url = git@github.com:huangyingw/vim-pbcopy.git
+[submodule "neovim"]
+	path = neovim
+	url = git@github.com:huangyingw/neovim.git
+[submodule "vimrc/.vim/bundle/vim-fetch"]
+	path = vimrc/.vim/bundle/vim-fetch
+	url = git@github.com:huangyingw/vim-fetch.git
+	branch = OpenOrSwitch
+[submodule "wifi-auto-reconnect"]
+	path = wifi-auto-reconnect
+	url = git@github.com:huangyingw/martinsoft_wifi-auto-reconnect.git
+[submodule "rsync"]
+	path = rsync
+	url = git@github.com:huangyingw/WayneD_rsync.git
+[submodule "vimrc/.vim/bundle/vim-php-cs-fixer"]
+	path = vimrc/.vim/bundle/vim-php-cs-fixer
+	url = https://github.com/stephpy/vim-php-cs-fixer.git
+[submodule "vimrc/.vim/bundle/cql-vim"]
+	path = vimrc/.vim/bundle/cql-vim
+	url = git@github.com:elubow/cql-vim.git
+[submodule "vimrc/.vim/bundle/plantuml-previewer.vim"]
+	path = vimrc/.vim/bundle/plantuml-previewer.vim
+	url = https://github.com/weirongxu/plantuml-previewer.vim.git
+[submodule "vimrc/.vim/bundle/open-browser.vim"]
+	path = vimrc/.vim/bundle/open-browser.vim
+	url = https://github.com/tyru/open-browser.vim.git
+[submodule "vimrc/.vim/bundle/plantuml-syntax"]
+	path = vimrc/.vim/bundle/plantuml-syntax
+	url = https://github.com/aklt/plantuml-syntax.git
+[submodule "vimrc/.vim/bundle/vim-ghost"]
+	path = vimrc/.vim/bundle/vim-ghost
+	url = git@github.com:raghur/vim-ghost.git
+[submodule "vimrc/.vim/bundle/firenvim"]
+	path = vimrc/.vim/bundle/firenvim
+	url = git@github.com:glacambre/firenvim.git
+[submodule "vimrc/.vim/bundle/vim-ps1"]
+	path = vimrc/.vim/bundle/vim-ps1
+	url = git@github.com:PProvost/vim-ps1.git
diff --git a/.gitrc b/.gitrc
--- ./.gitrc
+++ ./.gitrc
@@ -1,54 +1,50 @@
-#alias for git
-alias fgicb='$HOME/gitrc/fgicb.sh'
-alias fgs='$HOME/gitrc/fgs.sh'
-alias g='$HOME/gitrc/g.sh'
-alias ga='$HOME/gitrc/ga.sh'
-alias gagh='$HOME/gitrc/gagh.sh'
+alias fgicb='$HOME/loadrc/gitrc/fgicb.sh'
+alias fsync='$HOME/loadrc/gitrc/fsync.sh'
+alias g='$HOME/loadrc/gitrc/g.sh'
+alias ga='$HOME/loadrc/gitrc/ga.sh'
 alias gbi='git bisect'
-alias gbib='git bisect bad'
-alias gbig='git bisect good'
-alias gbir='git bisect reset'
-alias gbis='git bisect start'
-alias gbr='git branch'
-alias gbrD='$HOME/gitrc/gbrD.sh'
-alias gbra='git branch -a'
-alias gbrc='git branch --contains'
-alias gbrs='$HOME/gitrc/gbrs.sh'
+alias gbib='$HOME/loadrc/gitrc/gbib.sh'
+alias gbig='$HOME/loadrc/gitrc/gbig.sh'
+alias gbir='$HOME/loadrc/gitrc/gbir.sh'
+alias gbis='$HOME/loadrc/gitrc/gbis.sh'
+alias gbr='$HOME/loadrc/gitrc/gbr.sh'
+alias gbra='$HOME/loadrc/gitrc/gbra.sh'
+alias gbrd='$HOME/loadrc/gitrc/gbrd.sh'
+alias gbrm='$HOME/loadrc/gitrc/gbrm.sh'
 alias gch='git cherry'
 alias gchp='git cherry-pick'
-alias gci='$HOME/gitrc/gci.sh'
-alias gcia='$HOME/gitrc/gcia.sh'
-alias gcim='$HOME/gitrc/gcim.sh'
-alias gcl='$HOME/gitrc/gcl.sh'
-alias gclb='$HOME/gitrc/gclb.sh'
-alias gco='$HOME/gitrc/gco.sh'
-alias gcob='$HOME/gitrc/gcob.sh'
-alias gcof='$HOME/gitrc/gcof.sh'
-alias gcom='$HOME/gitrc/gcom.sh'
-alias gctb='$HOME/gitrc/gctb.sh'
-alias gdi='$HOME/gitrc/gdi.sh'
-alias gdif='$HOME/gitrc/gdif.sh'
+alias gcia='$HOME/loadrc/gitrc/gcia.sh'
+alias gcim='$HOME/loadrc/gitrc/gcim.sh'
+alias gcl='$HOME/loadrc/gitrc/gcl.sh'
+alias gclb='$HOME/loadrc/gitrc/gclb.sh'
+alias gclean='git clean -fd'
+alias gco='$HOME/loadrc/gitrc/gco.sh'
+alias gcob='$HOME/loadrc/gitrc/gcob.sh'
+alias gcof='$HOME/loadrc/gitrc/gcof.sh'
+alias gcom='$HOME/loadrc/gitrc/gcom.sh'
+alias gctb='$HOME/loadrc/gitrc/gctb.sh'
+alias gdev='$HOME/loadrc/gitrc/gdev.sh'
+alias gdi2='$HOME/loadrc/gitrc/gdi2.sh'
+alias gdi='$HOME/loadrc/gitrc/gdi.sh'
+alias gdif='$HOME/loadrc/gitrc/gdif.sh'
+alias gdio='$HOME/loadrc/gitrc/gdio.sh'
+alias gdit='$HOME/loadrc/gitrc/gdit.sh'
 alias gfe='git fetch'
-alias gff='$HOME/gitrc/gff.sh'
-alias gfix='$HOME/gitrc/gfix.sh'
-alias gfvd='$HOME/gitrc/gfvd.sh'
-alias gi='$HOME/gitrc/gi.sh'
-alias gib='$HOME/gitrc/gib.sh'
-alias gicb='$HOME/gitrc/gicb.sh'
+alias gff='$HOME/loadrc/gitrc/gff.sh'
+alias gfix='$HOME/loadrc/gitrc/gfix.sh'
+alias ghypo='~/loadrc/gitrc/ghypo.sh'
+alias gicb='$HOME/loadrc/gitrc/gicb.sh'
+alias gkd='$HOME/loadrc/gitrc/gkd.sh'
 alias glf='git ls-files'
-alias glg='$HOME/gitrc/glg.sh'
+alias glg='$HOME/loadrc/gitrc/glg.sh'
 alias glga='git log --all'
-alias gme2='$HOME/gitrc/gmeto.sh'
-alias gme='git merge'
 alias gmet='git mergetool'
-alias gmfix='$HOME/gitrc/gmfix.sh'
-alias gmup='$HOME/gitrc/gmup.sh'
-alias gpl='$HOME/gitrc/gpl.sh'
-alias gps='$HOME/gitrc/gps.sh'
-alias grc='$HOME/gitrc/grc.sh'
-alias grcr='git rm --cached -r'
+alias gpl='$HOME/loadrc/gitrc/gpl.sh'
+alias gps='$HOME/loadrc/gitrc/gps.sh'
+alias grm='$HOME/loadrc/gitrc/grm.sh'
+alias grmr='git rm --cached -r'
 alias grs='git reset'
-alias grsh='$HOME/gitrc/grsh.sh'
+alias grsh='$HOME/loadrc/gitrc/grsh.sh'
 alias grsm='git reset --mixed'
 alias grss='git reset --soft'
 alias grt='git remote'
@@ -57,20 +53,24 @@ alias grtao='git remote rm origin || git remote add origin'
 alias grtu='git remote update'
 alias grtv='git remote -v'
 alias grv='git revert'
-alias gs='$HOME/gitrc/gs.sh'
-alias gsearch='$HOME/gitrc/gsearch.sh'
-alias gsh='git show'
+alias gs='$HOME/loadrc/gitrc/gs.sh'
+alias gsearch='$HOME/loadrc/gitrc/gsearch.sh'
+alias gsh='$HOME/loadrc/gitrc/gsh.sh'
 alias gsm='git submodule'
-alias gst='git stash'
-alias gsta='git stash apply'
-alias gstd='$HOME/gitrc/gstd.sh'
-alias gstf='$HOME/gitrc/gstf.sh'
-alias gsti='git stash --keep-index'
-alias gstl='git stash list'
-alias gstp='$HOME/gitrc/gstp.sh'
-alias gsts='$HOME/gitrc/gsts.sh'
-alias gsync='$HOME/gitrc/gsync.sh'
-alias gtag='$HOME/gitrc/gtag.sh'
+alias gst='$HOME/loadrc/gitrc/gst.sh'
+alias gsta='$HOME/loadrc/gitrc/gsta.sh'
+alias gstf='$HOME/loadrc/gitrc/gstf.sh'
+alias gsti='$HOME/loadrc/gitrc/gsti.sh'
+alias gstl='$HOME/loadrc/gitrc/gstl.sh'
+alias gstlv='$HOME/loadrc/gitrc/gstlv.sh'
+alias gstp='$HOME/loadrc/gitrc/gstp.sh'
+alias gstv='$HOME/loadrc/gitrc/gstv.sh'
+alias gsubbr='$HOME/loadrc/gitrc/git_submodules_branch.sh'
+alias gsubmodule='$HOME/loadrc/gitrc/git-submodule.sh'
+alias gsync='$HOME/loadrc/gitrc/gsync.sh'
+alias gtag='$HOME/loadrc/gitrc/gtag.sh'
 alias gtg='git tag -l -n1'
-alias gvd='$HOME/gitrc/gvd.sh'
+alias gvd='$HOME/loadrc/gitrc/gvd.sh'
+alias gvlg='$HOME/loadrc/gitrc/gvlg.sh'
+alias gwap='$HOME/loadrc/gitrc/gwap.sh'
 export GIT_MERGE_AUTOEDIT=no
diff --git a/.gorc b/.gorc
new file mode 100644
--- /dev/null
+++ ./.gorc
@@ -0,0 +1 @@
+export GOPATH=$HOME/go
diff --git a/.hgignore b/.hgignore
new file mode 100644
--- /dev/null
+++ ./.hgignore
@@ -0,0 +1,10 @@
+.*.bak
+.*.findresult
+.*.orig
+.*.tmp
+.cscopedb.lock
+.git
+cscope.*
+files.proj
+files.proj*
+running.*
diff --git a/.hgrc b/.hgrc
--- ./.hgrc
+++ ./.hgrc
@@ -0,0 +1,10 @@
+[ui]
+username = Ying Huang <huangyingw@gmail.com>
+ignore = ~/.hgignore
+merge = kdiff3
+[extensions]
+hgext.extdiff =
+[extdiff]
+cmd.vd = kdiff3
+[merge-tools]
+kdiff3.args = $base $local $other -o $output
diff --git a/.imac.rc b/.imac.rc
new file mode 100755
--- /dev/null
+++ ./.imac.rc
@@ -0,0 +1,12 @@
+#!/bin/zsh
+#alias restartWifi='$HOME/loadrc/osxrc/restart_wifi.sh'
+
+if [ $(uname) = "Darwin" ]
+then
+    if ! (sudo systemsetup -getcomputersleep | grep -q Never) ; \
+        then \
+        sudo systemsetup -setcomputersleep Never; \
+        fi
+fi
+
+~/loadrc/wifi-auto-reconnect/install.sh
diff --git a/.imacpro.rc b/.imacpro.rc
new file mode 100644
diff --git a/.kdiff3rc b/.kdiff3rc
new file mode 100644
--- /dev/null
+++ ./.kdiff3rc
@@ -0,0 +1,93 @@
+AutoAdvance=1
+AutoAdvanceDelay=500
+AutoCopySelection=0
+AutoDetectUnicodeA=1
+AutoDetectUnicodeB=1
+AutoDetectUnicodeC=1
+AutoIndentation=1
+AutoMergeRegExp=.*\\$(Version\|Header\|Date\|Author).*\\$.*
+AutoSaveAndQuitOnMergeWithoutConflicts=0
+AutoSelectOutEncoding=1
+BgColor=255,255,255
+BinaryComparison=1
+CaseSensitiveFilenameComparison=1
+ColorA=0,0,200
+ColorB=0,150,0
+ColorC=150,0,150
+ColorForConflict=255,0,0
+CopyNewer=0
+CreateBakFiles=1
+CurrentRangeBgColor=220,220,100
+CurrentRangeDiffBgColor=255,255,150
+Diff3AlignBC=0
+DiffBgColor=224,224,224
+DirAntiPattern=CVS;.deps;.svn;.hg;.git
+EncodingForA=System
+EncodingForB=System
+EncodingForC=System
+EncodingForOutput=System
+EncodingForPP=System
+EscapeKeyQuits=0
+FgColor=0,0,0
+FileAntiPattern=*.orig;*.o;*.obj;*.rej;*.bak
+FilePattern=*
+FindHidden=1
+FollowDirLinks=0
+FollowFileLinks=0
+Font=Courier New,28,normal
+FullAnalysis=0
+Geometry=600,400
+HistoryEntryStartRegExp=\\s*\\\\main\\\\(\\S+)\\s+([0-9]+) (Jan\|Feb\|Mar\|Apr\|May\|Jun\|Jul\|Aug\|Sep\|Oct\|Nov\|Dec) ([0-9][0-9][0-9][0-9]) ([0-9][0-9]:[0-9][0-9]:[0-9][0-9])\\s+(.*)
+HistoryEntryStartSortKeyOrder=4,3,2,5,1,6
+HistoryMergeSorting=0
+HistoryStartRegExp=.*\\$Log.*\\$.*
+HorizDiffWindowSplitting=1
+IgnorableCmdLineOptions=-u;-query;-html;-abort
+IgnoreCase=0
+IgnoreComments=0
+IgnoreNumbers=0
+IrrelevantMergeCmd=
+ItalicForDeltas=0
+Language=Auto
+LineEndStyle=2
+LineMatchingPreProcessorCmd=
+ManualAlignmentRangeColor=255,208,128
+MaxNofHistoryEntries=-1
+MidAgeFileColor=192,192,0
+MissingFileColor=0,0,0
+NewestFileColor=0,208,0
+OldestFileColor=240,0,0
+Position=0,22
+PreProcessorCmd=
+RecentAFiles=
+RecentBFiles=
+RecentCFiles=
+RecentEncodings=
+RecentOutputFiles=
+RecursiveDirs=1
+ReplaceTabs=0
+RightToLeftLanguage=0
+RunHistoryAutoMergeOnMergeStart=0
+RunRegExpAutoMergeOnMergeStart=0
+SameEncoding=1
+Show Statusbar=1
+Show Toolbar=1
+ShowIdenticalFiles=1
+ShowInfoDialogs=1
+ShowLineNumbers=1
+ShowWhiteSpace=0
+ShowWhiteSpaceCharacters=0
+SkipDirStatus=0
+SyncMode=0
+TabSize=8
+TrustDate=0
+TrustDateFallbackToBinary=0
+TrustSize=0
+TryHard=1
+UnfoldSubdirs=0
+UseCvsIgnore=0
+WhiteSpace2FileMergeDefault=0
+WhiteSpace3FileMergeDefault=0
+WhiteSpaceEqual=1
+WindowStateMaximised=1
+WordWrap=1
diff --git a/.kvmrc b/.kvmrc
--- ./.kvmrc
+++ ./.kvmrc
@@ -1,23 +1,27 @@
 #alias for kvm
-alias vclone='$HOME/kvmrc/vclone.sh'
-alias vdestroy='$HOME/kvmrc/vdestroy.sh'
-alias vdisk='$HOME/kvmrc/vdisk.sh' 
-alias vreset='$HOME/kvmrc/vreset.sh' 
-alias vrestore='$HOME/kvmrc/vrestore.sh'
-alias vresume='$HOME/kvmrc/vresume.sh' 
-alias vsave='$HOME/kvmrc/vsave.sh'
-alias vsd='$HOME/kvmrc/vsd.sh' 
-alias vsdx='$HOME/kvmrc/vsdx.sh' 
+alias uvmount='$HOME/loadrc/kvmrc/uvmount.sh' 
+alias vclone='$HOME/loadrc/kvmrc/vclone.sh'
+alias vdestroy='$HOME/loadrc/kvmrc/vdestroy.sh'
+alias vdisk='$HOME/loadrc/kvmrc/vdisk.sh' 
+alias vmdk2qcow2='$HOME/loadrc/kvmrc/vmdk2qcow2.sh'
+alias vmount='$HOME/loadrc/kvmrc/vmount.sh' 
+alias vmsetup='$HOME/loadrc/kvmrc/vmsetup.sh'
+alias vreset='$HOME/loadrc/kvmrc/vreset.sh' 
+alias vrestore='$HOME/loadrc/kvmrc/vrestore.sh'
+alias vresume='$HOME/loadrc/kvmrc/vresume.sh' 
+alias vsave='$HOME/loadrc/kvmrc/vsave.sh'
+alias vsd='$HOME/loadrc/kvmrc/vsd.sh' 
+alias vsdx='$HOME/loadrc/kvmrc/vsdx.sh' 
 alias vse='virsh edit'
-alias vsl='$HOME/kvmrc/vsl.sh'
+alias vshrink='$HOME/loadrc/kvmrc/vshrink.sh'
+alias vsl='$HOME/loadrc/kvmrc/vsl.sh'
 alias vsr='virsh reset'
-alias vss='virsh start'
-alias vssc='$HOME/kvmrc/vssc.sh'
-alias vsscu='$HOME/kvmrc/vsscu.sh'
-alias vssp='$HOME/kvmrc/vssp.sh'
-alias vssd='$HOME/kvmrc/vssd.sh'
-alias vssi='$HOME/kvmrc/vssi.sh'
-alias vssl='virsh snapshot-list --tree'
-alias vssr='$HOME/kvmrc/vssr.sh'
-alias vsuspend='$HOME/kvmrc/vsuspend.sh'
-alias vview='$HOME/kvmrc/vview.sh'
+alias vss='$HOME/loadrc/kvmrc/vss.sh'
+alias vssc='$HOME/loadrc/kvmrc/vssc.sh'
+alias vssd='$HOME/loadrc/kvmrc/vssd.sh'
+alias vssi='$HOME/loadrc/kvmrc/vssi.sh'
+alias vssl='$HOME/loadrc/kvmrc/vssl.sh'
+alias vssp='$HOME/loadrc/kvmrc/vssp.sh'
+alias vssr='$HOME/loadrc/kvmrc/vssr.sh'
+alias vsuspend='$HOME/loadrc/kvmrc/vsuspend.sh'
+alias vview='$HOME/loadrc/kvmrc/vview.sh'
diff --git a/.linb-sandbox.rc b/.linb-sandbox.rc
new file mode 100644
--- /dev/null
+++ ./.linb-sandbox.rc
@@ -0,0 +1,2 @@
+# eval `ssh-agent -s`
+# ssh-add /home/cit/.ssh/github_id_rsa
diff --git a/.lint-sandbox.rc b/.lint-sandbox.rc
new file mode 100644
--- /dev/null
+++ ./.lint-sandbox.rc
@@ -0,0 +1,3 @@
+#mkdir -p /home/cit/BareReps/
+#sshfs work:/Users/yhuang/Dropbox/BareReps/ /home/cit/BareReps/
+#sshfs -o idmap=user work:/Users/yhuang/website/ /home/cit/imvu/website-project/website
diff --git a/.loadrc b/.loadrc
new file mode 100755
--- /dev/null
+++ ./.loadrc
@@ -0,0 +1,25 @@
+#!/bin/zsh
+. $HOME/loadrc/.pathrc
+. $HOME/loadrc/.dockerrc
+. $HOME/loadrc/.envrc
+. $HOME/loadrc/.gitrc
+. $HOME/loadrc/.kvmrc
+. $HOME/loadrc/.p4rc
+. $HOME/loadrc/.pythonrc
+. $HOME/loadrc/.shellrc
+. $HOME/loadrc/.sqlrc
+. $HOME/loadrc/.svnrc
+. $HOME/loadrc/openrc.sh
+. $HOME/loadrc/gpurc/.gpurc
+. $HOME/loadrc/.macosrc
+. $HOME/loadrc/.mindsrc
+. $HOME/loadrc/.gorc
+
+HOSTRC=$HOME/loadrc/."`hostname`".rc
+
+if [ -f "$HOSTRC" ]
+then
+    . "$HOSTRC"
+fi
+
+$HOME/loadrc/crontabrc/install.sh
diff --git a/.macmini.rc b/.macmini.rc
new file mode 100644
--- /dev/null
+++ ./.macmini.rc
@@ -0,0 +1,9 @@
+#!/bin/zsh
+#alias restartWifi='$HOME/loadrc/osxrc/restart_wifi.sh'
+
+if ! (sudo systemsetup -getcomputersleep | grep -q Never)
+then
+    sudo systemsetup -setcomputersleep Never
+fi
+
+~/loadrc/setup_pbpaste-remote.sh
diff --git a/.macos.rc b/.macos.rc
new file mode 100644
--- /dev/null
+++ ./.macos.rc
@@ -0,0 +1 @@
+~/loadrc/setup_pbpaste-remote.sh
diff --git a/.macosrc b/.macosrc
new file mode 100644
--- /dev/null
+++ ./.macosrc
@@ -0,0 +1,4 @@
+if [ $(uname) = "Darwin" ]
+then
+    alias restartBluetooth='$HOME/loadrc/osxrc/restart_bluetooth.sh'
+fi
diff --git a/.mba.rc b/.mba.rc
new file mode 100644
--- /dev/null
+++ ./.mba.rc
@@ -0,0 +1,9 @@
+#!/bin/zsh
+
+if ! (sudo systemsetup -getcomputersleep | grep -q Never)
+then
+    sudo systemsetup -setcomputersleep Never
+fi
+
+~/loadrc/setup_pbpaste-remote.sh
+~/loadrc/uninstall_bidirectional_clipboard.sh
diff --git a/.mbp2.rc b/.mbp2.rc
new file mode 100755
--- /dev/null
+++ ./.mbp2.rc
@@ -0,0 +1,9 @@
+#!/bin/zsh
+# alias restartWifi='$HOME/loadrc/osxrc/restart_wifi.sh'
+
+if ! (sudo systemsetup -getcomputersleep | grep -q Never)
+then
+    sudo systemsetup -setcomputersleep Never
+fi
+
+~/loadrc/setup_bidirectional_clipboard.sh
diff --git a/.mindsrc b/.mindsrc
new file mode 100644
--- /dev/null
+++ ./.mindsrc
@@ -0,0 +1,6 @@
+export MINDSROOT=~/myproject/git/ossn/Minds/minds/
+
+alias minds=$MINDSROOT/local/local
+alias minds-front-build=$MINDSROOT/local/front-build
+alias minds-ssr-build=$MINDSROOT/local/ssr-build
+alias minds-ssr-serve=$MINDSROOT/local/ssr-serve
diff --git a/.mini.rc b/.mini.rc
new file mode 100755
--- /dev/null
+++ ./.mini.rc
@@ -0,0 +1,2 @@
+~/loadrc/setup_pbpaste-remote.sh
+# export PATH=$HOME/anaconda3/bin:$PATH
diff --git a/.mini2.rc b/.mini2.rc
new file mode 100755
--- /dev/null
+++ ./.mini2.rc
@@ -0,0 +1,2 @@
+~/loadrc/setup_pbpaste-remote.sh
+~/loadrc/wifirc/enable.sh
diff --git a/.movie.mirror.check b/.movie.mirror.check
new file mode 100644
diff --git a/.movie.rc b/.movie.rc
new file mode 100644
diff --git a/.netrc b/.netrc
new file mode 100644
--- /dev/null
+++ ./.netrc
@@ -0,0 +1,3 @@
+machine MacPro
+login huangyingw
+password #^y*WI2pNf7t
diff --git a/.osxrc b/.osxrc
new file mode 100755
diff --git a/.pathrc b/.pathrc
new file mode 100644
--- /dev/null
+++ ./.pathrc
@@ -0,0 +1,12 @@
+export PATH=$HOME/Android/sdk/platform-tools:$PATH
+export PATH=$HOME/Android/sdk/tools:$PATH
+export PATH=$HOME/bin:$PATH
+export PATH=/Applications/NoMachine.app/Contents/MacOS:$PATH
+export PATH=/Applications/kdiff3.app/Contents/MacOS:$PATH
+export PATH=/opt/homebrew/bin:$PATH
+export PATH=/opt/local/bin:$PATH
+export PATH=/opt/local/sbin:$PATH
+export PATH=/users/alpine/.node_modules_global/bin:$PATH
+export PATH=/usr/local/bin:$PATH
+export PATH=/usr/local/cuda/bin:$PATH
+export PATH=/usr/local/go/bin:$PATH
diff --git a/.profile b/.profile
new file mode 100755
--- /dev/null
+++ ./.profile
@@ -0,0 +1,20 @@
+# ~/.profile: executed by the command interpreter for login shells.
+# This file is not read by bash(1), if ~/.bash_profile or ~/.bash_login
+# exists.
+# see /usr/share/doc/bash/examples/startup-files for examples.
+# the files are located in the bash-doc package.
+
+# the default umask is set in /etc/profile; for setting the umask
+# for ssh logins, install and configure the libpam-umask package.
+#umask 022
+
+# if running bash
+if [ -n "$BASH_VERSION" ]; then
+    # include .bashrc if it exists
+    if [ -f "$HOME/.bashrc" ]; then
+        . "$HOME/.bashrc"
+    fi
+fi
+
+export LANG="en_US.utf8"
+export LANGUAGE="en_US:en"
diff --git a/.pythonrc b/.pythonrc
new file mode 100644
--- /dev/null
+++ ./.pythonrc
@@ -0,0 +1 @@
+alias autopep8ipynb='$HOME/loadrc/pythonrc/autopep8-ipynb.py'
diff --git a/.rovirc b/.rovirc
deleted file mode 100755
--- ./.rovirc
+++ /dev/null
@@ -1,58 +0,0 @@
-########
-# TOMCAT
-export TOMCAT_HOME=/Users/yihuang/bin/apache-tomcat-7.0.55
-export PATH=${TOMCAT_HOME}/bin:${PATH}
-
-######
-# JAVA
-export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_67.jdk/Contents/Home/
-export PATH=${JAVA_HOME}/bin:${PATH}
-export PATH=/opt/subversion/bin:${PATH}
-
-#######
-# MAVEN
-export M2_HOME=/Users/yihuang/bin/apache-maven-3.2.3/
-export PATH=${M2_HOME}/bin:${PATH}
-
-export MANPATH=${JAVA_HOME}/man:${MANPATH}
-
-#######
-# MYSQL
-export MYSQL_HOME=/usr/local/mysql
-export PATH=${MYSQL_HOME}/bin:${PATH}
-
-
-########
-# GRADLE
-export GRADLE_HOME=/Users/yihuang/bin/gradle-1.12
-export PATH=${GRADLE_HOME}/bin:${PATH}
-
-
-###########
-# LIQUIBASE
-export LIQUIBASE_HOME=/Users/yihuang/bin/liquibase-3.2.0
-export PATH=${LIQUIBASE_HOME}:${PATH}
-
-
-#######
-#MONGOD
-
-export SVN_EDITOR=/usr/bin/vim
-
-######
-# PATH
-export MY_HOME=/Users/yihuang
-export PATH=${MY_HOME}/bin:${PATH}
-export PATH=$HOME/local/bin:$PATH
-
-#################
-# COLOR DIRECTORY
-export CLICOLOR=1
-export LSCOLORS=ExFxCxDxBxegedabagacad
-
-#######
-# ALIAS
-#alias ls='ls -lAF --color=tty'
-#alias ls='ls -la'
-alias updatedb='sudo /usr/libexec/locate.updatedb'
-alias runmongo='mongod --fork --logpath /var/log/mongodb.log'
diff --git a/.server.mirror.check b/.server.mirror.check
new file mode 100644
diff --git a/.server.rc b/.server.rc
new file mode 100644
--- /dev/null
+++ ./.server.rc
@@ -0,0 +1,2 @@
+#!/bin/zsh
+~/loadrc/setup_pbpaste-remote.sh
diff --git a/.server.theanorc b/.server.theanorc
new file mode 100644
--- /dev/null
+++ ./.server.theanorc
@@ -0,0 +1,7 @@
+[global]
+force_device = True
+device = gpu
+floatX = float32
+
+[cuda]
+root = /usr/local/cuda
diff --git a/.shellrc b/.shellrc
--- ./.shellrc
+++ ./.shellrc
@@ -1,87 +1,111 @@
-alias apf='apt-get update && aptitude full-upgrade'
-alias api='apt-get install'
-alias aps='$HOME/bashrc/aps.sh'
+#!/bin/zsh
+#alias pm-suspend='$HOME/loadrc/bashrc/sleep.sh'
+#alias tmux='$HOME/loadrc/bashrc/tmux.sh'
+alias apf='$HOME/loadrc/bashrc/apf.sh'
+alias api='apt-get install -y'
+alias aps='$HOME/loadrc/bashrc/aps.sh'
 alias apu='apt-get update'
 alias argouml='/opt/argouml-0.34/argouml2.sh'
 alias b='bochs'
-alias ca='$HOME/bashrc/ca.sh'
-alias copy='$HOME/bashrc/copy.sh'
-alias cscope='$HOME/bashrc/cscope.sh'
-alias csr='$HOME/bashrc/csr.sh'
-alias d='make && $HOME/bashrc/debug.sh'
-alias dcopy='$HOME/bashrc/dcopy.sh'
-alias dof='$HOME/bashrc/dof.sh'
-alias encrypt='$HOME/bashrc/encrypt.sh'
-alias exiso='$HOME/bashrc/exiso.sh'
-alias faa='$HOME/bashrc/faa.sh'
-alias fav='$HOME/bashrc/fav.sh'
-alias fc='$HOME/bashrc/fc.sh'
-alias fd='$HOME/bashrc/fd.sh'
-alias ff='$HOME/bashrc/ff.sh'
-alias fflink='$HOME/bashrc/fflink.sh'
-alias ffp='$HOME/bashrc/ffp.sh'
-alias fgh='$HOME/bashrc/fgh.sh'
-alias fjar='$HOME/bashrc/fjar.sh'
-alias flarge='$HOME/bashrc/flarge.sh'
-alias flargest='$HOME/bashrc/flargest.sh'
-alias flatest='$HOME/bashrc/flatest.sh'
-alias flink='$HOME/bashrc/flink.sh'
-alias fnine='$HOME/bashrc/fnine.sh'
-alias foldest='$HOME/bashrc/foldest.sh'
-alias fr='$HOME/bashrc/fr.sh'
-alias fw='$HOME/bashrc/fw.sh'
-alias fwt='$HOME/bashrc/fwt.sh'
-alias fww='$HOME/bashrc/fww.sh'
-alias fzw='$HOME/bashrc/fzw.sh'
-alias glink='$HOME/bashrc/glink.sh'
-alias jformat='$HOME/bashrc/jformat.sh'
-alias l='ls -aclt'
+alias binaryGrep='$HOME/loadrc/bashrc/binaryGrep.sh'
+alias ca='$HOME/loadrc/bashrc/ca.sh'
+alias clearDNS='$HOME/loadrc/bashrc/clearDNS.sh'
+alias copy='$HOME/loadrc/bashrc/copy.sh'
+alias csr='$HOME/loadrc/bashrc/csr.sh'
+alias dcopy='$HOME/loadrc/bashrc/dcopy.sh'
+alias dd='$HOME/loadrc/bashrc/dd.sh'
+alias deploy='$HOME/loadrc/bashrc/deploy.sh'
+alias encrypt='$HOME/loadrc/bashrc/encrypt.sh'
+alias envSync='$HOME/loadrc/bashrc/envSync.sh'
+alias exiso='$HOME/loadrc/bashrc/exiso.sh'
+alias fc='$HOME/loadrc/bashrc/fc.sh'
+alias fcscope='$HOME/loadrc/bashrc/fcscope.sh'
+alias fdisklog='$HOME/loadrc/bashrc/fdisk_log.sh'
+alias fflink='$HOME/loadrc/bashrc/fflink.sh'
+alias ffp='$HOME/loadrc/bashrc/ffp.sh'
+alias fgh='$HOME/loadrc/bashrc/fgh.sh'
+alias findProjects='$HOME/loadrc/bashrc/find_projects.sh'
+alias find_and_label_bad_files='$HOME/loadrc/ffmpegrc/find_and_label_bad_files.sh'
+alias fmv='$HOME/loadrc/bashrc/findmv.sh'
+alias fjar='$HOME/loadrc/bashrc/fjar.sh'
+alias flarge='$HOME/loadrc/bashrc/flarge.sh'
+alias flargest='$HOME/loadrc/bashrc/flargest.sh'
+alias flatest='$HOME/loadrc/bashrc/flatest.sh'
+alias flink='$HOME/loadrc/bashrc/flink.sh'
+alias fnine='$HOME/loadrc/bashrc/fnine.sh'
+alias fnotinuse='$HOME/loadrc/bashrc/fnotinuse.sh'
+alias fr='$HOME/loadrc/bashrc/fr.sh'
+alias fvideos='$HOME/loadrc/bashrc/fvideos.sh'
+alias fwt='$HOME/loadrc/bashrc/fwt.sh'
+alias fzw='$HOME/loadrc/bashrc/fzw.sh'
+alias glink='$HOME/loadrc/bashrc/glink.sh'
+alias grep='grep --color=auto'
+alias jdupes='$HOME/loadrc/bashrc/jdupes.sh'
+alias jformat='$HOME/loadrc/bashrc/jformat.sh'
+alias jupytext='$HOME/loadrc/ipynbrc/jupytext.sh'
+alias killPort='$HOME/loadrc/bashrc/kill_port.sh'
+alias l='ls -aclrt'
 alias la='ls -A'
 alias ll='ls -alF'
-alias loadrc='. $HOME/.loadrc'
+alias loadrc='. $HOME/loadrc/.loadrc'
+alias logFilter='$HOME/loadrc/bashrc/logFilter.sh'
 alias m='make'
 alias mb='make -B'
-alias mirror='$HOME/bashrc/mirror.sh'
-alias mklnk='$HOME/bashrc/mklnk.sh'
-alias mov='$HOME/bashrc/move.sh'
-alias netbak='$HOME/bashrc/netbak.sh'
-alias netsync='$HOME/bashrc/netsync.sh'
-alias ntp='$HOME/bashrc/ntp.sh'
-alias nubak='$HOME/bashrc/nubak.sh'
-alias r='$HOME/bashrc/run.sh'
-alias rb='$HOME/bashrc/runb.sh'
-alias reboot='$HOME/bashrc/reboot.sh'
+alias mirror='$HOME/loadrc/bashrc/mirror.sh'
+alias mklnk='$HOME/loadrc/bashrc/mklnk.sh'
+alias mosh='$HOME/loadrc/bashrc/mosh.sh'
+alias mov='$HOME/loadrc/bashrc/move.sh'
+alias netbak='$HOME/loadrc/bashrc/netbak.sh'
+alias netsync='$HOME/loadrc/bashrc/netsync.sh'
+alias ntp='$HOME/loadrc/bashrc/ntp.sh'
+alias nubak='$HOME/loadrc/bashrc/nubak.sh'
+alias osmirror='$HOME/loadrc/bashrc/osmirror.sh'
+alias pm-suspend='$HOME/loadrc/bashrc/sleep.sh'
+alias r='$HOME/loadrc/bashrc/run.sh'
+alias rb='$HOME/loadrc/bashrc/runb.sh'
+alias reboot='$HOME/loadrc/bashrc/reboot.sh'
+alias rmEmpty='$HOME/loadrc/bashrc/rmEmpty.sh'
 alias rse='rsync -aH -e ssh --progress'
-alias rsleep='$HOME/bashrc/rsleep.sh'
-alias rsync_svn='$HOME/bashrc/rsync_svn.sh'
-alias rsynctype='$HOME/bashrc/rsynctype.sh'
+alias rsleep='$HOME/loadrc/bashrc/rsleep.sh'
+alias rssh='$HOME/loadrc/bashrc/rssh.sh'
+alias rsync_svn='$HOME/loadrc/bashrc/rsync_svn.sh'
+alias rsynctype='$HOME/loadrc/bashrc/rsynctype.sh'
 alias sancho=/opt/sancho-0.9.4-59-linux-gtk/sancho
-alias sleep='$HOME/bashrc/sleep.sh'
-#alias ssh='$HOME/bashrc/ssh.sh'
-#alias sshfs='sshfs -o allow_other,uid=1000,gid=1000'
-alias sshmount='$HOME/bashrc/sshmount.sh'
+alias selectCopy='$HOME/loadrc/bashrc/select_copy.sh'
+alias selectmirror='$HOME/loadrc/bashrc/selectmirror.sh'
+alias sleep='$HOME/loadrc/bashrc/sleep.sh'
+alias smount='$HOME/loadrc/bashrc/smount.sh'
+alias split='$HOME/loadrc/bashrc/split.sh'
+alias ssh='$HOME/loadrc/bashrc/ssh.sh'
+alias sshmount='$HOME/loadrc/bashrc/sshmount.sh'
 alias sts='/opt/springsource/sts-2.9.2.RELEASE/STS'
 alias su='sudo su'
 alias sudo='sudo '
-alias tcopy='$HOME/bashrc/tcopy.sh'
-alias tk='$HOME/myproject/git/linux/bashrc/task.sh'
-alias tmirror='$HOME/bashrc/tmirror.sh'
-alias tmov='$HOME/bashrc/tmove.sh'
-alias trsync_svn='$HOME/bashrc/trsync_svn.sh'
-alias tubak='$HOME/bashrc/tubak.sh'
-alias tures='$HOME/bashrc/tures.sh'
-alias tusync='$HOME/bashrc/tusync.sh'
-alias tutran='$HOME/bashrc/tutran.sh'
-alias twhole_ures='$HOME/bashrc/twhole_ures.sh'
-alias ufind='$HOME/bashrc/ufind.sh'
-alias umlet='$HOME/bashrc/umlet.sh'
-alias umletc='$HOME/bashrc/umletc.sh'
-alias updatecsc='$HOME/bashrc/updatecsc.sh'
-alias ures='$HOME/bashrc/ures.sh'
-alias usync='$HOME/bashrc/usync.sh'
-alias utran='$HOME/bashrc/utran.sh'
-alias vi='$HOME/bashrc/vi.sh'
-alias vlog='$HOME/bashrc/vlog.sh'
-alias whole_ures='$HOME/bashrc/whole_ures.sh'
-alias wol='$HOME/bashrc/wol.sh'
-alias ygrep='$HOME/bashrc/ygrep.sh'
+alias tcopy='$HOME/loadrc/bashrc/tcopy.sh'
+alias testPorts='$HOME/loadrc/bashrc/testPorts.sh'
+alias tmbak='$HOME/loadrc/bashrc/tmbak.sh'
+alias tmirror='$HOME/loadrc/bashrc/tmirror.sh'
+alias tmov='$HOME/loadrc/bashrc/tmove.sh'
+alias tnetsync='$HOME/loadrc/bashrc/tnetsync.sh'
+alias tosmirror='$HOME/loadrc/bashrc/tosmirror.sh'
+alias trsync_svn='$HOME/loadrc/bashrc/trsync_svn.sh'
+alias tselectmirror='$HOME/loadrc/bashrc/tselectmirror.sh'
+alias tubak='$HOME/loadrc/bashrc/tubak.sh'
+alias tures='$HOME/loadrc/bashrc/tures.sh'
+alias tusync='$HOME/loadrc/bashrc/tusync.sh'
+alias tutran='$HOME/loadrc/bashrc/tutran.sh'
+alias twhole_ures='$HOME/loadrc/bashrc/twhole_ures.sh'
+alias ubak='$HOME/loadrc/bashrc/ubak.sh'
+alias ufind='$HOME/loadrc/bashrc/ufind.sh'
+alias umlet='$HOME/loadrc/bashrc/umlet.sh'
+alias umletc='$HOME/loadrc/bashrc/umletc.sh'
+alias updateProj='$HOME/loadrc/bashrc/update_proj.sh'
+alias ures='$HOME/loadrc/bashrc/ures.sh'
+alias usync='$HOME/loadrc/bashrc/usync.sh'
+alias utran='$HOME/loadrc/bashrc/utran.sh'
+alias vi='$HOME/loadrc/bashrc/vi.sh'
+alias vlog='$HOME/loadrc/bashrc/vlog.sh'
+alias whileCopy='$HOME/loadrc/bashrc/while_copy.sh'
+alias whole_ures='$HOME/loadrc/bashrc/whole_ures.sh'
+alias wol='$HOME/loadrc/bashrc/wol.sh'
+alias ygrep='$HOME/loadrc/bashrc/ygrep.sh'
diff --git a/.sqlrc b/.sqlrc
--- ./.sqlrc
+++ ./.sqlrc
@@ -1,3 +1,4 @@
-alias fsql='$HOME/sqlrc/fsql.sh'
-alias mysqlback='$HOME/sqlrc/mysqlback.sh'
-alias xsql='$HOME/sqlrc/xsql.sh'
+#alias for sql
+alias fsql='$HOME/loadrc/sqlrc/fsql.sh'
+alias mysqlback='$HOME/loadrc/sqlrc/mysqlback.sh'
+alias xsql='$HOME/loadrc/sqlrc/xsql.sh'
diff --git a/.subversion/auth/svn.simple/6146213a2dda95c6394ae9ae66ab729c b/.subversion/auth/svn.simple/6146213a2dda95c6394ae9ae66ab729c
new file mode 100644
--- /dev/null
+++ ./.subversion/auth/svn.simple/6146213a2dda95c6394ae9ae66ab729c
@@ -0,0 +1,13 @@
+K 8
+passtype
+V 8
+keychain
+K 15
+svn:realmstring
+V 46
+<http://sc-svn.corporate.local:80> sc-svn repo
+K 8
+username
+V 7
+yihuang
+END
diff --git a/.subversion/auth/svn.simple/aa981e5344c742bc4b68cc8ef33f0e18 b/.subversion/auth/svn.simple/aa981e5344c742bc4b68cc8ef33f0e18
new file mode 100644
--- /dev/null
+++ ./.subversion/auth/svn.simple/aa981e5344c742bc4b68cc8ef33f0e18
@@ -0,0 +1,13 @@
+K 8
+passtype
+V 8
+keychain
+K 15
+svn:realmstring
+V 46
+<http://sc-svn.macrovision.com:80> sc-svn repo
+K 8
+username
+V 7
+yihuang
+END
diff --git a/.subversion/config b/.subversion/config
new file mode 100644
--- /dev/null
+++ ./.subversion/config
@@ -0,0 +1,155 @@
+### This file configures various client-side behaviors.
+###
+### The commented-out examples below are intended to demonstrate
+### how to use this file.
+
+### Section for authentication and authorization customizations.
+[auth]
+### Set password stores used by Subversion. They should be
+### delimited by spaces or commas. The order of values determines
+### the order in which password stores are used.
+### Valid password stores:
+###   gnome-keyring        (Unix-like systems)
+###   kwallet              (Unix-like systems)
+###   keychain             (Mac OS X)
+###   windows-cryptoapi    (Windows)
+# password-stores = keychain
+# password-stores = windows-cryptoapi
+#else
+# password-stores = gnome-keyring,kwallet
+###
+### Set KWallet wallet used by Subversion. If empty or unset,
+### then the default network wallet will be used.
+# kwallet-wallet =
+###
+### Include PID (Process ID) in Subversion application name when
+### using KWallet. It defaults to 'no'.
+# kwallet-svn-application-name-with-pid = yes
+###
+### The rest of this section in this file has been deprecated.
+### Both 'store-passwords' and 'store-auth-creds' can now be
+### specified in the 'servers' file in your config directory.
+### Anything specified in this section is overridden by settings
+### specified in the 'servers' file.
+###
+### Set store-passwords to 'no' to avoid storing passwords in the
+### auth/ area of your config directory.  It defaults to 'yes',
+### but Subversion will never save your password to disk in
+### plaintext unless you tell it to (see the 'servers' file).
+### Note that this option only prevents saving of *new* passwords;
+### it doesn't invalidate existing passwords.  (To do that, remove
+### the cache files by hand as described in the Subversion book.)
+# store-passwords = no
+### Set store-auth-creds to 'no' to avoid storing any subversion
+### credentials in the auth/ area of your config directory.
+### It defaults to 'yes'.  Note that this option only prevents
+### saving of *new* credentials;  it doesn't invalidate existing
+### caches.  (To do that, remove the cache files by hand.)
+# store-auth-creds = no
+
+### Section for configuring external helper applications.
+[helpers]
+diff-cmd = /Users/yihuang/.subversion/svndiffwrapper.sh
+diff3-cmd = /Users/yihuang/.subversion/svndiffwrapper.sh
+merge-tool-cmd = /Users/yihuang/.subversion/svndiffwrapper.sh
+
+### Set editor-cmd to the command used to invoke your text editor.
+###   This will override the environment variables that Subversion
+###   examines by default to find this information ($EDITOR, 
+###   et al).
+# editor-cmd = editor (vi, emacs, notepad, etc.)
+### Set diff-cmd to the absolute path of your 'diff' program.
+###   This will override the compile-time default, which is to use
+###   Subversion's internal diff implementation.
+# diff-cmd = diff_program (diff, gdiff, etc.)
+### Set diff3-cmd to the absolute path of your 'diff3' program.
+###   This will override the compile-time default, which is to use
+###   Subversion's internal diff3 implementation.
+# diff3-cmd = diff3_program (diff3, gdiff3, etc.)
+### Set diff3-has-program-arg to 'yes' if your 'diff3' program
+###   accepts the '--diff-program' option.
+# diff3-has-program-arg = [yes | no]
+### Set merge-tool-cmd to the command used to invoke your external
+### merging tool of choice. Subversion will pass 4 arguments to
+### the specified command: base theirs mine merged
+# merge-tool-cmd = merge_command
+
+### Section for configuring tunnel agents.
+[tunnels]
+### Configure svn protocol tunnel schemes here.  By default, only
+### the 'ssh' scheme is defined.  You can define other schemes to
+### be used with 'svn+scheme://hostname/path' URLs.  A scheme
+### definition is simply a command, optionally prefixed by an
+### environment variable name which can override the command if it
+### is defined.  The command (or environment variable) may contain
+### arguments, using standard shell quoting for arguments with
+### spaces.  The command will be invoked as:
+###   <command> <hostname> svnserve -t
+### (If the URL includes a username, then the hostname will be
+### passed to the tunnel agent as <user>@<hostname>.)  If the
+### built-in ssh scheme were not predefined, it could be defined
+### as:
+# ssh = $SVN_SSH ssh -q
+### If you wanted to define a new 'rsh' scheme, to be used with
+### 'svn+rsh:' URLs, you could do so as follows:
+# rsh = rsh
+### Or, if you wanted to specify a full path and arguments:
+# rsh = /path/to/rsh -l myusername
+### On Windows, if you are specifying a full path to a command,
+### use a forward slash (/) or a paired backslash (\\\\) as the
+### path separator.  A single backslash will be treated as an
+### escape for the following character.
+
+### Section for configuring miscelleneous Subversion options.
+[miscellany]
+### Set global-ignores to a set of whitespace-delimited globs
+### which Subversion will ignore in its 'status' output, and
+### while importing or adding files and directories.
+### '*' matches leading dots, e.g. '*.rej' matches '.foo.rej'.
+global-ignores = *.o *.lo *.la *.al .libs *.so *.so.[0-9]* *.a *.pyc *.pyo *.findresult *.orig template-*target *.swp *.bak *.out .settings *.swo *.prefs
+#   *.rej *~ #*# .#* .*.swp .DS_Store
+### Set log-encoding to the default encoding for log messages
+# log-encoding = latin1
+### Set use-commit-times to make checkout/update/switch/revert
+### put last-committed timestamps on every file touched.
+# use-commit-times = yes
+### Set no-unlock to prevent 'svn commit' from automatically
+### releasing locks on files.
+# no-unlock = yes
+### Set mime-types-file to a MIME type registry file, used to
+### provide hints to Subversion's MIME type auto-detection
+### algorithm.
+# mime-types-file = /path/to/mime.types
+### Set preserved-conflict-file-exts to a whitespace-delimited
+### list of patterns matching file extensions which should be
+### preserved in generated conflict file names.  By default,
+### conflict files use custom extensions.
+# preserved-conflict-file-exts = doc ppt xls od?
+### Set enable-auto-props to 'yes' to enable automatic properties
+### for 'svn add' and 'svn import', it defaults to 'no'.
+### Automatic properties are defined in the section 'auto-props'.
+# enable-auto-props = yes
+### Set interactive-conflicts to 'no' to disable interactive
+### conflict resolution prompting.  It defaults to 'yes'.
+# interactive-conflicts = no
+
+### Section for configuring automatic properties.
+[auto-props]
+### The format of the entries is:
+###   file-name-pattern = propname[=value][;propname[=value]...]
+### The file-name-pattern can contain wildcards (such as '*' and
+### '?').  All entries which match (case-insensitively) will be
+### applied to the file.  Note that auto-props functionality
+### must be enabled, which is typically done by setting the
+### 'enable-auto-props' option.
+# *.c = svn:eol-style=native
+# *.cpp = svn:eol-style=native
+# *.h = svn:keywords=Author Date Id Rev URL;svn:eol-style=native
+# *.dsp = svn:eol-style=CRLF
+# *.dsw = svn:eol-style=CRLF
+# *.sh = svn:eol-style=native;svn:executable
+# *.txt = svn:eol-style=native;svn:keywords=Author Date Id Rev URL;
+# *.png = svn:mime-type=image/png
+# *.jpg = svn:mime-type=image/jpeg
+# Makefile = svn:eol-style=native
+
diff --git a/.subversion/servers b/.subversion/servers
new file mode 100644
--- /dev/null
+++ ./.subversion/servers
@@ -0,0 +1,158 @@
+### This file specifies server-specific parameters,
+### including HTTP proxy information, HTTP timeout settings,
+### and authentication settings.
+###
+### The currently defined server options are:
+###   http-proxy-host            Proxy host for HTTP connection
+###   http-proxy-port            Port number of proxy host service
+###   http-proxy-username        Username for auth to proxy service
+###   http-proxy-password        Password for auth to proxy service
+###   http-proxy-exceptions      List of sites that do not use proxy
+###   http-timeout               Timeout for HTTP requests in seconds
+###   http-compression           Whether to compress HTTP requests
+###   neon-debug-mask            Debug mask for Neon HTTP library
+###   http-auth-types            Auth types to use for HTTP library
+###   ssl-authority-files        List of files, each of a trusted CA
+###   ssl-trust-default-ca       Trust the system 'default' CAs
+###   ssl-client-cert-file       PKCS#12 format client certificate file
+###   ssl-client-cert-password   Client Key password, if needed.
+###   ssl-pkcs11-provider        Name of PKCS#11 provider to use.
+###   http-library               Which library to use for http/https
+###                              connections (neon or serf)
+###   store-passwords            Specifies whether passwords used
+###                              to authenticate against a
+###                              Subversion server may be cached
+###                              to disk in any way.
+###   store-plaintext-passwords  Specifies whether passwords may
+###                              be cached on disk unencrypted.
+###   store-ssl-client-cert-pp   Specifies whether passphrase used
+###                              to authenticate against a client
+###                              certificate may be cached to disk
+###                              in any way
+###   store-ssl-client-cert-pp-plaintext
+###                              Specifies whether client cert
+###                              passphrases may be cached on disk
+###                              unencrypted (i.e., as plaintext).
+###   store-auth-creds           Specifies whether any auth info
+###                              (passwords as well as server certs)
+###                              may be cached to disk.
+###   username                   Specifies the default username.
+###
+### Set store-passwords to 'no' to avoid storing passwords in the
+### auth/ area of your config directory.  It defaults to 'yes',
+### but Subversion will never save your password to disk in
+### plaintext unless you tell it to.
+### Note that this option only prevents saving of *new* passwords;
+### it doesn't invalidate existing passwords.  (To do that, remove
+### the cache files by hand as described in the Subversion book.)
+###
+### Set store-plaintext-passwords to 'no' to avoid storing
+### passwords in unencrypted form in the auth/ area of your config
+### directory. Set it to 'yes' to allow Subversion to store
+### unencrypted passwords in the auth/ area.  The default is
+### 'ask', which means that Subversion will ask you before
+### saving a password to disk in unencrypted form.  Note that
+### this option has no effect if either 'store-passwords' or 
+### 'store-auth-creds' is set to 'no'.
+###
+### Set store-ssl-client-cert-pp to 'no' to avoid storing ssl
+### client certificate passphrases in the auth/ area of your
+### config directory.  It defaults to 'yes', but Subversion will
+### never save your passphrase to disk in plaintext unless you tell
+### it to via 'store-ssl-client-cert-pp-plaintext' (see below).
+###
+### Note store-ssl-client-cert-pp only prevents the saving of *new*
+### passphrases; it doesn't invalidate existing passphrases.  To do
+### that, remove the cache files by hand as described in the
+### Subversion book at http://svnbook.red-bean.com/nightly/en/\\
+###                    svn.serverconfig.netmodel.html\\
+###                    #svn.serverconfig.netmodel.credcache
+###
+### Set store-ssl-client-cert-pp-plaintext to 'no' to avoid storing
+### passphrases in unencrypted form in the auth/ area of your
+### config directory.  Set it to 'yes' to allow Subversion to
+### store unencrypted passphrases in the auth/ area.  The default
+### is 'ask', which means that Subversion will prompt before
+### saving a passphrase to disk in unencrypted form.  Note that
+### this option has no effect if either 'store-auth-creds' or 
+### 'store-ssl-client-cert-pp' is set to 'no'.
+###
+### Set store-auth-creds to 'no' to avoid storing any Subversion
+### credentials in the auth/ area of your config directory.
+### Note that this includes SSL server certificates.
+### It defaults to 'yes'.  Note that this option only prevents
+### saving of *new* credentials;  it doesn't invalidate existing
+### caches.  (To do that, remove the cache files by hand.)
+###
+### HTTP timeouts, if given, are specified in seconds.  A timeout
+### of 0, i.e. zero, causes a builtin default to be used.
+###
+### The commented-out examples below are intended only to
+### demonstrate how to use this file; any resemblance to actual
+### servers, living or dead, is entirely coincidental.
+
+### In the 'groups' section, the URL of the repository you're
+### trying to access is matched against the patterns on the right.
+### If a match is found, the server options are taken from the
+### section with the corresponding name on the left.
+
+[groups]
+# group1 = *.collab.net
+# othergroup = repository.blarggitywhoomph.com
+# thirdgroup = *.example.com
+
+### Information for the first group:
+# [group1]
+# http-proxy-host = proxy1.some-domain-name.com
+# http-proxy-port = 80
+# http-proxy-username = blah
+# http-proxy-password = doubleblah
+# http-timeout = 60
+# http-auth-types = basic;digest;negotiate
+# neon-debug-mask = 130
+# store-plaintext-passwords = no
+# username = harry
+
+### Information for the second group:
+# [othergroup]
+# http-proxy-host = proxy2.some-domain-name.com
+# http-proxy-port = 9000
+# No username and password for the proxy, so use the defaults below.
+
+### You can set default parameters in the 'global' section.
+### These parameters apply if no corresponding parameter is set in
+### a specifically matched group as shown above.  Thus, if you go
+### through the same proxy server to reach every site on the
+### Internet, you probably just want to put that server's
+### information in the 'global' section and not bother with
+### 'groups' or any other sections.
+###
+### Most people might want to configure password caching
+### parameters here, but you can also configure them per server
+### group (per-group settings override global settings).
+###
+### If you go through a proxy for all but a few sites, you can
+### list those exceptions under 'http-proxy-exceptions'.  This only
+### overrides defaults, not explicitly matched server names.
+###
+### 'ssl-authority-files' is a semicolon-delimited list of files,
+### each pointing to a PEM-encoded Certificate Authority (CA) 
+### SSL certificate.  See details above for overriding security 
+### due to SSL.
+[global]
+# http-proxy-exceptions = *.exception.com, www.internal-site.org
+# http-proxy-host = defaultproxy.whatever.com
+# http-proxy-port = 7000
+# http-proxy-username = defaultusername
+# http-proxy-password = defaultpassword
+# http-compression = no
+# http-auth-types = basic;digest;negotiate
+# No http-timeout, so just use the builtin default.
+# No neon-debug-mask, so neon debugging is disabled.
+# ssl-authority-files = /path/to/CAcert.pem;/path/to/CAcert2.pem
+#
+# Password / passphrase caching parameters:
+# store-passwords = no
+# store-plaintext-passwords = no
+# store-ssl-client-cert-pp = no
+# store-ssl-client-cert-pp-plaintext = no
diff --git a/.subversion/svndiffwrapper.sh b/.subversion/svndiffwrapper.sh
new file mode 100755
--- /dev/null
+++ ./.subversion/svndiffwrapper.sh
@@ -0,0 +1,195 @@
+#!/bin/zsh
+
+# Return an errorcode of 0 on successful merge, 1 if unresolved conflicts
+# remain in the result.  Any other errorcode will be treated as fatal.
+# Author: Michael Bradley
+
+# NOTE: all output must be redirected to stderr with "1>&2" as all stdout
+# output is written to the output file
+
+VDIFF3="kdiff3"
+DIFF3="diff3"
+DIFF="diff"
+
+promptUser ()
+{
+    read answer
+    case "${answer}" in
+
+        "M"         )
+            echo "" 1>&2
+            echo "Attempting to merge ${baseFileName} with ${DIFF}" 1>&2
+            $VDIFF3 $older $mine $theirs --L1 $labelOlder --L2 $labelMine --L3 $labelTheirs -o $output 1>&2
+            bLoop=1
+            if [ -f $output ]
+            then
+                if [ -s $output ]
+                then
+                    #output succesfully written
+                    bLoop=0
+                fi
+            fi
+            if [ $bLoop = 0 ]
+            then
+                cat $output
+                rm -f $output
+                exit 0
+            else
+                echo "Merge failed, try again" 1>&2
+            fi
+
+            ;;
+
+        "m"         )
+            echo "" 1>&2
+            echo "Attempting to auto-merge ${baseFileName}" 1>&2
+            diff3 -L $labelMine -L $labelOlder -L $labelTheirs -Em $mine $older $theirs > $output
+            if [ $? = 1 ]
+            then
+                #Can't auto merge
+                rm -f $output
+                $VDIFF3 $older $mine $theirs --L1 $labelOlder --L2 $labelMine --L3 $labelTheirs -o $output --auto 1>&2
+                bLoop=1
+                if [ -f $output ]
+                then
+                    if [ -s $output ]
+                    then
+                        #output succesfully written
+                        bLoop=0
+                    fi
+                fi
+                if [ $bLoop = 0 ]
+                then
+                    cat $output
+                    rm -f $output
+                    exit 0
+                else
+                    echo "Merge failed, try again" 1>&2
+                fi
+            else
+                #We can automerge, and we already did it
+                cat $output
+                rm -f $output
+                exit 0
+            fi
+            ;;
+
+        "diff3" | "Diff3" | "DIFF3"  )
+            echo "" 1>&2
+            echo "Diffing..." 1>&2
+            $VDIFF3 $older $mine $theirs --L1 $labelOlder --L2 $labelMine --L3 $labelTheirs 1>&2
+            ;;
+
+        "diff" | "Diff" | "DIFF"  )
+            echo "" 1>&2
+            echo "Diffing..." 1>&2
+            $DIFF $mine $theirs -L $labelMine -L $labelTheirs 1>&2
+            ;;
+
+        "A" | "a"   )
+            echo "" 1>&2
+            echo "Accepting remote version of file..." 1>&2
+            cat ${theirs}
+            exit 0
+            ;;
+
+        "I" | "i"   )
+            echo "" 1>&2
+            echo "Keeping local modifications..." 1>&2
+            cat ${mine}
+            exit 0
+            ;;
+
+        "R" | "r"   )
+            echo "" 1>&2
+            echo "Reverting to base..." 1>&2
+            cat ${older}
+            exit 0
+            ;;
+
+        "D" | "d"   )
+            echo "" 1>&2
+            echo "Runnig diff3..." 1>&2
+            diff3 -L $labelMine -L $labelOlder -L $labelTheirs -Em $mine $older $theirs
+            #Exit with return vaule of the diff3 (to write out files if necessary)
+            exit $?
+            ;;
+
+        "S" | "s"   )
+            echo "" 1>&2
+            echo "Saving for later..." 1>&2
+            cat ${mine}
+            #Exit with return vaule of 1 to force writting of files
+            exit 1
+            ;;
+
+        "Fail" | "fail" | "FAIL"   )
+            echo "" 1>&2
+            echo "Failing..." 1>&2
+            exit 2
+            ;;
+
+        "H" | "h"   )
+            echo "" 1>&2
+            echo "USAGE OPTIONS:" 1>&2
+            echo "  [A]ccept    Accept $labelTheirs and throw out local modifications" 1>&2
+            echo "  [D]efault   Use diff3 to merge files (same behavior as vanilla SVN)" 1>&2
+            echo "  [Fail]      Kills the command (not suggested)" 1>&2
+            echo "  [H]elp      Print this message" 1>&2
+            echo "  [I]gnore    Keep your locally modified version as is" 1>&2
+            echo "  [M]erge     Manually merge using ${VDIFF3}" 1>&2
+            echo "  [m]erge     Same as "M" but attempts to automerge if possible" 1>&2
+            echo "  [R]evert    Revert to base version (${labelOlder})" 1>&2
+            echo "  [S]ave      Same as 'I' but writes out rold, rnew, and rmine files to deal with later" 1>&2
+            echo "  [diff]      Type 'diff' to diff versions $labelMine and $labelTheirs before making a descision" 1>&2
+            echo "  [diff3]     Type 'diff3' to diff all three versions before making a descision" 1>&2
+            echo "" 1>&2
+            ;;
+
+        *   )
+            echo "'${answer}' is not an option, try again." 1>&2
+            ;;
+    esac
+}
+
+if [ -z $2 ]
+then
+    echo ERROR: This script expects to be called by subversion
+    exit 1
+fi
+
+if [ $2 = "-m" ]
+then
+    #Setup vars
+    labelMine=${4}
+    labelOlder=${6}
+    labelTheirs=${8}
+    mine=${9}
+    older=${10}
+    theirs=${11}
+    output=${9}.svnDiff3TempOutput
+    baseFileName=`echo $mine | sed -e "s/.tmp$//"`
+
+    #Prompt user for direction
+    while [ 1 ]
+    do
+        echo "" 1>&2
+        echo "${baseFileName} requires merging." 1>&2
+        echo "" 1>&2
+        echo "What would you like to do?" 1>&2
+        echo "[M]erge [A]ccept [I]gnore [R]evert [D]efault [H]elp" 1>&2
+        promptUser
+    done
+else
+    L="-L"          #Argument option for left label
+    R="-L"          #Argument option for right label
+    label1=$3       #Left label
+    label2=$5       #Right label
+    file1=$6        #Left file
+    file2=$7        #Right file
+
+    $DIFF $file1 $file2 $L "$label1" $L "$label2" &
+    #wait for the command to finish
+    wait
+fi
+exit 0
diff --git a/.svnrc b/.svnrc
--- ./.svnrc
+++ ./.svnrc
@@ -1,4 +1,5 @@
-alias svndiff='$HOME/svnrc/svndiff.sh'
-alias svnhistory='$HOME/svnrc/svnhistory.sh'
-alias svnst='$HOME/svnrc/svnst.sh'
-alias svnvdiff='$HOME/svnrc/svnvdiff.sh'
+alias svndiff='$HOME/loadrc/svnrc/svndiff.sh'
+alias svnhistory='$HOME/loadrc/svnrc/svnhistory.sh'
+alias svnreset='$HOME/loadrc/svnrc/svnreset.sh'
+alias svnst='$HOME/loadrc/svnrc/svnst.sh'
+alias svnup='$HOME/loadrc/svnrc/svnup.sh'
diff --git a/.theanorc b/.theanorc
new file mode 100644
--- /dev/null
+++ ./.theanorc
@@ -0,0 +1,7 @@
+[global]
+force_device = False
+device = cpu
+floatX = float32
+
+[cuda]
+root = /usr/local/cuda
diff --git a/.tigrc b/.tigrc
new file mode 100644
--- /dev/null
+++ ./.tigrc
@@ -0,0 +1 @@
+bind generic 9 @sh -c "echo -n %(commit) | xclip -selection c"
diff --git a/.tmux.conf b/.tmux.conf
new file mode 100644
--- /dev/null
+++ ./.tmux.conf
@@ -0,0 +1,5 @@
+bind-key -n C-j next-window
+bind-key -n C-k previous-window
+bind-key -n C-w new-window
+# if run as "tmux attach", create a session if one does not already exist
+new-session -n main
diff --git a/.u1804.rc b/.u1804.rc
new file mode 100644
diff --git a/.ubuntu.rc b/.ubuntu.rc
new file mode 100644
--- /dev/null
+++ ./.ubuntu.rc
@@ -0,0 +1 @@
+~/loadrc/setup_pbpaste-remote.sh
diff --git a/.vserver.rc b/.vserver.rc
new file mode 100644
--- /dev/null
+++ ./.vserver.rc
@@ -0,0 +1 @@
+alias vi='nvim'
diff --git a/.vserver.theanorc b/.vserver.theanorc
new file mode 100644
--- /dev/null
+++ ./.vserver.theanorc
@@ -0,0 +1,7 @@
+[global]
+force_device = True
+device = cpu
+floatX = float32
+
+[cuda]
+root = /usr/local/cuda
diff --git a/.zerotierrc b/.zerotierrc
new file mode 100644
diff --git a/.zshrc b/.zshrc
new file mode 100644
--- /dev/null
+++ ./.zshrc
@@ -0,0 +1,101 @@
+# If you come from bash you might have to change your $PATH.
+
+# Path to your oh-my-zsh installation.
+export ZSH=$HOME/.oh-my-zsh
+
+# Set name of the theme to load --- if set to "random", it will
+# load a random theme each time oh-my-zsh is loaded, in which case,
+# to know which specific one was loaded, run: echo $RANDOM_THEME
+# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes
+ZSH_THEME="robbyrussell"
+
+# Set list of themes to pick from when loading at random
+# Setting this variable when ZSH_THEME=random will cause zsh to load
+# a theme from this variable instead of looking in ~/.oh-my-zsh/themes/
+# If set to an empty array, this variable will have no effect.
+# ZSH_THEME_RANDOM_CANDIDATES=( "robbyrussell" "agnoster" )
+
+# Uncomment the following line to use case-sensitive completion.
+# CASE_SENSITIVE="true"
+
+# Uncomment the following line to use hyphen-insensitive completion.
+# Case-sensitive completion must be off. _ and - will be interchangeable.
+# HYPHEN_INSENSITIVE="true"
+
+# Uncomment the following line to disable bi-weekly auto-update checks.
+# DISABLE_AUTO_UPDATE="true"
+
+# Uncomment the following line to automatically update without prompting.
+# DISABLE_UPDATE_PROMPT="true"
+
+# Uncomment the following line to change how often to auto-update (in days).
+# export UPDATE_ZSH_DAYS=13
+
+# Uncomment the following line if pasting URLs and other text is messed up.
+# DISABLE_MAGIC_FUNCTIONS=true
+
+# Uncomment the following line to disable colors in ls.
+# DISABLE_LS_COLORS="true"
+
+# Uncomment the following line to disable auto-setting terminal title.
+# DISABLE_AUTO_TITLE="true"
+
+# Uncomment the following line to enable command auto-correction.
+# ENABLE_CORRECTION="true"
+
+# Uncomment the following line to display red dots whilst waiting for completion.
+# COMPLETION_WAITING_DOTS="true"
+
+# Uncomment the following line if you want to disable marking untracked files
+# under VCS as dirty. This makes repository status check for large repositories
+# much, much faster.
+# DISABLE_UNTRACKED_FILES_DIRTY="true"
+
+# Uncomment the following line if you want to change the command execution time
+# stamp shown in the history command output.
+# You can set one of the optional three formats:
+# "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"
+# or set a custom format using the strftime function format specifications,
+# see 'man strftime' for details.
+# HIST_STAMPS="mm/dd/yyyy"
+
+# Would you like to use another custom folder than $ZSH/custom?
+# ZSH_CUSTOM=/path/to/new-custom-folder
+
+# Which plugins would you like to load?
+# Standard plugins can be found in ~/.oh-my-zsh/plugins/*
+# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/
+# Example format: plugins=(rails git textmate ruby lighthouse)
+# Add wisely, as too many plugins slow down shell startup.
+plugins=(git git-flow brew history node npm kubectl helm zsh-nvm vagrant golang docker docker-compose)
+
+source $ZSH/oh-my-zsh.sh
+
+# User configuration
+
+# export MANPATH="/usr/local/man:$MANPATH"
+
+# You may need to manually set your language environment
+# export LANG=en_US.UTF-8
+
+# Preferred editor for local and remote sessions
+# if [[ -n $SSH_CONNECTION ]]; then
+#   export EDITOR='vim'
+# else
+#   export EDITOR='mvim'
+# fi
+
+# Compilation flags
+# export ARCHFLAGS="-arch x86_64"
+
+# Set personal aliases, overriding those provided by oh-my-zsh libs,
+# plugins, and themes. Aliases can be placed here, though oh-my-zsh
+# users are encouraged to define aliases within the ZSH_CUSTOM folder.
+# For a full list of active aliases, run `alias`.
+#
+# Example aliases
+# alias zshconfig="mate ~/.zshrc"
+# alias ohmyzsh="mate ~/.oh-my-zsh"
+
+. $HOME/loadrc/.loadrc
+setopt HIST_IGNORE_ALL_DUPS
diff --git a/Dockerfile b/Dockerfile
new file mode 100644
--- /dev/null
+++ ./Dockerfile
@@ -0,0 +1,26 @@
+FROM ubuntu:22.04
+
+ENV DEBIAN_FRONTEND noninteractive
+WORKDIR /root/loadrc
+
+COPY ./*.sh /root/loadrc/
+COPY ./bashrc/*.sh /root/loadrc/bashrc/
+COPY ./gitrc/*.sh /root/loadrc/gitrc/
+COPY ./.ssh/id_* /root/.ssh/
+COPY ./entrypoint.sh /entrypoint.sh
+
+RUN /root/loadrc/fix_resolvconf_in_docker.sh 
+RUN /root/loadrc/install_prerequisite.sh
+RUN /root/loadrc/setup_locale.sh
+RUN chmod 400 /root/.ssh/id_rsa
+
+COPY ./cscope/ /root/loadrc/cscope/
+RUN /root/loadrc/cscope/install-sh.sh
+
+COPY ./neovim/ /root/loadrc/neovim/
+RUN /root/loadrc/install_nvim.sh
+
+# Clean up APT when done.
+RUN apt-get clean && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*
+
+CMD ["/bin/sh", "-c", "/entrypoint.sh 2>&1 | tee /var/logs/containner.log"]
diff --git a/Library/LaunchAgents/pbcopy.plist b/Library/LaunchAgents/pbcopy.plist
new file mode 100644
--- /dev/null
+++ ./Library/LaunchAgents/pbcopy.plist
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+    <dict>
+	<key>Label</key>
+	<string>localhost.pbcopy</string>
+	<key>ProgramArguments</key>
+	<array>
+	    <string>/bin/sh</string>
+	    <string>-c</string>
+	    <string>LC_CTYPE=en_US.UTF-8 pbcopy</string>
+	</array>
+	<key>Sockets</key>
+	<dict>
+	    <key>Listeners</key>
+	    <dict>
+		<key>SockNodeName</key>
+		<string>127.0.0.1</string>
+		<key>SockServiceName</key>
+		<string>2224</string>
+	    </dict>
+	</dict>
+	<key>inetdCompatibility</key>
+	<dict>
+	    <key>Wait</key>
+	    <false/>
+	</dict>
+    </dict>
+</plist>
diff --git a/Library/LaunchAgents/pbpaste.plist b/Library/LaunchAgents/pbpaste.plist
new file mode 100644
--- /dev/null
+++ ./Library/LaunchAgents/pbpaste.plist
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+    <dict>
+	<key>Label</key>
+	<string>localhost.pbpaste</string>
+	<key>ProgramArguments</key>
+	<array>
+	    <string>/bin/sh</string>
+	    <string>-c</string>
+	    <string>LC_CTYPE=en_US.UTF-8 pbpaste</string>
+	</array>
+	<key>Sockets</key>
+	<dict>
+	    <key>Listeners</key>
+	    <dict>
+		<key>SockNodeName</key>
+		<string>127.0.0.1</string>
+		<key>SockServiceName</key>
+		<string>2225</string>
+	    </dict>
+	</dict>
+	<key>inetdCompatibility</key>
+	<dict>
+	    <key>Wait</key>
+	    <false/>
+	</dict>
+    </dict>
+</plist>
diff --git a/Library/Preferences/org.videolan.vlc/vlcrc b/Library/Preferences/org.videolan.vlc/vlcrc
new file mode 100644
--- /dev/null
+++ ./Library/Preferences/org.videolan.vlc/vlcrc
@@ -0,0 +1,4721 @@
+###
+###  vlc 3.0.12
+###
+
+###
+### lines beginning with a '#' character are comments
+###
+
+[speex_resampler] # Speex resampler
+
+# Resampling quality (integer)
+#speex-resampler-quality=4
+
+[smem] # Stream output to memory buffer
+
+# Time Synchronized output (boolean)
+#sout-smem-time-sync=1
+
+[amem] # Audio memory output
+
+# Sample format (string)
+#amem-format=S16N
+
+# Sample rate (integer)
+#amem-rate=44100
+
+# Channels count (integer)
+#amem-channels=2
+
+[swscale] # Video scaling filter
+
+# Scaling mode (integer)
+#swscale-mode=2
+
+[subsdelay] # Subtitle delay
+
+# Delay calculation mode (integer)
+#subsdelay-mode=1
+
+# Calculation factor (float)
+#subsdelay-factor=2.000000
+
+# Maximum overlapping subtitles (integer)
+#subsdelay-overlap=3
+
+# Minimum alpha value (integer)
+#subsdelay-min-alpha=70
+
+# Interval between two disappearances (integer)
+#subsdelay-min-stops=1000
+
+# Interval between appearance and disappearance (integer)
+#subsdelay-min-start-stop=1000
+
+# Interval between disappearance and appearance (integer)
+#subsdelay-min-stop-start=1000
+
+[syslog] # System logger (syslog)
+
+# System log (syslog) (boolean)
+#syslog=0
+
+# Debug messages (boolean)
+#syslog-debug=0
+
+# Identity (string)
+#syslog-ident=vlc
+
+# Facility (string)
+#syslog-facility=user
+
+[scaletempo] # Audio tempo scaler synched with rate
+
+# Stride Length (integer)
+#scaletempo-stride=30
+
+# Overlap Length (float)
+#scaletempo-overlap=0.200000
+
+# Search Length (integer)
+#scaletempo-search=14
+
+[mod] # MOD demuxer (libmodplug)
+
+# Noise reduction (boolean)
+#mod-noisereduction=1
+
+# Reverb (boolean)
+#mod-reverb=0
+
+# Reverberation level (integer)
+#mod-reverb-level=0
+
+# Reverberation delay (integer)
+#mod-reverb-delay=40
+
+# Mega bass (boolean)
+#mod-megabass=0
+
+# Mega bass level (integer)
+#mod-megabass-level=0
+
+# Mega bass cutoff (integer)
+#mod-megabass-range=10
+
+# Surround (boolean)
+#mod-surround=0
+
+# Surround level (integer)
+#mod-surround-level=0
+
+# Surround delay (ms) (integer)
+#mod-surround-delay=5
+
+[access_mms] # Microsoft Media Server (MMS) input
+
+# TCP/UDP timeout (ms) (integer)
+#mms-timeout=5000
+
+# Force selection of all streams (boolean)
+#mms-all=0
+
+# Maximum bitrate (integer)
+#mms-maxbitrate=0
+
+[stream_out_chromecast] # Chromecast stream output
+
+# ? (string)
+#sout-chromecast-ip=
+
+# ? (integer)
+#sout-chromecast-port=8009
+
+# ? (boolean)
+#sout-chromecast-video=1
+
+# HTTP port (integer)
+#sout-chromecast-http-port=8010
+
+# Performance warning (integer)
+#sout-chromecast-show-perf-warning=1
+
+# Enable Audio passthrough (boolean)
+#sout-chromecast-audio-passthrough=0
+
+# Conversion quality (integer)
+#sout-chromecast-conversion-quality=1
+
+[shm] # Shared memory framebuffer
+
+# Frame rate (float)
+#shm-fps=10.000000
+
+# Frame buffer depth (integer)
+#shm-depth=0
+
+# Frame buffer width (integer)
+#shm-width=800
+
+# Frame buffer height (integer)
+#shm-height=480
+
+[macosx] # Mac OS X interface
+
+# Run VLC with dark interface style (boolean)
+#macosx-interfacestyle=0
+
+# Use the native fullscreen mode (boolean)
+#macosx-nativefullscreenmode=0
+
+# Display VLC status menu icon (boolean)
+#macosx-statusicon=1
+
+# Allow automatic icon changes (boolean)
+#macosx-icon-change=1
+
+# Show Previous & Next Buttons (boolean)
+#macosx-show-playback-buttons=0
+
+# Show Shuffle & Repeat Buttons (boolean)
+#macosx-show-playmode-buttons=0
+
+# Show Audio Effects Button (boolean)
+#macosx-show-effects-button=0
+
+# Maximum Volume displayed (integer)
+#macosx-max-volume=125
+
+# Use large text for list views (boolean)
+#macosx-large-text=0
+
+# Auto-playback of new items (boolean)
+#macosx-autoplay=1
+
+# Keep Recent Items (boolean)
+#macosx-recentitems=1
+
+# Show Fullscreen controller (boolean)
+#macosx-fspanel=1
+
+# Resize interface to the native video size (boolean)
+#macosx-video-autoresize=1
+
+# Pause the video playback when minimized (boolean)
+#macosx-pause-minimized=0
+
+# Lock Aspect Ratio (boolean)
+#macosx-lock-aspect-ratio=1
+
+# Dim keyboard backlight during fullscreen playback (boolean)
+#macosx-dim-keyboard=0
+
+# Control external music players (integer)
+#macosx-control-itunes=1
+
+# Continue playback where you left off (integer)
+macosx-continue-playback=1
+
+# Control playback with the Apple Remote (boolean)
+#macosx-appleremote=1
+
+# Control system volume with the Apple Remote (boolean)
+#macosx-appleremote-sysvol=0
+
+# Control playlist items with the Apple Remote (boolean)
+#macosx-appleremote-prevnext=0
+
+# Control playback with media keys (boolean)
+#macosx-mediakeys=1
+
+# Video device (integer)
+#macosx-vdev=0
+
+# Opaqueness (float)
+#macosx-opaqueness=1.000000
+
+# Black screens in fullscreen (boolean)
+#macosx-black=0
+
+[dynamicoverlay] # Dynamic video overlay
+
+# Input FIFO (string)
+#overlay-input=
+
+# Output FIFO (string)
+#overlay-output=
+
+[ncurses] # Ncurses interface
+
+# Filebrowser starting point (string)
+#browse-dir=
+
+[mp4] # MP4 stream demuxer
+
+# M4A audio only (boolean)
+#mp4-m4a-audioonly=0
+
+[mosaic_bridge] # Mosaic bridge stream output
+
+# ID (string)
+#sout-mosaic-bridge-id=Id
+
+# Video width (integer)
+#sout-mosaic-bridge-width=0
+
+# Video height (integer)
+#sout-mosaic-bridge-height=0
+
+# Sample aspect ratio (string)
+#sout-mosaic-bridge-sar=1:1
+
+# Image chroma (string)
+#sout-mosaic-bridge-chroma=
+
+# Video filter (string)
+#sout-mosaic-bridge-vfilter=
+
+# Transparency (integer)
+#sout-mosaic-bridge-alpha=255
+
+# X offset (integer)
+#sout-mosaic-bridge-x=-1
+
+# Y offset (integer)
+#sout-mosaic-bridge-y=-1
+
+[afile] # File audio output
+
+# Output file (string)
+#audiofile-file=audiofile.wav
+
+# Output format (string)
+#audiofile-format=s16
+
+# Number of output channels (integer)
+#audiofile-channels=0
+
+# Add WAVE header (boolean)
+#audiofile-wav=1
+
+[yuv] # YUV video output
+
+# device, fifo or filename (string)
+#yuv-file=stream.yuv
+
+# Chroma used (string)
+#yuv-chroma=
+
+# Add a YUV4MPEG2 header (boolean)
+#yuv-yuv4mpeg2=0
+
+[vdummy] # Dummy video output
+
+# Dummy image chroma format (string)
+#dummy-chroma=
+
+[ttml] # TTML subtitles decoder
+
+# Subtitle justification (integer)
+#ttml-align=0
+
+[live555] # RTP/RTSP/SDP demuxer (using Live555)
+
+# Use RTP over RTSP (TCP) (boolean)
+#rtsp-tcp=0
+
+# Client port (integer)
+#rtp-client-port=-1
+
+# Force multicast RTP via RTSP (boolean)
+#rtsp-mcast=0
+
+# Tunnel RTSP and RTP over HTTP (boolean)
+#rtsp-http=0
+
+# HTTP tunnel port (integer)
+#rtsp-http-port=80
+
+# Kasenna RTSP dialect (boolean)
+#rtsp-kasenna=0
+
+# WMServer RTSP dialect (boolean)
+#rtsp-wmserver=0
+
+# Username (string)
+#rtsp-user=
+
+# Password (string)
+#rtsp-pwd=
+
+# RTSP frame buffer size (integer)
+#rtsp-frame-buffer-size=250000
+
+[h26x] # H264 video demuxer
+
+# Frames per Second (float)
+#h264-fps=0.000000
+
+# Frames per Second (float)
+#hevc-fps=0.000000
+
+[spatialaudio] # Ambisonics renderer and binauralizer
+
+# Headphones mode (binaural) (boolean)
+#spatialaudio-headphones=0
+
+# HRTF file for the binauralization (string)
+#hrtf-file=
+
+[file] # File logger
+
+# Log to file (boolean)
+#file-logging=0
+
+# Log filename (string)
+#logfile=
+
+# Log format (string)
+#logmode=text
+
+# Verbosity (integer)
+#log-verbose=-1
+
+[rist] # RIST input
+
+# RIST maximum packet size (bytes) (integer)
+#packet-size=1472
+
+# RIST demux/decode maximum jitter (default is 5ms) (integer)
+#maximum-jitter=5
+
+# RIST latency (ms) (integer)
+#latency=1000
+
+# RIST nack retry interval (ms) (integer)
+#retry-interval=132
+
+# RIST reorder buffer (ms) (integer)
+#reorder-buffer=70
+
+# RIST maximum retry count (integer)
+#max-retries=10
+
+# RIST nack type, 0 = range, 1 = bitmask. Default is range (integer)
+#nack-type=0
+
+# Disable NACK output packets (boolean)
+#disable-nacks=0
+
+# Do not check for a valid rtcp message from the encoder (boolean)
+#mcast-blind-nacks=0
+
+[audiobargraph_v] # Audio Bar Graph Video sub source
+
+# X coordinate (integer)
+#audiobargraph_v-x=0
+
+# Y coordinate (integer)
+#audiobargraph_v-y=0
+
+# Transparency of the bargraph (integer)
+#audiobargraph_v-transparency=255
+
+# Bargraph position (integer)
+#audiobargraph_v-position=-1
+
+# Bar width in pixel (integer)
+#audiobargraph_v-barWidth=10
+
+# Bar Height in pixel (integer)
+#audiobargraph_v-barHeight=400
+
+[remap] # Audio channel remapper
+
+# Left (integer)
+#aout-remap-channel-left=0
+
+# Center (integer)
+#aout-remap-channel-center=1
+
+# Right (integer)
+#aout-remap-channel-right=2
+
+# Rear left (integer)
+#aout-remap-channel-rearleft=3
+
+# Rear center (integer)
+#aout-remap-channel-rearcenter=4
+
+# Rear right (integer)
+#aout-remap-channel-rearright=5
+
+# Side left (integer)
+#aout-remap-channel-middleleft=6
+
+# Side right (integer)
+#aout-remap-channel-middleright=7
+
+# Low-frequency effects (integer)
+#aout-remap-channel-lfe=8
+
+# Normalize channels (boolean)
+#aout-remap-normalize=1
+
+[extract] # Extract RGB component video filter
+
+# RGB component to extract (integer)
+#extract-component=16711680
+
+[ts] # MPEG Transport Stream demuxer
+
+# Digital TV Standard (string)
+#ts-standard=auto
+
+# Extra PMT (string)
+#ts-extra-pmt=
+
+# Trust in-stream PCR (boolean)
+#ts-trust-pcr=1
+
+# Set id of ES to PID (boolean)
+#ts-es-id-pid=1
+
+# CSA Key (string)
+#ts-csa-ck=
+
+# Second CSA Key (string)
+#ts-csa2-ck=
+
+# Packet size in bytes to decrypt (integer)
+#ts-csa-pkt=188
+
+# Separate sub-streams (boolean)
+#ts-split-es=1
+
+# Seek based on percent not time (boolean)
+#ts-seek-percent=0
+
+# Check packets continuity counter (boolean)
+#ts-cc-check=1
+
+# Only create ES on program sending data (boolean)
+#ts-pmtfix-waitdata=1
+
+# Try to generate PAT/PMT if missing (boolean)
+#ts-patfix=1
+
+# Try to fix too early PCR (or late DTS) (boolean)
+#ts-pcr-offsetfix=1
+
+[telx] # Teletext subtitles decoder
+
+# Override page (integer)
+#telx-override-page=-1
+
+# Ignore subtitle flag (boolean)
+#telx-ignore-subtitle-flag=0
+
+# Workaround for France (boolean)
+#telx-french-workaround=0
+
+[libbluray] # Blu-ray Disc support (libbluray)
+
+# Blu-ray menus (boolean)
+#bluray-menu=1
+
+# Region code (string)
+#bluray-region=B
+
+[avi] # AVI muxer
+
+# Artist (string)
+#sout-avi-artist=
+
+# Date (string)
+#sout-avi-date=
+
+# Genre (string)
+#sout-avi-genre=
+
+# Copyright (string)
+#sout-avi-copyright=
+
+# Comment (string)
+#sout-avi-comment=
+
+# Name (string)
+#sout-avi-name=
+
+# Subject (string)
+#sout-avi-subject=
+
+# Encoder (string)
+#sout-avi-encoder=VLC Media Player - 3.0.12 Vetinari
+
+# Keywords (string)
+#sout-avi-keywords=
+
+[schroedinger] # Dirac video decoder using libschroedinger
+
+# Rate control method (string)
+#sout-schro-rate-control=
+
+# Constant quality factor (float)
+#sout-schro-quality=-1.000000
+
+# Noise Threshold (float)
+#sout-schro-noise-threshold=-1.000000
+
+# CBR bitrate (kbps) (integer)
+#sout-schro-bitrate=-1
+
+# Maximum bitrate (kbps) (integer)
+#sout-schro-max-bitrate=-1
+
+# Minimum bitrate (kbps) (integer)
+#sout-schro-min-bitrate=-1
+
+# GOP structure (string)
+#sout-schro-gop-structure=
+
+# GOP length (integer)
+#sout-schro-gop-length=-1
+
+# Chroma format (string)
+#sout-schro-chroma-fmt=420
+
+# Picture coding mode (string)
+#sout-schro-coding-mode=auto
+
+# Motion Vector precision (string)
+#sout-schro-mv-precision=
+
+# Size of motion compensation blocks (string)
+#sout-schro-motion-block-size=
+
+# Overlap of motion compensation blocks (string)
+#sout-schro-motion-block-overlap=
+
+# Three component motion estimation (integer)
+#sout-schro-me-combined=-1
+
+# Enable hierarchical Motion Estimation (integer)
+#sout-schro-enable-hierarchical-me=-1
+
+# Number of levels of downsampling (integer)
+#sout-schro-downsample-levels=-1
+
+# Enable Global Motion Estimation (integer)
+#sout-schro-enable-global-me=-1
+
+# Enable Phase Correlation Estimation (integer)
+#sout-schro-enable-phasecorr-me=-1
+
+# Intra picture DWT filter (string)
+#sout-schro-intra-wavelet=
+
+# Inter picture DWT filter (string)
+#sout-schro-inter-wavelet=
+
+# Number of DWT iterations (integer)
+#sout-schro-transform-depth=-1
+
+# Enable multiple quantizers (integer)
+#sout-schro-enable-multiquant=-1
+
+# Size of code blocks in each subband (string)
+#sout-schro-codeblock-size=
+
+# Prefilter (string)
+#sout-schro-filtering=
+
+# Amount of prefiltering (float)
+#sout-schro-filter-value=-1.000000
+
+# Enable Scene Change Detection (integer)
+#sout-schro-enable-scd=-1
+
+# perceptual weighting method (string)
+#sout-schro-perceptual-weighting=
+
+# perceptual distance (float)
+#sout-schro-perceptual-distance=-1.000000
+
+# Disable arithmetic coding (integer)
+#sout-schro-enable-noarith=-1
+
+# Horizontal slices per frame (integer)
+#sout-schro-horiz-slices=-1
+
+# Vertical slices per frame (integer)
+#sout-schro-vert-slices=-1
+
+# Force Profile (string)
+#sout-schro-force-profile=
+
+[deinterlace] # Deinterlacing video filter
+
+# Streaming deinterlace mode (string)
+#sout-deinterlace-mode=blend
+
+# Phosphor chroma mode for 4:2:0 input (integer)
+#sout-deinterlace-phosphor-chroma=2
+
+# Phosphor old field dimmer strength (integer)
+#sout-deinterlace-phosphor-dimmer=2
+
+[stream_out_standard] # Standard stream output
+
+# Output access method (string)
+#sout-standard-access=
+
+# Output muxer (string)
+#sout-standard-mux=
+
+# Output destination (string)
+#sout-standard-dst=
+
+# Address to bind to (helper setting for dst) (string)
+#sout-standard-bind=
+
+# Filename for stream (helper setting for dst) (string)
+#sout-standard-path=
+
+# SAP announcing (boolean)
+#sout-standard-sap=0
+
+# Session name (string)
+#sout-standard-name=
+
+# Session description (string)
+#sout-standard-description=
+
+# Session URL (string)
+#sout-standard-url=
+
+# Session email (string)
+#sout-standard-email=
+
+[adaptive] # Unified adaptive streaming for DASH/HLS
+
+# Adaptive Logic (string)
+#adaptive-logic=
+
+# Maximum device width (integer)
+#adaptive-maxwidth=0
+
+# Maximum device height (integer)
+#adaptive-maxheight=0
+
+# Fixed Bandwidth in KiB/s (integer)
+#adaptive-bw=250
+
+# Use regular HTTP modules (boolean)
+#adaptive-use-access=0
+
+# Live Playback delay (ms) (integer)
+#adaptive-livedelay=15000
+
+# Max buffering (ms) (integer)
+#adaptive-maxbuffer=30000
+
+# Low latency (integer)
+#adaptive-lowlatency=-1
+
+[erase] # Erase video filter
+
+# Image mask (string)
+#erase-mask=
+
+# X coordinate (integer)
+#erase-x=0
+
+# Y coordinate (integer)
+#erase-y=0
+
+[ps] # MPEG-PS demuxer
+
+# Trust MPEG timestamps (boolean)
+#ps-trust-timestamps=1
+
+[aribsub] # ARIB subtitles decoder
+
+# Ignore ruby (furigana) (boolean)
+#aribsub-ignore-ruby=0
+
+# Use Core Text renderer (boolean)
+#aribsub-use-coretext=0
+
+[kate] # Kate overlay decoder
+
+# Formatted Subtitles (boolean)
+#kate-formatted=1
+
+[bridge] # Bridge stream output
+
+# ID (integer)
+#sout-bridge-out-id=0
+
+# Destination bridge-in name (string)
+#sout-bridge-out-in-name=default
+
+# Delay (integer)
+#sout-bridge-in-delay=0
+
+# ID Offset (integer)
+#sout-bridge-in-id-offset=8192
+
+# Name of current instance (string)
+#sout-bridge-in-name=default
+
+# Fallback to placeholder stream when out of data (boolean)
+#sout-bridge-in-placeholder=0
+
+# Placeholder delay (integer)
+#sout-bridge-in-placeholder-delay=200
+
+# Wait for I frame before toggling placeholder (boolean)
+#sout-bridge-in-placeholder-switch-on-iframe=1
+
+[filesystem] # File input
+
+# List special files (boolean)
+#list-special-files=0
+
+[netsync] # Network synchronization
+
+# Network master clock (boolean)
+#netsync-master=0
+
+# Master server IP address (string)
+#netsync-master-ip=
+
+# UDP timeout (in ms) (integer)
+#netsync-timeout=500
+
+[jpeg] # JPEG image decoder
+
+# Quality level (integer)
+#sout-jpeg-quality=95
+
+[es] # MPEG-I/II/4 / A52 / DTS / MLP audio
+
+# Frames per Second (float)
+#es-fps=25.000000
+
+[audiotoolbox_midi] # AudioToolbox MIDI synthesizer
+
+# SoundFont file (string)
+#aumidi-soundfont=
+
+[http] # HTTP input
+
+# Auto re-connect (boolean)
+#http-reconnect=0
+
+[param_eq] # Parametric Equalizer
+
+# Low freq (Hz) (float)
+#param-eq-lowf=100.000000
+
+# Low freq gain (dB) (float)
+#param-eq-lowgain=0.000000
+
+# High freq (Hz) (float)
+#param-eq-highf=10000.000000
+
+# High freq gain (dB) (float)
+#param-eq-highgain=0.000000
+
+# Freq 1 (Hz) (float)
+#param-eq-f1=300.000000
+
+# Freq 1 gain (dB) (float)
+#param-eq-gain1=0.000000
+
+# Freq 1 Q (float)
+#param-eq-q1=3.000000
+
+# Freq 2 (Hz) (float)
+#param-eq-f2=1000.000000
+
+# Freq 2 gain (dB) (float)
+#param-eq-gain2=0.000000
+
+# Freq 2 Q (float)
+#param-eq-q2=3.000000
+
+# Freq 3 (Hz) (float)
+#param-eq-f3=3000.000000
+
+# Freq 3 gain (dB) (float)
+#param-eq-gain3=0.000000
+
+# Freq 3 Q (float)
+#param-eq-q3=3.000000
+
+[dav1d] # Dav1d video decoder
+
+# Frames Threads (integer)
+#dav1d-thread-frames=0
+
+# Tiles Threads (integer)
+#dav1d-thread-tiles=0
+
+[cdda] # Audio CD input
+
+# Audio CD device (string)
+#cd-audio=/dev/cdrom
+
+# CDDB Server (string)
+#cddb-server=freedb.videolan.org
+
+# CDDB port (integer)
+#cddb-port=80
+
+[gradfun] # Gradfun video filter
+
+# Radius (integer)
+#gradfun-radius=16
+
+# Strength (float)
+#gradfun-strength=1.200000
+
+[x264] # H.264/MPEG-4 Part 10/AVC encoder (x264)
+
+# Maximum GOP size (integer)
+#sout-x264-keyint=250
+
+# Minimum GOP size (integer)
+#sout-x264-min-keyint=25
+
+# Use recovery points to close GOPs (boolean)
+#sout-x264-opengop=0
+
+# Enable compatibility hacks for Blu-ray support (boolean)
+#sout-x264-bluray-compat=0
+
+# Extra I-frames aggressivity (integer)
+#sout-x264-scenecut=40
+
+# B-frames between I and P (integer)
+#sout-x264-bframes=3
+
+# Adaptive B-frame decision (integer)
+#sout-x264-b-adapt=1
+
+# Influence (bias) B-frames usage (integer)
+#sout-x264-b-bias=0
+
+# Keep some B-frames as references (string)
+#sout-x264-bpyramid=normal
+
+# CABAC (boolean)
+#sout-x264-cabac=1
+
+# Use fullrange instead of TV colorrange (boolean)
+#sout-x264-fullrange=0
+
+# Number of reference frames (integer)
+#sout-x264-ref=3
+
+# Skip loop filter (boolean)
+#sout-x264-nf=0
+
+# Loop filter AlphaC0 and Beta parameters alpha:beta (string)
+#sout-x264-deblock=0:0
+
+# Strength of psychovisual optimization, default is "1.0:0.0" (string)
+#sout-x264-psy-rd=1.0:0.0
+
+# Use Psy-optimizations (boolean)
+#sout-x264-psy=1
+
+# H.264 level (string)
+#sout-x264-level=0
+
+# H.264 profile (string)
+#sout-x264-profile=high
+
+# Interlaced mode (boolean)
+#sout-x264-interlaced=0
+
+# Frame packing (integer)
+#sout-x264-frame-packing=-1
+
+# Force number of slices per frame (integer)
+#sout-x264-slices=0
+
+# Limit the size of each slice in bytes (integer)
+#sout-x264-slice-max-size=0
+
+# Limit the size of each slice in macroblocks (integer)
+#sout-x264-slice-max-mbs=0
+
+# HRD-timing information (string)
+#sout-x264-hrd=none
+
+# Set QP (integer)
+#sout-x264-qp=-1
+
+# Quality-based VBR (integer)
+#sout-x264-crf=23
+
+# Min QP (integer)
+#sout-x264-qpmin=10
+
+# Max QP (integer)
+#sout-x264-qpmax=51
+
+# Max QP step (integer)
+#sout-x264-qpstep=4
+
+# Average bitrate tolerance (float)
+#sout-x264-ratetol=1.000000
+
+# Max local bitrate (integer)
+#sout-x264-vbv-maxrate=0
+
+# VBV buffer (integer)
+#sout-x264-vbv-bufsize=0
+
+# Initial VBV buffer occupancy (float)
+#sout-x264-vbv-init=0.900000
+
+# QP factor between I and P (float)
+#sout-x264-ipratio=1.400000
+
+# QP factor between P and B (float)
+#sout-x264-pbratio=1.300000
+
+# QP difference between chroma and luma (integer)
+#sout-x264-chroma-qp-offset=0
+
+# Multipass ratecontrol (integer)
+#sout-x264-pass=0
+
+# QP curve compression (float)
+#sout-x264-qcomp=0.600000
+
+# Reduce fluctuations in QP (float)
+#sout-x264-cplxblur=20.000000
+
+# Reduce fluctuations in QP (float)
+#sout-x264-qblur=0.500000
+
+# How AQ distributes bits (integer)
+#sout-x264-aq-mode=1
+
+# Strength of AQ (float)
+#sout-x264-aq-strength=1.000000
+
+# Partitions to consider (string)
+#sout-x264-partitions=normal
+
+# Direct MV prediction mode (string)
+#sout-x264-direct=spatial
+
+# Direct prediction size (integer)
+#sout-x264-direct-8x8=1
+
+# Weighted prediction for B-frames (boolean)
+#sout-x264-weightb=1
+
+# Weighted prediction for P-frames (integer)
+#sout-x264-weightp=2
+
+# Integer pixel motion estimation method (string)
+#sout-x264-me=hex
+
+# Maximum motion vector search range (integer)
+#sout-x264-merange=16
+
+# Maximum motion vector length (integer)
+#sout-x264-mvrange=-1
+
+# Minimum buffer space between threads (integer)
+#sout-x264-mvrange-thread=-1
+
+# Subpixel motion estimation and partition decision quality (integer)
+#sout-x264-subme=7
+
+# Decide references on a per partition basis (boolean)
+#sout-x264-mixed-refs=1
+
+# Chroma in motion estimation (boolean)
+#sout-x264-chroma-me=1
+
+# Adaptive spatial transform size (boolean)
+#sout-x264-8x8dct=1
+
+# Trellis RD quantization (integer)
+#sout-x264-trellis=1
+
+# Framecount to use on frametype lookahead (integer)
+#sout-x264-lookahead=40
+
+# Use Periodic Intra Refresh (boolean)
+#sout-x264-intra-refresh=0
+
+# Use mb-tree ratecontrol (boolean)
+#sout-x264-mbtree=1
+
+# Early SKIP detection on P-frames (boolean)
+#sout-x264-fast-pskip=1
+
+# Coefficient thresholding on P-frames (boolean)
+#sout-x264-dct-decimate=1
+
+# Noise reduction (integer)
+#sout-x264-nr=0
+
+# Inter luma quantization deadzone (integer)
+#sout-x264-deadzone-inter=21
+
+# Intra luma quantization deadzone (integer)
+#sout-x264-deadzone-intra=11
+
+# Non-deterministic optimizations when threaded (boolean)
+#sout-x264-non-deterministic=0
+
+# CPU optimizations (boolean)
+#sout-x264-asm=1
+
+# PSNR computation (boolean)
+#sout-x264-psnr=0
+
+# SSIM computation (boolean)
+#sout-x264-ssim=0
+
+# Quiet mode (boolean)
+#sout-x264-quiet=0
+
+# SPS and PPS id numbers (integer)
+#sout-x264-sps-id=0
+
+# Access unit delimiters (boolean)
+#sout-x264-aud=0
+
+# Statistics (boolean)
+#sout-x264-verbose=0
+
+# Filename for 2 pass stats file (string)
+#sout-x264-stats=x264_2pass.log
+
+# Default preset setting used (string)
+#sout-x264-preset=
+
+# Default tune setting used (string)
+#sout-x264-tune=
+
+# x264 advanced options (string)
+#sout-x264-options=
+
+[compressor] # Dynamic range compressor
+
+# RMS/peak (float)
+#compressor-rms-peak=0.200000
+
+# Attack time (float)
+#compressor-attack=25.000000
+
+# Release time (float)
+#compressor-release=100.000000
+
+# Threshold level (float)
+#compressor-threshold=-11.000000
+
+# Ratio (float)
+#compressor-ratio=4.000000
+
+# Knee radius (float)
+#compressor-knee=5.000000
+
+# Makeup gain (float)
+#compressor-makeup-gain=7.000000
+
+[mpegvideo] # MPEG-I/II video packetizer
+
+# Sync on Intra Frame (boolean)
+#packetizer-mpegvideo-sync-iframe=0
+
+[access_output_rist] # RIST stream output
+
+# RIST target packet size (bytes) (integer)
+#sout-rist-packet-size=1328
+
+# RIST data output caching size (ms) (integer)
+#sout-rist-caching=50
+
+# RIST retry-buffer queue size (ms) (integer)
+#sout-rist-buffer-size=0
+
+# SSRC used in RTP output (default is random, i.e. 0) (integer)
+#sout-rist-ssrc=0
+
+# Stream name (string)
+#sout-rist-stream-name=
+
+[svcdsub] # Philips OGT (SVCD subtitle) decoder
+
+[ci_filters] # Mac OS X hardware video filters
+
+# Use a specific Core Image Filter (string)
+#ci-filter=CIComicEffect
+
+[oldrc] # Remote control interface
+
+# Show stream position (boolean)
+#rc-show-pos=0
+
+# Fake TTY (boolean)
+#rc-fake-tty=0
+
+# UNIX socket command input (string)
+#rc-unix=
+
+# TCP command input (string)
+#rc-host=
+
+[vorbis] # Vorbis audio decoder
+
+# Encoding quality (integer)
+#sout-vorbis-quality=0
+
+# Maximum encoding bitrate (integer)
+#sout-vorbis-max-bitrate=0
+
+# Minimum encoding bitrate (integer)
+#sout-vorbis-min-bitrate=0
+
+# CBR encoding (boolean)
+#sout-vorbis-cbr=0
+
+[theora] # Theora video decoder
+
+# Post processing quality (integer)
+#theora-postproc=-1
+
+# Encoding quality (integer)
+#sout-theora-quality=2
+
+[lua] # Lua interpreter
+
+# Lua interface (string)
+#lua-intf=dummy
+
+# Lua interface configuration (string)
+#lua-config=
+
+# Password (string)
+#http-password=
+
+# Source directory (string)
+#http-src=
+
+# Directory index (boolean)
+#http-index=0
+
+# TCP command input (string)
+#rc-host=
+
+# CLI input (string)
+#cli-host=
+
+# Host (string)
+#telnet-host=localhost
+
+# Port (integer)
+#telnet-port=4212
+
+# Password (string)
+#telnet-password=
+
+[demuxdump] # File dumper
+
+# Dump module (string)
+#demuxdump-access=file
+
+# Dump filename (string)
+#demuxdump-file=stream-demux.dump
+
+# Append to existing file (boolean)
+#demuxdump-append=0
+
+[asf] # ASF muxer
+
+# Title (string)
+#sout-asf-title=
+
+# Author (string)
+#sout-asf-author=
+
+# Copyright (string)
+#sout-asf-copyright=
+
+# Comment (string)
+#sout-asf-comment=
+
+# Rating (string)
+#sout-asf-rating=
+
+# Packet Size (integer)
+#sout-asf-packet-size=4096
+
+# Bitrate override (integer)
+#sout-asf-bitrate-override=0
+
+[podcast] # Podcasts
+
+# Podcast URLs list (string)
+#podcast-urls=
+
+[goom] # Goom effect
+
+# Goom display width (integer)
+#goom-width=800
+
+# Goom display height (integer)
+#goom-height=500
+
+# Goom animation speed (integer)
+#goom-speed=6
+
+[adjust] # Image properties filter
+
+# Image contrast (0-2) (float)
+#contrast=1.000000
+
+# Image brightness (0-2) (float)
+#brightness=1.000000
+
+# Image hue (-180..180) (float)
+#hue=0.000000
+
+# Image saturation (0-3) (float)
+#saturation=1.000000
+
+# Image gamma (0-10) (float)
+#gamma=1.000000
+
+# Brightness threshold (boolean)
+#brightness-threshold=0
+
+[prefetch] # Stream prefetch filter
+
+# Buffer size (integer)
+#prefetch-buffer-size=16384
+
+# Read size (integer)
+#prefetch-read-size=16777216
+
+# Seek threshold (integer)
+#prefetch-seek-threshold=16384
+
+[vpx] # WebM video decoder
+
+# Quality mode (integer)
+#sout-vpx-quality-mode=1000000
+
+[dvdread] # DVDRead Input (no menu support)
+
+# DVD angle (integer)
+#dvdread-angle=1
+
+[spudec] # DVD subtitles decoder
+
+# Disable DVD subtitle transparency (boolean)
+#dvdsub-transparency=0
+
+[access_output_srt] # SRT stream output
+
+# SRT chunk size (bytes) (integer)
+#chunk-size=1316
+
+# Return poll wait after timeout milliseconds (-1 = infinite) (integer)
+#poll-timeout=100
+
+# SRT latency (ms) (integer)
+#latency=125
+
+# Password for stream encryption (string)
+#passphrase=
+
+# Crypto key length in bytes (integer)
+#key-length=16
+
+[rss] # RSS and Atom feed display
+
+# Feed URLs (string)
+#rss-urls=
+
+# X offset (integer)
+#rss-x=0
+
+# Y offset (integer)
+#rss-y=0
+
+# Text position (integer)
+#rss-position=-1
+
+# Opacity (integer)
+#rss-opacity=255
+
+# Color (integer)
+#rss-color=16777215
+
+# Font size, pixels (integer)
+#rss-size=0
+
+# Speed of feeds (integer)
+#rss-speed=100000
+
+# Max length (integer)
+#rss-length=60
+
+# Refresh time (integer)
+#rss-ttl=1800
+
+# Feed images (boolean)
+#rss-images=1
+
+# Title display mode (integer)
+#rss-title=-1
+
+[rawaud] # Raw audio demuxer
+
+# Audio channels (integer)
+#rawaud-channels=2
+
+# Audio samplerate (Hz) (integer)
+#rawaud-samplerate=48000
+
+# FOURCC code of raw input format (string)
+#rawaud-fourcc=s16l
+
+# Forces the audio language (string)
+#rawaud-lang=eng
+
+[grain] # Grain video filter
+
+# Variance (float)
+#grain-variance=2.000000
+
+# Minimal period (integer)
+#grain-period-min=1
+
+# Maximal period (integer)
+#grain-period-max=48
+
+[bluescreen] # Bluescreen video filter
+
+# Bluescreen U value (integer)
+#bluescreen-u=120
+
+# Bluescreen V value (integer)
+#bluescreen-v=90
+
+# Bluescreen U tolerance (integer)
+#bluescreen-ut=17
+
+# Bluescreen V tolerance (integer)
+#bluescreen-vt=17
+
+[stream_out_rtp] # RTP stream output
+
+# Destination (string)
+#sout-rtp-dst=
+
+# SDP (string)
+#sout-rtp-sdp=
+
+# Muxer (string)
+#sout-rtp-mux=
+
+# SAP announcing (boolean)
+#sout-rtp-sap=0
+
+# Session name (string)
+#sout-rtp-name=
+
+# Session category (string)
+#sout-rtp-cat=
+
+# Session description (string)
+#sout-rtp-description=
+
+# Session URL (string)
+#sout-rtp-url=
+
+# Session email (string)
+#sout-rtp-email=
+
+# Transport protocol (string)
+#sout-rtp-proto=udp
+
+# Port (integer)
+#sout-rtp-port=5004
+
+# Audio port (integer)
+#sout-rtp-port-audio=0
+
+# Video port (integer)
+#sout-rtp-port-video=0
+
+# Hop limit (TTL) (integer)
+#sout-rtp-ttl=-1
+
+# RTP/RTCP multiplexing (boolean)
+#sout-rtp-rtcp-mux=0
+
+# Caching value (ms) (integer)
+#sout-rtp-caching=300
+
+# SRTP key (hexadecimal) (string)
+#sout-rtp-key=
+
+# SRTP salt (hexadecimal) (string)
+#sout-rtp-salt=
+
+# MP4A LATM (boolean)
+#sout-rtp-mp4a-latm=0
+
+# RTSP session timeout (s) (integer)
+#rtsp-timeout=60
+
+# Username (string)
+#sout-rtsp-user=
+
+# Password (string)
+#sout-rtsp-pwd=
+
+[console] # Console logger
+
+[postproc] # Video post processing filter
+
+# Post processing quality (integer)
+#postproc-q=6
+
+# FFmpeg post processing filter chains (string)
+#postproc-name=default
+
+[ftp] # FTP input
+
+# Username (string)
+#ftp-user=
+
+# Password (string)
+#ftp-pwd=
+
+# FTP account (string)
+#ftp-account=anonymous
+
+[cc] # Closed Captions decoder
+
+# Opacity (boolean)
+#cc-opaque=1
+
+[keychain] # Keystore for iOS, Mac OS X and tvOS
+
+# Synchronize stored items (integer)
+#keychain-synchronize=1
+
+# Accessibility type for all future passwords saved to the Keychain (integer)
+#keychain-accessibility-type=0
+
+# Keychain access group (string)
+#keychain-access-group=
+
+[remoteosd] # Remote-OSD over VNC
+
+# VNC Host (string)
+#rmtosd-host=myvdr
+
+# VNC Port (integer)
+#rmtosd-port=20001
+
+# VNC Password (string)
+#rmtosd-password=
+
+# VNC poll interval (integer)
+#rmtosd-update=1000
+
+# VNC polling (boolean)
+#rmtosd-vnc-polling=0
+
+# Mouse events (boolean)
+#rmtosd-mouse-events=0
+
+# Key events (boolean)
+#rmtosd-key-events=0
+
+# Alpha transparency value (default 255) (integer)
+#rmtosd-alpha=255
+
+[rotate] # Rotate video filter
+
+# Angle in degrees (float)
+#rotate-angle=30.000000
+
+# Use motion sensors (boolean)
+#rotate-use-motion=0
+
+[zvbi] # VBI and Teletext decoder
+
+# Teletext page (integer)
+#vbi-page=100
+
+# Opacity (boolean)
+#vbi-opaque=0
+
+# Teletext alignment (integer)
+#vbi-position=8
+
+# Teletext text subtitles (boolean)
+#vbi-text=0
+
+# Presentation Level (integer)
+#vbi-level=3
+
+[access_output_shout] # IceCAST output
+
+# Stream name (string)
+#sout-shout-name=VLC media player - Live stream
+
+# Stream description (string)
+#sout-shout-description=Live stream from VLC media player
+
+# Stream MP3 (boolean)
+#sout-shout-mp3=0
+
+# Genre description (string)
+#sout-shout-genre=Alternative
+
+# URL description (string)
+#sout-shout-url=http://www.videolan.org/vlc
+
+# Bitrate (string)
+#sout-shout-bitrate=
+
+# Samplerate (string)
+#sout-shout-samplerate=
+
+# Number of channels (string)
+#sout-shout-channels=
+
+# Ogg Vorbis Quality (string)
+#sout-shout-quality=
+
+# Stream public (boolean)
+#sout-shout-public=0
+
+[gain] # Gain control filter
+
+# Gain multiplier (float)
+#gain-value=1.000000
+
+[http] # HTTP stream output
+
+# Username (string)
+#sout-http-user=
+
+# Password (string)
+#sout-http-pwd=
+
+# Mime (string)
+#sout-http-mime=
+
+# Metacube (boolean)
+#sout-http-metacube=0
+
+[timecode] # Time code subpicture elementary stream generator
+
+# Frame rate (string)
+#timecode-fps=25/1
+
+[mjpeg] # M-JPEG camera demuxer
+
+# Frames per Second (float)
+#mjpeg-fps=0.000000
+
+[headphone] # Headphone virtual spatialization effect
+
+# Characteristic dimension (integer)
+#headphone-dim=10
+
+# Compensate delay (boolean)
+#headphone-compensate=0
+
+# No decoding of Dolby Surround (boolean)
+#headphone-dolby=0
+
+[colorthres] # Color threshold filter
+
+# Color (integer)
+#colorthres-color=16711680
+
+# Saturation threshold (integer)
+#colorthres-saturationthres=20
+
+# Similarity threshold (integer)
+#colorthres-similaritythres=15
+
+[mkv] # Matroska stream demuxer
+
+# Respect ordered chapters (boolean)
+#mkv-use-ordered-chapters=1
+
+# Chapter codecs (boolean)
+#mkv-use-chapter-codec=1
+
+# Preload MKV files in the same directory (boolean)
+#mkv-preload-local-dir=1
+
+# Seek based on percent not time (boolean)
+#mkv-seek-percent=0
+
+# Dummy Elements (boolean)
+#mkv-use-dummy=0
+
+# Preload clusters (boolean)
+#mkv-preload-clusters=0
+
+[motion] # motion control interface
+
+[dca] # DTS Coherent Acoustics audio decoder
+
+# DTS dynamic range compression (boolean)
+#dts-dynrng=1
+
+[udp] # UDP input
+
+# UDP Source timeout (sec) (integer)
+#udp-timeout=-1
+
+[transform] # Video transformation filter
+
+# Transform type (string)
+#transform-type=90
+
+[subtitle] # Text subtitle parser
+
+# Frames per Second (float)
+#sub-fps=0.000000
+
+# Subtitle delay (integer)
+#sub-delay=0
+
+# Subtitle format (string)
+#sub-type=auto
+
+# Subtitle description (string)
+#sub-description=
+
+[gradient] # Gradient video filter
+
+# Distort mode (string)
+#gradient-mode=gradient
+
+# Gradient image type (integer)
+#gradient-type=0
+
+# Apply cartoon effect (boolean)
+#gradient-cartoon=1
+
+[playlist] # Playlist
+
+# Skip ads (boolean)
+#playlist-skip-ads=1
+
+# Show shoutcast adult content (boolean)
+#shoutcast-show-adult=0
+
+[audioscrobbler] # Submission of played songs to last.fm
+
+# Username (string)
+#lastfm-username=
+
+# Password (string)
+#lastfm-password=
+
+# Scrobbler URL (string)
+#scrobbler-url=post.audioscrobbler.com
+
+[es] # Elementary stream output
+
+# Output access method (string)
+#sout-es-access=
+
+# Output muxer (string)
+#sout-es-mux=
+
+# Output URL (string)
+#sout-es-dst=
+
+# Audio output access method (string)
+#sout-es-access-audio=
+
+# Audio output muxer (string)
+#sout-es-mux-audio=
+
+# Audio output URL (string)
+#sout-es-dst-audio=
+
+# Video output access method (string)
+#sout-es-access-video=
+
+# Video output muxer (string)
+#sout-es-mux-video=
+
+# Video output URL (string)
+#sout-es-dst-video=
+
+[logger] # File logging
+
+[antiflicker] # antiflicker video filter
+
+# Window size (integer)
+#antiflicker-window-size=10
+
+# Softening value (integer)
+#antiflicker-softening-size=10
+
+[nfs] # NFS input
+
+# Set NFS uid/guid automatically (boolean)
+#nfs-auto-guid=1
+
+[delay] # Delay a stream
+
+# Elementary Stream ID (integer)
+#sout-delay-id=0
+
+# Delay of the ES (ms) (integer)
+#sout-delay-delay=0
+
+[puzzle] # Puzzle interactive game video filter
+
+# Number of puzzle rows (integer)
+#puzzle-rows=4
+
+# Number of puzzle columns (integer)
+#puzzle-cols=4
+
+# Border (integer)
+#puzzle-border=3
+
+# Small preview (boolean)
+#puzzle-preview=0
+
+# Small preview size (integer)
+#puzzle-preview-size=15
+
+# Piece edge shape size (integer)
+#puzzle-shape-size=90
+
+# Auto shuffle (integer)
+#puzzle-auto-shuffle=0
+
+# Auto solve (integer)
+#puzzle-auto-solve=0
+
+# Rotation (integer)
+#puzzle-rotation=0
+
+# Game mode (integer)
+#puzzle-mode=0
+
+[auhal] # HAL AudioUnit output
+
+# Audio volume (integer)
+auhal-volume=512
+
+# Last audio device (string)
+auhal-audio-device=0
+
+# ? (string)
+#auhal-warned-devices=
+
+[rtsp] # Legacy RTSP VoD server
+
+# MUX for RAW RTSP transport (string)
+#rtsp-raw-mux=ts
+
+# Maximum number of connections (integer)
+#rtsp-throttle-users=0
+
+# Sets the timeout option in the RTSP session string (integer)
+#rtsp-session-timeout=5
+
+[imem] # Memory input
+
+# ID (integer)
+#imem-id=-1
+
+# Group (integer)
+#imem-group=0
+
+# Category (integer)
+#imem-cat=0
+
+# Codec (string)
+#imem-codec=
+
+# Language (string)
+#imem-language=
+
+# Sample rate (integer)
+#imem-samplerate=0
+
+# Channels count (integer)
+#imem-channels=0
+
+# Width (integer)
+#imem-width=0
+
+# Height (integer)
+#imem-height=0
+
+# Display aspect ratio (string)
+#imem-dar=
+
+# Frame rate (string)
+#imem-fps=
+
+# Size (integer)
+#imem-size=0
+
+[display] # Display stream output
+
+# Enable audio (boolean)
+#sout-display-audio=1
+
+# Enable video (boolean)
+#sout-display-video=1
+
+# Delay (ms) (integer)
+#sout-display-delay=100
+
+[rawvid] # Raw video demuxer
+
+# Frames per Second (string)
+#rawvid-fps=
+
+# Width (integer)
+#rawvid-width=0
+
+# Height (integer)
+#rawvid-height=0
+
+# Force chroma (Use carefully) (string)
+#rawvid-chroma=
+
+# Aspect ratio (string)
+#rawvid-aspect-ratio=
+
+[canvas] # Canvas video filter
+
+# Output width (integer)
+#canvas-width=0
+
+# Output height (integer)
+#canvas-height=0
+
+# Output picture aspect ratio (string)
+#canvas-aspect=
+
+# Pad video (boolean)
+#canvas-padd=1
+
+[sftp] # SFTP input
+
+# SFTP port (integer)
+#sftp-port=22
+
+# Username (string)
+#sftp-user=
+
+# Password (string)
+#sftp-pwd=
+
+[wall] # Wall video filter
+
+# Number of columns (integer)
+#wall-cols=3
+
+# Number of rows (integer)
+#wall-rows=3
+
+# Active windows (string)
+#wall-active=
+
+# Element aspect ratio (string)
+#wall-element-aspect=16:9
+
+[motionblur] # Motion blur filter
+
+# Blur factor (1-127) (integer)
+#blur-factor=80
+
+[dvbsub] # DVB subtitles decoder
+
+# Subpicture position (integer)
+#dvbsub-position=8
+
+# Decoding X coordinate (integer)
+#dvbsub-x=-1
+
+# Decoding Y coordinate (integer)
+#dvbsub-y=-1
+
+# Encoding X coordinate (integer)
+#sout-dvbsub-x=-1
+
+# Encoding Y coordinate (integer)
+#sout-dvbsub-y=-1
+
+[subsusf] # USF subtitles decoder
+
+# Formatted Subtitles (boolean)
+#subsdec-formatted=1
+
+[stream_out_chromaprint] # Chromaprint stream output
+
+# Duration of the fingerprinting (integer)
+#duration=90
+
+[rtp] # Real-Time Protocol (RTP) input
+
+# RTCP (local) port (integer)
+#rtcp-port=0
+
+# SRTP key (hexadecimal) (string)
+#srtp-key=
+
+# SRTP salt (hexadecimal) (string)
+#srtp-salt=
+
+# Maximum RTP sources (integer)
+#rtp-max-src=1
+
+# RTP source timeout (sec) (integer)
+#rtp-timeout=5
+
+# Maximum RTP sequence number dropout (integer)
+#rtp-max-dropout=3000
+
+# Maximum RTP sequence number misordering (integer)
+#rtp-max-misorder=100
+
+# RTP payload format assumed for dynamic payloads (string)
+#rtp-dynamic-pt=
+
+[avi] # AVI demuxer
+
+# Force interleaved method (boolean)
+#avi-interleaved=0
+
+# Force index creation (integer)
+#avi-index=0
+
+[gaussianblur] # Gaussian blur video filter
+
+# Gaussian's std deviation (float)
+#gaussianblur-sigma=2.000000
+
+[clone] # Clone video filter
+
+# Number of clones (integer)
+#clone-count=2
+
+# Video output modules (string)
+#clone-vout-list=
+
+[file] # Secrets are stored on a file without any encryption
+
+# ? (string)
+#keystore-file=
+
+[sharpen] # Sharpen video filter
+
+# Sharpen strength (0-2) (float)
+#sharpen-sigma=0.050000
+
+[diracsys] # Dirac video demuxer
+
+# Value to adjust dts by (integer)
+#dirac-dts-offset=0
+
+[logo] # Logo sub source
+
+# Logo filenames (string)
+#logo-file=
+
+# X coordinate (integer)
+#logo-x=-1
+
+# Y coordinate (integer)
+#logo-y=-1
+
+# Logo individual image time in ms (integer)
+#logo-delay=1000
+
+# Logo animation # of loops (integer)
+#logo-repeat=-1
+
+# Opacity of the logo (integer)
+#logo-opacity=255
+
+# Logo position (integer)
+#logo-position=-1
+
+[visual] # Visualizer filter
+
+# Effects list (string)
+#effect-list=spectrum
+
+# Video width (integer)
+#effect-width=800
+
+# Video height (integer)
+#effect-height=500
+
+# FFT window (string)
+#effect-fft-window=flat
+
+# Kaiser window parameter (float)
+#effect-kaiser-param=3.000000
+
+# Show 80 bands instead of 20 (boolean)
+#visual-80-bands=1
+
+# Draw peaks in the analyzer (boolean)
+#visual-peaks=1
+
+# Enable original graphic spectrum (boolean)
+#spect-show-original=0
+
+# Draw the base of the bands (boolean)
+#spect-show-base=1
+
+# Base pixel radius (integer)
+#spect-radius=42
+
+# Spectral sections (integer)
+#spect-sections=3
+
+# V-plane color (integer)
+#spect-color=80
+
+# Draw bands in the spectrometer (boolean)
+#spect-show-bands=1
+
+# Show 80 bands instead of 20 (boolean)
+#spect-80-bands=1
+
+# Number of blank pixels between bands. (integer)
+#spect-separ=1
+
+# Amplification (integer)
+#spect-amp=8
+
+# Draw peaks in the analyzer (boolean)
+#spect-show-peaks=1
+
+# Peak extra width (integer)
+#spect-peak-width=61
+
+# Peak height (integer)
+#spect-peak-height=1
+
+[ball] # Ball video filter
+
+# Ball color (string)
+#ball-color=red
+
+# Ball speed (integer)
+#ball-speed=4
+
+# Ball size (integer)
+#ball-size=10
+
+# Gradient threshold (integer)
+#ball-gradient-threshold=40
+
+# Edge visible (boolean)
+#ball-edge-visible=1
+
+[access] # HTTPS input
+
+# Cookies forwarding (boolean)
+#http-forward-cookies=1
+
+# User agent (string)
+#http-user-agent=
+
+[fps] # FPS conversion video filter
+
+# Frame rate (string)
+#fps-fps=
+
+[access_output_livehttp] # HTTP Live streaming output
+
+# Segment length (integer)
+#sout-livehttp-seglen=10
+
+# Number of segments (integer)
+#sout-livehttp-numsegs=0
+
+# Number of first segment (integer)
+#sout-livehttp-initial-segment-number=1
+
+# Split segments anywhere (boolean)
+#sout-livehttp-splitanywhere=0
+
+# Delete segments (boolean)
+#sout-livehttp-delsegs=1
+
+# Use muxers rate control mechanism (boolean)
+#sout-livehttp-ratecontrol=0
+
+# Allow cache (boolean)
+#sout-livehttp-caching=0
+
+# Use randomized IV for encryption (boolean)
+#sout-livehttp-generate-iv=0
+
+# Index file (string)
+#sout-livehttp-index=
+
+# Full URL to put in index file (string)
+#sout-livehttp-index-url=
+
+# AES key URI to place in playlist (string)
+#sout-livehttp-key-uri=
+
+# AES key file (string)
+#sout-livehttp-key-file=
+
+# File where vlc reads key-uri and keyfile-location (string)
+#sout-livehttp-key-loadfile=
+
+[setid] # Change the id of an elementary stream
+
+# Elementary Stream ID (integer)
+#sout-setid-id=0
+
+# New ES ID (integer)
+#sout-setid-new-id=0
+
+# Elementary Stream ID (integer)
+#sout-setlang-id=0
+
+# Language (string)
+#sout-setlang-lang=eng
+
+[mux_ogg] # Ogg/OGM muxer
+
+# Index interval (integer)
+#sout-ogg-indexintvl=1000
+
+# Index size ratio (float)
+#sout-ogg-indexratio=1.000000
+
+[rawdv] # DV (Digital Video) demuxer
+
+# Hurry up (boolean)
+#rawdv-hurry-up=0
+
+[audiobargraph_a] # Audio part of the BarGraph function
+
+# Defines if BarGraph information should be sent (integer)
+#audiobargraph_a-bargraph=1
+
+# Sends the barGraph information every n audio packets (integer)
+#audiobargraph_a-bargraph_repetition=4
+
+# Defines if silence alarm information should be sent (integer)
+#audiobargraph_a-silence=1
+
+# Time window to use in ms (integer)
+#audiobargraph_a-time_window=5000
+
+# Minimum Audio level to raise the alarm (float)
+#audiobargraph_a-alarm_threshold=0.020000
+
+# Time between two alarm messages in ms (integer)
+#audiobargraph_a-repetition_time=2000
+
+[mp4] # MP4/MOV muxer
+
+# Create "Fast Start" files (boolean)
+#sout-mp4-faststart=1
+
+[udp] # UDP stream output
+
+# Caching value (ms) (integer)
+#sout-udp-caching=300
+
+# Group packets (integer)
+#sout-udp-group=1
+
+[sepia] # Sepia video filter
+
+# Sepia intensity (integer)
+#sepia-intensity=120
+
+[twolame] # Libtwolame audio encoder
+
+# Encoding quality (float)
+#sout-twolame-quality=0.000000
+
+# Stereo mode (integer)
+#sout-twolame-mode=0
+
+# VBR mode (boolean)
+#sout-twolame-vbr=0
+
+# Psycho-acoustic model (integer)
+#sout-twolame-psy=3
+
+[stereo_widen] # Simple stereo widening effect
+
+# Delay time (float)
+#stereowiden-delay=20.000000
+
+# Feedback gain (float)
+#stereowiden-feedback=0.300000
+
+# Crossfeed (float)
+#stereowiden-crossfeed=0.300000
+
+# Dry mix (float)
+#stereowiden-dry-mix=0.800000
+
+[alphamask] # Alpha mask video filter
+
+# Transparency mask (string)
+#alphamask-mask=
+
+[x26410b] # H.264/MPEG-4 Part 10/AVC encoder (x264 10-bit)
+
+# Maximum GOP size (integer)
+#sout-x26410b-keyint=250
+
+# Minimum GOP size (integer)
+#sout-x26410b-min-keyint=25
+
+# Use recovery points to close GOPs (boolean)
+#sout-x26410b-opengop=0
+
+# Enable compatibility hacks for Blu-ray support (boolean)
+#sout-x26410b-bluray-compat=0
+
+# Extra I-frames aggressivity (integer)
+#sout-x26410b-scenecut=40
+
+# B-frames between I and P (integer)
+#sout-x26410b-bframes=3
+
+# Adaptive B-frame decision (integer)
+#sout-x26410b-b-adapt=1
+
+# Influence (bias) B-frames usage (integer)
+#sout-x26410b-b-bias=0
+
+# Keep some B-frames as references (string)
+#sout-x26410b-bpyramid=normal
+
+# CABAC (boolean)
+#sout-x26410b-cabac=1
+
+# Use fullrange instead of TV colorrange (boolean)
+#sout-x26410b-fullrange=0
+
+# Number of reference frames (integer)
+#sout-x26410b-ref=3
+
+# Skip loop filter (boolean)
+#sout-x26410b-nf=0
+
+# Loop filter AlphaC0 and Beta parameters alpha:beta (string)
+#sout-x26410b-deblock=0:0
+
+# Strength of psychovisual optimization, default is "1.0:0.0" (string)
+#sout-x26410b-psy-rd=1.0:0.0
+
+# Use Psy-optimizations (boolean)
+#sout-x26410b-psy=1
+
+# H.264 level (string)
+#sout-x26410b-level=0
+
+# H.264 profile (string)
+#sout-x26410b-profile=high
+
+# Interlaced mode (boolean)
+#sout-x26410b-interlaced=0
+
+# Frame packing (integer)
+#sout-x26410b-frame-packing=-1
+
+# Force number of slices per frame (integer)
+#sout-x26410b-slices=0
+
+# Limit the size of each slice in bytes (integer)
+#sout-x26410b-slice-max-size=0
+
+# Limit the size of each slice in macroblocks (integer)
+#sout-x26410b-slice-max-mbs=0
+
+# HRD-timing information (string)
+#sout-x26410b-hrd=none
+
+# Set QP (integer)
+#sout-x26410b-qp=-1
+
+# Quality-based VBR (integer)
+#sout-x26410b-crf=23
+
+# Min QP (integer)
+#sout-x26410b-qpmin=10
+
+# Max QP (integer)
+#sout-x26410b-qpmax=51
+
+# Max QP step (integer)
+#sout-x26410b-qpstep=4
+
+# Average bitrate tolerance (float)
+#sout-x26410b-ratetol=1.000000
+
+# Max local bitrate (integer)
+#sout-x26410b-vbv-maxrate=0
+
+# VBV buffer (integer)
+#sout-x26410b-vbv-bufsize=0
+
+# Initial VBV buffer occupancy (float)
+#sout-x26410b-vbv-init=0.900000
+
+# QP factor between I and P (float)
+#sout-x26410b-ipratio=1.400000
+
+# QP factor between P and B (float)
+#sout-x26410b-pbratio=1.300000
+
+# QP difference between chroma and luma (integer)
+#sout-x26410b-chroma-qp-offset=0
+
+# Multipass ratecontrol (integer)
+#sout-x26410b-pass=0
+
+# QP curve compression (float)
+#sout-x26410b-qcomp=0.600000
+
+# Reduce fluctuations in QP (float)
+#sout-x26410b-cplxblur=20.000000
+
+# Reduce fluctuations in QP (float)
+#sout-x26410b-qblur=0.500000
+
+# How AQ distributes bits (integer)
+#sout-x26410b-aq-mode=1
+
+# Strength of AQ (float)
+#sout-x26410b-aq-strength=1.000000
+
+# Partitions to consider (string)
+#sout-x26410b-partitions=normal
+
+# Direct MV prediction mode (string)
+#sout-x26410b-direct=spatial
+
+# Direct prediction size (integer)
+#sout-x26410b-direct-8x8=1
+
+# Weighted prediction for B-frames (boolean)
+#sout-x26410b-weightb=1
+
+# Weighted prediction for P-frames (integer)
+#sout-x26410b-weightp=2
+
+# Integer pixel motion estimation method (string)
+#sout-x26410b-me=hex
+
+# Maximum motion vector search range (integer)
+#sout-x26410b-merange=16
+
+# Maximum motion vector length (integer)
+#sout-x26410b-mvrange=-1
+
+# Minimum buffer space between threads (integer)
+#sout-x26410b-mvrange-thread=-1
+
+# Subpixel motion estimation and partition decision quality (integer)
+#sout-x26410b-subme=7
+
+# Decide references on a per partition basis (boolean)
+#sout-x26410b-mixed-refs=1
+
+# Chroma in motion estimation (boolean)
+#sout-x26410b-chroma-me=1
+
+# Adaptive spatial transform size (boolean)
+#sout-x26410b-8x8dct=1
+
+# Trellis RD quantization (integer)
+#sout-x26410b-trellis=1
+
+# Framecount to use on frametype lookahead (integer)
+#sout-x26410b-lookahead=40
+
+# Use Periodic Intra Refresh (boolean)
+#sout-x26410b-intra-refresh=0
+
+# Use mb-tree ratecontrol (boolean)
+#sout-x26410b-mbtree=1
+
+# Early SKIP detection on P-frames (boolean)
+#sout-x26410b-fast-pskip=1
+
+# Coefficient thresholding on P-frames (boolean)
+#sout-x26410b-dct-decimate=1
+
+# Noise reduction (integer)
+#sout-x26410b-nr=0
+
+# Inter luma quantization deadzone (integer)
+#sout-x26410b-deadzone-inter=21
+
+# Intra luma quantization deadzone (integer)
+#sout-x26410b-deadzone-intra=11
+
+# Non-deterministic optimizations when threaded (boolean)
+#sout-x26410b-non-deterministic=0
+
+# CPU optimizations (boolean)
+#sout-x26410b-asm=1
+
+# PSNR computation (boolean)
+#sout-x26410b-psnr=0
+
+# SSIM computation (boolean)
+#sout-x26410b-ssim=0
+
+# Quiet mode (boolean)
+#sout-x26410b-quiet=0
+
+# SPS and PPS id numbers (integer)
+#sout-x26410b-sps-id=0
+
+# Access unit delimiters (boolean)
+#sout-x26410b-aud=0
+
+# Statistics (boolean)
+#sout-x26410b-verbose=0
+
+# Filename for 2 pass stats file (string)
+#sout-x26410b-stats=x264_2pass.log
+
+# Default preset setting used (string)
+#sout-x26410b-preset=
+
+# Default tune setting used (string)
+#sout-x26410b-tune=
+
+# x264 advanced options (string)
+#sout-x26410b-options=
+
+[mono] # Stereo to mono downmixer
+
+# Use downmix algorithm (boolean)
+#sout-mono-downmix=1
+
+# Select channel to keep (integer)
+#sout-mono-channel=-1
+
+[sap] # Network streams (SAP)
+
+# SAP multicast address (string)
+#sap-addr=
+
+# SAP timeout (seconds) (integer)
+#sap-timeout=1800
+
+# Try to parse the announce (boolean)
+#sap-parse=1
+
+# SAP Strict mode (boolean)
+#sap-strict=0
+
+[anaglyph] # Convert 3D picture to anaglyph image video filter
+
+# Color scheme (string)
+#anaglyph-scheme=red-cyan
+
+[spatializer] # Audio Spatializer
+
+# Room size (float)
+#spatializer-roomsize=0.850000
+
+# Room width (float)
+#spatializer-width=1.000000
+
+# Wet (float)
+#spatializer-wet=0.400000
+
+# Dry (float)
+#spatializer-dry=0.500000
+
+# Damp (float)
+#spatializer-damp=0.500000
+
+[mirror] # Mirror video filter
+
+# Mirror orientation (integer)
+#mirror-split=0
+
+# Direction (integer)
+#mirror-direction=0
+
+[hqdn3d] # High Quality 3D Denoiser filter
+
+# Spatial luma strength (0-254) (float)
+#hqdn3d-luma-spat=4.000000
+
+# Spatial chroma strength (0-254) (float)
+#hqdn3d-chroma-spat=3.000000
+
+# Temporal luma strength (0-254) (float)
+#hqdn3d-luma-temp=6.000000
+
+# Temporal chroma strength (0-254) (float)
+#hqdn3d-chroma-temp=4.500000
+
+[dvdnav] # DVDnav Input
+
+# DVD angle (integer)
+#dvdnav-angle=1
+
+# Start directly in menu (boolean)
+#dvdnav-menu=1
+
+[chorus_flanger] # Sound Delay
+
+# Delay time (float)
+#delay-time=20.000000
+
+# Sweep Depth (float)
+#sweep-depth=6.000000
+
+# Sweep Rate (float)
+#sweep-rate=6.000000
+
+# Feedback gain (float)
+#feedback-gain=0.500000
+
+# Wet mix (float)
+#wet-mix=0.400000
+
+# Dry Mix (float)
+#dry-mix=0.400000
+
+[samplerate] # Secret Rabbit Code (libsamplerate) resampler
+
+# Sample rate converter type (integer)
+#src-converter-type=2
+
+[satip] # SAT>IP Receiver Plugin
+
+# Receive buffer (integer)
+#satip-buffer=4194304
+
+# Request multicast stream (boolean)
+#satip-multicast=0
+
+# Host (string)
+#satip-host=
+
+[stats] # Writes statistic info about stream
+
+# Output file (string)
+#sout-stats-output=
+
+# Prefix to show on output line (string)
+#sout-stats-prefix=stats
+
+[vmem] # Video memory output
+
+# Width (integer)
+#vmem-width=320
+
+# Height (integer)
+#vmem-height=200
+
+# Pitch (integer)
+#vmem-pitch=640
+
+# Chroma (string)
+#vmem-chroma=RV16
+
+[image] # Image demuxer
+
+# ES ID (integer)
+#image-id=-1
+
+# Group (integer)
+#image-group=0
+
+# Decode (boolean)
+#image-decode=1
+
+# Forced chroma (string)
+#image-chroma=
+
+# Duration in seconds (float)
+#image-duration=10.000000
+
+# Frame rate (string)
+#image-fps=10/1
+
+# Real-time (boolean)
+#image-realtime=0
+
+[stream_out_transcode] # Transcode stream output
+
+# Video encoder (string)
+#sout-transcode-venc=
+
+# Destination video codec (string)
+#sout-transcode-vcodec=
+
+# Video bitrate (integer)
+#sout-transcode-vb=0
+
+# Video scaling (float)
+#sout-transcode-scale=0.000000
+
+# Video frame-rate (string)
+#sout-transcode-fps=
+
+# Deinterlace video (boolean)
+#sout-transcode-deinterlace=0
+
+# Deinterlace module (string)
+#sout-transcode-deinterlace-module=deinterlace
+
+# Video width (integer)
+#sout-transcode-width=0
+
+# Video height (integer)
+#sout-transcode-height=0
+
+# Maximum video width (integer)
+#sout-transcode-maxwidth=0
+
+# Maximum video height (integer)
+#sout-transcode-maxheight=0
+
+# Video filter (string)
+#sout-transcode-vfilter=
+
+# Audio encoder (string)
+#sout-transcode-aenc=
+
+# Destination audio codec (string)
+#sout-transcode-acodec=
+
+# Audio bitrate (integer)
+#sout-transcode-ab=96
+
+# Audio language (string)
+#sout-transcode-alang=
+
+# Audio channels (integer)
+#sout-transcode-channels=0
+
+# Audio sample rate (integer)
+#sout-transcode-samplerate=0
+
+# Audio filter (string)
+#sout-transcode-afilter=
+
+# Subtitle encoder (string)
+#sout-transcode-senc=
+
+# Destination subtitle codec (string)
+#sout-transcode-scodec=
+
+# Destination subtitle codec (boolean)
+#sout-transcode-soverlay=0
+
+# Overlays (string)
+#sout-transcode-sfilter=
+
+# Number of threads (integer)
+#sout-transcode-threads=0
+
+# Picture pool size (integer)
+#sout-transcode-pool-size=10
+
+# High priority (boolean)
+#sout-transcode-high-priority=0
+
+[gnutls] # GNU TLS transport layer security
+
+# Use system trust database (boolean)
+#gnutls-system-trust=1
+
+# Trust directory (string)
+#gnutls-dir-trust=
+
+# TLS cipher priorities (string)
+#gnutls-priorities=NORMAL
+
+[gestures] # Mouse gestures control interface
+
+# Motion threshold (10-100) (integer)
+#gestures-threshold=30
+
+# Trigger button (string)
+#gestures-button=left
+
+[subsdec] # Text subtitle decoder
+
+# Subtitle justification (integer)
+#subsdec-align=-1
+
+# Subtitle text encoding (string)
+#subsdec-encoding=
+
+# UTF-8 subtitle autodetection (boolean)
+#subsdec-autodetect-utf8=1
+
+[posterize] # Posterize video filter
+
+# Posterize level (integer)
+#posterize-level=6
+
+[upnp] # Universal Plug'n'Play
+
+# SAT>IP channel list (string)
+#satip-channelist=auto
+
+# Custom SAT>IP channel list URL (string)
+#satip-channellist-url=
+
+[scene] # Scene video filter
+
+# Image format (string)
+#scene-format=png
+
+# Image width (integer)
+#scene-width=-1
+
+# Image height (integer)
+#scene-height=-1
+
+# Filename prefix (string)
+#scene-prefix=scene
+
+# Directory path prefix (string)
+#scene-path=
+
+# Always write to the same file (boolean)
+#scene-replace=0
+
+# Recording ratio (integer)
+#scene-ratio=50
+
+[a52] # ATSC A/52 (AC-3) audio decoder
+
+# A/52 dynamic range compression (boolean)
+#a52-dynrng=1
+
+[vdr] # VDR recordings
+
+# Chapter offset in ms (integer)
+#vdr-chapter-offset=0
+
+# Frame rate (float)
+#vdr-fps=25.000000
+
+[record] # Record stream output
+
+# Destination prefix (string)
+#sout-record-dst-prefix=
+
+[folder] # Folder meta data
+
+# Album art filename (string)
+#album-art-filename=
+
+[dcp] # Digital Cinema Package module
+
+# KDM file (string)
+#kdm=
+
+[vc1] # VC1 video demuxer
+
+# Frames per Second (float)
+#vc1-fps=25.000000
+
+[blendbench] # Blending benchmark filter
+
+# Number of time to blend (integer)
+#blendbench-loops=1000
+
+# Alpha of the blended image (integer)
+#blendbench-alpha=128
+
+# Image to be blended onto (string)
+#blendbench-base-image=
+
+# Chroma for the base image (string)
+#blendbench-base-chroma=I420
+
+# Image which will be blended (string)
+#blendbench-blend-image=
+
+# Chroma for the blend image (string)
+#blendbench-blend-chroma=YUVA
+
+[avcodec] # FFmpeg audio/video decoder
+
+# Direct rendering (boolean)
+#avcodec-dr=1
+
+# Show corrupted frames (boolean)
+#avcodec-corrupted=1
+
+# Error resilience (integer)
+#avcodec-error-resilience=1
+
+# Workaround bugs (integer)
+#avcodec-workaround-bugs=1
+
+# Hurry up (boolean)
+#avcodec-hurry-up=1
+
+# Skip frame (default=0) (integer)
+#avcodec-skip-frame=0
+
+# Skip idct (default=0) (integer)
+#avcodec-skip-idct=0
+
+# Allow speed tricks (boolean)
+#avcodec-fast=0
+
+# Skip the loop filter for H.264 decoding (integer)
+#avcodec-skiploopfilter=0
+
+# Debug mask (integer)
+#avcodec-debug=0
+
+# Codec name (string)
+#avcodec-codec=
+
+# Hardware decoding (string)
+#avcodec-hw=any
+
+# Threads (integer)
+#avcodec-threads=0
+
+# Advanced options (string)
+#avcodec-options=
+
+# Codec name (string)
+#sout-avcodec-codec=
+
+# Quality level (string)
+#sout-avcodec-hq=rd
+
+# Ratio of key frames (integer)
+#sout-avcodec-keyint=0
+
+# Ratio of B frames (integer)
+#sout-avcodec-bframes=0
+
+# Hurry up (boolean)
+#sout-avcodec-hurry-up=0
+
+# Interlaced encoding (boolean)
+#sout-avcodec-interlace=0
+
+# Interlaced motion estimation (boolean)
+#sout-avcodec-interlace-me=1
+
+# Video bitrate tolerance (integer)
+#sout-avcodec-vt=0
+
+# Pre-motion estimation (boolean)
+#sout-avcodec-pre-me=0
+
+# Rate control buffer size (integer)
+#sout-avcodec-rc-buffer-size=0
+
+# Rate control buffer aggressiveness (float)
+#sout-avcodec-rc-buffer-aggressivity=1.000000
+
+# I quantization factor (float)
+#sout-avcodec-i-quant-factor=0.000000
+
+# Noise reduction (integer)
+#sout-avcodec-noise-reduction=0
+
+# MPEG4 quantization matrix (boolean)
+#sout-avcodec-mpeg4-matrix=0
+
+# Minimum video quantizer scale (integer)
+#sout-avcodec-qmin=0
+
+# Maximum video quantizer scale (integer)
+#sout-avcodec-qmax=0
+
+# Trellis quantization (boolean)
+#sout-avcodec-trellis=0
+
+# Fixed quantizer scale (float)
+#sout-avcodec-qscale=3.000000
+
+# Strict standard compliance (integer)
+#sout-avcodec-strict=0
+
+# Luminance masking (float)
+#sout-avcodec-lumi-masking=0.000000
+
+# Darkness masking (float)
+#sout-avcodec-dark-masking=0.000000
+
+# Motion masking (float)
+#sout-avcodec-p-masking=0.000000
+
+# Border masking (float)
+#sout-avcodec-border-masking=0.000000
+
+# Luminance elimination (integer)
+#sout-avcodec-luma-elim-threshold=0
+
+# Chrominance elimination (integer)
+#sout-avcodec-chroma-elim-threshold=0
+
+# Specify AAC audio profile to use (string)
+#sout-avcodec-aac-profile=low
+
+# Advanced options (string)
+#sout-avcodec-options=
+
+# Format name (string)
+#avformat-format=
+
+# Advanced options (string)
+#avformat-options=
+
+# Avformat mux (string)
+#sout-avformat-mux=
+
+# Advanced options (string)
+#sout-avformat-options=
+
+# Reset timestamps (boolean)
+#sout-avformat-reset-ts=0
+
+# Advanced options (string)
+#avio-options=
+
+# Advanced options (string)
+#sout-avio-options=
+
+[mux_ts] # TS muxer (libdvbpsi)
+
+# Digital TV Standard (string)
+#sout-ts-standard=dvb
+
+# Video PID (integer)
+#sout-ts-pid-video=100
+
+# Audio PID (integer)
+#sout-ts-pid-audio=200
+
+# SPU PID (integer)
+#sout-ts-pid-spu=300
+
+# PMT PID (integer)
+#sout-ts-pid-pmt=32
+
+# TS ID (integer)
+#sout-ts-tsid=0
+
+# NET ID (integer)
+#sout-ts-netid=0
+
+# PMT Program numbers (string)
+#sout-ts-program-pmt=
+
+# Set PID to ID of ES (boolean)
+#sout-ts-es-id-pid=0
+
+# Mux PMT (requires --sout-ts-es-id-pid) (string)
+#sout-ts-muxpmt=
+
+# SDT Descriptors (requires --sout-ts-es-id-pid) (string)
+#sout-ts-sdtdesc=
+
+# Data alignment (boolean)
+#sout-ts-alignment=1
+
+# Shaping delay (ms) (integer)
+#sout-ts-shaping=200
+
+# Use keyframes (boolean)
+#sout-ts-use-key-frames=0
+
+# PCR interval (ms) (integer)
+#sout-ts-pcr=70
+
+# Minimum B (deprecated) (integer)
+#sout-ts-bmin=0
+
+# Maximum B (deprecated) (integer)
+#sout-ts-bmax=0
+
+# DTS delay (ms) (integer)
+#sout-ts-dts-delay=400
+
+# Crypt audio (boolean)
+#sout-ts-crypt-audio=1
+
+# Crypt video (boolean)
+#sout-ts-crypt-video=1
+
+# CSA Key (string)
+#sout-ts-csa-ck=
+
+# Second CSA Key (string)
+#sout-ts-csa2-ck=
+
+# CSA Key in use (string)
+#sout-ts-csa-use=1
+
+# Packet size in bytes to encrypt (integer)
+#sout-ts-csa-pkt=188
+
+[flaschen] # Flaschen-Taschen video output
+
+# Flaschen-Taschen display address (string)
+#flaschen-display=
+
+# Width (integer)
+#flaschen-width=25
+
+# Height (integer)
+#flaschen-height=20
+
+[macosx] # Mac OS X OpenGL video output
+
+# Open GL/GLES hardware converter (string)
+#glconv=
+
+# Rendering intent for color conversion (integer)
+#rendering-intent=1
+
+# Display primaries (integer)
+#target-prim=0
+
+# Display gamma / transfer function (integer)
+#target-trc=0
+
+# Tone-mapping algorithm (integer)
+#tone-mapping=3
+
+# Tone-mapping parameter (float)
+#tone-mapping-param=0.000000
+
+# Highlight clipped pixels (boolean)
+#tone-mapping-warn=0
+
+# Dithering algorithm (integer)
+#dither-algo=-1
+
+# Dither depth override (0 = framebuffer depth) (integer)
+#dither-depth=0
+
+# Tone-mapping desaturation coefficient (float)
+#tone-mapping-desat=0.500000
+
+[file] # File stream output
+
+# Overwrite existing file (boolean)
+#sout-file-overwrite=1
+
+# Append to file (boolean)
+#sout-file-append=0
+
+# Format time and date (boolean)
+#sout-file-format=0
+
+# Synchronous writing (boolean)
+#sout-file-sync=0
+
+[croppadd] # Video cropping filter
+
+# Pixels to crop from top (integer)
+#croppadd-croptop=0
+
+# Pixels to crop from bottom (integer)
+#croppadd-cropbottom=0
+
+# Pixels to crop from left (integer)
+#croppadd-cropleft=0
+
+# Pixels to crop from right (integer)
+#croppadd-cropright=0
+
+# Pixels to padd to top (integer)
+#croppadd-paddtop=0
+
+# Pixels to padd to bottom (integer)
+#croppadd-paddbottom=0
+
+# Pixels to padd to left (integer)
+#croppadd-paddleft=0
+
+# Pixels to padd to right (integer)
+#croppadd-paddright=0
+
+[videotoolbox] # VideoToolbox video decoder
+
+# Enable hardware acceleration (boolean)
+#videotoolbox=1
+
+# Use Hardware decoders only (boolean)
+#videotoolbox-hw-decoder-only=1
+
+# Force the VT decoder CVPX chroma (string)
+#videotoolbox-cvpx-chroma=
+
+[access_srt] # SRT input
+
+# SRT chunk size (bytes) (integer)
+#chunk-size=1316
+
+# Return poll wait after timeout milliseconds (-1 = infinite) (integer)
+#poll-timeout=-1
+
+# SRT latency (ms) (integer)
+#latency=125
+
+# Password for stream encryption (string)
+#passphrase=
+
+# Crypto key length in bytes (integer)
+#key-length=16
+
+[scaletempo_pitch] # Pitch Shifter
+
+# Stride Length (integer)
+#scaletempo-stride=30
+
+# Overlap Length (float)
+#scaletempo-overlap=0.200000
+
+# Search Length (integer)
+#scaletempo-search=14
+
+# Pitch Shift (float)
+#pitch-shift=0.000000
+
+[normvol] # Volume normalizer
+
+# Number of audio buffers (integer)
+#norm-buff-size=20
+
+# Maximal volume level (float)
+#norm-max-level=2.000000
+
+[ps] # PS muxer
+
+# DTS delay (ms) (integer)
+#sout-ps-dts-delay=200
+
+# PES maximum size (integer)
+#sout-ps-pes-max-size=65500
+
+[equalizer] # Equalizer with 10 bands
+
+# Equalizer preset (string)
+#equalizer-preset=flat
+
+# Bands gain (string)
+#equalizer-bands=
+
+# Two pass (boolean)
+#equalizer-2pass=0
+
+# Use VLC frequency bands (boolean)
+#equalizer-vlcfreqs=1
+
+# Global gain (float)
+#equalizer-preamp=12.000000
+
+[concat] # Concatenated inputs
+
+# Inputs list (string)
+#concat-list=
+
+[mosaic] # Mosaic video sub source
+
+# Transparency (integer)
+#mosaic-alpha=255
+
+# Height (integer)
+#mosaic-height=100
+
+# Width (integer)
+#mosaic-width=100
+
+# Mosaic alignment (integer)
+#mosaic-align=5
+
+# Top left corner X coordinate (integer)
+#mosaic-xoffset=0
+
+# Top left corner Y coordinate (integer)
+#mosaic-yoffset=0
+
+# Border width (integer)
+#mosaic-borderw=0
+
+# Border height (integer)
+#mosaic-borderh=0
+
+# Positioning method (integer)
+#mosaic-position=0
+
+# Number of rows (integer)
+#mosaic-rows=2
+
+# Number of columns (integer)
+#mosaic-cols=2
+
+# Keep aspect ratio (boolean)
+#mosaic-keep-aspect-ratio=0
+
+# Keep original size (boolean)
+#mosaic-keep-picture=0
+
+# Elements order (string)
+#mosaic-order=
+
+# Offsets in order (string)
+#mosaic-offsets=
+
+# Delay (integer)
+#mosaic-delay=0
+
+[screen] # Screen Input
+
+# Frame rate (float)
+#screen-fps=5.000000
+
+# Region top row (integer)
+#screen-top=0
+
+# Region left column (integer)
+#screen-left=0
+
+# Capture region width (integer)
+#screen-width=0
+
+# Capture region height (integer)
+#screen-height=0
+
+# Follow the mouse (boolean)
+#screen-follow-mouse=0
+
+# Mouse pointer image (string)
+#screen-mouse-image=
+
+# Display ID (integer)
+#screen-display-id=0
+
+# Screen index (integer)
+#screen-index=0
+
+[freetype] # Freetype2 font renderer
+
+# Font (string)
+#freetype-font=Helvetica Neue
+
+# Monospace Font (string)
+#freetype-monofont=Monaco
+
+# Font size in pixels (integer)
+#freetype-fontsize=0
+
+# Relative font size (integer)
+#freetype-rel-fontsize=0
+
+# Text opacity (integer)
+#freetype-opacity=255
+
+# Text default color (integer)
+#freetype-color=16777215
+
+# Force bold (boolean)
+#freetype-bold=0
+
+# Background opacity (integer)
+#freetype-background-opacity=0
+
+# Background color (integer)
+#freetype-background-color=0
+
+# Outline opacity (integer)
+#freetype-outline-opacity=255
+
+# Outline color (integer)
+#freetype-outline-color=0
+
+# Outline thickness (integer)
+#freetype-outline-thickness=4
+
+# Shadow opacity (integer)
+#freetype-shadow-opacity=128
+
+# Shadow color (integer)
+#freetype-shadow-color=0
+
+# Shadow angle (float)
+#freetype-shadow-angle=-45.000000
+
+# Shadow distance (float)
+#freetype-shadow-distance=0.060000
+
+# Use YUVP renderer (boolean)
+#freetype-yuvp=0
+
+# Text direction (integer)
+#freetype-text-direction=0
+
+[marq] # Marquee display
+
+# Text (string)
+#marq-marquee=VLC
+
+# Text file (string)
+#marq-file=
+
+# X offset (integer)
+#marq-x=0
+
+# Y offset (integer)
+#marq-y=0
+
+# Marquee position (integer)
+#marq-position=-1
+
+# Opacity (integer)
+#marq-opacity=255
+
+# Color (integer)
+#marq-color=16777215
+
+# Font size, pixels (integer)
+#marq-size=0
+
+# Timeout (integer)
+#marq-timeout=0
+
+# Refresh period in ms (integer)
+#marq-refresh=1000
+
+[speex] # Speex audio decoder
+
+# Mode (integer)
+#sout-speex-mode=0
+
+# Encoding complexity (integer)
+#sout-speex-complexity=3
+
+# CBR encoding (boolean)
+#sout-speex-cbr=0
+
+# Encoding quality (float)
+#sout-speex-quality=8.000000
+
+# Maximal bitrate (integer)
+#sout-speex-max-bitrate=0
+
+# Voice activity detection (boolean)
+#sout-speex-vad=1
+
+# Discontinuous Transmission (boolean)
+#sout-speex-dtx=0
+
+[ddummy] # Dummy decoder
+
+# Save raw codec data (boolean)
+#dummy-save-es=0
+
+[core] # core program
+
+# Enable audio (boolean)
+#audio=1
+
+# Audio gain (float)
+#gain=1.000000
+
+# Audio output volume step (float)
+#volume-step=12.800000
+
+# Remember the audio volume (boolean)
+#volume-save=1
+
+# Force S/PDIF support (boolean)
+#spdif=0
+
+# Force detection of Dolby Surround (integer)
+#force-dolby-surround=0
+
+# Stereo audio output mode (integer)
+#stereo-mode=0
+
+# Audio desynchronization compensation (integer)
+#audio-desync=0
+
+# Replay gain mode (string)
+#audio-replay-gain-mode=none
+
+# Replay preamp (float)
+#audio-replay-gain-preamp=0.000000
+
+# Default replay gain (float)
+#audio-replay-gain-default=-7.000000
+
+# Peak protection (boolean)
+#audio-replay-gain-peak-protection=1
+
+# Enable time stretching audio (boolean)
+#audio-time-stretch=1
+
+# Audio output module (string)
+#aout=
+
+# Media role (string)
+#role=video
+
+# Audio filters (string)
+#audio-filter=
+
+# Audio visualizations (string)
+#audio-visual=none
+
+# Audio resampler (string)
+#audio-resampler=
+
+# Enable video (boolean)
+#video=1
+
+# Grayscale video output (boolean)
+#grayscale=0
+
+# Fullscreen video output (boolean)
+#fullscreen=0
+
+# Embedded video (boolean)
+#embedded-video=1
+
+#  (boolean)
+#xlib=1
+
+# Drop late frames (boolean)
+#drop-late-frames=1
+
+# Skip frames (boolean)
+#skip-frames=1
+
+# Quiet synchro (boolean)
+#quiet-synchro=0
+
+# Key press events (boolean)
+#keyboard-events=1
+
+# Mouse events (boolean)
+#mouse-events=1
+
+# Always on top (boolean)
+#video-on-top=0
+
+# Enable wallpaper mode (boolean)
+#video-wallpaper=0
+
+# Disable screensaver (boolean)
+#disable-screensaver=1
+
+# Show media title on video (boolean)
+#video-title-show=1
+
+# Show video title for x milliseconds (integer)
+#video-title-timeout=5000
+
+# Position of video title (integer)
+#video-title-position=8
+
+# Hide cursor and fullscreen controller after x milliseconds (integer)
+#mouse-hide-timeout=1000
+
+# Video snapshot directory (or filename) (string)
+#snapshot-path=
+
+# Video snapshot file prefix (string)
+#snapshot-prefix=vlcsnap-
+
+# Video snapshot format (string)
+#snapshot-format=png
+
+# Display video snapshot preview (boolean)
+#snapshot-preview=1
+
+# Use sequential numbers instead of timestamps (boolean)
+#snapshot-sequential=0
+
+# Video snapshot width (integer)
+#snapshot-width=-1
+
+# Video snapshot height (integer)
+#snapshot-height=-1
+
+# Video width (integer)
+#width=-1
+
+# Video height (integer)
+#height=-1
+
+# Video X coordinate (integer)
+#video-x=0
+
+# Video Y coordinate (integer)
+#video-y=0
+
+# Video cropping (string)
+#crop=
+
+# Custom crop ratios list (string)
+#custom-crop-ratios=
+
+# Source aspect ratio (string)
+#aspect-ratio=
+
+# Video Auto Scaling (boolean)
+#autoscale=1
+
+# Monitor pixel aspect ratio (string)
+#monitor-par=
+
+# Custom aspect ratios list (string)
+#custom-aspect-ratios=
+
+# Fix HDTV height (boolean)
+#hdtv-fix=1
+
+# Window decorations (boolean)
+#video-deco=1
+
+# Video title (string)
+#video-title=
+
+# Video alignment (integer)
+#align=0
+
+# Zoom video (float)
+#zoom=1.000000
+
+# Deinterlace (integer)
+#deinterlace=-1
+
+# Deinterlace mode (string)
+#deinterlace-mode=auto
+
+# Video output module (string)
+#vout=
+
+# Video filter module (string)
+#video-filter=
+
+# Video splitter module (string)
+#video-splitter=
+
+# Enable sub-pictures (boolean)
+#spu=1
+
+# On Screen Display (boolean)
+#osd=1
+
+# Text rendering module (string)
+#text-renderer=
+
+# Use subtitle file (string)
+#sub-file=
+
+# Autodetect subtitle files (boolean)
+#sub-autodetect-file=1
+
+# Subtitle autodetection fuzziness (integer)
+#sub-autodetect-fuzzy=3
+
+# Subtitle autodetection paths (string)
+#sub-autodetect-path=./Subtitles, ./subtitles, ./Subs, ./subs
+
+# Force subtitle position (integer)
+#sub-margin=0
+
+# Subpictures source module (string)
+#sub-source=
+
+# Subpictures filter module (string)
+#sub-filter=
+
+# Program (integer)
+#program=0
+
+# Programs (string)
+#programs=
+
+# Audio track (integer)
+#audio-track=-1
+
+# Subtitle track (integer)
+#sub-track=-1
+
+# Audio language (string)
+#audio-language=
+
+# Subtitle language (string)
+#sub-language=
+
+# Menu language (string)
+#menu-language=
+
+# Audio track ID (integer)
+#audio-track-id=-1
+
+# Subtitle track ID (integer)
+#sub-track-id=-1
+
+# Preferred Closed Captions decoder (integer)
+#captions=608
+
+# Preferred video resolution (integer)
+#preferred-resolution=-1
+
+# Input repetitions (integer)
+#input-repeat=0
+
+# Start time (float)
+#start-time=0.000000
+
+# Stop time (float)
+#stop-time=0.000000
+
+# Run time (float)
+#run-time=0.000000
+
+# Fast seek (boolean)
+#input-fast-seek=0
+
+# Playback speed (float)
+#rate=1.000000
+
+# Input list (string)
+#input-list=
+
+# Input slave (experimental) (string)
+#input-slave=
+
+# Bookmarks list for a stream (string)
+#bookmarks=
+
+# DVD device (string)
+#dvd=/dev/dvd
+
+# VCD device (string)
+#vcd=/dev/cdrom
+
+# MTU of the network interface (integer)
+#mtu=1400
+
+# TCP connection timeout (integer)
+#ipv4-timeout=5000
+
+# HTTP server address (string)
+#http-host=
+
+# HTTP server port (integer)
+#http-port=8080
+
+# HTTPS server port (integer)
+#https-port=8443
+
+# RTSP server address (string)
+#rtsp-host=
+
+# RTSP server port (integer)
+#rtsp-port=554
+
+# HTTP/TLS server certificate (string)
+#http-cert=
+
+# HTTP/TLS server private key (string)
+#http-key=
+
+# SOCKS server (string)
+#socks=
+
+# SOCKS user name (string)
+#socks-user=
+
+# SOCKS password (string)
+#socks-pwd=
+
+# Title metadata (string)
+#meta-title=
+
+# Author metadata (string)
+#meta-author=
+
+# Artist metadata (string)
+#meta-artist=
+
+# Genre metadata (string)
+#meta-genre=
+
+# Copyright metadata (string)
+#meta-copyright=
+
+# Description metadata (string)
+#meta-description=
+
+# Date metadata (string)
+#meta-date=
+
+# URL metadata (string)
+#meta-url=
+
+# File caching (ms) (integer)
+#file-caching=1000
+
+# Live capture caching (ms) (integer)
+#live-caching=300
+
+# Disc caching (ms) (integer)
+#disc-caching=300
+
+# Network caching (ms) (integer)
+#network-caching=1000
+
+# Clock reference average counter (integer)
+#cr-average=40
+
+# Clock synchronisation (integer)
+#clock-synchro=-1
+
+# Clock jitter (integer)
+#clock-jitter=5000
+
+# Network synchronisation (boolean)
+#network-synchronisation=0
+
+# Record directory (string)
+#input-record-path=
+
+# Prefer native stream recording (boolean)
+#input-record-native=1
+
+# Timeshift directory (string)
+#input-timeshift-path=
+
+# Timeshift granularity (integer)
+#input-timeshift-granularity=-1
+
+# Change title according to current media (string)
+#input-title-format=$Z
+
+# Disable all lua plugins (boolean)
+#lua=1
+
+# Preferred decoders list (string)
+#codec=
+
+# Preferred encoders list (string)
+#encoder=
+
+# Access module (string)
+#access=
+
+# Demux module (string)
+#demux=any
+
+# Stream filter module (string)
+#stream-filter=
+
+# Demux filter module (string)
+#demux-filter=
+
+# Default stream output chain (string)
+#sout=
+
+# Display while streaming (boolean)
+#sout-display=0
+
+# Keep stream output open (boolean)
+#sout-keep=0
+
+# Enable streaming of all ES (boolean)
+#sout-all=1
+
+# Enable audio stream output (boolean)
+#sout-audio=1
+
+# Enable video stream output (boolean)
+#sout-video=1
+
+# Enable SPU stream output (boolean)
+#sout-spu=1
+
+# Stream output muxer caching (ms) (integer)
+#sout-mux-caching=1500
+
+# VLM configuration file (string)
+#vlm-conf=
+
+# SAP announcement interval (integer)
+#sap-interval=5
+
+# Mux module (string)
+#mux=
+
+# Access output module (string)
+#access_output=
+
+# Hop limit (TTL) (integer)
+#ttl=-1
+
+# Multicast output interface (string)
+#miface=
+
+# DiffServ Code Point (integer)
+#dscp=0
+
+# Preferred packetizer list (string)
+#packetizer=
+
+# VoD server module (string)
+#vod-server=
+
+# Use a plugins cache (boolean)
+#plugins-cache=1
+
+# Scan for new plugins (boolean)
+#plugins-scan=1
+
+# Preferred keystore list (string)
+#keystore=
+
+# Play files randomly forever (boolean)
+#random=0
+
+# Repeat all (boolean)
+#loop=0
+
+# Repeat current item (boolean)
+#repeat=0
+
+# Play and exit (boolean)
+#play-and-exit=0
+
+# Play and stop (boolean)
+#play-and-stop=0
+
+# Play and pause (boolean)
+#play-and-pause=0
+
+# Start paused (boolean)
+#start-paused=0
+
+# Auto start (boolean)
+#playlist-autostart=1
+
+# Pause on audio communication (boolean)
+#playlist-cork=1
+
+# Use media library (boolean)
+#media-library=0
+
+# Display playlist tree (boolean)
+#playlist-tree=0
+
+# Default stream (string)
+#open=
+
+# Automatically preparse items (boolean)
+#auto-preparse=1
+
+# Preparsing timeout (integer)
+#preparse-timeout=5000
+
+# Allow metadata network access (boolean)
+metadata-network-access=1
+
+# Subdirectory behavior (string)
+#recursive=collapse
+
+# Ignored extensions (string)
+#ignore-filetypes=m3u,db,nfo,ini,jpg,jpeg,ljpg,gif,png,pgm,pgmyuv,pbm,pam,tga,bmp,pnm,xpm,xcf,pcx,tif,tiff,lbm,sfv,txt,sub,idx,srt,cue,ssa
+
+# Show hidden files (boolean)
+#show-hiddenfiles=0
+
+# Services discovery modules (string)
+#services-discovery=
+
+# Run as daemon process (boolean)
+#daemon=0
+
+# Write process id to file (string)
+#pidfile=
+
+# Show advanced options (boolean)
+#advanced=0
+
+# Interface interaction (boolean)
+#interact=1
+
+# Locally collect statistics (boolean)
+#stats=1
+
+# Interface module (string)
+#intf=
+
+# Extra interface modules (string)
+#extraintf=
+
+# Control interfaces (string)
+#control=
+
+# Mouse wheel vertical axis control (integer)
+#hotkeys-y-wheel-mode=0
+
+# Mouse wheel horizontal axis control (integer)
+#hotkeys-x-wheel-mode=2
+
+# Fullscreen (string)
+#global-key-toggle-fullscreen=
+
+# Fullscreen (string)
+key-toggle-fullscreen=f
+
+# Exit fullscreen (string)
+#global-key-leave-fullscreen=
+
+# Exit fullscreen (string)
+#key-leave-fullscreen=Esc
+
+# Play/Pause (string)
+#global-key-play-pause=
+
+# Play/Pause (string)
+#key-play-pause=Space
+
+# Pause only (string)
+#global-key-pause=
+
+# Pause only (string)
+#key-pause=
+
+# Play only (string)
+#global-key-play=
+
+# Play only (string)
+#key-play=
+
+# Faster (string)
+#global-key-faster=
+
+# Faster (string)
+#key-faster=Command+=
+
+# Slower (string)
+#global-key-slower=
+
+# Slower (string)
+#key-slower=Command+-
+
+# Normal rate (string)
+#global-key-rate-normal=
+
+# Normal rate (string)
+#key-rate-normal=
+
+# Faster (fine) (string)
+#global-key-rate-faster-fine=
+
+# Faster (fine) (string)
+#key-rate-faster-fine=
+
+# Slower (fine) (string)
+#global-key-rate-slower-fine=
+
+# Slower (fine) (string)
+#key-rate-slower-fine=
+
+# Next (string)
+#global-key-next=
+
+# Next (string)
+#key-next=Command+Right
+
+# Previous (string)
+#global-key-prev=
+
+# Previous (string)
+#key-prev=Command+Left
+
+# Stop (string)
+#global-key-stop=
+
+# Stop (string)
+#key-stop=Command+.
+
+# Position (string)
+#global-key-position=
+
+# Position (string)
+#key-position=t
+
+# Very short backwards jump (string)
+#global-key-jump-extrashort=
+
+# Very short backwards jump (string)
+#key-jump-extrashort=Command+Ctrl+Left
+
+# Very short forward jump (string)
+#global-key-jump+extrashort=
+
+# Very short forward jump (string)
+#key-jump+extrashort=Command+Ctrl+Right
+
+# Short backwards jump (string)
+#global-key-jump-short=
+
+# Short backwards jump (string)
+key-jump-short=Left
+
+# Short forward jump (string)
+#global-key-jump+short=
+
+# Short forward jump (string)
+key-jump+short=Right
+
+# Medium backwards jump (string)
+#global-key-jump-medium=
+
+# Medium backwards jump (string)
+key-jump-medium=Down
+
+# Medium forward jump (string)
+#global-key-jump+medium=
+
+# Medium forward jump (string)
+key-jump+medium=Up
+
+# Long backwards jump (string)
+#global-key-jump-long=
+
+# Long backwards jump (string)
+key-jump-long=K
+
+# Long forward jump (string)
+#global-key-jump+long=
+
+# Long forward jump (string)
+key-jump+long=J
+
+# Next frame (string)
+#global-key-frame-next=
+
+# Next frame (string)
+#key-frame-next=e
+
+# Activate (string)
+#global-key-nav-activate=
+
+# Activate (string)
+#key-nav-activate=Enter
+
+# Navigate up (string)
+#global-key-nav-up=
+
+# Navigate up (string)
+#key-nav-up=Up
+
+# Navigate down (string)
+#global-key-nav-down=
+
+# Navigate down (string)
+#key-nav-down=Down
+
+# Navigate left (string)
+#global-key-nav-left=
+
+# Navigate left (string)
+#key-nav-left=Left
+
+# Navigate right (string)
+#global-key-nav-right=
+
+# Navigate right (string)
+#key-nav-right=Right
+
+# Go to the DVD menu (string)
+#global-key-disc-menu=
+
+# Go to the DVD menu (string)
+#key-disc-menu=Ctrl+m
+
+# Select previous DVD title (string)
+#global-key-title-prev=
+
+# Select previous DVD title (string)
+#key-title-prev=Ctrl+p
+
+# Select next DVD title (string)
+#global-key-title-next=
+
+# Select next DVD title (string)
+#key-title-next=Ctrl+n
+
+# Select prev DVD chapter (string)
+#global-key-chapter-prev=
+
+# Select prev DVD chapter (string)
+#key-chapter-prev=Ctrl+u
+
+# Select next DVD chapter (string)
+#global-key-chapter-next=
+
+# Select next DVD chapter (string)
+#key-chapter-next=Ctrl+d
+
+# Quit (string)
+#global-key-quit=
+
+# Quit (string)
+key-quit=n
+
+# Volume up (string)
+#global-key-vol-up=
+
+# Volume up (string)
+#key-vol-up=Command+Up
+
+# Volume down (string)
+#global-key-vol-down=
+
+# Volume down (string)
+#key-vol-down=Command+Down
+
+# Mute (string)
+#global-key-vol-mute=
+
+# Mute (string)
+#key-vol-mute=Command+Alt+Down
+
+# Subtitle delay up (string)
+#global-key-subdelay-up=
+
+# Subtitle delay up (string)
+#key-subdelay-up=j
+
+# Subtitle delay down (string)
+#global-key-subdelay-down=
+
+# Subtitle delay down (string)
+#key-subdelay-down=h
+
+# Subtitle sync / bookmark audio timestamp (string)
+#global-key-subsync-markaudio=
+
+# Subtitle sync / bookmark audio timestamp (string)
+#key-subsync-markaudio=Shift+h
+
+# Subtitle sync / bookmark subtitle timestamp (string)
+#global-key-subsync-marksub=
+
+# Subtitle sync / bookmark subtitle timestamp (string)
+#key-subsync-marksub=Shift+j
+
+# Subtitle sync / synchronize audio & subtitle timestamps (string)
+#global-key-subsync-apply=
+
+# Subtitle sync / synchronize audio & subtitle timestamps (string)
+#key-subsync-apply=Shift+k
+
+# Subtitle sync / reset audio & subtitle synchronization (string)
+#global-key-subsync-reset=
+
+# Subtitle sync / reset audio & subtitle synchronization (string)
+#key-subsync-reset=Command+Shift+k
+
+# Subtitle position up (string)
+#global-key-subpos-up=
+
+# Subtitle position up (string)
+#key-subpos-up=
+
+# Subtitle position down (string)
+#global-key-subpos-down=
+
+# Subtitle position down (string)
+#key-subpos-down=
+
+# Audio delay up (string)
+#global-key-audiodelay-up=
+
+# Audio delay up (string)
+#key-audiodelay-up=g
+
+# Audio delay down (string)
+#global-key-audiodelay-down=
+
+# Audio delay down (string)
+key-audiodelay-down=
+
+# Cycle audio track (string)
+#global-key-audio-track=
+
+# Cycle audio track (string)
+#key-audio-track=l
+
+# Cycle through audio devices (string)
+#global-key-audiodevice-cycle=
+
+# Cycle through audio devices (string)
+#key-audiodevice-cycle=Shift+a
+
+# Cycle subtitle track in reverse order (string)
+#global-key-subtitle-revtrack=
+
+# Cycle subtitle track in reverse order (string)
+#key-subtitle-revtrack=Alt+s
+
+# Cycle subtitle track (string)
+#global-key-subtitle-track=
+
+# Cycle subtitle track (string)
+#key-subtitle-track=s
+
+# Toggle subtitles (string)
+#global-key-subtitle-toggle=
+
+# Toggle subtitles (string)
+#key-subtitle-toggle=Shift+s
+
+# Cycle next program Service ID (string)
+#global-key-program-sid-next=
+
+# Cycle next program Service ID (string)
+#key-program-sid-next=x
+
+# Cycle previous program Service ID (string)
+#global-key-program-sid-prev=
+
+# Cycle previous program Service ID (string)
+#key-program-sid-prev=Shift+x
+
+# Cycle source aspect ratio (string)
+#global-key-aspect-ratio=
+
+# Cycle source aspect ratio (string)
+#key-aspect-ratio=a
+
+# Cycle video crop (string)
+#global-key-crop=
+
+# Cycle video crop (string)
+#key-crop=c
+
+# Toggle autoscaling (string)
+#global-key-toggle-autoscale=
+
+# Toggle autoscaling (string)
+#key-toggle-autoscale=o
+
+# Increase scale factor (string)
+#global-key-incr-scalefactor=
+
+# Increase scale factor (string)
+#key-incr-scalefactor=Alt+o
+
+# Decrease scale factor (string)
+#global-key-decr-scalefactor=
+
+# Decrease scale factor (string)
+#key-decr-scalefactor=Shift+Alt+o
+
+# Toggle deinterlacing (string)
+#global-key-deinterlace=
+
+# Toggle deinterlacing (string)
+#key-deinterlace=d
+
+# Cycle deinterlace modes (string)
+#global-key-deinterlace-mode=
+
+# Cycle deinterlace modes (string)
+#key-deinterlace-mode=Shift+d
+
+# Show controller in fullscreen (string)
+#global-key-intf-show=
+
+# Show controller in fullscreen (string)
+#key-intf-show=i
+
+# Boss key (string)
+#global-key-intf-boss=
+
+# Boss key (string)
+#key-intf-boss=
+
+# Context menu (string)
+#global-key-intf-popup-menu=
+
+# Context menu (string)
+#key-intf-popup-menu=Menu
+
+# Take video snapshot (string)
+#global-key-snapshot=
+
+# Take video snapshot (string)
+#key-snapshot=Command+Alt+s
+
+# Record (string)
+#global-key-record=
+
+# Record (string)
+#key-record=Command+Shift+r
+
+# Zoom (string)
+#global-key-zoom=
+
+# Zoom (string)
+#key-zoom=z
+
+# Un-Zoom (string)
+#global-key-unzoom=
+
+# Un-Zoom (string)
+#key-unzoom=Shift+z
+
+# Toggle wallpaper mode in video output (string)
+#global-key-wallpaper=
+
+# Toggle wallpaper mode in video output (string)
+#key-wallpaper=
+
+# Crop one pixel from the top of the video (string)
+#global-key-crop-top=
+
+# Crop one pixel from the top of the video (string)
+#key-crop-top=Alt+i
+
+# Uncrop one pixel from the top of the video (string)
+#global-key-uncrop-top=
+
+# Uncrop one pixel from the top of the video (string)
+#key-uncrop-top=Alt+Shift+i
+
+# Crop one pixel from the left of the video (string)
+#global-key-crop-left=
+
+# Crop one pixel from the left of the video (string)
+#key-crop-left=Alt+j
+
+# Uncrop one pixel from the left of the video (string)
+#global-key-uncrop-left=
+
+# Uncrop one pixel from the left of the video (string)
+#key-uncrop-left=Alt+Shift+j
+
+# Crop one pixel from the bottom of the video (string)
+#global-key-crop-bottom=
+
+# Crop one pixel from the bottom of the video (string)
+#key-crop-bottom=Alt+k
+
+# Uncrop one pixel from the bottom of the video (string)
+#global-key-uncrop-bottom=
+
+# Uncrop one pixel from the bottom of the video (string)
+#key-uncrop-bottom=Alt+Shift+k
+
+# Crop one pixel from the right of the video (string)
+#global-key-crop-right=
+
+# Crop one pixel from the right of the video (string)
+#key-crop-right=Alt+l
+
+# Uncrop one pixel from the right of the video (string)
+#global-key-uncrop-right=
+
+# Uncrop one pixel from the right of the video (string)
+#key-uncrop-right=Alt+Shift+l
+
+# Random (string)
+#global-key-random=
+
+# Random (string)
+#key-random=Command+z
+
+# Normal/Loop/Repeat (string)
+#global-key-loop=
+
+# Normal/Loop/Repeat (string)
+#key-loop=Shift+l
+
+# Shrink the viewpoint field of view (360) (string)
+#global-key-viewpoint-fov-in=
+
+# Shrink the viewpoint field of view (360) (string)
+#key-viewpoint-fov-in=Page Up
+
+# Expand the viewpoint field of view (360) (string)
+#global-key-viewpoint-fov-out=
+
+# Expand the viewpoint field of view (360) (string)
+#key-viewpoint-fov-out=Page Down
+
+# Roll the viewpoint clockwise (360) (string)
+#global-key-viewpoint-roll-clock=
+
+# Roll the viewpoint clockwise (360) (string)
+#key-viewpoint-roll-clock=
+
+# Roll the viewpoint anti-clockwise (360) (string)
+#global-key-viewpoint-roll-anticlock=
+
+# Roll the viewpoint anti-clockwise (360) (string)
+#key-viewpoint-roll-anticlock=
+
+# 1:4 Quarter (string)
+#global-key-zoom-quarter=
+
+# 1:4 Quarter (string)
+#key-zoom-quarter=
+
+# 1:2 Half (string)
+#global-key-zoom-half=
+
+# 1:2 Half (string)
+#key-zoom-half=Command+0
+
+# 1:1 Original (string)
+#global-key-zoom-original=
+
+# 1:1 Original (string)
+#key-zoom-original=Command+1
+
+# 2:1 Double (string)
+#global-key-zoom-double=
+
+# 2:1 Double (string)
+#key-zoom-double=Command+2
+
+# Very short jump length (integer)
+#extrashort-jump-size=3
+
+# Short jump length (integer)
+#short-jump-size=10
+
+# Medium jump length (integer)
+#medium-jump-size=60
+
+# Long jump length (integer)
+long-jump-size=600
+
+# Set playlist bookmark 1 (string)
+#global-key-set-bookmark1=
+
+# Set playlist bookmark 1 (string)
+#key-set-bookmark1=Command+F1
+
+# Set playlist bookmark 2 (string)
+#global-key-set-bookmark2=
+
+# Set playlist bookmark 2 (string)
+#key-set-bookmark2=Command+F2
+
+# Set playlist bookmark 3 (string)
+#global-key-set-bookmark3=
+
+# Set playlist bookmark 3 (string)
+#key-set-bookmark3=Command+F3
+
+# Set playlist bookmark 4 (string)
+#global-key-set-bookmark4=
+
+# Set playlist bookmark 4 (string)
+#key-set-bookmark4=Command+F4
+
+# Set playlist bookmark 5 (string)
+#global-key-set-bookmark5=
+
+# Set playlist bookmark 5 (string)
+#key-set-bookmark5=Command+F5
+
+# Set playlist bookmark 6 (string)
+#global-key-set-bookmark6=
+
+# Set playlist bookmark 6 (string)
+#key-set-bookmark6=Command+F6
+
+# Set playlist bookmark 7 (string)
+#global-key-set-bookmark7=
+
+# Set playlist bookmark 7 (string)
+#key-set-bookmark7=Command+F7
+
+# Set playlist bookmark 8 (string)
+#global-key-set-bookmark8=
+
+# Set playlist bookmark 8 (string)
+#key-set-bookmark8=Command+F8
+
+# Set playlist bookmark 9 (string)
+#global-key-set-bookmark9=
+
+# Set playlist bookmark 9 (string)
+#key-set-bookmark9=
+
+# Set playlist bookmark 10 (string)
+#global-key-set-bookmark10=
+
+# Set playlist bookmark 10 (string)
+#key-set-bookmark10=
+
+# Play playlist bookmark 1 (string)
+#global-key-play-bookmark1=
+
+# Play playlist bookmark 1 (string)
+#key-play-bookmark1=F1
+
+# Play playlist bookmark 2 (string)
+#global-key-play-bookmark2=
+
+# Play playlist bookmark 2 (string)
+#key-play-bookmark2=F2
+
+# Play playlist bookmark 3 (string)
+#global-key-play-bookmark3=
+
+# Play playlist bookmark 3 (string)
+#key-play-bookmark3=F3
+
+# Play playlist bookmark 4 (string)
+#global-key-play-bookmark4=
+
+# Play playlist bookmark 4 (string)
+#key-play-bookmark4=F4
+
+# Play playlist bookmark 5 (string)
+#global-key-play-bookmark5=
+
+# Play playlist bookmark 5 (string)
+#key-play-bookmark5=F5
+
+# Play playlist bookmark 6 (string)
+#global-key-play-bookmark6=
+
+# Play playlist bookmark 6 (string)
+#key-play-bookmark6=F6
+
+# Play playlist bookmark 7 (string)
+#global-key-play-bookmark7=
+
+# Play playlist bookmark 7 (string)
+#key-play-bookmark7=F7
+
+# Play playlist bookmark 8 (string)
+#global-key-play-bookmark8=
+
+# Play playlist bookmark 8 (string)
+#key-play-bookmark8=F8
+
+# Play playlist bookmark 9 (string)
+#global-key-play-bookmark9=
+
+# Play playlist bookmark 9 (string)
+#key-play-bookmark9=
+
+# Play playlist bookmark 10 (string)
+#global-key-play-bookmark10=
+
+# Play playlist bookmark 10 (string)
+#key-play-bookmark10=
+
+# Clear the playlist (string)
+#global-key-clear-playlist=
+
+# Clear the playlist (string)
+#key-clear-playlist=
+
+# Reset subtitles text scale (string)
+#global-key-subtitle-text-scale-normal=
+
+# Reset subtitles text scale (string)
+#key-subtitle-text-scale-normal=Command+0
+
+# Scale down subtitles text (string)
+#global-key-subtitle-text-scale-up=
+
+# Scale down subtitles text (string)
+#key-subtitle-text-scale-up=Command+Mouse Wheel Up
+
+# Scale up subtitles text (string)
+#global-key-subtitle-text-scale-down=
+
+# Scale up subtitles text (string)
+#key-subtitle-text-scale-down=Command+Mouse Wheel Down
+
+# Playlist bookmark 1 (string)
+#bookmark1=
+
+# Playlist bookmark 2 (string)
+#bookmark2=
+
+# Playlist bookmark 3 (string)
+#bookmark3=
+
+# Playlist bookmark 4 (string)
+#bookmark4=
+
+# Playlist bookmark 5 (string)
+#bookmark5=
+
+# Playlist bookmark 6 (string)
+#bookmark6=
+
+# Playlist bookmark 7 (string)
+#bookmark7=
+
+# Playlist bookmark 8 (string)
+#bookmark8=
+
+# Playlist bookmark 9 (string)
+#bookmark9=
+
+# Playlist bookmark 10 (string)
+#bookmark10=
+
diff --git a/bashrc/HuangYings-MacBook-Pro.local.csc.properties b/bashrc/HuangYings-MacBook-Pro.local.csc.properties
new file mode 100644
--- /dev/null
+++ ./bashrc/HuangYings-MacBook-Pro.local.csc.properties
@@ -0,0 +1 @@
+~/myproject/git/vim/macvim-snapshot-73/
diff --git a/bashrc/apf.sh b/bashrc/apf.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/apf.sh
@@ -0,0 +1,13 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+if [ $(uname) != "Darwin" ]
+then
+    apt-get update
+    aptitude -y full-upgrade
+else
+    brew update
+    brew upgrade
+fi
diff --git a/bashrc/app_list b/bashrc/app_list
new file mode 100644
--- /dev/null
+++ ./bashrc/app_list
@@ -0,0 +1,111 @@
+acroread
+anjuta
+apache2
+apt-mirror
+apvlv
+autogen
+bridge-utils
+build-essential
+cmake
+codeblocks
+cscope
+curl
+debmirror
+doxygen
+eclipse
+ethtool
+firefox
+g++
+gcc
+gdb
+gdm
+geany
+git-core
+gnome-core
+gnome-devel
+gnome-devel-docs
+gnome-system-tools
+gthumb
+hibernate
+htop
+kdesdk
+kdiff3
+kvpnc
+language-pack-zh
+libasound2-dev
+libboost-dev
+libgnutls-dev
+libgtk2.0-dev
+libid3tag0-dev
+liblastfm-dev
+libmad0-dev
+libpoppler-glib-dev
+libqjson-dev
+libqt4-dev
+libqt4-sql-sqlite
+librapi2-tools
+librra-tools
+libtag1-dev
+libtag1c2a
+libvorbis-dev
+lvm2
+makeself
+mdadm
+mercurial
+mldonkey-server
+mplayer
+nfs-common
+nfs-kernel-server
+pkg-config
+pm-utils
+python
+qt4-designer
+qt4-doc
+rar
+ristretto
+samba
+scons
+slurm
+cifs-utils
+mplayer
+smplayer
+ssh
+stardict
+sunclock
+synce-hal
+sysv-rc-conf
+tomcat6
+ubuntu-desktop
+ubuntu-restricted-extras
+uml-utilities
+unrar
+update-manager
+valgrind
+vifm
+vim
+virtualbox-ose
+vpnc
+wicd
+xclip
+xorg
+zlib1g-dev
+ndisgtk
+virt-manager
+xmame-x
+mysql-server
+mysql-client
+php5-mysql
+phpmyadmin
+gnome-color-chooser
+curlftpfs
+wine
+unzip
+xsltproc
+pstotext
+antiword
+catdoc
+xsltproc
+libwpd-tools
+unrtf
+untex
+unrar
diff --git a/bashrc/append_num.sh b/bashrc/append_num.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/append_num.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+
+echo "$1" | sed "s/\/[6-9]\([^0-9][^\/]*$\)/\/\1/g;s/\/\([^\/]*$\)/\/$2 \1/g;s/\"//g" | tr -s ' '
diff --git a/bashrc/append_rate.sh b/bashrc/append_rate.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/append_rate.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+
+source=$(echo "$1" | sed 's/"//g')
+target=$(~/loadrc/bashrc/append_num.sh "$1" "$2")
+mkdir -p "$(dirname "$target")"
+mv -nv "$source" "$target"
diff --git a/bashrc/apt-mirror.sh b/bashrc/apt-mirror.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/apt-mirror.sh
@@ -0,0 +1,43 @@
+#! /bin/zsh
+
+RSYNCSOURCE=rsync://mirrors.sohu.com/ubuntu/
+#RSYNCSOURCE=rsync://debian.nctu.edu.tw/ubuntu/
+#RSYNCSOURCE=rsync://ubuntu.dormforce.net/ubuntu/
+#RSYNCSOURCE=rsync://mirror.anl.gov/ubuntu/
+
+BASEDIR=~/mirror/
+
+check_bool=`~/myproject/git/linux/bashrc/check_disk.sh`
+if [ ${check_bool} -eq 1 ]
+then
+    # check to see if script is already running
+    PDIR=${0%`basename $0`}
+    LCK_FILE=`basename $0`.lck
+
+    if [ -f "${LCK_FILE}" ]
+    then
+        MYPID=`head -n 1 "${LCK_FILE}"`
+
+        TEST_RUNNING=`ps -p ${MYPID} | grep ${MYPID}`
+
+        if [ -z "${TEST_RUNNING}" ]
+        then
+            # The process is not running
+            # Echo current PID into lock file
+            echo $$ > "${LCK_FILE}"
+            rsync -ahHv --log-file=/root/rlog --delete-after \
+                --exclude \*dapper\* --exclude \*hardy\* --exclude \*intrepid\* --exclude \*jaunty\* \
+                --exclude \*powerpc\* --exclude \*sparc\* \
+                ${RSYNCSOURCE} ${BASEDIR}
+        else
+            # the process IS running
+            # handle it
+            echo this process is running
+            exit 1
+        fi
+    else
+        echo $$ > "${LCK_FILE}"
+    fi
+else
+    echo the disks not ready!!!
+fi
diff --git a/bashrc/back.sh b/bashrc/back.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/back.sh
@@ -0,0 +1,18 @@
+#! /bin/zsh
+SOURCE=$1
+TARGET=$2
+
+if [ ! -d "${TARGET}" ]
+then
+    mkdir -p "${TARGET}"
+fi
+
+rsync -aH --delete-after \
+    --exclude=/proc \
+    --exclude=/etc/fstab \
+    --exclude=/boot/grub/grub.cfg \
+    --exclude=/lost+found \
+    --exclude=/media \
+    --exclude=/sys \
+    --include=myproject \
+    "${SOURCE}" "${TARGET}"
diff --git a/bashrc/backup_with_time.sh b/bashrc/backup_with_time.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/backup_with_time.sh
@@ -0,0 +1,12 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+source="$1"
+dt=$(date '+%m_%d_%Y_%H_%M_%S');
+target="${source}.$dt"
+echo "target --> $target"
+
+rsync -aHv --delete-after \
+    "${source}/" "${target}/"
diff --git a/bashrc/backup_with_time.test.sh b/bashrc/backup_with_time.test.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/backup_with_time.test.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./backup_with_time.sh /var/lib/transmission-daemon/.config/transmission-daemon
diff --git a/bashrc/bash.test.sh b/bashrc/bash.test.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/bash.test.sh
@@ -0,0 +1,25 @@
+#!/bin/bash - 
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+if [ $(uname) = "Darwin" ]
+then
+    echo "it is macos"
+else
+    echo "it is Linux"
+fi
+
+if [ $(uname) = "Darwin" ]
+then
+    echo "it is macos"
+else
+    echo "it is Linux"
+fi
+
+if [[ $(uname) == "Darwin" ]]
+then
+    echo "it is macos"
+else
+    echo "it is Linux"
+fi
diff --git a/bashrc/best_find.sh b/bashrc/best_find.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/best_find.sh
@@ -0,0 +1,28 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+cd ~/imvu/website-project/website/
+ps ax|awk '/\yfind\y/{print $1}' | while read ss; do kill -9 "$ss"; done
+ps ax|awk '/\ycscope\y/{print $1}' | while read ss; do kill -9 "$ss"; done
+time \
+    find . -type f > /dev/null 2>&1
+
+time \
+    find . -type f -exec file {} + | grep text | cut -d: -f1 > /dev/null 2>&1
+
+time \
+    find . -type f -exec grep -Il "" {} + > /dev/null 2>&1
+
+time \
+    find . -type f -exec grep -Iq . {} \; -print > /dev/null 2>&1
+
+time \
+    find . -type f -exec grep -Il "" {} \; > /dev/null 2>&1
+
+time \
+    find . -type f -exec grep -Il . {} + > /dev/null 2>&1
+
+time \
+    find . -type f -print0 | xargs -0 grep -IZl . > /dev/null 2>&1
diff --git a/bashrc/binaryGrep.sh b/bashrc/binaryGrep.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/binaryGrep.sh
@@ -0,0 +1,51 @@
+#!/bin/zsh
+#===============================================================================
+#
+#          FILE: binaryGrep.sh
+#
+#         USAGE: ./binaryGrep.sh
+#
+#   DESCRIPTION:
+#
+#       OPTIONS: ---
+#  REQUIREMENTS: ---
+#          BUGS: ---
+#         NOTES: ---
+#        AUTHOR: YOUR NAME (),
+#  ORGANIZATION:
+#       CREATED: 05/03/2016 16:12
+#      REVISION:  ---
+#===============================================================================
+
+set -o nounset                              # Treat unset variables as an error
+
+find_result="`echo "$1".binaryGrep.findresult |sed  -e "s/\//\_/g;s/\ /\_/g"`"
+if [ -f "$find_result" ]
+then
+    read -p "the search is already done, if you want to update, press u --> " update
+    case $update in
+        u)
+            ;;
+        "")
+            exit 1
+            ;;
+        ?)
+            exit 1
+            ;;
+    esac
+fi
+grep -rl \
+    --include *.jar \
+    --include *.class \
+    --include *.tar \
+    --include *.war \
+    --include *target* \
+    "$1" \
+    . > "$find_result"
+grep -rl \
+    --include *.jar \
+    --include *.class \
+    --include *.tar \
+    --include *.war \
+    "$1" \
+    ~/.m2/ >> "$find_result"
diff --git a/bashrc/catRSA.sh b/bashrc/catRSA.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/catRSA.sh
@@ -0,0 +1,11 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+while read -r line || [[ -n "$line" ]]
+do
+    cat ~/.ssh/id_rsa.pub | sshpass -p '1qaz@WSX' ssh huangyingw@"$line"  'mkdir -p ~/.ssh/ ; cat >> .ssh/authorized_keys'
+done < servers.list
+
+cd -
diff --git a/bashrc/change_mac_hostname.sh b/bashrc/change_mac_hostname.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/change_mac_hostname.sh
@@ -0,0 +1,17 @@
+#!/bin/zsh
+if [ $(uname) != "Darwin" ]
+then
+    exit 0
+fi
+
+if [ -z "$1" ]
+then
+    echo -e "${red}Please provide hostname ... ${NC}"
+    exit 1
+fi
+
+HOSTNAME="$1"
+sudo scutil --set HostName "$HOSTNAME"
+sudo scutil --set LocalHostName "$HOSTNAME"
+sudo scutil --set ComputerName "$HOSTNAME"
+dscacheutil -flushcache
diff --git a/bashrc/change_mac_hostname_test.sh b/bashrc/change_mac_hostname_test.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/change_mac_hostname_test.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./change_mac_hostname.sh mba
diff --git a/bashrc/check_disk.sh b/bashrc/check_disk.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/check_disk.sh
@@ -0,0 +1,14 @@
+#! /bin/zsh
+check_file=~/disk_list.txt
+result=1
+
+for file in `cat $check_file`
+do
+    if ! (df -Th | grep -q ${file})
+    then
+        result=0
+        echo ${file} >> check_disk.log
+    fi
+done
+
+echo ${result}
diff --git a/bashrc/check_remote_mounted.sh b/bashrc/check_remote_mounted.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/check_remote_mounted.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+
+if (df -P . | sed -n '$s/[[:blank:]].*//p' | grep -q ':')
+then
+    return 0
+else
+    return 1
+fi
diff --git a/bashrc/check_running.sh b/bashrc/check_running.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/check_running.sh
@@ -0,0 +1,35 @@
+#!/bin/zsh
+
+if [ -z "$1" ]
+then
+    echo -e "${red}Please provide the target file name... ${NC}"
+    exit 1
+fi
+
+targetFile="$1"
+SCRIPT=$(realpath "$targetFile")
+
+# check to see if script is already running
+PDIR=${0%`basename $0`}
+LCK_FILE="$(basename -- "$SCRIPT" | cut -d. -f1).lck"
+
+if [ -f "${LCK_FILE}" ]
+then
+    MYPID=`head -n 1 "${LCK_FILE}"`
+
+    TEST_RUNNING=`ps -p ${MYPID} | grep ${MYPID}`
+
+    if [ -z "${TEST_RUNNING}" ]
+    then
+        # The process is not running
+        # Echo current PID into lock file
+        echo $$ > "${LCK_FILE}"
+        "$SCRIPT" "$2" "$3" "$4"
+    else
+        # the process IS running
+        # handle it
+        exit 1
+    fi
+else
+    echo $$ > "${LCK_FILE}"
+fi
diff --git a/bashrc/clearDNS.sh b/bashrc/clearDNS.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/clearDNS.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+sudo dscacheutil -flushcache;sudo killall -HUP mDNSResponder; say cache flushed
+
+cd -
diff --git a/bashrc/copy.sh b/bashrc/copy.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/copy.sh
@@ -0,0 +1,20 @@
+#!/bin/zsh
+
+if [ -z "$1" ] || [ -z "$2" ]
+then
+    echo -e "${red}Please provide both source and target parameters... ${NC}"
+    exit 1
+fi
+
+source=$1
+target=$2
+
+iconvs=$(~/loadrc/bashrc/get_iconvs.sh "$source" "$target")
+rsyncpath=$(~/loadrc/bashrc/get_rsyncpath.sh "$source" "$target")
+rsync_basic_options=($(< ~/loadrc/bashrc/rsync_basic_options))
+
+rsync \
+    "${rsync_basic_options[@]}" \
+    "$iconvs" \
+    "$rsyncpath" \
+    "$source/" "$target/"
diff --git a/bashrc/copy.test.sh b/bashrc/copy.test.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/copy.test.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./copy.sh ~/loadrc/ ~/loadrc.bak/
diff --git a/bashrc/copy10.sh b/bashrc/copy10.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/copy10.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh 
+find dogscats/ -type d | while read ss; do find "$ss" -maxdepth 1 -type f | head -n10; done | while read tt; do cp -v "$tt" $(echo "$tt" | sed 's/dogscats/smallset/g'); done
diff --git a/bashrc/copy_dirs.sh b/bashrc/copy_dirs.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/copy_dirs.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+find dogscats/ -type d -print | sed 's/dogscats/smallset/g' | xargs mkdir -p
diff --git a/bashrc/copy_files.sh b/bashrc/copy_files.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/copy_files.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+~/loadrc/bashrc/copy.sh ~/var/lib/mldonkey/incoming/files/ mini:/media/mini_crypt/var/lib/mldonkey/incoming/files/ 2>&1 | tee ~/loadrc/bashrc/copy_files.log
diff --git a/bashrc/copy_ignore_existing.sh b/bashrc/copy_ignore_existing.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/copy_ignore_existing.sh
@@ -0,0 +1,18 @@
+#!/bin/zsh
+
+if [ -z "$1" ] || [ -z "$2" ]
+then
+    echo -e "${red}Please provide both source and target parameters... ${NC}"
+    exit 1
+fi
+
+SOURCE=$1
+TARGET=$2
+
+if [[ "${TARGET}" != *":"* ]] && [[ ! -d "${TARGET}" ]]
+then
+    mkdir -p "${TARGET}"
+fi
+
+rsync -aHSv --progress --force --ignore-existing \
+    "${SOURCE}" "${TARGET}"
diff --git a/bashrc/create_folders.sh b/bashrc/create_folders.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/create_folders.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+
diff --git a/bashrc/cscope.sh b/bashrc/cscope.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/cscope.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+
+SOURCEFILE="cscopesourcefile.bak"
+
+cp -fv files.proj "$SOURCEFILE" && \
+    sed -i.bak 's/\\ / /g' "$SOURCEFILE" && \
+    cscope -bq -i "$SOURCEFILE"
diff --git a/bashrc/csr.sh b/bashrc/csr.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/csr.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+find . -name "*.h" -o -name "*.c" -o -name "*.cc" -o -name "*.cpp" -o -name "*.hpp" -o -name "*.java"> cscope.files
+cscope -Rq cscope.files
diff --git a/bashrc/cutcommon.sh b/bashrc/cutcommon.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/cutcommon.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+export LC_ALL=C
+
+comm -2 -3 <(sort "$1") <(sort "$2") > "$1".findresult
+comm -1 -3 <(sort "$1") <(sort "$2") > "$2".findresult
+cp -fv "$1".findresult "$1"
+cp -fv "$2".findresult "$2"
diff --git a/bashrc/dcopy.sh b/bashrc/dcopy.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/dcopy.sh
@@ -0,0 +1,13 @@
+#!/bin/zsh
+SOURCE=$1
+TARGET=$2
+
+if [ ! -d "${TARGET}" ]
+then
+    mkdir -p "${TARGET}"
+fi
+
+~/loadrc/bashrc/copy.sh \
+    "$SOURCE" "$TARGET" \
+    && ~/loadrc/bashrc/copy.sh \
+    "$TARGET" "$SOURCE"
diff --git a/bashrc/dd.sh b/bashrc/dd.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/dd.sh
@@ -0,0 +1,12 @@
+#!/bin/zsh
+
+input="$1"
+output="$2"
+
+if [[ "$input" = *'.img' ]] && [[ "$output" = *'/dev/'* ]]
+then
+    (pv -n "$input" | dd of="$output" bs=128M conv=notrunc,noerror) 2>&1 | gunzip -c | dialog --gauge "Running dd command (cloning), please wait..." 10 70 0
+elif [[ "$output" = *'.img' ]] && [[ "$input" = *'/dev/'* ]]
+then
+    (pv -n "$input" | gzip -c1 | dd of="$output" bs=128M conv=notrunc,noerror) 2>&1 | dialog --gauge "Running dd command (cloning), please wait..." 10 70 0
+fi
diff --git a/bashrc/dd.test.sh b/bashrc/dd.test.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/dd.test.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./dd.sh /dev/nbd0 /media/volgrp/software/test.img
diff --git a/bashrc/debmirror.sh b/bashrc/debmirror.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/debmirror.sh
@@ -0,0 +1,67 @@
+#### Start script to automate building of Ubuntu mirror #####
+## THE NEXT LINE IS NEEDED THE REST OF THE LINES STARTING WITH A # CAN BE DELETED
+
+#!/bin/zsh
+
+## Setting variables with explanations.
+
+#
+# Don't touch the user's keyring, have our own instead
+#
+export GNUPGHOME=/home/mirrorkeyring
+
+# Arch=         -a      # Architecture. For Ubuntu can be i386, powerpc or amd64.
+# sparc, only starts in dapper, it is only the later models of sparc.
+#
+arch=i386,amd64
+
+# Minimum Ubuntu system requires main, restricted
+# Section=      -s      # Section (One of the following - main/restricted/universe/multiverse).
+# You can add extra file with $Section/debian-installer. ex: main/debian-installer,universe/debian-installer,multiverse/debian-installer,restricted/debian-installer
+#
+section=main,restricted,universe,multiverse
+
+# Release=      -d      # Release of the system (Dapper, Edgy, Feisty, Gutsy, Hardy, Intrepid), and the -updates and -security ( -backports can be added if desired)
+#
+release=Lucid,Lucid-security,Lucid-updates,Maverick,Maverick-security,Maverick-updates,Karmic,Karmic-security,Karmic-updates
+
+# Server=       -h      # Server name, minus the protocol and the path at the end
+# CHANGE "*" to equal the mirror you want to create your mirror from. au. in Australia  ca. in Canada.
+# This can be found in your own /etc/apt/sources.list file, assuming you have Ubuntu installed.
+#
+#server=debian.nctu.edu.tw
+#server=debian.cn99.com
+server=archive.ubuntu.com
+
+# Dir=          -r      # Path from the main server, so http://my.web.server/$dir, Server dependant
+#
+inPath=/ubuntu
+
+# Proto=        -e      # Protocol to use for transfer (http, ftp, hftp, rsync)
+# Choose one - http is most usual the service, and the service must be avaialbe on the server you point at.
+#
+proto=rsync
+
+# Outpath=              # Directory to store the mirror in
+# Make this a full path to where you want to mirror the material.
+#
+outPath=/home/UbuntuMirror
+
+# The --nosource option only downloads debs and not deb-src's
+# The --progress option shows files as they are downloaded
+# --source \ in the place of --no-source \ if you want sources also.
+# --nocleanup  Do not clean up the local mirror after mirroring is complete. Use this option to keep older repository
+# Start script
+#
+debmirror       -a $arch \
+                --source \
+                -s $section \
+                -h $server \
+                -d $release \
+                -r $inPath \
+                --progress \
+                -e $proto \
+                $outPath
+
+
+#### End script to automate building of Ubuntu mirror ####
diff --git a/bashrc/debug.sh b/bashrc/debug.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/debug.sh
@@ -0,0 +1,7 @@
+#! /bin/zsh
+if [ -z "$1" ]
+then
+    valgrind -v --log-file=vlog --leak-check=full ./*.exe
+else
+    valgrind -v --log-file=vlog --leak-check=full ./$1
+fi
diff --git a/bashrc/delete_files_with_string.sh b/bashrc/delete_files_with_string.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/delete_files_with_string.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh 
+find . | xargs grep -l email@domain.com | awk '{print "rm "$1}' > doit.sh
diff --git a/bashrc/deploy.sh b/bashrc/deploy.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/deploy.sh
@@ -0,0 +1,15 @@
+#!/bin/zsh
+
+host=$(git config deploy.host)
+rpath=$(git config deploy.path)
+
+if [ "$host" = "localhost" ]
+then
+    exit 0
+fi
+
+if [[ -n "$host" ]] && [[ -n "$rpath" ]]
+then
+    ssh -n "$host" "mkdir -p $rpath"
+    ~/loadrc/bashrc/check_running.sh ~/loadrc/bashrc/do_deploy.sh
+fi
diff --git a/bashrc/deployLoadrc.sh b/bashrc/deployLoadrc.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/deployLoadrc.sh
@@ -0,0 +1,26 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+realDeploy () {
+    server="$1"
+    echo "Begin loadrc deploy on $server"
+    ./rsync.sh "$server":~/loadrc/
+    ssh -n "$server" "sudo apt-get update && sudo apt-get install -y vim-gnome cscope git tmux mosh htop realpath"
+    ssh -n "$server" "ln -fs ~/loadrc/vimrc/.vimrc ~/.vimrc"
+    ssh -n "$server" "ln -fs ~/loadrc/vimrc/.vim ~/.vim"
+    ssh -n "$server" "ln -fs ~/loadrc/gitrc/.gitconfig ~/.gitconfig"
+    ssh -n "$server" "ln -fs ~/loadrc/gitrc/.globalgitignore ~/.globalgitignore"
+}
+
+if [ -n "$1" ]
+then
+    realDeploy "$1"
+    exit
+fi
+
+while read -r line || [[ -n "$line" ]]
+do
+    realDeploy "$line"
+done < deployLoadrc.list
diff --git a/bashrc/deploy_backward.sh b/bashrc/deploy_backward.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/deploy_backward.sh
@@ -0,0 +1,9 @@
+#!/bin/zsh
+
+host=$(git config deploy.host)
+rpath=$(git config deploy.path)
+
+rsync -aHv --force --progress \
+    --files-from files.rev \
+    "$host:/" \
+    .
diff --git a/bashrc/deploy_forward.sh b/bashrc/deploy_forward.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/deploy_forward.sh
@@ -0,0 +1,9 @@
+#!/bin/zsh
+
+host=$(git config deploy.host)
+rpath=$(git config deploy.path)
+
+rsync -aHv --force --progress \
+    --files-from rsync.files \
+    . \
+    "$host:$rpath"
diff --git a/bashrc/do_deploy.sh b/bashrc/do_deploy.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/do_deploy.sh
@@ -0,0 +1,5 @@
+#!/bin/zsh
+
+parallel --jobs 0 -k ::: \
+    ~/loadrc/bashrc/deploy_forward.sh \
+    ~/loadrc/bashrc/deploy_backward.sh
diff --git a/bashrc/do_ports_forward.sh b/bashrc/do_ports_forward.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/do_ports_forward.sh
@@ -0,0 +1,11 @@
+#!/bin/zsh
+
+while read host
+do
+    for port in \
+        2224 \
+        2225
+    do
+        ssh -fnN -R "$port":localhost:"$port" "$host" &
+    done
+done < ~/loadrc/bashrc/ports_forward.hosts
diff --git a/bashrc/do_update_proj.sh b/bashrc/do_update_proj.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/do_update_proj.sh
@@ -0,0 +1,9 @@
+#!/bin/zsh
+
+parallel --jobs 10 -k ::: \
+    ~/loadrc/bashrc/generate_files_proj.sh \
+    ~/loadrc/bashrc/generate_rsync_files.sh \
+    ~/loadrc/bashrc/fvideos.sh \
+    ~/loadrc/bashrc/fdocs.sh \
+    ~/loadrc/bashrc/cscope.sh \
+    'git remote update'
diff --git a/bashrc/echo.sh b/bashrc/echo.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/echo.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+LCK_FILE="echo.lck"
+MYPID=`head -n 1 "${LCK_FILE}"`
+while true
+do
+    echo "I am running, pid --> $MYPID"
+done
diff --git a/bashrc/encrypt.sh b/bashrc/encrypt.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/encrypt.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+if [ -z "$1" ]
+then
+    echo -e "${red}Please provide parameter ... ${NC}"
+    exit 1
+fi
+cryptsetup -h sha256 -c aes-cbc-essiv:sha256 -s 256 luksFormat "$1"
+cryptsetup luksAddKey "$1" /root/loadrc/keys/keyfile
diff --git a/bashrc/envSync.sh b/bashrc/envSync.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/envSync.sh
@@ -0,0 +1,14 @@
+#!/bin/zsh
+if [ -z "$1" ]
+then
+    echo -e "${red}please provide the host name... ${NC}"
+    exit 1
+fi
+rsync -aH --force -e ssh ~/.ssh/ "$1":~/.ssh/ \
+    && rsync -aH --force -e ssh ~/.ssh/ root@"$1":~/.ssh/ \
+    && scp ~/loadrc/bashrc/ssh_host_* root@"$1":/etc/ssh/ \
+    && rsync -aH --force -e ssh ~/.git/ "$1":~/.git/ \
+    && rsync -aH --force -e ssh ~/loadrc/.git/ "$1":~/loadrc/.git/ \
+    && rsync -aH --force -e ssh ~/.git/ root@"$1":~/.git/ \
+    && rsync -aH --force -e ssh ~/loadrc/.git/ root@"$1":~/loadrc/.git/ \
+    && rsync -aHv --progress --delete --force -e ssh ~/loadrc/grub.d/ root@"$1":/etc/grub.d/
diff --git a/bashrc/eval.test.sh b/bashrc/eval.test.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/eval.test.sh
@@ -0,0 +1,12 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+TARGET=mini
+COMMAND="ping $TARGET &"
+eval "$COMMAND"
+
+TARGET=server
+COMMAND="ping $TARGET &"
+eval "$COMMAND"
diff --git a/bashrc/excludeFile b/bashrc/excludeFile
new file mode 100644
--- /dev/null
+++ ./bashrc/excludeFile
@@ -0,0 +1,9 @@
+*.bak
+*.findresult
+*.orig
+*.swp
+.git/
+cscope.in.out
+files.proj
+cscope.po.out
+vimrc/.vim/view/*
diff --git a/bashrc/exiso.sh b/bashrc/exiso.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/exiso.sh
@@ -0,0 +1,11 @@
+#! /bin/zsh
+source=$1
+
+mkdir -p /media/cdrom
+umount -fl /media/cdrom
+target="`echo "${source}" |sed  -e "s/\.iso$/\_iso/g;s/\.ISO$/\_iso/g"`"
+mkdir -p "${target}"
+
+mount "${source}" /media/cdrom -o loop \
+  && rsync -vrlptDH --progress /media/cdrom/ "${target}" \
+  && rm -fv "${source}"
diff --git a/bashrc/fc.sh b/bashrc/fc.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/fc.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+find "$1" \( -name \.svn -o -name \.git -o -name \.hg \) -prune -o -mmin -5 -print
diff --git a/bashrc/fcscope.sh b/bashrc/fcscope.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/fcscope.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh 
+cscopes=($(find . -type f -name files.proj))
+for cscope in "${cscopes[@]}"
+do
+  echo "${cscope}"
+  ~/loadrc/bashrc/do_update_proj.sh $(dirname "${cscope}")
+done
diff --git a/bashrc/fdisk_log.sh b/bashrc/fdisk_log.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/fdisk_log.sh
@@ -0,0 +1,14 @@
+#!/bin/zsh
+logFile=~/loadrc/fdisk.log
+
+df -TH > "$logFile"
+fdisk -l >> "$logFile"
+cat /etc/fstab >> "$logFile"
+cat ~/loadrc/linux_links/etc/crypttab >> "$logFile"
+DEVICE=`mdadm -D --scan|awk '{print $2}'`
+mdadm -D "$DEVICE" >> "$logFile"
+blkid >> "$logFile"
+ifconfig >> "$logFile"
+iw list >> "$logFile"
+cat /etc/network/interfaces >> "$logFile"
+~/loadrc/kvmrc/vsl.sh >> "$logFile"
diff --git a/bashrc/fdocs.sh b/bashrc/fdocs.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/fdocs.sh
@@ -0,0 +1,32 @@
+#! /bin/zsh
+
+FdocsInclude="fdocs.include"
+FdocsExclude="fdocs.exclude"
+TARGET="fdocs.list.tmp"
+
+if [ ! -f "$FdocsInclude" ] || [ ! -f "$FdocsExclude" ]
+then
+    exit 0
+fi
+
+or="";
+
+while read suf
+do
+    suf=$(echo "$suf" | sed 's/"//g')
+    include_params+=( $or "-wholename" "$suf" )
+    or="-o"
+done < "$FdocsInclude"
+
+or="";
+
+while read suf
+do
+    suf=$(echo "$suf" | sed 's/"//g')
+    exclude_params+=( $or "-wholename" "$suf" )
+    or="-o"
+done < "$FdocsExclude"
+
+find . "(" "${exclude_params[@]}" ")" -a -prune -o "(" "${include_params[@]}" ")" -type f -print | sed 's/\(["'\''\]\)/\\\1/g;s/.*/"&"/' > "$TARGET" && \
+    sort -u "$TARGET" -o "$TARGET" && \
+    cp -fv "$TARGET" fdocs.list
diff --git a/bashrc/fflink.sh b/bashrc/fflink.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/fflink.sh
@@ -0,0 +1,21 @@
+#!/bin/zsh
+[ $# -eq 0 ]&&directorys=`pwd`||directorys=$@
+linkchk()
+{
+    for file in $1/*
+    do
+        #       echo "$file"
+        [ -L "$file" -a ! -e "$file" ]&& ls -l $file | awk '{for(i=9;i<=19;i++) printf $i""FS;print ""}'
+        # -aand-L "$file" -e "$file" 
+        [ -d "$file" ]&&linkchk $file
+    done
+}
+for directory in $directorys
+do
+    if [ -d $directory ]
+    then linkchk $directory
+    else
+        echo "$directory is not a directory"
+        echo "Usage:$0 dir1 dir2 ..."
+    fi
+done
diff --git a/bashrc/fgh.sh b/bashrc/fgh.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/fgh.sh
@@ -0,0 +1,21 @@
+#!/bin/zsh
+function iterate_dir(){
+    for file in "$1"/*
+    do
+        if [ -d "$file" ]
+        then
+            if [ -d "$file/.git" ]
+            then
+                $HOME/loadrc/bashrc/gagh.sh "$file"
+            else
+                iterate_dir "$file"
+            fi
+        fi
+    done
+}
+if [ -z "$1" ]
+then
+    iterate_dir .
+else
+    iterate_dir "$1"
+fi
diff --git a/bashrc/file_move.sh b/bashrc/file_move.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/file_move.sh
@@ -0,0 +1,9 @@
+#!/bin/zsh
+
+if [ ! -d "$2" ]
+then
+    mkdir -p "$2"
+fi
+
+ss=$(echo "$1" | sed 's/"//g')
+mv -nv "$ss" "$2"
diff --git a/bashrc/file_type b/bashrc/file_type
new file mode 100755
--- /dev/null
+++ ./bashrc/file_type
@@ -0,0 +1,3 @@
+pdf
+docx
+doc
diff --git a/bashrc/find-free-nbd-device.sh b/bashrc/find-free-nbd-device.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/find-free-nbd-device.sh
@@ -0,0 +1,62 @@
+#!/bin/zsh
+#===============================================================================
+#
+#          FILE: find-free-nbd-device.sh
+#
+#         USAGE: ./find-free-nbd-device.sh
+#
+#   DESCRIPTION:
+#
+#       OPTIONS: ---
+#  REQUIREMENTS: ---
+#          BUGS: ---
+#         NOTES: ---
+#        AUTHOR: YOUR NAME (),
+#  ORGANIZATION:
+#       CREATED: 05/07/2016 12:52
+#      REVISION:  ---
+#===============================================================================
+
+set -o nounset                              # Treat unset variables as an error
+
+set -e
+set -o pipefail
+
+function nbd_used?() {
+    local devpath=${1}
+
+    local find=0 line=
+    while read line
+    do
+        [[ ${line} == "" ]] && continue
+
+        set ${line}
+        [[ "${1}" == "43" ]] || continue
+
+        if [[ ${devpath} == /dev/${4} ]]
+        then
+            find=1
+        fi
+    done < /proc/partitions
+
+    [[ "${find}" == "1" ]]
+}
+
+function find_free_nbd_device() {
+    local nbd=
+    for nbd in /dev/nbd*; do
+        case "${nbd}" in
+            *p[0-9]) continue ;;
+        esac
+
+        nbd_used? ${nbd} && continue
+
+        echo ${nbd}
+        break
+    done
+
+    # free nbd device not found
+    return 1
+}
+
+find_free_nbd_device
diff --git a/bashrc/find_projects.sh b/bashrc/find_projects.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/find_projects.sh
@@ -0,0 +1,10 @@
+#!/bin/zsh
+
+if [ -z "$1" ]
+then
+    find . -type f -name files.proj -exec realpath {} \; | sed 's/\(["'\''\]\)/\\\1/g;s/ /\\ /g;s/.*/"&"/' >> ~/all.proj
+else
+    find "$1" -type f -name files.proj -exec realpath {} \; | sed 's/\(["'\''\]\)/\\\1/g;s/ /\\ /g;s/.*/"&"/' >> ~/all.proj
+fi
+
+sort -u ~/all.proj -o ~/all.proj
diff --git a/bashrc/find_text.sh b/bashrc/find_text.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/find_text.sh
@@ -0,0 +1,34 @@
+#!/bin/zsh
+
+cd ~/loadrc/
+
+function fun1()
+{
+    find . -type f -exec grep -Il "" {} + > fun1.log
+}
+
+function fun2()
+{
+    find . -type f -exec grep -Iq . {} \; -print > fun2.log
+}
+
+function fun3()
+{
+    find . -type f -exec grep -Il "" {} \; > fun3.log
+}
+
+function fun4()
+{
+    find . -type f -exec grep -Il . {} + > fun4.log
+}
+
+function fun5()
+{
+    find . -type f -print0 | xargs -0 grep -IZl . > fun5.log
+}
+
+fun1
+fun2
+fun3
+fun4
+fun5
diff --git a/bashrc/find_up.sh b/bashrc/find_up.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/find_up.sh
@@ -0,0 +1,13 @@
+#!/bin/zsh
+
+rpath="$1"
+
+while [[ !"$rpath" = "" && ! -e "$rpath/$2" ]]
+do
+    rpath=${rpath%/*}
+done
+
+if [ -f "$rpath/$2" ]
+then
+    echo "$rpath/$2"
+fi
diff --git a/bashrc/find_up_folder.sh b/bashrc/find_up_folder.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/find_up_folder.sh
@@ -0,0 +1,10 @@
+#!/bin/zsh
+
+rpath="$1"
+
+while [[ "$rpath" != "" && ! -e "$rpath/$2" ]]
+do
+    rpath=${rpath%/*}
+done
+
+echo "$rpath"
diff --git a/bashrc/find_up_goto.sh b/bashrc/find_up_goto.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/find_up_goto.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+function upsearch () {
+    test / = "$pwd" && return || test -e "$1" && return || cd .. && upsearch "$1"
+}
+
+upsearch "$1"
diff --git a/bashrc/find_up_goto_test.sh b/bashrc/find_up_goto_test.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/find_up_goto_test.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+. ~/loadrc/bashrc/find_up_goto.sh ".git"
+echo "pwd --> $PWD"
+cd ~/myproject/git/AI/MorvanZhou/tutorials/kerasTUT/
+. ~/loadrc/bashrc/find_up_goto.sh ".git"
+echo "pwd --> $PWD"
+. ~/loadrc/bashrc/find_up_goto.sh "files.proj"
+echo "pwd --> $PWD"
diff --git a/bashrc/find_up_test.sh b/bashrc/find_up_test.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/find_up_test.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./find_up.sh "/Users/yhuang/loadrc/dvim" ".git"
+./find_up.sh "/Users/yhuang/loadrc/dvim" "files.proj"
diff --git a/bashrc/findmv.sh b/bashrc/findmv.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/findmv.sh
@@ -0,0 +1,27 @@
+#!/bin/zsh
+
+if [ -z "$1" ]
+then
+    echo -e "${red}Please provide the SOURCE... ${NC}"
+    exit 1
+fi
+
+if [ -z "$2" ]
+then
+    echo -e "${red}Please provide the TARGET... ${NC}"
+    exit 1
+fi
+
+SOURCE="$1"
+TARGET="$2"
+
+
+find "$SOURCE" -type f | \
+    while read ss
+    do
+        new_ss=$(echo "$ss" | sed -e "s#$SOURCE#$TARGET#g")
+        mkdir -p "$(dirname "$new_ss")"
+        mv -nv "$ss" "$new_ss"
+    done
+
+~/loadrc/bashrc/move.sh "$SOURCE" "$TARGET"
diff --git a/bashrc/fjar.sh b/bashrc/fjar.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/fjar.sh
@@ -0,0 +1,12 @@
+#!/bin/zsh
+LOOK_FOR="$2"
+
+for i in `find "$1" -name "*jar"`
+do
+    echo "Looking in $i ..."
+    jar tvf $i | grep $LOOK_FOR > /dev/null
+    if [ $? = 0 ]
+    then
+        echo "==> Found \"$LOOK_FOR\" in $i"
+    fi
+done
diff --git a/bashrc/flargest.sh b/bashrc/flargest.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/flargest.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+if [ -z "$1" ]
+then
+    find . -type f -exec du -sk {} \; | sort -n
+else
+    find $1 -type f -exec du -sk {} \; | sort -n
+fi
diff --git a/bashrc/flatest.sh b/bashrc/flatest.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/flatest.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+find $1 -type f -mtime -100 -exec ls -lrt {} \+;
+#find $1 -type f -exec ls -lrt {} \+;
diff --git a/bashrc/flink.sh b/bashrc/flink.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/flink.sh
@@ -0,0 +1,9 @@
+#!/bin/zsh
+TARGET=.
+
+if [ -n "$1" ]
+then
+    TARGET="$1"
+fi
+
+find "${TARGET}" -type l -exec ls -ld {} \;
diff --git a/bashrc/fnotinuse.sh b/bashrc/fnotinuse.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/fnotinuse.sh
@@ -0,0 +1,13 @@
+#!/bin/zsh
+find_result=fnotinuse.findresult
+echo > "$find_result"
+cscope_db_file="/export/home1/username/cscope_db/""${pwd##*/}"
+while read fullfile
+do
+    filename=$(basename "$fullfile")
+    filename="${filename%.*}"
+    if [ $(xargs fgrep -wnH "$filename" < "$cscope_db_file" |wc -l) -eq 0 ]
+    then
+        echo "$fullfile" >> "$find_result"
+    fi
+done < '/export/home1/username/cscope_db/'`pwd |sed -e "s/^.*\///g"`
diff --git a/bashrc/for.sh b/bashrc/for.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/for.sh
@@ -0,0 +1,39 @@
+#!/bin/zsh
+for ss in `$1`
+do
+    $2 $ss
+done
+
+for ss in \
+    str1 \
+    str2 \
+    str3
+do
+    echo $ss
+done
+
+#echo "for ss in `$1`; do echo $ss; done"
+for (( c=1; c<=5; c++ ))
+do
+    echo "Welcome $c times"
+done
+
+a=0
+for d in `seq 1 2 7`
+do
+    ((a++))
+    echo $a
+done
+
+function copyFiles() {
+    arr=("$@")
+    for i in "${arr[@]}";
+    do
+        echo "$i"
+    done
+
+}
+
+array=("one 1" "two 2" "three 3")
+
+copyFiles "${array[@]}"
diff --git a/bashrc/fpath.sh b/bashrc/fpath.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/fpath.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+find . -path \*content/docs/file.xml
diff --git a/bashrc/fr.sh b/bashrc/fr.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/fr.sh
@@ -0,0 +1,16 @@
+#!/bin/zsh
+
+FIND=$(echo $1 | sed 's/\//\\\//g')
+REPLACE=$(echo $2 | sed 's/\//\\\//g')
+
+if [[ "$4" == "w" ]]
+then
+    if [ $(uname) = "Darwin" ]
+    then
+        xargs sed -i.bak "s/[[:<:]]${FIND}[[:>:]]/${REPLACE}/g" < "$3"
+    else
+        xargs sed -i.bak "s/\b${FIND}\b/${REPLACE}/g" < "$3"
+    fi
+else
+    xargs sed -i.bak  "s/${FIND}/${REPLACE}/g" < "$3"
+fi
diff --git a/bashrc/fvideos.sh b/bashrc/fvideos.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/fvideos.sh
@@ -0,0 +1,21 @@
+#! /bin/zsh
+
+FAVLOG="fav.log.tmp"
+FAVLOGSORT="fav.log.sort.tmp"
+export LC_ALL=C
+
+if [ -n "$2" ]
+then
+    SIZE_OPTION="+$2M"
+else
+    SIZE_OPTION="+10M"
+fi
+
+cd "$1"
+echo "SIZE_OPTION --> $SIZE_OPTION"
+find . -type f -size "$SIZE_OPTION" -exec du -h {} + | sort -r -h | cut -f 2 | sed 's/\(["\]\)/\\\1/g;s/.*/"&"/' > "$FAVLOG" && \
+    cp -fv "$FAVLOG" fav.log && \
+    find . -type f -size "$SIZE_OPTION" -exec ls -t {} \+ | sed 's/\(["\]\)/\\\1/g;s/.*/"&"/' > "$FAVLOGSORT" && \
+    cp -fv "$FAVLOGSORT" fav.log.sort
+
+cd -
diff --git a/bashrc/generate_files_proj.sh b/bashrc/generate_files_proj.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/generate_files_proj.sh
@@ -0,0 +1,61 @@
+#!/bin/zsh
+
+if [ -z "$1" ]
+then
+    TARGETEDIR=`realpath "$PWD"`
+else
+    TARGETEDIR=`realpath "$1"`
+fi
+
+cd "$TARGETEDIR"
+
+if [ ! -f files.proj ]
+then
+    echo -e "${red}No files.proj file here, will not build the index ... ${NC}"
+    exit 1
+fi
+
+TARGETEDIR=`realpath "$PWD"`
+cp -nv ~/loadrc/prunefix_template.conf ./prunefix.conf
+cp -nv ~/loadrc/prunefile_template.conf ./prunefile.conf
+cp -nv ~/loadrc/includefile_template.conf ./includefile.conf
+cp -nv ~/loadrc/setup.cfg ./setup.cfg
+TARGET=files.proj.tmp
+PRUNE_POSTFIX=prunefix.conf
+PRUNE_FILE=prunefile.conf
+INCLUDE_FILE=includefile.conf
+
+or="";
+
+[ -f "$PRUNE_POSTFIX" ] && while read suf
+do
+    suf=$(echo "$suf" | sed 's/"//g')
+    prune_params+=( $or "-wholename" "$suf" )
+    or="-o"
+done < "$PRUNE_POSTFIX"
+
+or="";
+
+[ -f "$INCLUDE_FILE" ] && while read suf
+do
+    suf=$(echo "$suf" | sed 's/"//g')
+    include_params+=( $or "-wholename" "$suf" )
+    or="-o"
+done < "$INCLUDE_FILE"
+
+export LC_ALL=C
+
+find . "(" "${prune_params[@]}" ")" -a -prune -o -size +0 -type f -exec grep -Il "" {} + > "$TARGET" ; \
+    if [ ${#include_params[@]} -gt 0 ] ; \
+    then \
+        find . "(" "${include_params[@]}" ")" -type f -size -9000k >> ${TARGET} ; \
+        fi && \
+        echo "./$(~/loadrc/gitrc/get_current_branch.sh).gdio.diff" >> ${TARGET} && \
+        sed -i.bak 's/\(["'\''\]\)/\\\1/g;s/.*/"&"/;s/ /\\ /g' "$TARGET" && \
+        comm -23 <(sort "$TARGET") <(sort "$PRUNE_FILE") > "$TARGET.tmp" && \
+        cp -fv "$TARGET.tmp" "$TARGET" && \
+        sort -u "$TARGET" -o "$TARGET" && \
+        cp -fv "$TARGET" files.proj && \
+        echo "$TARGETEDIR"/files.proj | sed 's/\(["'\''\]\)/\\\1/g;s/ /\\ /g;s/.*/"&"/' >> ~/all.proj && \
+        sort -u ~/all.proj -o ~/all.proj.tmp && \
+        cp -fv ~/all.proj.tmp ~/all.proj
diff --git a/bashrc/generate_rsync_files.sh b/bashrc/generate_rsync_files.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/generate_rsync_files.sh
@@ -0,0 +1,41 @@
+#!/bin/zsh
+
+rsyncFiles=rsync.files.tmp
+cat files.proj | sed 's/^"//g;s/"$//g;s/\\ / /g' > "$rsyncFiles"
+PRUNE_POSTFIX=prunefix.rsync
+INCLUDE_FILE=includefile.rsync
+
+touch "$PRUNE_POSTFIX"
+
+or="";
+
+[ -f "$PRUNE_POSTFIX" ] && while read suf
+do
+    suf=$(echo "$suf" | sed 's/"//g')
+    prune_params+=( $or "-wholename" "$suf" )
+    or="-o"
+done < "$PRUNE_POSTFIX"
+
+or="";
+
+[ -f "$INCLUDE_FILE" ] && while read suf
+do
+    suf=$(echo "$suf" | sed 's/"//g')
+    include_params+=( $or "-wholename" "$suf" )
+    or="-o"
+done < "$INCLUDE_FILE"
+
+if [ ${#prune_params[@]} -gt 0 ] ; \
+then \
+    find . "(" "${prune_params[@]}" ")" -type f -size -9000k > "$rsyncFiles.diff" && \
+    comm -23 <(sort "$rsyncFiles") <(sort "$rsyncFiles".diff) > "$rsyncFiles.tmp" && \
+    cp -fv "$rsyncFiles.tmp" "$rsyncFiles" && \
+    comm -23 <(sort "$rsyncFiles") <(sort files.rev) > "$rsyncFiles.tmp" && \
+    cp -fv "$rsyncFiles.tmp" "$rsyncFiles" && \
+    fi && \
+    if [ ${#include_params[@]} -gt 0 ] ; \
+    then \
+        find . "(" "${include_params[@]}" ")" -type f | sed 's/\(["'\''\]\)/\\\1/g' >> "$rsyncFiles" && \
+        sort -u "$rsyncFiles" -o "$rsyncFiles" ; \
+        fi && \
+        cp -fv "$rsyncFiles" rsync.files
diff --git a/bashrc/get_first_column_of_file.sh b/bashrc/get_first_column_of_file.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/get_first_column_of_file.sh
@@ -0,0 +1,14 @@
+#!/bin/zsh
+
+if [ "$1" = "files.proj" ]
+then
+    echo "files.proj"
+    exit
+fi
+
+inputFile="$1"
+inputBak="$inputFile".tmp
+awk -F":" '{print $1}' "$inputFile" > "$inputBak"
+sed -i.bak "/^$/d" "$inputBak"
+sort -u "$inputBak" -o "$inputBak"
+echo "$inputBak"
diff --git a/bashrc/get_first_column_of_file_test.sh b/bashrc/get_first_column_of_file_test.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/get_first_column_of_file_test.sh
@@ -0,0 +1,9 @@
+#!/bin/zsh 
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+resultFile="/Users/yhuang/Dropbox/loadrc/loadrc.findresult"
+cat "$resultFile" | wc -l
+./get_first_column_of_file.sh "$resultFile"
+cat "$resultFile" | wc -l
diff --git a/bashrc/get_iconv.test.sh b/bashrc/get_iconv.test.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/get_iconv.test.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./get_iconv.sh "u2004:~/loadrc"
+./get_iconv.sh "huangyingw@mbp:~/loadrc"
+./get_iconv.sh "~/loadrc"
diff --git a/bashrc/get_iconvs.sh b/bashrc/get_iconvs.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/get_iconvs.sh
@@ -0,0 +1,33 @@
+#!/bin/zsh
+
+source=$1
+target=$2
+
+shost=$(~/loadrc/bashrc/parse_host.sh "$source")
+thost=$(~/loadrc/bashrc/parse_host.sh "$target")
+
+function get_utf_8_str()
+{
+    host=$1
+
+    if ( ssh -q "$host" "uname" | grep -q Darwin )
+    then
+        echo "utf-8-mac"
+    else
+        echo "utf-8"
+    fi
+}
+
+local_utf_8_str=$(get_utf_8_str "localhost")
+
+if [ "$shost" != "localhost" ]
+then
+    remote_utf_8_str=$(get_utf_8_str $shost)
+    echo "--iconv=$local_utf_8_str,$remote_utf_8_str"
+elif [ "$thost" != "localhost" ]
+then
+    remote_utf_8_str=$(get_utf_8_str $thost)
+    echo "--iconv=$local_utf_8_str,$remote_utf_8_str"
+else
+    echo "--iconv=$local_utf_8_str,$local_utf_8_str"
+fi
diff --git a/bashrc/get_rsyncpath.sh b/bashrc/get_rsyncpath.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/get_rsyncpath.sh
@@ -0,0 +1,26 @@
+#!/bin/zsh
+
+source=$1
+target=$2
+
+shost=$(~/loadrc/bashrc/parse_host.sh "$source")
+thost=$(~/loadrc/bashrc/parse_host.sh "$target")
+
+function get_rsyncpath()
+{
+    host=$1
+    echo $(ssh "$host" ". ~/loadrc/.pathrc ; which rsync")
+}
+
+if [ "$shost" != "localhost" ]
+then
+    rsyncpath=$(get_rsyncpath $shost)
+    echo "--rsync-path=$rsyncpath"
+elif [ "$thost" != "localhost" ]
+then
+    rsyncpath=$(get_rsyncpath $thost)
+    echo "--rsync-path=$rsyncpath"
+else
+    rsyncpath=$(get_rsyncpath "localhost")
+    echo "--rsync-path=$rsyncpath"
+fi
diff --git a/bashrc/get_rsyncpath.test.sh b/bashrc/get_rsyncpath.test.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/get_rsyncpath.test.sh
@@ -0,0 +1,10 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./get_rsyncpath.sh mba:~/loadrc/ ~/loadrc/
+./get_rsyncpath.sh ~/loadrc/ ~/loadrc.bak/
+./get_rsyncpath.sh ~/loadrc/ mba:~/loadrc/
+./get_rsyncpath.sh ~/loadrc/ mini:~/loadrc/
+./get_rsyncpath.sh mini:~/loadrc/ ~/loadrc/
diff --git a/bashrc/getopts.sh b/bashrc/getopts.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/getopts.sh
@@ -0,0 +1,55 @@
+#!/bin/zsh
+# Argument = -t test -r server -p password -v
+
+usage()
+{
+  cat <<EOF
+  usage: $0 options
+
+  This script run the test1 or test2 over a machine.
+
+  OPTIONS:
+  -h      Show this message
+  -t      Test type, can be test1 or test2
+  -r      Server address
+  -p      Server root password
+  -v      Verbose
+EOF
+}
+
+TEST=
+SERVER=
+PASSWD=
+VERBOSE=
+while getopts ht:r:p:v OPTION
+do
+  case $OPTION in
+    h)
+      usage
+      exit 1
+      ;;
+    t)
+      TEST=$OPTARG
+      ;;
+    r)
+      SERVER=$OPTARG
+      ;;
+    p)
+      PASSWD=$OPTARG
+      ;;
+    v)
+      VERBOSE=1
+      ;;
+    ?)
+      usage
+      exit
+      ;;
+  esac
+done
+
+if [[ -z $TEST ]] || [[ -z $SERVER ]] || [[ -z $PASSWD ]]
+then
+  usage
+  exit 1
+fi
+echo test:$TEST server:$SERVER passwd:$PASSWD
diff --git a/bashrc/glink.sh b/bashrc/glink.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/glink.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+real_dir=`ls -l "$1"|awk '{print $11}'`
+cd "$real_dir"
diff --git a/bashrc/hardseed.list b/bashrc/hardseed.list
new file mode 100644
--- /dev/null
+++ ./bashrc/hardseed.list
@@ -0,0 +1,10 @@
+caoliu_west_reposted
+caoliu_asia_mosaicked_reposted
+caoliu_asia_non_mosaicked_reposted
+caoliu_west_original
+caoliu_asia_mosaicked_original
+caoliu_asia_non_mosaicked_original
+caoliu_selfie
+aicheng_west
+aicheng_asia_mosaicked
+aicheng_asia_non_mosaicked  
diff --git a/bashrc/hardseed.sh b/bashrc/hardseed.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/hardseed.sh
@@ -0,0 +1,5 @@
+#!/bin/zsh
+while read ss
+do
+    hardseed --saveas-path /media/volgrp/av/seed/ --concurrent-tasks 16 --topics-range 1024 --av-class $ss --timeout-download-picture 320 --proxy ""
+done < ~/loadrc/bashrc/hardseed.list
diff --git a/bashrc/heritrix.sh b/bashrc/heritrix.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/heritrix.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+/root/myproject/git/java/heritrix-1.14.4/bin/heritrix --bind=/ --admin=admin:admin
diff --git a/bashrc/includeFrom b/bashrc/includeFrom
new file mode 100644
--- /dev/null
+++ ./bashrc/includeFrom
@@ -0,0 +1 @@
+vimrc/.vim/plugin/command.vim
diff --git a/bashrc/jdupes.sh b/bashrc/jdupes.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/jdupes.sh
@@ -0,0 +1,19 @@
+#!/bin/zsh
+
+if [ -z "$1" ]
+then
+    echo -e "${red}Please provide TARGET ... ${NC}"
+    exit 1
+fi
+
+TARGET="$1"
+dt=$(date '+%m_%d_%Y_%H_%M_%S');
+logFile="$TARGET/jdupes.$dt.log"
+jdupes -dNr -X size+:100m -X nostr:/.git/ "$TARGET" 2>&1 | tee "$logFile"
+
+MIRRORCHECK=$HOME/loadrc/."`hostname`".mirror.check
+
+if [ -f ${MIRRORCHECK} ] ; \
+then \
+    ~/loadrc/bashrc/sleep.sh ; \
+fi
diff --git a/bashrc/jformat.sh b/bashrc/jformat.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/jformat.sh
@@ -0,0 +1,10 @@
+#! /bin/zsh
+folderForGit=$(realpath .)
+LIST=( -name \*.java -o -name \*.vala )
+
+if [ -f $HOME/.workrc ]
+then
+    find "$folderForGit" -type f \( "${LIST[@]}" \) -exec astyle --mode=java -nfxejoU -y -s2 --style=java -pcH {} \;
+else
+    find "$folderForGit" -type f \( "${LIST[@]}" \) -exec astyle --mode=java -nfxejoUys4pHU --style=allman -pcH {} \;
+fi
diff --git a/bashrc/kdisk.sh b/bashrc/kdisk.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/kdisk.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+qemu-img create -f qcow2 /root/kvm/"$1"/"$1".qcow2 500G
diff --git a/bashrc/kill_port.sh b/bashrc/kill_port.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/kill_port.sh
@@ -0,0 +1,5 @@
+#!/bin/zsh
+if [ -n "$1" ]
+then
+    lsof -i :"$1" | awk 'NR > 1 {print $2}' | while read ss; do kill -9 "$ss"; done
+fi
diff --git a/bashrc/kill_top_processes.sh b/bashrc/kill_top_processes.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/kill_top_processes.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh 
+sudo ps -eo pcpu,pid,user,args | grep -v iTerm2 | sort -k 1 -r | head -1 | awk '{print $2}' | while read ss; do sudo kill -9 "$ss"; done
diff --git a/bashrc/ln_fs.sh b/bashrc/ln_fs.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/ln_fs.sh
@@ -0,0 +1,22 @@
+#!/bin/zsh
+
+SOURCE="$1"
+realpath "$1" && SOURCE=$(realpath "$1")
+TARGET="$2"
+
+if [ "$SOURCE" != "$TARGET" ]
+then
+    if [ -L "$TARGET" ]
+    then
+        rm "$TARGET"
+    elif [ -f "$TARGET" ]
+    then
+        cp -nv "$TARGET" "$TARGET".bak
+    elif [ -d "$TARGET" ]
+    then
+        rsync -aHv --progress --remove-source-files "$TARGET"/ "$TARGET".bak/ ; \
+        ~/loadrc/bashrc/rmEmpty.sh "$TARGET"
+    fi
+
+    ln -fs "$SOURCE" "$TARGET"
+fi
diff --git a/bashrc/ln_fs.test.sh b/bashrc/ln_fs.test.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/ln_fs.test.sh
@@ -0,0 +1,27 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+rm -fr lib
+./ln_fs.sh /var/lib lib
+ls -al lib
+echo
+
+rm lib
+mkdir lib
+./ln_fs.sh /var/lib lib
+ls -al lib
+echo
+
+rm lib
+touch lib
+./ln_fs.sh /var/lib lib
+ls -al lib
+echo
+
+rm lib
+ln -fs /var/lib lib
+./ln_fs.sh /var/lib lib
+ls -al lib
+echo
diff --git a/bashrc/logFilter.sh b/bashrc/logFilter.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/logFilter.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh 
+targetFile="$1"
+keyWord="$2"
+sed -i.bak '/'"$keyWord"'/,$!d' $targetFile
+tail -r $targetFile | sed '/'"$keyWord"'/,$!d' | tail -r > $targetFile.findresult \
+  && cp -f $targetFile.findresult $targetFile
diff --git a/bashrc/lsnic.sh b/bashrc/lsnic.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/lsnic.sh
@@ -0,0 +1,82 @@
+#! /bin/zsh
+
+#******************************************************************************
+#  Copyright(c) 1999 - 2008 Intel Corporation.
+#
+#  This program is free software; you can redistribute it and/or modify it
+#  under the terms and conditions of the GNU General Public License,
+#  version 2, as published by the Free Software Foundation.
+#
+#  This program is distributed in the hope it will be useful, but WITHOUT
+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+#  more details.
+#
+#  You should have received a copy of the GNU General Public License along with
+#  this program; if not, write to the Free Software Foundation, Inc.,
+#  51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#
+#  Contact Information:
+#  Linux NICS <linux.nics@intel.com>
+#  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+#******************************************************************************
+
+#Determine how many Ethernet & Network controllers are installed in the system
+TotalControllers=`lspci | grep -c -i 'Ethernet Controller\|Network Controller'`
+
+temp=`lspci | grep -i 'Ethernet Controller\|Network Controller'|cut -f1 -d " "`
+
+#Define two arrays for storing IPPorts
+declare -a IOPorts1
+declare -a IOPorts2
+
+#Populate IOPorts1 with bus info from lspci.  Populate IoPorts2 with bus info
+#from ethtool.
+
+for (( counter=0 ; counter < $TotalControllers ; counter++ ))
+do
+    offset=$(($counter+1))
+    IOPorts1[$counter]=`echo $temp|cut -f$offset -d" "`
+    if (ethtool -i eth$counter) &> /dev/null; then
+        IOPorts2[$counter]=`ethtool -i eth$counter|grep 'bus-info'|cut -f3- -d :`
+    fi
+done
+
+#Loop through both arrays and determine if there's a match in IOPort1 & IOPort2.  If so
+#then the driver is loaded, and write to screen all the related information.  If there
+#is no match then there isn't a driver loaded for that device and write to screen only
+#the information available from lspci
+
+for ((counter=0 ; counter < $TotalControllers ; counter++))
+do
+    Match=0
+    for ((counter1=0 ; counter1 < $TotalControllers; counter1++))
+    do
+        if [ "${IOPorts1[$counter]}" = "${IOPorts2[$counter1]}" ]
+        then
+            Match=1
+            DeviceID=`lspci -nn | grep ${IOPorts2[$counter1]} |cut -f3- -d"["| cut -c 1-9`
+            EthernetController=`lspci -v |grep ${IOPorts2[$counter1]} | cut -f4- -d" "|cut -f1 -d"("`
+            AdapterName=`lspci -v | grep ${IOPorts2[$counter1]} -A 1 | grep 'Subsystem'|cut -f2- -d" "`
+            DriverName=`ethtool -i eth$counter1 | grep -i 'driver' | cut -f2 -d" "`
+            DriverVersion=`ethtool -i eth$counter1 | grep -m 1 -i 'version'| cut -f2 -d" "`
+            echo "eth$counter1 : ${IOPorts2[$counter1]}"
+            echo "    Make/Model = $AdapterName"
+            echo "    Ethernet controller = $EthernetController"
+            echo "    VenID:DevID = $DeviceID"
+            echo "    Driver name = $DriverName"
+            echo "    Driver version = $DriverVersion"
+        fi
+    done
+    if [ "$Match" = "0" ] ; then
+        DeviceID=`lspci -nn | grep ${IOPorts1[$counter]} |cut -f3- -d"["| cut -c 1-9`
+        EthernetController=`lspci -v |grep ${IOPorts1[$counter]} | cut -f4- -d" "|cut -f1 -d"("`
+        AdapterName=`lspci -v | grep ${IOPorts1[$counter]} -A 1 | grep 'Subsystem'|cut -f2- -d" "`
+        echo ": ${IOPorts1[$counter]}"
+        echo "    Make/Model = $AdapterName"
+        echo "    Ethernet controller = $EthernetController"
+        echo "    VenID:DevID = $DeviceID"
+        echo "    Driver name = No driver loaded"
+        echo "    Driver version = No driver loaded"
+    fi
+done
diff --git a/bashrc/lsof.sh b/bashrc/lsof.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/lsof.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+lsof -i :22
diff --git a/bashrc/lucene.sh b/bashrc/lucene.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/lucene.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh 
+java -cp /media/myproject/git/java/lucene/lucene-3.0.1/lucene-core-3.0.1.jar:/media/myproject/git/java/lucene/lucene-3.0.1/lucene-core-3.0.1.jar org.apache.lucene.demo.IndexFiles /media/myproject/git/java/lucene/lucene-3.0.1/docs/
diff --git a/bashrc/mbak_ex b/bashrc/mbak_ex
new file mode 100644
--- /dev/null
+++ ./bashrc/mbak_ex
@@ -0,0 +1,6 @@
+~/Documents/Parallels/
+/Volumes/
+/installer.failurerequests/
+~/samba/
+/private/var/vm/sleepimage
+/private/var/vm/swapfile*
diff --git a/bashrc/mbak_in b/bashrc/mbak_in
new file mode 100644
--- /dev/null
+++ ./bashrc/mbak_in
@@ -0,0 +1,7 @@
+/boot/
+/etc/
+/home/
+/lib/
+/root/
+/usr/
+/var/
diff --git a/bashrc/mirror.sh b/bashrc/mirror.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/mirror.sh
@@ -0,0 +1,48 @@
+#!/bin/zsh
+
+if [ -z "$1" ] || [ -z "$2" ]
+then
+    echo -e "${red}Please provide both source and target parameters... ${NC}"
+    exit 1
+fi
+
+source=$1
+target=$2
+
+ready_file="$source"/"tmirror.ready"
+MIRRORCHECK=$HOME/loadrc/."`hostname`".mirror.check
+
+if [[ "${ready_file}" != *":"* ]] && [[ ! -f ${ready_file} ]]
+then
+    echo -e "${red}tmirror must be run before mirror ... ${NC}"
+    exit 1
+fi
+
+if [ -z "$source" ]
+then
+    echo -e "${red}source could not be none... ${NC}"
+    exit 1
+fi
+
+if [ -z "$target" ]
+then
+    echo -e "${red}target could not be none... ${NC}"
+    exit 1
+fi
+
+rm "$ready_file"
+
+iconvs=$(~/loadrc/bashrc/get_iconvs.sh "$source" "$target")
+rsyncpath=$(~/loadrc/bashrc/get_rsyncpath.sh "$source" "$target")
+rsync_basic_options=($(< ~/loadrc/bashrc/rsync_basic_options))
+
+rsync \
+    --delete-before \
+    "${rsync_basic_options[@]}" \
+    "$iconvs" \
+    "$rsyncpath" \
+    "$source/" "$target/" && \
+    if [ -f "${MIRRORCHECK}" ] ; \
+    then \
+        ~/loadrc/bashrc/sleep.sh ; \
+    fi
diff --git a/bashrc/mklnk.sh b/bashrc/mklnk.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/mklnk.sh
@@ -0,0 +1,20 @@
+#!/bin/zsh
+SOURCE="$1"
+realpath "$1" && SOURCE=$(realpath "$1")
+TARGET="$2"
+realpath "$2" && TARGET=$(realpath "$2")
+
+if [ "$SOURCE" = "$TARGET" ]
+then
+    echo -e "${red} source and target are identical ... ${NC}"
+    exit 1
+fi
+
+if [ -f "$TARGET" ]
+then
+    echo -e "${red}Please consider backup/move the target folder --> $TARGET first ! ... ${NC}"
+    exit 1
+fi
+
+~/loadrc/bashrc/move.sh "$SOURCE" "$TARGET"
+~/loadrc/bashrc/ln_fs.sh "$TARGET" "$SOURCE"
diff --git a/bashrc/mldonkey.csc.properties b/bashrc/mldonkey.csc.properties
new file mode 100644
--- /dev/null
+++ ./bashrc/mldonkey.csc.properties
@@ -0,0 +1 @@
+~/myproject/git/vim/macvim-snapshot-73/
diff --git a/bashrc/mosh.sh b/bashrc/mosh.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/mosh.sh
@@ -0,0 +1,17 @@
+#!/bin/bash
+target=$(echo "$1" | sed  -e "s/\/$//g")
+
+MOSHSERVER=$(ssh "$target" ". ~/loadrc/.pathrc ; which mosh-server")
+tmuxAction="$(ssh "$target" ". ~/loadrc/.pathrc ; which tmux") new-session -A -s mosh"
+
+if ( nc -vz "$target" 22 2>&1 | grep -q succeeded ) && [ -z "$MOSHSERVER" ] || [ -z "$tmuxAction" ]
+then
+    echo -e "${red}please check connection, mosh and tmux setting of $target first... ${NC}"
+    exit 1
+fi
+
+while true
+do
+    ssh "$target" ". ~/loadrc/.pathrc ; ~/loadrc/macosrc/configure_mosh.sh" &
+    mosh --server="$MOSHSERVER" "$target" -- ${tmuxAction}
+done
diff --git a/bashrc/move.sh b/bashrc/move.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/move.sh
@@ -0,0 +1,32 @@
+#!/bin/zsh
+
+if [ -z "$1" ] || [ -z "$2" ]
+then
+    echo -e "${red}Please provide both source and target parameters... ${NC}"
+    exit 1
+fi
+
+source="$1"
+realpath "$1" && source=$(realpath "$1")
+
+target="$2"
+realpath "$2" && target=$(realpath "$2")
+
+if [ -n "$source" ] && [ -n "$target" ] && [ "$source" != "$target" ]
+then
+    iconvs=$(~/loadrc/bashrc/get_iconvs.sh "$source" "$target")
+    rsyncpath=$(~/loadrc/bashrc/get_rsyncpath.sh "$source" "$target")
+    rsync_basic_options=($(< ~/loadrc/bashrc/rsync_basic_options))
+    rsync \
+        --remove-source-files \
+        "${rsync_basic_options[@]}" \
+        "$iconvs" \
+        "$rsyncpath" \
+        "$source/" "$target/" ; \
+        ~/loadrc/bashrc/rmEmpty.sh "$source"
+
+else
+    echo -e "${red}same dir --> ${source} ... ${NC}"
+    echo -e "${red}please choose the different dir! ... ${NC}"
+    exit 1
+fi
diff --git a/bashrc/move67.sh b/bashrc/move67.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/move67.sh
@@ -0,0 +1,14 @@
+#!/bin/zsh
+
+find /media/volgrp/mirror1/av/ -type f -size +100M  | while read ss
+do
+    target=$(echo "$ss" | sed 's/\/mirror1\(\/.*\/[6-7][^0-9][^\/]*$\)/\/zarchive\1/g')
+
+    if [ "$ss" != "$target" ]
+    then
+        dir=$(dirname "$target")
+        mkdir -p "$dir"
+        source=$(echo "$ss" | sed 's/"//g')
+        mv -nv "$source" "$target"
+    fi
+done
diff --git a/bashrc/netbak.sh b/bashrc/netbak.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/netbak.sh
@@ -0,0 +1,3 @@
+#! /bin/zsh
+rsync -aH --force -e ssh --exclude=/media/volgrp/kvm/* /media/volgrp/ server:/media/volgrp/ \
+  ; $HOME/loadrc/bashrc/rsleep.sh
diff --git a/bashrc/netsync.sh b/bashrc/netsync.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/netsync.sh
@@ -0,0 +1,18 @@
+#!/bin/zsh
+if [ -z "$1" ]
+then
+    echo -e "${red}please specify the source server ... ${NC}"
+    exit 1
+fi
+SOURCE="$1"
+NETSYNC="$HOME/loadrc/bashrc/netsync_ex"
+exclude_params=();
+while read suf
+do
+    exclude_params+=( "--exclude=$suf" )
+done < "$NETSYNC"
+rsync -e ssh -aH --delete-during --force "${exclude_params[@]}" "${SOURCE}":/ / \
+    && scp "${SOURCE}":/boot/vmlinuz-* "${SOURCE}":/boot/initrd.img-*   /boot/ \
+    && update-initramfs -u \
+    && update-grub2 \
+    && reboot
diff --git a/bashrc/netsync_ex b/bashrc/netsync_ex
new file mode 100644
--- /dev/null
+++ ./bashrc/netsync_ex
@@ -0,0 +1,29 @@
+/boot/grub
+/boot/initrd.img-*
+/boot/vmlinuz-*
+/dev/
+/etc/NetworkManager/system-connections/
+/etc/fstab
+/etc/hostname
+/etc/initramfs-tools/conf.d/resume
+/etc/network/interfaces
+/etc/udev/rules.d/70-persistent-net.rules
+/media/
+/proc/
+/root/loadrc/
+/run/
+/sys/
+/tmp/
+/var/lib/NetworkManager/
+/var/log/
+/var/tmp/
+bashrc
+fstab
+grub.cfg
+hostname
+initrd.img
+initrd.img.old
+interfaces
+mdadm.conf
+vmlinuz
+vmlinuz.old
diff --git a/bashrc/ntp.sh b/bashrc/ntp.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/ntp.sh
@@ -0,0 +1,3 @@
+#cp -fv /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \
+#ntpdate cn.pool.ntp.org
+ntpdate pool.ntp.org
diff --git a/bashrc/ntp_update.sh b/bashrc/ntp_update.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/ntp_update.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+service ntp stop
+ntpdate -s time.nist.gov
+service ntp start
diff --git a/bashrc/nubak.sh b/bashrc/nubak.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/nubak.sh
@@ -0,0 +1,20 @@
+#! /bin/zsh
+TARGET=/media/volgrp/slink/media/`hostname`/
+if [ -n "$1" ]
+then 
+  TARGET="$1":$TARGET
+fi
+echo $TARGET
+UBAKEX="$HOME/loadrc/bashrc/ubak_ex"
+UBAKIN="$HOME/loadrc/bashrc/ubak_in"
+exclude_params=();
+while read suf
+do
+  exclude_params+=( "--exclude=$suf" )
+done < "$UBAKEX"
+include_params=();
+while read suf
+do
+  include_params+=( "--include=$suf" )
+done < "$UBAKIN"
+rsync -aH --force --delete-during "${exclude_params[@]}" "${include_params[@]}" / "${TARGET}"
diff --git a/bashrc/osmirror.sh b/bashrc/osmirror.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/osmirror.sh
@@ -0,0 +1,24 @@
+#!/bin/zsh
+SOURCE=$1
+TARGET=$2
+
+if [[ "${TARGET}" != *":"* ]] && [[ ! -d "${TARGET}" ]]
+then
+    mkdir -p "${TARGET}"
+fi
+
+if [[ "${SOURCE}" != *":"* ]] && [[ ! -f "$SOURCE/etc/fstab" ]]
+then
+    echo -e "${red}please choose the correct SOURCE os folder... ${NC}"
+    exit 1
+fi
+
+if [[ "${TARGET}" != *":"* ]] && [[ ! -f "$TARGET/etc/fstab" ]]
+then
+    echo -e "${red}please choose the correct TARGET os folder... ${NC}"
+    exit 1
+fi
+
+rsync -aHSv --progress --delete-during --force \
+    --exclude-from="$HOME"/loadrc/bashrc/osmirror_exclude \
+    "${SOURCE}/" "${TARGET}/"
diff --git a/bashrc/osmirror_exclude b/bashrc/osmirror_exclude
new file mode 100644
--- /dev/null
+++ ./bashrc/osmirror_exclude
@@ -0,0 +1,29 @@
+*/.bash_history
+*/.zsh_history
+*/all.proj
+*/cscope.out
+*/files.proj
+*/includefile.conf
+*/loadrc
+*/prunefile.conf
+*/prunefix.conf
+boot/grub/grub.cfg
+etc/crypttab
+etc/exports
+etc/fstab
+etc/hostname
+etc/hosts
+etc/libvirt
+etc/mdadm/mdadm.conf
+home/huangyingw/snap/
+media/dev
+media/nvme
+media/volgrp
+root/.fastai
+root/.kaggle
+root/anaconda3
+var/lib/docker
+var/lib/libvirt
+var/lib/mldonkey
+var/lib/zerotier-one/identity.public
+var/lib/zerotier-one/identity.secret
diff --git a/bashrc/osmirror_test.sh b/bashrc/osmirror_test.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/osmirror_test.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+~/loadrc/bashrc/osmirror.sh /media/dev/nbd0p1/ /media/thinkpad/
diff --git a/bashrc/parse_host.sh b/bashrc/parse_host.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/parse_host.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+
+echo "$1" | sed 's/^[^:]*$/localhost/g;s/\([^:]*\):.*$/\1/g'
diff --git a/bashrc/parse_host.test.sh b/bashrc/parse_host.test.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/parse_host.test.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./parse_host.sh "mini:~/loadrc"
+./parse_host.sh "huangyingw@mini:~/loadrc"
+./parse_host.sh "~/loadrc"
diff --git a/bashrc/portList b/bashrc/portList
new file mode 100644
--- /dev/null
+++ ./bashrc/portList
@@ -0,0 +1,9 @@
+32355
+3306
+3478
+443
+65535
+8091
+8092
+8443
+8888
diff --git a/bashrc/ports_forward.hosts b/bashrc/ports_forward.hosts
new file mode 100644
--- /dev/null
+++ ./bashrc/ports_forward.hosts
@@ -0,0 +1,8 @@
+work
+mba
+mbp
+mini
+pikvm
+sb
+server
+imacpro
diff --git a/bashrc/ports_forward.sh b/bashrc/ports_forward.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/ports_forward.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+
+~/loadrc/bashrc/check_running.sh ~/loadrc/bashrc/do_ports_forward.sh
diff --git a/bashrc/post.sh b/bashrc/post.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/post.sh
@@ -0,0 +1,32 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+curl \
+    -H "x-imvu-sauce: xxxxxxxxxxxxxxxxxxxxxxxxxxxx" \
+    -H "Cookie: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" \
+    -d "preview_image=$(cat /Users/yhuang/imvu_code/website1/test_images/test20x50.png | base64)" \
+    https://api.imvu.com/product/product-53328306 > product-53328306-test20x50-post.json
+
+# recomment Content-Type: application/json version, to avoid some weird issue of losing '+', '=' characters.
+curl \
+    -H "x-imvu-sauce: xxxxxxxxxxxxxxxxxxxxxxxxxxxx" \
+    -H "Cookie: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" \
+    -H "Content-Type: application/json" \
+    -d '{
+            "cfl": "'"$(cat /Users/yhuang/imvu_code/website1/scripts/test-data/product914462.cfl | base64)"'",
+            "email": "'"${EMAIL}"'",
+            "image_filename": "test100x80.png",
+            "profit": 5,
+            "is_purchasable": true
+        }' \
+    https://api.imvu.com/product > product-create.json
+
+curl \
+   -H "Accept: application/json" \
+   -H "Content-Type: application/json" \
+   -H "x-imvu-sauce: $SAUCE" \
+   -H "Cookie: osCsid=$OSCSID" \
+   -d @body.json \
+   https://api.imvu.com/gift > gift.json
diff --git a/bashrc/qrsync.sh b/bashrc/qrsync.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/qrsync.sh
@@ -0,0 +1,12 @@
+#!/bin/zsh 
+SOURCE=$1
+TARGET=$2
+
+if [ ! -d "${TARGET}" ]
+then   
+    mkdir -p "${TARGET}"
+fi
+
+rsync -aH --delete-after \
+"${SOURCE}" "${TARGET}"
+
diff --git a/bashrc/random_string.sh b/bashrc/random_string.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/random_string.sh
@@ -0,0 +1,4 @@
+#!/bin/zsh
+
+len="$1"
+cat /dev/random | LC_ALL=C tr -dc A-Za-z0-9 | head -c "$len"
diff --git a/bashrc/random_string.test.sh b/bashrc/random_string.test.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/random_string.test.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+  
+./random_string.sh 100
+echo
+./random_string.sh 100100
diff --git a/bashrc/reboot.sh b/bashrc/reboot.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/reboot.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+
+if [ $(uname) = "Darwin" ]
+then
+    sudo fdesetup authrestart -user $(whoami) -inputplist < ~/login.plist
+else
+    reboot
+fi
diff --git a/bashrc/recurse.sh b/bashrc/recurse.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/recurse.sh
@@ -0,0 +1,18 @@
+#!/bin/zsh
+recurse()
+{
+    # since the example runs slowly, the following
+    # if-elif avoid unuseful output; the elif was
+    # added after a first run ended with a segmentation
+    # fault after printing "10000"
+    if [[ $(($1 % 50)) -eq 0 ]]
+    then
+        echo $1;
+    elif [[ $1 -gt 100 ]]
+    then
+        echo $1
+    fi
+    recurse $(($1 + 1))
+}
+
+recurse 0
diff --git a/bashrc/redo.sh b/bashrc/redo.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/redo.sh
@@ -0,0 +1,9 @@
+#!/bin/zsh
+if [ -z "$1" ]
+then
+    echo "Please provide commit message"
+    exit 1
+fi
+pattern=$1
+shift
+history | awk '/'$pattern'/ { print $1 }'
diff --git a/bashrc/remove_path.sh b/bashrc/remove_path.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/remove_path.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+export PATH=$(echo $PATH | tr ":" "\n" | grep -v "anaconda3" | tr "\n" ":")
diff --git a/bashrc/removing_ansi_color_codes.sh b/bashrc/removing_ansi_color_codes.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/removing_ansi_color_codes.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+perl -pe 's/\e\[[0-9;]*m(?:\e\[K)?//g' "$1" > "$1".tmp
+cp -fv "$1".tmp "$1"
diff --git a/bashrc/rename.sh b/bashrc/rename.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/rename.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+
+source="$1"
+target="$2"
+mkdir -p "$(dirname "$target")"
+mv -nv "$source" "$target"
diff --git a/bashrc/replace_spaces_in_file_names.sh b/bashrc/replace_spaces_in_file_names.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/replace_spaces_in_file_names.sh
@@ -0,0 +1,4 @@
+#!/bin/zsh 
+find . -name "* *" -type d -exec rename "s/ /_/g" {} \;    # do the directories first
+find . -name "* *" -type f -exec rename "s/ /_/g" {} \;
+find . -name "* *" -type f -exec rename 's/(.*)\/([^\/]*)/$1\/\L$2/' {} \;
diff --git a/bashrc/retire_parts.sh b/bashrc/retire_parts.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/retire_parts.sh
@@ -0,0 +1,46 @@
+#!/bin/zsh
+
+if ! (/usr/bin/df -TH /dev/mapper/transmission | /usr/bin/grep -q 100% )
+then
+    echo "partition is not full yet"
+    exit 1
+fi
+
+function CountParts()
+{
+    /usr/bin/find /var/lib/transmission-daemon/ -type f -mtime +"$1" -name \*.part | /usr/bin/wc -l
+}
+
+left=1
+right=300
+
+while [ $((left + 1)) -lt $right ]
+do
+    mid=$(printf '%s\n' $left $right | /usr/bin/datamash median 1)
+    mid=${mid%.*}
+    echo "mid --> $mid"
+
+    local result=$(CountParts $mid)
+    result=${result%.*}
+    echo "result --> $result"
+
+    if [ $result -gt 0 ]
+    then
+        left=$mid
+        echo "left --> $left"
+    else
+        right=$mid
+        echo "right --> $right"
+    fi
+done
+
+local result=$(CountParts $right)
+result=${result%.*}
+echo "result --> $result"
+
+if [ $result -gt 0 ]
+then
+    /usr/bin/find /var/lib/transmission-daemon/ -type f -mtime +$right -name \*.part -delete
+else
+    /usr/bin/find /var/lib/transmission-daemon/ -type f -mtime +$left -name \*.part -delete
+fi
diff --git a/bashrc/rmEmpty.sh b/bashrc/rmEmpty.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/rmEmpty.sh
@@ -0,0 +1,11 @@
+#!/bin/zsh
+
+if [ -z "$1" ]
+then
+    TARGETEDIR=.
+else
+    TARGETEDIR="$1"
+fi
+
+find "$TARGETEDIR" -type d -empty -delete
+rmdir "$TARGETEDIR"
diff --git a/bashrc/rsleep.sh b/bashrc/rsleep.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/rsleep.sh
@@ -0,0 +1,9 @@
+#!/bin/zsh
+target=$(echo "$1" | sed  -e "s/\/$//g")
+
+if [ -z "$1" ]
+then
+    ssh server "~/loadrc/bashrc/sleep.sh"
+fi
+
+ssh "$target" "~/loadrc/bashrc/sleep.sh"
diff --git a/bashrc/rssh.sh b/bashrc/rssh.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/rssh.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh 
+ssh "$1" "$2"
diff --git a/bashrc/rsyncFiles.sh b/bashrc/rsyncFiles.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/rsyncFiles.sh
@@ -0,0 +1,13 @@
+#!/bin/zsh
+host=$(git config deploy.host)
+rpath=$(git config deploy.path)
+
+rsync -aHv --force --progress \
+    --files-from rsync.files \
+    . \
+    "$host:$rpath"
+
+rsync -aHv --force --progress \
+    --files-from files.rev \
+    "$host:/" \
+    .
diff --git a/bashrc/rsync_basic_options b/bashrc/rsync_basic_options
new file mode 100644
--- /dev/null
+++ ./bashrc/rsync_basic_options
@@ -0,0 +1,3 @@
+-aHSv
+--progress
+--force
diff --git a/bashrc/rsync_svn.sh b/bashrc/rsync_svn.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/rsync_svn.sh
@@ -0,0 +1,12 @@
+#!/bin/zsh
+SOURCE=$1
+TARGET=$2
+
+if [ ! -d "${TARGET}" ]
+then
+    mkdir -p "${TARGET}"
+fi
+
+rsync -aH --delete-after \
+    --exclude .svn --exclude *.sw* \
+    "${SOURCE}" "${TARGET}"
diff --git a/bashrc/rsynctype.sh b/bashrc/rsynctype.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/rsynctype.sh
@@ -0,0 +1,16 @@
+#!/bin/zsh
+SOURCE=$1
+TARGET=$2
+FILE_TYPE=$HOME/loadrc/bashrc/file_type
+command_params=`cat ${FILE_TYPE}|{ read suf; echo -n "--include=*.$suf";while read suf;do echo -n " --include=*.$suf";done; }`
+
+if [ "$SOURCE" != "$TARGET" ]
+then
+    if [ ! -d "$TARGET" ]
+    then
+        mkdir -p "$TARGET"
+    fi
+    rsync -avH --include=*/  $command_params --exclude=* --prune-empty-dirs "$SOURCE" "$TARGET"
+else
+    echo "please choose the different dir!"
+fi
diff --git a/bashrc/run.sh b/bashrc/run.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/run.sh
@@ -0,0 +1,10 @@
+#!/bin/zsh
+if [ -f "run.sh" ]
+then
+    ./run.sh
+else
+    if [ -f "run" ]
+    then
+        ./run
+    fi
+fi
diff --git a/bashrc/runb.sh b/bashrc/runb.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/runb.sh
@@ -0,0 +1,11 @@
+#!/bin/zsh
+make -B
+if [ -f "run.sh" ] 
+then
+    ./run.sh
+else
+    if [ -f "run" ] 
+    then
+        ./run
+    fi
+fi
diff --git a/bashrc/searchIP.sh b/bashrc/searchIP.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/searchIP.sh
@@ -0,0 +1,22 @@
+#!/bin/zsh
+#===============================================================================
+#
+#          FILE: searchIP.sh
+#
+#         USAGE: ./searchIP.sh
+#
+#   DESCRIPTION:
+#
+#       OPTIONS: ---
+#  REQUIREMENTS: ---
+#          BUGS: ---
+#         NOTES: ---
+#        AUTHOR: YOUR NAME (),
+#  ORGANIZATION:
+#       CREATED: 05/19/2016 17:57
+#      REVISION:  ---
+#===============================================================================
+
+set -o nounset                              # Treat unset variables as an error
+
+xargs grep -onHE -- "([0-9]{1,3}\.){3}[0-9]{1,3}" /dev/null < /export/home1/username/cscope_db/H2HSetup
diff --git a/bashrc/select_copy.sh b/bashrc/select_copy.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/select_copy.sh
@@ -0,0 +1,9 @@
+#!/bin/zsh
+while true
+do
+    cat "$1" | sed 's/^"//g;s/"$//g;s/\\ / /g' > "$1".tmp
+    rsync -aHv --force --progress \
+        --files-from "$1".tmp \
+        "$2" \
+        "$3"
+done
diff --git a/bashrc/select_move.sh b/bashrc/select_move.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/select_move.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+
+cat "$1" | sed 's/^"//g;s/"$//g;s/\\ / /g' > "$1".tmp
+rsync -aHv --force --progress \
+    --remove-source-files \
+    --files-from "$1".tmp \
+    . \
+    "$2"
diff --git a/bashrc/select_random_files.sh b/bashrc/select_random_files.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/select_random_files.sh
@@ -0,0 +1,9 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+ls | sort -R | tail -50 | while read file
+do
+    echo $file
+done
diff --git a/bashrc/selectmirror.sh b/bashrc/selectmirror.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/selectmirror.sh
@@ -0,0 +1,20 @@
+#!/bin/zsh 
+
+if [ "$#" -lt 2 ]
+then
+  echo -e "${red}Please specify enough parameter ... ${NC}"
+  exit 1
+fi
+
+SOURCE="$1"
+TARGET="$2"
+
+ready_file="$SOURCE/tselectmirror.ready"
+
+if [ ! -f ${ready_file} ]
+then
+    echo -e "${red}tmirror must be run before mirror ... ${NC}"
+    exit 1
+fi
+
+rsync -aHv --exclude-from="$SOURCE"/excludeFile --delete-during --force "$SOURCE"/  "$TARGET"/
diff --git a/bashrc/sleep.sh b/bashrc/sleep.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/sleep.sh
@@ -0,0 +1,10 @@
+#!/bin/zsh
+
+if [ $(uname) = "Darwin" ]
+then
+    pmset displaysleepnow
+    #pmset sleepnow
+else
+    # ~/loadrc/gpurc/kill_nvidia.sh
+    pm-suspend
+fi
diff --git a/bashrc/smount.sh b/bashrc/smount.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/smount.sh
@@ -0,0 +1,24 @@
+#!/bin/zsh
+
+if [ -z "$1" ]
+then
+    echo -e "${red}please provide the host name... ${NC}"
+    exit 1
+fi
+
+remoteServer=$(echo "$1" | sed  -e "s/\/$//g")
+mkdir -p ~/"$remoteServer"
+mkdir -p ~/nfs/"$remoteServer"
+
+if [ $(uname) = "Linux" ]
+then
+    sshfs "$remoteServer":/media/ ~/"$remoteServer"
+    df -TH
+else
+    diskutil unmount force ~/nfs/"$remoteServer"
+    diskutil unmount force ~/"$remoteServer"
+    ps ax | awk '/sshfs '$remoteServer'/NR > 1 {print $1}' | xargs kill -9
+    sshfs "$remoteServer":/ ~/"$remoteServer"
+    # sudo mount -o nolocks -o resvport "$remoteServer":/media/ ~/nfs/"$remoteServer" &
+    df -H
+fi
diff --git a/bashrc/split.sh b/bashrc/split.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/split.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+gsplit -l 1 --numeric-suffixes --additional-suffix=.json "$1" "$1"
+find . -type f -name "$1*.json" -exec js-beautify -r {} \; 
diff --git a/bashrc/ssh.sh b/bashrc/ssh.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/ssh.sh
@@ -0,0 +1,8 @@
+#! /bin/zsh
+target=$(echo "$1" | sed  -e "s/\/$//g")
+tmuxAction="$(ssh "$target" ". ~/loadrc/.pathrc ; which tmux") new-session -A -s ssh"
+
+while true
+do
+    ssh -Y "$target" -t -- ${tmuxAction}
+done
diff --git a/bashrc/tcopy.sh b/bashrc/tcopy.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/tcopy.sh
@@ -0,0 +1,12 @@
+#!/bin/zsh
+SOURCE=$1
+TARGET=$2
+
+if [ ! -d "${TARGET}" ]
+then
+    mkdir -p "${TARGET}"
+fi
+
+rsync -aHinv \
+    "${SOURCE}" "${TARGET}"> find.findresult
+nvim find.findresult
diff --git a/bashrc/testPorts.sh b/bashrc/testPorts.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/testPorts.sh
@@ -0,0 +1,15 @@
+#!/bin/zsh
+portList="$HOME/Dropbox/loadrc/bashrc/portList"
+while read -r line || [[ -n "$line" ]]
+do
+    while read port
+    do
+        echo "port listening --> $port"
+        ssh -n "$line" "nohup nc -l $port &" &
+    done < "$portList"
+    while read port
+    do
+        echo "port requesting --> $port"
+        nc -zv "$line" "$port"
+    done < "$portList"
+done < servers.list
diff --git a/bashrc/tmirror.sh b/bashrc/tmirror.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/tmirror.sh
@@ -0,0 +1,17 @@
+#!/bin/zsh
+source=$1
+target=$2
+
+ready_file="$source"/"tmirror.ready"
+
+iconvs=$(~/loadrc/bashrc/get_iconvs.sh "$source" "$target")
+rsyncpath=$(~/loadrc/bashrc/get_rsyncpath.sh "$source" "$target")
+rsync_basic_options=($(< ~/loadrc/bashrc/rsync_basic_options))
+
+rsync \
+    -in \
+    --delete-before \
+    "${rsync_basic_options[@]}" \
+    "$iconvs" \
+    "$rsyncpath" \
+    "$source/" "$target/" > "$ready_file"
diff --git a/bashrc/tmove.sh b/bashrc/tmove.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/tmove.sh
@@ -0,0 +1,31 @@
+#!/bin/zsh
+returnstring=""
+function IsSlash()
+{
+    var=$1
+    case $var in
+        */)
+            returnstring=$var
+            ;;
+        *)
+            returnstring=$var"/"
+            ;;
+    esac
+}
+IsSlash "$1"
+SOURCE=$returnstring
+IsSlash "$2"
+TARGET=$returnstring
+
+if [ "$SOURCE" != "$TARGET" ]
+then
+    if [ ! -d "$TARGET" ]
+    then
+        mkdir -p "$TARGET"
+    fi
+
+    rsync -aHinv \
+        "${SOURCE}" "${TARGET}"> find.cc
+else
+    echo "please choose the different dir!"
+fi
diff --git a/bashrc/tmux.sh b/bashrc/tmux.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/tmux.sh
@@ -0,0 +1,2 @@
+#! /bin/zsh
+tmux attach
diff --git a/bashrc/tosmirror.sh b/bashrc/tosmirror.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/tosmirror.sh
@@ -0,0 +1,24 @@
+#!/bin/zsh
+SOURCE=$1
+TARGET=$2
+
+if [[ "${TARGET}" != *":"* ]] && [[ ! -d "${TARGET}" ]]
+then
+    mkdir -p "${TARGET}"
+fi
+
+if [[ "${SOURCE}" != *":"* ]] && [[ ! -f "$SOURCE/etc/fstab" ]]
+then
+    echo -e "${red}please choose the correct SOURCE os folder... ${NC}"
+    exit 1
+fi
+
+if [[ "${TARGET}" != *":"* ]] && [[ ! -f "$TARGET/etc/fstab" ]]
+then
+    echo -e "${red}please choose the correct TARGET os folder... ${NC}"
+    exit 1
+fi
+
+rsync -aHSvn --progress --delete-during --force \
+    --exclude-from="$HOME"/loadrc/bashrc/osmirror_exclude \
+    "${SOURCE}/" "${TARGET}/" > ~/loadrc/tosmirror.ready
diff --git a/bashrc/trim_lines.sh b/bashrc/trim_lines.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/trim_lines.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+xargs sed -e :a -e '/./,$!d;/^\n*$/{$d;N;};/\n$/ba' < files.proj
diff --git a/bashrc/trsync_svn.sh b/bashrc/trsync_svn.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/trsync_svn.sh
@@ -0,0 +1,12 @@
+#!/bin/zsh
+SOURCE=$1
+TARGET=$2
+
+if [ ! -d "${TARGET}" ]
+then
+    mkdir -p "${TARGET}"
+fi
+
+rsync -aHinv --delete-after \
+    --exclude .svn --exclude *.sw* \
+    "${SOURCE}" "${TARGET}"|vim -
diff --git a/bashrc/tselectmirror.sh b/bashrc/tselectmirror.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/tselectmirror.sh
@@ -0,0 +1,13 @@
+#!/bin/zsh 
+
+if [ "$#" -lt 2 ]
+then
+  echo -e "${red}Please specify enough parameter ... ${NC}"
+  exit 1
+fi
+
+SOURCE="$1"
+TARGET="$2"
+ready_file="$SOURCE/tselectmirror.ready"
+
+rsync -aHvn --exclude-from="$SOURCE"/excludeFile --delete-during --force "$SOURCE"/  "$TARGET"/  > "$ready_file" 
diff --git a/bashrc/tubak.sh b/bashrc/tubak.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/tubak.sh
@@ -0,0 +1,21 @@
+#! /bin/zsh
+TARGET=/media/volgrp/media/`hostname`/
+if [ -n "$1" ]
+then 
+  TARGET="$1"
+fi
+echo $TARGET
+UBAKEX="$HOME/loadrc/bashrc/ubak_ex"
+UBAKIN="$HOME/loadrc/bashrc/ubak_in"
+exclude_params=();
+while read suf
+do
+  exclude_params+=( "--exclude=$suf" )
+done < "$UBAKEX"
+include_params=();
+while read suf
+do
+  include_params+=( "--include=$suf" )
+done < "$UBAKIN"
+rsync -aHinv --force --delete-during "${exclude_params[@]}" "${include_params[@]}" / "${TARGET}" > find.findresult
+nvim find.findresult
diff --git a/bashrc/tures.sh b/bashrc/tures.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/tures.sh
@@ -0,0 +1,23 @@
+#!/bin/zsh
+if [ $(uname) = "Darwin" ]
+then
+    echo -e "${red}It could only run in Linux... ${NC}"
+    exit 1
+fi
+
+if [ -z "$1" ]
+then
+    echo -e "${red}Please provide SOURCE ... ${NC}"
+    exit 1
+fi
+
+if [ -z "$2" ]
+then
+    echo -e "${red}Please provide TARGET ... ${NC}"
+    exit 1
+fi
+
+output=~/loadrc/tures.findresult
+touch "$output"
+rsync -aHSvn --progress --delete-before --force --exclude-from ~/loadrc/bashrc/ures_ex "$1" "$2" 2>&1 | tee "$output"
+nvim "$output"
diff --git a/bashrc/tusync.sh b/bashrc/tusync.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/tusync.sh
@@ -0,0 +1,20 @@
+#! /bin/zsh
+TARGET=exp
+if [ -n "$1" ]
+then 
+  TARGET="$1"
+fi
+echo $TARGET
+UBAKEX="$HOME/loadrc/bashrc/usync_ex"
+UBAKIN="$HOME/loadrc/bashrc/usync_in"
+exclude_params=();
+while read suf
+do
+    exclude_params+=( "--exclude=$suf" )
+done < "$UBAKEX"
+include_params=();
+while read suf
+do
+    include_params+=( "--include=$suf" )
+done < "$UBAKIN"
+rsync -aHinv --force -e ssh "${exclude_params[@]}" "${include_params[@]}" /home/huangyingw/ "${TARGET}":/home/huangyingw/> find.findresult 
diff --git a/bashrc/ubak.sh b/bashrc/ubak.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/ubak.sh
@@ -0,0 +1,25 @@
+#! /bin/zsh
+if [ $(uname) = "Darwin" ]
+then
+    echo -e "${red}It could only run in Linux... ${NC}"
+    exit 1
+fi
+TARGET=/media/volgrp/media/`hostname`/
+if [ -n "$1" ]
+then
+    TARGET="$1"
+fi
+echo $TARGET
+UBAKEX="$HOME/loadrc/bashrc/ubak_ex"
+UBAKIN="$HOME/loadrc/bashrc/ubak_in"
+exclude_params=();
+while read suf
+do
+    exclude_params+=( "--exclude=$suf" )
+done < "$UBAKEX"
+include_params=();
+while read suf
+do
+    include_params+=( "--include=$suf" )
+done < "$UBAKIN"
+rsync -aH --force --delete-during "${exclude_params[@]}" "${include_params[@]}" / "${TARGET}"
diff --git a/bashrc/ubak_ex b/bashrc/ubak_ex
new file mode 100644
--- /dev/null
+++ ./bashrc/ubak_ex
@@ -0,0 +1,4 @@
+/media/
+/proc/
+/run/
+/sys/
diff --git a/bashrc/ubak_in b/bashrc/ubak_in
new file mode 100644
--- /dev/null
+++ ./bashrc/ubak_in
@@ -0,0 +1,7 @@
+/boot/
+/etc/
+/home/
+/lib/
+/root/
+/usr/
+/var/
diff --git a/bashrc/ufind.sh b/bashrc/ufind.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/ufind.sh
@@ -0,0 +1,36 @@
+#!/bin/zsh
+function Find()
+{
+  FILE_POSTFIX=$HOME/loadrc/bashrc/postfix
+  PRUNE_POSTFIX=$HOME/loadrc/bashrc/prunefix
+  PRUNE_FILE=$HOME/loadrc/bashrc/prunefile
+  find_params=();
+  prune_params=();
+  prune_files=();
+  find_result="$2".findresult
+  or="";
+  grep_params="";
+  if [ -n "$3" ]
+  then grep_params=" -A"$3" -B"$3;
+  fi
+  while read suf
+  do
+    find_params+=( $or "-iname" "*.$suf" )
+    or="-o"
+  done < "$FILE_POSTFIX"
+  or="";
+  while read suf
+  do
+    prune_params+=( $or "-iname" "*.$suf" )
+    or="-o"
+  done < "$PRUNE_POSTFIX"
+  while read suf
+  do
+    prune_files+=( $or "-iname" "$suf" )
+    or="-o"
+  done < "$PRUNE_FILE"
+  find "$1" "(" "${prune_params[@]}" "${prune_files[@]}" "-o" "-iname" "$find_result" ")" -prune -o "(" "${find_params[@]}" "-o" "-iname" "makefile" ")" -exec fgrep -inH  $grep_params "$2" {} \; > "$find_result"
+}
+
+ls *.findresult|while read ss; do echo $ss|sed 's/.findresult//g'; done \
+  |while read ss;do Find "." "$ss" && echo "$ss" is done;done
diff --git a/bashrc/umlet.sh b/bashrc/umlet.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/umlet.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+programDir=~/bin/Umlet
+
+if [ $# -eq 1 ]
+ then java -jar ${programDir}/umlet.jar -filename="$1"
+ else java -jar ${programDir}/umlet.jar "$@"
+fi
diff --git a/bashrc/umletc.sh b/bashrc/umletc.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/umletc.sh
@@ -0,0 +1,14 @@
+#!/bin/zsh
+
+if [ -z "$1" ]
+then
+    target=.
+else
+    target="$1"
+fi
+
+find "$target" -type f -name \*.uxf|while read ss
+do
+    output="`echo "$ss"|sed  -e "s/\.uxf$/\.pdf/g"`"
+    umlet -action=convert -format=pdf -filename="$ss" -output="$output"
+done
diff --git a/bashrc/umount.sh b/bashrc/umount.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/umount.sh
@@ -0,0 +1,20 @@
+#!/bin/zsh
+
+if [ -z "$1" ]
+then
+    echo -e "${red}please provide the host name... ${NC}"
+    exit 1
+fi
+
+remoteServer=$(echo "$1" | sed  -e "s/\/$//g")
+
+if [ $(uname) = "Linux" ]
+then
+    umount -l ~/"$remoteServer"
+    ~/loadrc/bashrc/rsleep.sh "$remoteServer" &
+    df -TH
+else
+    diskutil unmountDisk force ~/"$remoteServer"
+    ~/loadrc/bashrc/rsleep.sh "$remoteServer" &
+    df -H
+fi
diff --git a/bashrc/un7z.sh b/bashrc/un7z.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/un7z.sh
@@ -0,0 +1,18 @@
+#!/bin/zsh
+
+if [ -z "$1" ]
+then
+    TARGETEDIR=.
+else
+    TARGETEDIR="$1"
+fi
+
+find "$TARGETEDIR" -type f -iname \*.7z | \
+    while read ss
+    do
+        echo "ss un7z --> $ss"
+        ss="$(realpath "$ss")"
+        cd "$(dirname "$ss")"
+        7z e "$ss" && rm "$ss"
+        cd -
+    done
diff --git a/bashrc/unrar.sh b/bashrc/unrar.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/unrar.sh
@@ -0,0 +1,18 @@
+#!/bin/zsh
+
+if [ -z "$1" ]
+then
+    TARGETEDIR=.
+else
+    TARGETEDIR="$1"
+fi
+
+find "$TARGETEDIR" -type f -iname \*.rar | \
+    while read ss
+    do
+        echo "ss unrar --> $ss"
+        ss="$(realpath "$ss")"
+        cd "$(dirname "$ss")"
+        unrar x -r -p- -o+ "$ss" && rm "$ss"
+        cd -
+    done
diff --git a/bashrc/unzip.sh b/bashrc/unzip.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/unzip.sh
@@ -0,0 +1,16 @@
+#!/bin/zsh
+
+if [ -z "$1" ]
+then
+    TARGETEDIR=.
+else
+    TARGETEDIR="$1"
+fi
+
+find "$TARGETEDIR" -type f -iname \*.zip | \
+    while read ss
+    do
+        echo "ss unzip --> $ss"
+        unzip -n -d "$(echo "$ss"|sed 's/\.zip$//g')" "$ss" && \
+            rm "$ss"
+        done
diff --git a/bashrc/update_proj.sh b/bashrc/update_proj.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/update_proj.sh
@@ -0,0 +1,15 @@
+#!/bin/zsh
+
+if [ ! -f files.proj ]
+then
+    echo -e "${red}No files.proj file here, will not update the proj ... ${NC}"
+    exit 1
+fi
+
+if (~/loadrc/bashrc/check_remote_mounted.sh)
+then
+    echo -e "${red}running on remote mounted file system would be extremely slow ... ${NC}"
+    exit 1
+fi
+
+~/loadrc/bashrc/check_running.sh ~/loadrc/bashrc/do_update_proj.sh
diff --git a/bashrc/ures.sh b/bashrc/ures.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/ures.sh
@@ -0,0 +1,22 @@
+#!/bin/zsh
+if [ $(uname) = "Darwin" ]
+then
+    echo -e "${red}It could only run in Linux... ${NC}"
+    exit 1
+fi
+
+if [ -z "$1" ]
+then
+    echo -e "${red}Please provide SOURCE ... ${NC}"
+    exit 1
+fi
+
+if [ -z "$2" ]
+then
+    echo -e "${red}Please provide TARGET ... ${NC}"
+    exit 1
+fi
+
+output=~/loadrc/tures.findresult
+touch "$output"
+rsync -aHSv --progress --delete-before --force --exclude-from ~/loadrc/bashrc/ures_ex "$1" "$2" 2>&1 | tee "$output"
diff --git a/bashrc/ures_ex b/bashrc/ures_ex
new file mode 100644
--- /dev/null
+++ ./bashrc/ures_ex
@@ -0,0 +1,3 @@
+etc/fstab
+etc/hostname
+etc/hosts
diff --git a/bashrc/ures_in b/bashrc/ures_in
new file mode 100644
diff --git a/bashrc/usync.sh b/bashrc/usync.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/usync.sh
@@ -0,0 +1,21 @@
+#! /bin/zsh
+TARGET=exp
+if [ -n "$1" ]
+then 
+  TARGET="$1"
+fi
+echo $TARGET
+UBAKEX="$HOME/loadrc/bashrc/usync_ex"
+UBAKIN="$HOME/loadrc/bashrc/usync_in"
+exclude_params=();
+while read suf
+do
+    exclude_params+=( "--exclude=$suf" )
+done < "$UBAKEX"
+include_params=();
+while read suf
+do
+    include_params+=( "--include=$suf" )
+done < "$UBAKIN"
+rsync -aH --force -e ssh "${exclude_params[@]}" "${include_params[@]}" /home/huangyingw/ "${TARGET}":/home/huangyingw/
+rsync -aH --force -e ssh "${exclude_params[@]}" "${include_params[@]}" /root/ "${TARGET}":/root/
diff --git a/bashrc/usync_ex b/bashrc/usync_ex
new file mode 100644
diff --git a/bashrc/usync_in b/bashrc/usync_in
new file mode 100644
diff --git a/bashrc/utran.sh b/bashrc/utran.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/utran.sh
@@ -0,0 +1,30 @@
+#!/bin/zsh 
+SOURCE=/media/volgrp/slink/media/`hostname`/ 
+TARGET=/
+if [ -n "$1" ]
+then 
+  SOURCE="$1"
+fi
+if [ -n "$2" ]
+then 
+  TARGET="$2"
+fi
+echo $SOURCE
+echo $TARGET
+UTRANEX="$HOME/loadrc/bashrc/utran_ex"
+UTRANIN="$HOME/loadrc/bashrc/utran_in"
+exclude_params=();
+while read suf
+do
+  exclude_params+=( "--exclude=$suf" )
+done < "$UTRANEX"
+include_params=();
+while read suf
+do
+  include_params+=( "--include=$suf" )
+done < "$UTRANIN"
+rsync -aH --force --delete-during "${exclude_params[@]}" "${SOURCE}" "${TARGET}" \
+  && scp -v "${SOURCE}"boot/vmlinuz-* "${SOURCE}"boot/initrd.img-*   "${TARGET}"boot/ \
+  && update-initramfs -u \
+  && update-grub2 \
+  && reboot
diff --git a/bashrc/utran_ex b/bashrc/utran_ex
new file mode 100644
--- /dev/null
+++ ./bashrc/utran_ex
@@ -0,0 +1,48 @@
+/boot/grub
+/boot/initrd.img-*
+/boot/vmlinuz-*
+/dev/
+/etc/hosts
+/etc/initramfs-tools/conf.d/resume
+/etc/resolv.conf
+/etc/udev/rules.d/70-persistent-net.rules
+/home/huangyingw/.cache/
+/home/huangyingw/.local/share/gnome-shell/
+/home/huangyingw/.local/share/gnome-shell/application_state
+/home/huangyingw/.xsession-errors
+/home/huangyingw/find.cc
+/home/huangyingw/vimrc/.vim/view/
+/media/
+/proc/
+/root/.viminfo
+/root/find.cc
+/run/
+/run/udev/data/
+/sys/
+/tmp/
+/var/backups/
+/var/cache/nscd/
+/var/lib/dhcp/dhclient.leases
+/var/lib/mldonkey/
+/var/lib/pm-utils/
+/var/lib/upower/
+/var/lib/ureadahead/debugfs
+/var/log/
+/var/tmp/
+bashrc
+fstab
+grub.cfg
+hostname
+initrd.img
+initrd.img.old
+interfaces
+mdadm.conf
+mldonkey
+mldonkey-server
+vmlinuz
+vmlinuz.old
+/etc/wicd/manager-settings.conf
+/etc/wicd/wired-settings.conf
+/etc/wicd/wireless-settings.conf
+/var/lib/wicd/dhclient.conf
+/var/lib/wicd/configurations/6466b35fa7c3
diff --git a/bashrc/utran_in b/bashrc/utran_in
new file mode 100644
diff --git a/bashrc/vi.sh b/bashrc/vi.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/vi.sh
@@ -0,0 +1,14 @@
+#!/bin/zsh
+if [ -z "$1" ]
+then
+    projectFile=$(~/loadrc/bashrc/find_up.sh $PWD files.proj)
+
+    if [ -z "$projectFile" ]
+    then
+        nvim ~/all.proj
+    else
+        nvim "$projectFile"
+    fi
+else
+    nvim "$1"
+fi
diff --git a/bashrc/vm2img.sh b/bashrc/vm2img.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/vm2img.sh
@@ -0,0 +1,9 @@
+#!/bin/zsh
+
+input=/var/lib/libvirt/images/u2004.qcow2
+output=$(echo "$input" | sed 's/\.qcow2$/\.img/g;s/\.hds$/\.img/g')
+echo "output --> $output"
+
+#qemu-img convert "$input" -O raw "$output"
+
+(qemu-img convert "$input" -O raw "$output") 2>&1 | dialog --gauge "Running dd command (cloning), please wait..." 10 70 0
diff --git a/bashrc/vm2img.test.sh b/bashrc/vm2img.test.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/vm2img.test.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./vm2img.sh /var/lib/libvirt/images/u2004.qcow2
diff --git a/bashrc/wait_for_pid.sh b/bashrc/wait_for_pid.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/wait_for_pid.sh
@@ -0,0 +1,9 @@
+#!/bin/zsh
+pid="$1"
+
+if [ $(uname) = "Darwin" ]
+then
+    lsof -p "$pid" +r 1 &>/dev/null
+else
+    tail --pid="$pid" -f /dev/null
+fi
diff --git a/bashrc/wait_for_pid.test.sh b/bashrc/wait_for_pid.test.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/wait_for_pid.test.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+~/loadrc/bashrc/check_running.sh ~/loadrc/bashrc/echo.sh
diff --git a/bashrc/watch_copy.sh b/bashrc/watch_copy.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/watch_copy.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+watch ~/loadrc/bashrc/check_running.sh ~/loadrc/bashrc/copy_files.sh
diff --git a/bashrc/watch_fvideos.sh b/bashrc/watch_fvideos.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/watch_fvideos.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+
+/root/loadrc/bashrc/check_running.sh /root/loadrc/bashrc/fvideos.sh /media/ 100
diff --git a/bashrc/while_copy.sh b/bashrc/while_copy.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/while_copy.sh
@@ -0,0 +1,5 @@
+#!/bin/zsh
+while true
+do
+    ~/loadrc/bashrc/copy.sh "$1" "$2"
+done
diff --git a/bashrc/whole_ures_ex b/bashrc/whole_ures_ex
new file mode 100644
--- /dev/null
+++ ./bashrc/whole_ures_ex
@@ -0,0 +1,22 @@
+fstab
+grub.cfg
+initrd.img-*
+vmlinuz-*
+70-persistent-net.rules
+interfaces
+/etc/initramfs-tools/conf.d/resume
+/proc/
+/media/
+/sys/
+myproject
+/dev/
+/tmp/
+/run/udev/data/
+/run/
+/var/log/
+initrd.img
+vmlinuz
+/boot/grub
+/boot
+hostname
+bashrc
diff --git a/bashrc/wol.sh b/bashrc/wol.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/wol.sh
@@ -0,0 +1,59 @@
+#!/bin/zsh
+target=$(echo "$1" | sed  -e "s/\/$//g")
+if [ -z "$1" ]
+then
+    wakeonlan -i 192.168.2.2 10:7b:44:f0:e7:2f #server
+    wakeonlan b0:ea:bc:09:20:c6 #server wifi
+    wakeonlan 10:7b:44:f0:e7:2f #server mother board Ethernet
+    wakeonlan 00:e0:4c:68:03:cd
+    wakeonlan 00:e0:4c:00:07:a8
+    ping server
+elif [ "$target" = "haikou" ]
+then
+    wakeonlan 00:01:c0:12:92:a2 #haikou
+    ping haikou
+elif [ "$target" = "thinkpad" ]
+then
+    wakeonlan 00:21:cc:c0:53:a9 #thinkpad
+    ping thinkpad
+elif [ "$target" = "toshiba" ]
+then
+    wakeonlan b8:70:f4:ce:3d:f3 #toshiba
+    ping toshiba
+elif [ "$target" = "vserver" ]
+then
+    wakeonlan 00:01:c0:15:fa:ed #vserver
+    ping vserver
+elif [ "$target" = "mini" ]
+then
+    wakeonlan 00:01:c0:15:fa:ed #mini
+    ping mini
+elif [ "$target" = "server" ]
+then
+    wakeonlan -i 192.168.2.12 10:7b:44:f0:e7:2f #server
+    wakeonlan b0:ea:bc:09:20:c6 #server wifi
+    ping server
+elif [ "$target" = "movie" ]
+then
+    wakeonlan 50:e5:49:ca:fd:04 #movie
+    wakeonlan 1c:87:2c:b7:a1:ce #movie wifi
+    wakeonlan -i 192.168.1.2 00:0a:cd:1e:e9:be #movie
+    ping movie
+elif [ "$target" = "mini2" ]
+then
+    wakeonlan f4:4e:e3:fd:1c:e5 #mini2 wifi
+    wakeonlan 00:E0:4C:00:07:A8 #mini2 wired
+    ping mini2
+elif [ "$target" = "mba" ]
+then
+    wakeonlan FC:E2:6C:07:12:2E #wifi
+    ping mba
+elif [ "$target" = "mbp" ]
+then
+    wakeonlan AC:BC:32:87:BF:DB #wifi
+    ping mbp
+elif [ "$target" = "tiny" ]
+then
+    wakeonlan e4:5f:01:81:11:55
+    ping tinypilot
+fi
diff --git a/bashrc/zsh.test.sh b/bashrc/zsh.test.sh
new file mode 100755
--- /dev/null
+++ ./bashrc/zsh.test.sh
@@ -0,0 +1,25 @@
+#!/bin/zsh 
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+if [ $(uname) = "Darwin" ]
+then
+    echo "it is macos"
+else
+    echo "it is Linux"
+fi
+
+if [ $(uname) = "Darwin" ]
+then
+    echo "it is macos"
+else
+    echo "it is Linux"
+fi
+
+if [[ $(uname) == "Darwin" ]]
+then
+    echo "it is macos"
+else
+    echo "it is Linux"
+fi
diff --git a/chrome_install.sh b/chrome_install.sh
new file mode 100755
--- /dev/null
+++ ./chrome_install.sh
@@ -0,0 +1,9 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub |  apt-key add -
+sh -c 'echo "deb https://dl.google.com/linux/chrome/deb/ stable main" >> /etc/apt/sources.list.d/google.list'
+apt-get update
+apt-get install -y google-chrome-stable
diff --git a/config/iTerm/com.googlecode.iterm2.plist b/config/iTerm/com.googlecode.iterm2.plist
new file mode 100644
--- /dev/null
+++ ./config/iTerm/com.googlecode.iterm2.plist
@@ -0,0 +1,1659 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>AllowClipboardAccess</key>
+	<true/>
+	<key>AppleAntiAliasingThreshold</key>
+	<integer>1</integer>
+	<key>ApplePressAndHoldEnabled</key>
+	<false/>
+	<key>AppleScrollAnimationEnabled</key>
+	<integer>0</integer>
+	<key>AppleSmoothFixedFontsSizeThreshold</key>
+	<integer>1</integer>
+	<key>AppleWindowTabbingMode</key>
+	<string>manual</string>
+	<key>Default Bookmark Guid</key>
+	<string>F3235381-8B88-41C3-BBD8-5CB4E8502D2D</string>
+	<key>EnableAPIServer</key>
+	<true/>
+	<key>GlobalKeyMap</key>
+	<dict>
+		<key>0x19-0x60000</key>
+		<dict>
+			<key>Action</key>
+			<integer>39</integer>
+			<key>Text</key>
+			<string></string>
+		</dict>
+		<key>0x48-0x120000</key>
+		<dict>
+			<key>Action</key>
+			<integer>33</integer>
+			<key>Text</key>
+			<string></string>
+		</dict>
+		<key>0x4c-0x120000</key>
+		<dict>
+			<key>Action</key>
+			<integer>34</integer>
+			<key>Text</key>
+			<string></string>
+		</dict>
+		<key>0x68-0x100000</key>
+		<dict>
+			<key>Action</key>
+			<integer>2</integer>
+			<key>Text</key>
+			<string></string>
+		</dict>
+		<key>0x6c-0x100000</key>
+		<dict>
+			<key>Action</key>
+			<integer>0</integer>
+			<key>Text</key>
+			<string></string>
+		</dict>
+		<key>0x9-0x40000</key>
+		<dict>
+			<key>Action</key>
+			<integer>32</integer>
+			<key>Text</key>
+			<string></string>
+		</dict>
+		<key>0xf700-0x300000</key>
+		<dict>
+			<key>Action</key>
+			<integer>7</integer>
+			<key>Text</key>
+			<string></string>
+		</dict>
+		<key>0xf701-0x300000</key>
+		<dict>
+			<key>Action</key>
+			<integer>6</integer>
+			<key>Text</key>
+			<string></string>
+		</dict>
+		<key>0xf702-0x300000</key>
+		<dict>
+			<key>Action</key>
+			<integer>3</integer>
+			<key>Text</key>
+			<string></string>
+		</dict>
+		<key>0xf702-0x320000</key>
+		<dict>
+			<key>Action</key>
+			<integer>60</integer>
+			<key>Text</key>
+			<string>move_current_tab_to_next_screen()</string>
+		</dict>
+		<key>0xf703-0x300000</key>
+		<dict>
+			<key>Action</key>
+			<integer>1</integer>
+			<key>Text</key>
+			<string></string>
+		</dict>
+		<key>0xf703-0x320000</key>
+		<dict>
+			<key>Action</key>
+			<integer>60</integer>
+			<key>Text</key>
+			<string>move_current_tab_to_previous_screen()</string>
+		</dict>
+		<key>0xf729-0x100000</key>
+		<dict>
+			<key>Action</key>
+			<integer>5</integer>
+			<key>Text</key>
+			<string></string>
+		</dict>
+		<key>0xf72b-0x100000</key>
+		<dict>
+			<key>Action</key>
+			<integer>4</integer>
+			<key>Text</key>
+			<string></string>
+		</dict>
+		<key>0xf72c-0x100000</key>
+		<dict>
+			<key>Action</key>
+			<integer>9</integer>
+			<key>Text</key>
+			<string></string>
+		</dict>
+		<key>0xf72c-0x20000</key>
+		<dict>
+			<key>Action</key>
+			<integer>9</integer>
+			<key>Text</key>
+			<string></string>
+		</dict>
+		<key>0xf72d-0x100000</key>
+		<dict>
+			<key>Action</key>
+			<integer>8</integer>
+			<key>Text</key>
+			<string></string>
+		</dict>
+		<key>0xf72d-0x20000</key>
+		<dict>
+			<key>Action</key>
+			<integer>8</integer>
+			<key>Text</key>
+			<string></string>
+		</dict>
+	</dict>
+	<key>HapticFeedbackForEsc</key>
+	<false/>
+	<key>HotkeyMigratedFromSingleToMulti</key>
+	<true/>
+	<key>LoadPrefsFromCustomFolder</key>
+	<true/>
+	<key>NSNavLastRootDirectory</key>
+	<string>~/Library/Application Support/iTerm2/Scripts</string>
+	<key>NSNavLastUserSetHideExtensionButtonState</key>
+	<true/>
+	<key>NSNavPanelExpandedSizeForOpenMode</key>
+	<string>{799, 448}</string>
+	<key>NSNavPanelExpandedSizeForSaveMode</key>
+	<string>{712, 448}</string>
+	<key>NSQuotedKeystrokeBinding</key>
+	<string></string>
+	<key>NSRepeatCountBinding</key>
+	<string></string>
+	<key>NSScrollAnimationEnabled</key>
+	<false/>
+	<key>NSScrollViewShouldScrollUnderTitlebar</key>
+	<false/>
+	<key>NSSplitView Subview Frames NSColorPanelSplitView</key>
+	<array>
+		<string>0.000000, 0.000000, 224.000000, 258.000000, NO, NO</string>
+		<string>0.000000, 259.000000, 224.000000, 48.000000, NO, NO</string>
+	</array>
+	<key>NSTableView Columns v2 KeyBingingTable</key>
+	<data>
+	YnBsaXN0MDDUAQIDBAUGBwpYJHZlcnNpb25ZJGFyY2hpdmVyVCR0b3BYJG9iamVjdHMS
+	AAGGoF8QD05TS2V5ZWRBcmNoaXZlctEICVVBcnJheYABrgsMEx4fICEiIyQqNDU2VSRu
+	dWxs0g0ODxJaTlMub2JqZWN0c1YkY2xhc3OiEBGAAoAKgA3TFA0OFRkdV05TLmtleXOj
+	FhcYgAOABIAFoxobHIAGgAeACIAJWklkZW50aWZpZXJVV2lkdGhWSGlkZGVuUTAjQGjA
+	AAAAAAAI0iUmJyhaJGNsYXNzbmFtZVgkY2xhc3Nlc1xOU0RpY3Rpb25hcnmiJylYTlNP
+	YmplY3TTFA0OKy8doxYXGIADgASABaMwMRyAC4AMgAiACVExI0B0oZ2yLQ5W0iUmNzhe
+	TlNNdXRhYmxlQXJyYXmjNzkpV05TQXJyYXkACAARABoAJAApADIANwBJAEwAUgBUAGMA
+	aQBuAHkAgACDAIUAhwCJAJAAmACcAJ4AoACiAKYAqACqAKwArgC5AL8AxgDIANEA0gDX
+	AOIA6wD4APsBBAELAQ8BEQETARUBGQEbAR0BHwEhASMBLAExAUABRAAAAAAAAAIBAAAA
+	AAAAADoAAAAAAAAAAAAAAAAAAAFM
+	</data>
+	<key>NSTableView Sort Ordering v2 KeyBingingTable</key>
+	<data>
+	YnBsaXN0MDDUAQIDBAUGBwpYJHZlcnNpb25ZJGFyY2hpdmVyVCR0b3BYJG9iamVjdHMS
+	AAGGoF8QD05TS2V5ZWRBcmNoaXZlctEICVVBcnJheYABowsMEVUkbnVsbNINDg8QWk5T
+	Lm9iamVjdHNWJGNsYXNzoIAC0hITFBVaJGNsYXNzbmFtZVgkY2xhc3Nlc15OU011dGFi
+	bGVBcnJheaMUFhdXTlNBcnJheVhOU09iamVjdAgRGiQpMjdJTFJUWF5jbnV2eH2IkaCk
+	rAAAAAAAAAEBAAAAAAAAABgAAAAAAAAAAAAAAAAAAAC1
+	</data>
+	<key>NSTableView Supports v2 KeyBingingTable</key>
+	<true/>
+	<key>NSToolbar Configuration com.apple.NSColorPanel</key>
+	<dict>
+		<key>TB Is Shown</key>
+		<integer>1</integer>
+	</dict>
+	<key>NSWindow Frame NSNavPanelAutosaveName</key>
+	<string>1106 903 347 183 0 0 2560 1440 </string>
+	<key>NSWindow Frame SUAutomaticUpdateAlert</key>
+	<string>972 949 616 174 0 0 2560 1440 </string>
+	<key>NSWindow Frame SUStatusFrame</key>
+	<string>1080 983 400 129 0 0 2560 1440 </string>
+	<key>NSWindow Frame SUUpdateAlert</key>
+	<string>970 768 620 392 0 0 2560 1417 </string>
+	<key>NSWindow Frame iTerm Window 0</key>
+	<string>0 943 570 452 0 0 2560 1440 </string>
+	<key>NSWindow Frame iTerm Window 1</key>
+	<string>0 0 2560 1417 0 0 2560 1440 </string>
+	<key>New Bookmarks</key>
+	<array>
+		<dict>
+			<key>ASCII Anti Aliased</key>
+			<true/>
+			<key>Allow Title Setting</key>
+			<false/>
+			<key>Ambiguous Double Width</key>
+			<false/>
+			<key>Ansi 0 Color</key>
+			<dict>
+				<key>Blue Component</key>
+				<real>0.0</real>
+				<key>Green Component</key>
+				<real>0.0</real>
+				<key>Red Component</key>
+				<real>0.0</real>
+			</dict>
+			<key>Ansi 1 Color</key>
+			<dict>
+				<key>Blue Component</key>
+				<real>0.0</real>
+				<key>Green Component</key>
+				<real>0.0</real>
+				<key>Red Component</key>
+				<real>0.73333334922790527</real>
+			</dict>
+			<key>Ansi 10 Color</key>
+			<dict>
+				<key>Blue Component</key>
+				<real>0.3333333432674408</real>
+				<key>Green Component</key>
+				<real>1</real>
+				<key>Red Component</key>
+				<real>0.3333333432674408</real>
+			</dict>
+			<key>Ansi 11 Color</key>
+			<dict>
+				<key>Blue Component</key>
+				<real>0.3333333432674408</real>
+				<key>Green Component</key>
+				<real>1</real>
+				<key>Red Component</key>
+				<real>1</real>
+			</dict>
+			<key>Ansi 12 Color</key>
+			<dict>
+				<key>Blue Component</key>
+				<real>1</real>
+				<key>Green Component</key>
+				<real>0.3333333432674408</real>
+				<key>Red Component</key>
+				<real>0.3333333432674408</real>
+			</dict>
+			<key>Ansi 13 Color</key>
+			<dict>
+				<key>Blue Component</key>
+				<real>1</real>
+				<key>Green Component</key>
+				<real>0.3333333432674408</real>
+				<key>Red Component</key>
+				<real>1</real>
+			</dict>
+			<key>Ansi 14 Color</key>
+			<dict>
+				<key>Blue Component</key>
+				<real>1</real>
+				<key>Green Component</key>
+				<real>1</real>
+				<key>Red Component</key>
+				<real>0.3333333432674408</real>
+			</dict>
+			<key>Ansi 15 Color</key>
+			<dict>
+				<key>Blue Component</key>
+				<real>1</real>
+				<key>Green Component</key>
+				<real>1</real>
+				<key>Red Component</key>
+				<real>1</real>
+			</dict>
+			<key>Ansi 2 Color</key>
+			<dict>
+				<key>Blue Component</key>
+				<real>0.0</real>
+				<key>Green Component</key>
+				<real>0.73333334922790527</real>
+				<key>Red Component</key>
+				<real>0.0</real>
+			</dict>
+			<key>Ansi 3 Color</key>
+			<dict>
+				<key>Blue Component</key>
+				<real>0.0</real>
+				<key>Green Component</key>
+				<real>0.73333334922790527</real>
+				<key>Red Component</key>
+				<real>0.73333334922790527</real>
+			</dict>
+			<key>Ansi 4 Color</key>
+			<dict>
+				<key>Blue Component</key>
+				<real>0.73333334922790527</real>
+				<key>Green Component</key>
+				<real>0.0</real>
+				<key>Red Component</key>
+				<real>0.0</real>
+			</dict>
+			<key>Ansi 5 Color</key>
+			<dict>
+				<key>Blue Component</key>
+				<real>0.73333334922790527</real>
+				<key>Green Component</key>
+				<real>0.0</real>
+				<key>Red Component</key>
+				<real>0.73333334922790527</real>
+			</dict>
+			<key>Ansi 6 Color</key>
+			<dict>
+				<key>Blue Component</key>
+				<real>0.73333334922790527</real>
+				<key>Green Component</key>
+				<real>0.73333334922790527</real>
+				<key>Red Component</key>
+				<real>0.0</real>
+			</dict>
+			<key>Ansi 7 Color</key>
+			<dict>
+				<key>Blue Component</key>
+				<real>0.73333334922790527</real>
+				<key>Green Component</key>
+				<real>0.73333334922790527</real>
+				<key>Red Component</key>
+				<real>0.73333334922790527</real>
+			</dict>
+			<key>Ansi 8 Color</key>
+			<dict>
+				<key>Blue Component</key>
+				<real>0.3333333432674408</real>
+				<key>Green Component</key>
+				<real>0.3333333432674408</real>
+				<key>Red Component</key>
+				<real>0.3333333432674408</real>
+			</dict>
+			<key>Ansi 9 Color</key>
+			<dict>
+				<key>Blue Component</key>
+				<real>0.3333333432674408</real>
+				<key>Green Component</key>
+				<real>0.3333333432674408</real>
+				<key>Red Component</key>
+				<real>1</real>
+			</dict>
+			<key>BM Growl</key>
+			<true/>
+			<key>Background Color</key>
+			<dict>
+				<key>Blue Component</key>
+				<real>0.0</real>
+				<key>Green Component</key>
+				<real>0.0</real>
+				<key>Red Component</key>
+				<real>0.0</real>
+			</dict>
+			<key>Background Image Location</key>
+			<string></string>
+			<key>Blinking Cursor</key>
+			<false/>
+			<key>Blur</key>
+			<false/>
+			<key>Bold Color</key>
+			<dict>
+				<key>Blue Component</key>
+				<real>1</real>
+				<key>Green Component</key>
+				<real>1</real>
+				<key>Red Component</key>
+				<real>1</real>
+			</dict>
+			<key>Character Encoding</key>
+			<integer>4</integer>
+			<key>Close Sessions On End</key>
+			<true/>
+			<key>Columns</key>
+			<integer>80</integer>
+			<key>Command</key>
+			<string></string>
+			<key>Cursor Color</key>
+			<dict>
+				<key>Blue Component</key>
+				<real>0.73333334922790527</real>
+				<key>Green Component</key>
+				<real>0.73333334922790527</real>
+				<key>Red Component</key>
+				<real>0.73333334922790527</real>
+			</dict>
+			<key>Cursor Text Color</key>
+			<dict>
+				<key>Blue Component</key>
+				<real>1</real>
+				<key>Green Component</key>
+				<real>1</real>
+				<key>Red Component</key>
+				<real>1</real>
+			</dict>
+			<key>Custom Command</key>
+			<string>No</string>
+			<key>Custom Directory</key>
+			<string>No</string>
+			<key>Default Bookmark</key>
+			<string>No</string>
+			<key>Description</key>
+			<string>Default</string>
+			<key>Disable Window Resizing</key>
+			<true/>
+			<key>Flashing Bell</key>
+			<false/>
+			<key>Foreground Color</key>
+			<dict>
+				<key>Blue Component</key>
+				<real>0.73333334922790527</real>
+				<key>Green Component</key>
+				<real>0.73333334922790527</real>
+				<key>Red Component</key>
+				<real>0.73333334922790527</real>
+			</dict>
+			<key>Guid</key>
+			<string>F3235381-8B88-41C3-BBD8-5CB4E8502D2D</string>
+			<key>Horizontal Spacing</key>
+			<real>1</real>
+			<key>Idle Code</key>
+			<integer>0</integer>
+			<key>Jobs to Ignore</key>
+			<array>
+				<string>rlogin</string>
+				<string>ssh</string>
+				<string>slogin</string>
+				<string>telnet</string>
+			</array>
+			<key>Keyboard Map</key>
+			<dict>
+				<key>0x2d-0x40000</key>
+				<dict>
+					<key>Action</key>
+					<integer>11</integer>
+					<key>Text</key>
+					<string>0x1f</string>
+				</dict>
+				<key>0x32-0x40000</key>
+				<dict>
+					<key>Action</key>
+					<integer>11</integer>
+					<key>Text</key>
+					<string>0x00</string>
+				</dict>
+				<key>0x33-0x40000</key>
+				<dict>
+					<key>Action</key>
+					<integer>11</integer>
+					<key>Text</key>
+					<string>0x1b</string>
+				</dict>
+				<key>0x34-0x40000</key>
+				<dict>
+					<key>Action</key>
+					<integer>11</integer>
+					<key>Text</key>
+					<string>0x1c</string>
+				</dict>
+				<key>0x35-0x40000</key>
+				<dict>
+					<key>Action</key>
+					<integer>11</integer>
+					<key>Text</key>
+					<string>0x1d</string>
+				</dict>
+				<key>0x36-0x40000</key>
+				<dict>
+					<key>Action</key>
+					<integer>11</integer>
+					<key>Text</key>
+					<string>0x1e</string>
+				</dict>
+				<key>0x37-0x40000</key>
+				<dict>
+					<key>Action</key>
+					<integer>11</integer>
+					<key>Text</key>
+					<string>0x1f</string>
+				</dict>
+				<key>0x38-0x40000</key>
+				<dict>
+					<key>Action</key>
+					<integer>11</integer>
+					<key>Text</key>
+					<string>0x7f</string>
+				</dict>
+				<key>0xf700-0x220000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[1;2A</string>
+				</dict>
+				<key>0xf700-0x240000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[1;5A</string>
+				</dict>
+				<key>0xf700-0x260000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[1;6A</string>
+				</dict>
+				<key>0xf700-0x280000</key>
+				<dict>
+					<key>Action</key>
+					<integer>11</integer>
+					<key>Text</key>
+					<string>0x1b 0x1b 0x5b 0x41</string>
+				</dict>
+				<key>0xf701-0x220000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[1;2B</string>
+				</dict>
+				<key>0xf701-0x240000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[1;5B</string>
+				</dict>
+				<key>0xf701-0x260000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[1;6B</string>
+				</dict>
+				<key>0xf701-0x280000</key>
+				<dict>
+					<key>Action</key>
+					<integer>11</integer>
+					<key>Text</key>
+					<string>0x1b 0x1b 0x5b 0x42</string>
+				</dict>
+				<key>0xf702-0x220000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[1;2D</string>
+				</dict>
+				<key>0xf702-0x240000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[1;5D</string>
+				</dict>
+				<key>0xf702-0x260000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[1;6D</string>
+				</dict>
+				<key>0xf702-0x280000</key>
+				<dict>
+					<key>Action</key>
+					<integer>11</integer>
+					<key>Text</key>
+					<string>0x1b 0x1b 0x5b 0x44</string>
+				</dict>
+				<key>0xf703-0x220000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[1;2C</string>
+				</dict>
+				<key>0xf703-0x240000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[1;5C</string>
+				</dict>
+				<key>0xf703-0x260000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[1;6C</string>
+				</dict>
+				<key>0xf703-0x280000</key>
+				<dict>
+					<key>Action</key>
+					<integer>11</integer>
+					<key>Text</key>
+					<string>0x1b 0x1b 0x5b 0x43</string>
+				</dict>
+				<key>0xf704-0x20000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[1;2P</string>
+				</dict>
+				<key>0xf705-0x20000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[1;2Q</string>
+				</dict>
+				<key>0xf706-0x20000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[1;2R</string>
+				</dict>
+				<key>0xf707-0x20000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[1;2S</string>
+				</dict>
+				<key>0xf708-0x20000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[15;2~</string>
+				</dict>
+				<key>0xf709-0x20000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[17;2~</string>
+				</dict>
+				<key>0xf70a-0x20000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[18;2~</string>
+				</dict>
+				<key>0xf70b-0x20000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[19;2~</string>
+				</dict>
+				<key>0xf70c-0x20000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[20;2~</string>
+				</dict>
+				<key>0xf70d-0x20000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[21;2~</string>
+				</dict>
+				<key>0xf70e-0x20000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[23;2~</string>
+				</dict>
+				<key>0xf70f-0x20000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[24;2~</string>
+				</dict>
+				<key>0xf729-0x20000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[1;2H</string>
+				</dict>
+				<key>0xf729-0x40000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[1;5H</string>
+				</dict>
+				<key>0xf72b-0x20000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[1;2F</string>
+				</dict>
+				<key>0xf72b-0x40000</key>
+				<dict>
+					<key>Action</key>
+					<integer>10</integer>
+					<key>Text</key>
+					<string>[1;5F</string>
+				</dict>
+			</dict>
+			<key>Mouse Reporting</key>
+			<true/>
+			<key>Name</key>
+			<string>Default</string>
+			<key>Non Ascii Font</key>
+			<string>Monaco 12</string>
+			<key>Non-ASCII Anti Aliased</key>
+			<true/>
+			<key>Normal Font</key>
+			<string>Monaco 12</string>
+			<key>Option Key Sends</key>
+			<integer>0</integer>
+			<key>Prompt Before Closing 2</key>
+			<false/>
+			<key>Right Option Key Sends</key>
+			<integer>0</integer>
+			<key>Rows</key>
+			<integer>25</integer>
+			<key>Screen</key>
+			<integer>-1</integer>
+			<key>Scrollback Lines</key>
+			<integer>1000</integer>
+			<key>Selected Text Color</key>
+			<dict>
+				<key>Blue Component</key>
+				<real>0.0</real>
+				<key>Green Component</key>
+				<real>0.0</real>
+				<key>Red Component</key>
+				<real>0.0</real>
+			</dict>
+			<key>Selection Color</key>
+			<dict>
+				<key>Blue Component</key>
+				<real>1</real>
+				<key>Green Component</key>
+				<real>0.8353000283241272</real>
+				<key>Red Component</key>
+				<real>0.70980000495910645</real>
+			</dict>
+			<key>Send Code When Idle</key>
+			<false/>
+			<key>Shortcut</key>
+			<string></string>
+			<key>Silence Bell</key>
+			<false/>
+			<key>Sync Title</key>
+			<false/>
+			<key>Tags</key>
+			<array/>
+			<key>Terminal Type</key>
+			<string>xterm-256color</string>
+			<key>Title Components</key>
+			<integer>1</integer>
+			<key>Transparency</key>
+			<real>0.0</real>
+			<key>Unlimited Scrollback</key>
+			<false/>
+			<key>Use Bold Font</key>
+			<true/>
+			<key>Use Bright Bold</key>
+			<true/>
+			<key>Use Italic Font</key>
+			<true/>
+			<key>Use Non-ASCII Font</key>
+			<false/>
+			<key>Vertical Spacing</key>
+			<real>1</real>
+			<key>Visual Bell</key>
+			<true/>
+			<key>Window Type</key>
+			<integer>0</integer>
+			<key>Working Directory</key>
+			<string>/Users/admin</string>
+		</dict>
+	</array>
+	<key>NoSyncAllAppVersions</key>
+	<array>
+		<string>3.3.9</string>
+		<string>3.3.8</string>
+		<string>3.3.11</string>
+		<string>3.3.7</string>
+		<string>3.3.12</string>
+		<string>3.3.6</string>
+	</array>
+	<key>NoSyncFrame_SessionsPreferences</key>
+	<dict>
+		<key>screenFrame</key>
+		<string>{{0, 0}, {2560, 1440}}</string>
+		<key>topLeft</key>
+		<string>{977, 1209}</string>
+	</dict>
+	<key>NoSyncFrame_SharedPreferences</key>
+	<dict>
+		<key>screenFrame</key>
+		<string>{{0, 0}, {2560, 1440}}</string>
+		<key>topLeft</key>
+		<string>{958, 1132}</string>
+	</dict>
+	<key>NoSyncInstallationId</key>
+	<string>FCC96D74-BD16-4553-9DA6-8F85F68727FE</string>
+	<key>NoSyncLaunchExperienceControllerRunCount</key>
+	<integer>37</integer>
+	<key>NoSyncNeverAskAboutSettingAlternateMouseScroll</key>
+	<true/>
+	<key>NoSyncNeverRemindPrefsChangesLostForFile</key>
+	<true/>
+	<key>NoSyncNeverRemindPrefsChangesLostForFile_selection</key>
+	<integer>0</integer>
+	<key>NoSyncNextAnnoyanceTime</key>
+	<real>596003715.66972005</real>
+	<key>NoSyncOnboardingWindowHasBeenShown</key>
+	<true/>
+	<key>NoSyncPermissionToShowTip</key>
+	<false/>
+	<key>NoSyncPersistentRateLimitedUpdates</key>
+	<dict>
+		<key>CheckForUpdatedPythonRuntime</key>
+		<real>595801361.42414904</real>
+	</dict>
+	<key>NoSyncRecordedVariables</key>
+	<dict>
+		<key>0</key>
+		<array>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string></string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+		</array>
+		<key>1</key>
+		<array>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>presentationName</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>tmuxRole</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>lastCommand</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>profileName</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>termid</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>id</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>jobName</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>columns</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>tab.tmuxWindowTitle</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>hostname</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>tmuxClientName</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>path</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>triggerName</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>terminalIconName</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>tmuxWindowPane</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>tmuxStatusRight</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>mouseReportingMode</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<false/>
+				<key>name</key>
+				<string>iterm2</string>
+				<key>nonterminalContext</key>
+				<integer>4</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>name</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>tmuxPaneTitle</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>rows</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>username</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>tty</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>autoLogId</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>badge</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>tab.tmuxWindowName</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<false/>
+				<key>name</key>
+				<string>tab</string>
+				<key>nonterminalContext</key>
+				<integer>2</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>tmuxStatusLeft</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>autoNameFormat</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>autoName</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>terminalWindowName</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>creationTimeString</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>commandLine</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>jobPid</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>pid</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+		</array>
+		<key>16</key>
+		<array>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentTab.currentSession.presentationName</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentTab.iterm2.localhostName</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>style</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>frame</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentTab.currentSession.pid</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentTab.currentSession.termid</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentTab.currentSession.terminalWindowName</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentTab.currentSession.terminalIconName</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<false/>
+				<key>name</key>
+				<string>currentTab</string>
+				<key>nonterminalContext</key>
+				<integer>2</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentTab.currentSession</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentTab.window</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>id</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentTab.currentSession.name</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>titleOverride</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>number</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentTab.currentSession.path</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentTab.currentSession.commandLine</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentTab.currentSession.hostname</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentTab.currentSession.tty</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentTab.currentSession.username</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<false/>
+				<key>name</key>
+				<string>iterm2</string>
+				<key>nonterminalContext</key>
+				<integer>4</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>titleOverrideFormat</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentTab.currentSession.jobName</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+		</array>
+		<key>2</key>
+		<array>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentSession.terminalWindowName</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentSession.commandLine</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<false/>
+				<key>name</key>
+				<string>title</string>
+				<key>nonterminalContext</key>
+				<integer>1</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>title</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>tmuxWindowTitle</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentSession.terminalIconName</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentSession.presentationName</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>iterm2.localhostName</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentSession.jobPid</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>tmuxWindowName</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<false/>
+				<key>name</key>
+				<string>window</string>
+				<key>nonterminalContext</key>
+				<integer>16</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentSession.tty</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentSession.jobName</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentSession.name</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>window</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>id</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>titleOverride</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentSession.username</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentSession.termid</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<false/>
+				<key>name</key>
+				<string>iterm2</string>
+				<key>nonterminalContext</key>
+				<integer>4</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>titleOverrideFormat</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentSession.hostname</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentSession.path</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentSession.pid</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>tmuxWindow</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>currentSession</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<false/>
+				<key>name</key>
+				<string>currentSession</string>
+				<key>nonterminalContext</key>
+				<integer>1</integer>
+			</dict>
+		</array>
+		<key>4</key>
+		<array>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>pid</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>localhostName</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+			<dict>
+				<key>isTerminal</key>
+				<true/>
+				<key>name</key>
+				<string>effectiveTheme</string>
+				<key>nonterminalContext</key>
+				<integer>0</integer>
+			</dict>
+		</array>
+	</dict>
+	<key>NoSyncTipOfTheDayEligibilityBeganTime</key>
+	<real>595620815.40603602</real>
+	<key>PMPrintingExpandedStateForPrint2</key>
+	<false/>
+	<key>PointerActions</key>
+	<dict>
+		<key>Button,1,1,,</key>
+		<dict>
+			<key>Action</key>
+			<string>kContextMenuPointerAction</string>
+		</dict>
+		<key>Button,2,1,,</key>
+		<dict>
+			<key>Action</key>
+			<string>kPasteFromClipboardPointerAction</string>
+		</dict>
+		<key>Gesture,ThreeFingerSwipeDown,,</key>
+		<dict>
+			<key>Action</key>
+			<string>kPrevWindowPointerAction</string>
+		</dict>
+		<key>Gesture,ThreeFingerSwipeLeft,,</key>
+		<dict>
+			<key>Action</key>
+			<string>kPrevTabPointerAction</string>
+		</dict>
+		<key>Gesture,ThreeFingerSwipeRight,,</key>
+		<dict>
+			<key>Action</key>
+			<string>kNextTabPointerAction</string>
+		</dict>
+		<key>Gesture,ThreeFingerSwipeUp,,</key>
+		<dict>
+			<key>Action</key>
+			<string>kNextWindowPointerAction</string>
+		</dict>
+	</dict>
+	<key>PrefsCustomFolder</key>
+	<string>/Users/huangyingw/Dropbox/config/iTerm</string>
+	<key>Print In Black And White</key>
+	<true/>
+	<key>SUAutomaticallyUpdate</key>
+	<true/>
+	<key>SUEnableAutomaticChecks</key>
+	<true/>
+	<key>SUFeedAlternateAppNameKey</key>
+	<string>iTerm</string>
+	<key>SUFeedURL</key>
+	<string>https://iterm2.com/appcasts/final_new.xml?shard=29</string>
+	<key>SUHasLaunchedBefore</key>
+	<true/>
+	<key>SULastCheckTime</key>
+	<date>2020-07-23T04:37:19Z</date>
+	<key>SUSendProfileInfo</key>
+	<false/>
+	<key>SUUpdateGroupIdentifier</key>
+	<integer>1904053161</integer>
+	<key>SUUpdateRelaunchingMarker</key>
+	<false/>
+	<key>ShowFullScreenTabBar</key>
+	<true/>
+	<key>SoundForEsc</key>
+	<false/>
+	<key>VisualIndicatorForEsc</key>
+	<false/>
+	<key>findMode_iTerm</key>
+	<integer>0</integer>
+	<key>iTerm Version</key>
+	<string>3.3.12</string>
+</dict>
+</plist>
diff --git a/configure_gitk.sh b/configure_gitk.sh
new file mode 100755
--- /dev/null
+++ ./configure_gitk.sh
@@ -0,0 +1,4 @@
+#!/bin/zsh
+
+GITK=$(realpath $(which gitk))
+sed -i.bak 's/set ignorespace 0/set ignorespace 1/g' "$GITK"
diff --git a/crontabrc/.imacpro.cron b/crontabrc/.imacpro.cron
new file mode 100644
diff --git a/crontabrc/.mbp.cron b/crontabrc/.mbp.cron
new file mode 100644
--- /dev/null
+++ ./crontabrc/.mbp.cron
@@ -0,0 +1 @@
+*/10 * * * * /root/loadrc/dropboxrc/dropbox_start.sh
diff --git a/crontabrc/.mbp2.cron b/crontabrc/.mbp2.cron
new file mode 100644
--- /dev/null
+++ ./crontabrc/.mbp2.cron
@@ -0,0 +1 @@
+*/10 * * * * /Users/huangyingw/loadrc/bashrc/ports_forward.sh > /Users/huangyingw/loadrc/ports_forward.log 2>&1
diff --git a/crontabrc/.mini.cron b/crontabrc/.mini.cron
new file mode 100644
--- /dev/null
+++ ./crontabrc/.mini.cron
@@ -0,0 +1,3 @@
+*/10 * * * * /usr/bin/expressvpn connect smart
+* * * * * /root/loadrc/bashrc/retire_parts.sh >> /root/loadrc/retire_parts.log 2>&1
+*/10 * * * * /root/loadrc/dropboxrc/dropbox_start.sh
diff --git a/crontabrc/.mldonkey.cron b/crontabrc/.mldonkey.cron
new file mode 100644
--- /dev/null
+++ ./crontabrc/.mldonkey.cron
@@ -0,0 +1,2 @@
+0 * * * * /usr/bin/expressvpn connect smart
+*/1 * * * * /root/loadrc/crontabrc/mldonkey_start.sh
diff --git a/crontabrc/.server.cron b/crontabrc/.server.cron
new file mode 100644
--- /dev/null
+++ ./crontabrc/.server.cron
@@ -0,0 +1 @@
+* * * * * /root/loadrc/bashrc/watch_fvideos.sh >> /root/loadrc/watch_fvideos.log 2>&1
diff --git a/crontabrc/.studio.cron b/crontabrc/.studio.cron
new file mode 100644
--- /dev/null
+++ ./crontabrc/.studio.cron
@@ -0,0 +1 @@
+*/5 * * * * /Users/huangyingw/loadrc/bashrc/ports_forward.sh > /Users/huangyingw/loadrc/ports_forward.log 2>&1
diff --git a/crontabrc/.vserver.cron b/crontabrc/.vserver.cron
new file mode 100644
--- /dev/null
+++ ./crontabrc/.vserver.cron
@@ -0,0 +1,2 @@
+30 23,0-9 * * * /root/loadrc/crontabrc/mldonkey_start.sh
+0 10-23 * * * /root/loadrc/crontabrc/mldonkey_stop.sh
diff --git a/crontabrc/install.sh b/crontabrc/install.sh
new file mode 100755
--- /dev/null
+++ ./crontabrc/install.sh
@@ -0,0 +1,29 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+cat ~/loadrc/crontabrc/silent.cron > crontab_file
+cat ~/loadrc/crontabrc/ssh.cron >> crontab_file
+CRONRC=$HOME/loadrc/crontabrc/."`hostname`".cron
+
+if [ -f "$CRONRC" ]
+then
+    cat "$CRONRC" >> crontab_file
+fi
+
+echo2crontab() {
+    RESTARTFILE="$1"
+    if [ -f "$RESTARTFILE" ]
+    then
+        echo "*/10 * * * * $RESTARTFILE" >> crontab_file
+    fi
+}
+
+while read -r line || [ -n "$line" ]
+do
+    echo2crontab "$line"
+done < restartfiles
+
+sort -u crontab_file -o crontab_file
+crontab crontab_file
diff --git a/crontabrc/mldonkey_start.sh b/crontabrc/mldonkey_start.sh
new file mode 100755
--- /dev/null
+++ ./crontabrc/mldonkey_start.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+/etc/init.d/mldonkey-server start
diff --git a/crontabrc/mldonkey_stop.sh b/crontabrc/mldonkey_stop.sh
new file mode 100755
--- /dev/null
+++ ./crontabrc/mldonkey_stop.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+/etc/init.d/mldonkey-server stop
diff --git a/crontabrc/restartfiles b/crontabrc/restartfiles
new file mode 100644
--- /dev/null
+++ ./crontabrc/restartfiles
@@ -0,0 +1,3 @@
+/Users/huangyingw/loadrc/zerotierrc/restart.sh
+/Users/yhuang/loadrc/zerotierrc/restart.sh
+/root/loadrc/zerotierrc/restart.sh
diff --git a/crontabrc/set_brightness.sh b/crontabrc/set_brightness.sh
new file mode 100755
--- /dev/null
+++ ./crontabrc/set_brightness.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+
+/usr/local/bin/brightness -m 0.082765
diff --git a/crontabrc/silent.cron b/crontabrc/silent.cron
new file mode 100644
--- /dev/null
+++ ./crontabrc/silent.cron
@@ -0,0 +1,2 @@
+0 23,0-8 * * * /Users/huangyingw/loadrc/crontabrc/silent.sh
+0 23,0-8 * * * /Users/ying.huang/loadrc/crontabrc/silent.sh
diff --git a/crontabrc/silent.sh b/crontabrc/silent.sh
new file mode 100755
--- /dev/null
+++ ./crontabrc/silent.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+
+sudo /usr/bin/osascript -e "set Volume 0"
diff --git a/crontabrc/ssh.cron b/crontabrc/ssh.cron
new file mode 100644
--- /dev/null
+++ ./crontabrc/ssh.cron
@@ -0,0 +1,2 @@
+*/10 * * * * /Users/huangyingw/loadrc/macosrc/restart_ssh.sh
+*/10 * * * * /Users/ying.huang/loadrc/macosrc/restart_ssh.sh
diff --git a/crontabrc/zerotier.cron b/crontabrc/zerotier.cron
new file mode 100644
--- /dev/null
+++ ./crontabrc/zerotier.cron
@@ -0,0 +1,2 @@
+*/10 * * * * /root/loadrc/zerotierrc/restart.sh
+*/10 * * * * /Users/huangyingw/loadrc/zerotierrc/restart.sh
diff --git a/cscope b/cscope
new file mode 160000
--- /dev/null
+++ ./cscope
@@ -0,0 +1 @@
+Subproject commit 0a3848832a97406727cdf7c85ac0c78837c634c9-dirty
diff --git a/demo b/demo
new file mode 100644
--- /dev/null
+++ ./demo
@@ -0,0 +1,54 @@
+search
+    cscope
+"./bashrc/do_update_proj.sh"
+
+filter
+SearchAgain
+fugitive
+smart add
+how to maintain mini:/etc, auto add to git only after edit/change a file
+    vimrc/.vimrc:167 function AddToGit()
+
+universal clipboard
+
+neovim docker
+play video
+
+git
+    gdio gdif gdi gdi2
+    edit diff file directly, and reapply
+
+"./bashrc/update_proj.sh"
+
+leetcode-cli
+    commit, code analysis, especially the failed one.
+    search across for while loop
+    search for one question
+
+code change
+    neovim
+    fugitive
+    cscope
+    vim-anyfold
+    "./vimrc/.vim/plugin/keymap.vim"
+    "./vimrc/.vim/plugin/auto_cscope.vim"
+    "./vimrc/.vim/plugin/auto_deploy.vim"
+    iterm2 move display feature
+        https://gitlab.com/gnachman/iterm2/-/issues/7438
+        https://gitlab.com/gnachman/iterm2/-/issues/7354
+    leetcode-cli
+        add new features
+    share clip board
+        from mosh.sh
+
+training AI from vim:
+    vim demo from Photo
+    this involved some fastai source code change to add cache, so the next time, the same training would not re-run again, to save my money
+
+kubernetes:
+@mini:"/media/volgrp/myproject/git/Kubernetes/kubernetes-setup/files.proj"
+@mini:"/media/volgrp/myproject/git/AI/setup/files.proj"
+@mini:"/media/volgrp/myproject/git/Kubernetes/bitnami/charts/files.proj"
+
+docker:
+~/loadrc/docker-compose.yml
diff --git a/deploy_configurations.sh b/deploy_configurations.sh
new file mode 100755
--- /dev/null
+++ ./deploy_configurations.sh
@@ -0,0 +1,40 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+cp -nv ~/.bashrc ~/.bashrc.bak
+cp -nv ~/.profile ~/.profile.bak
+cp -nv ~/.zshrc ~/.zshrc.bak
+
+if [ $(uname) = "Darwin" ]
+then
+    ~/loadrc/bashrc/ln_fs.sh ~/loadrc/macos/.bashrc ~/.bashrc
+else
+    ~/loadrc/bashrc/ln_fs.sh ~/loadrc/.bashrc ~/.bashrc
+fi
+
+~/loadrc/bashrc/ln_fs.sh ~/loadrc/.zshrc ~/.zshrc
+~/loadrc/bashrc/ln_fs.sh ~/loadrc/.profile ~/.profile
+~/loadrc/bashrc/ln_fs.sh ~/loadrc/oh-my-zsh ~/.oh-my-zsh
+
+# mv -fv ~/.config/git/gitk ~/.config/git/gitk.bak
+~/loadrc/bashrc/ln_fs.sh ~/loadrc/."`hostname`".theanorc  ~/.theanorc
+# ~/loadrc/bashrc/ln_fs.sh ~/loadrc/.config/git/gitk  ~/.config/git/gitk
+# sed -i.bak "s/set ignorespace 0/set ignorespace 1/g" $(which gitk)
+~/loadrc/bashrc/ln_fs.sh ~/loadrc/.ssh ~/.ssh
+~/loadrc/bashrc/ln_fs.sh ~/loadrc/.tmux.conf ~/.tmux.conf
+~/loadrc/bashrc/ln_fs.sh ~/loadrc/gitrc/.gitconfig ~/.gitconfig
+~/loadrc/bashrc/ln_fs.sh ~/loadrc/gitrc/.globalgitignore ~/.globalgitignore
+~/loadrc/bashrc/ln_fs.sh ~/loadrc/pythonrc/setup.cfg  ~/setup.cfg
+~/loadrc/bashrc/ln_fs.sh ~/loadrc/.hgrc ~/.hgrc
+~/loadrc/bashrc/ln_fs.sh ~/loadrc/.hgignore ~/.hgignore
+# ~/loadrc/bashrc/ln_fs.sh ~/loadrc/Library/Preferences/org.videolan.vlc/vlcrc ~/Library/Preferences/org.videolan.vlc/vlcrc
+~/loadrc/bashrc/ln_fs.sh ~/loadrc/iterm2rc/movescreen.py ~/Library/ApplicationSupport/iTerm2/Scripts/movescreen/movescreen/movescreen.py
+# ~/loadrc/bashrc/ln_fs.sh ~/loadrc/.kdiff3rc ~/.kdiff3rc
+~/loadrc/bashrc/ln_fs.sh ~/loadrc/.tigrc ~/.tigrc
+
+./set_linux_configuration.sh
+./set_macos_configuration.sh
+./set_host_configuration.sh
+./neovim/post.sh
diff --git a/dhcprc/all.sh b/dhcprc/all.sh
new file mode 100755
--- /dev/null
+++ ./dhcprc/all.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh 
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./install.sh
+./config.sh
+./restart.sh
diff --git a/dhcprc/config.sh b/dhcprc/config.sh
new file mode 100755
--- /dev/null
+++ ./dhcprc/config.sh
@@ -0,0 +1,15 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+cp -fv ~/loadrc/host_links/`hostname`/etc/default/isc-dhcp-server /etc/default/isc-dhcp-server
+cp -fv ~/loadrc/host_links/`hostname`/etc/dhcp/dhcpd.conf /etc/dhcp/dhcpd.conf
+
+systemctl start isc-dhcp-server
+systemctl enable isc-dhcp-server
+service isc-dhcp-server restart
+
+ufw allow  67/udp
+#ufw reload
+#ufw show
diff --git a/dhcprc/install.sh b/dhcprc/install.sh
new file mode 100755
--- /dev/null
+++ ./dhcprc/install.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+apt-get -y install isc-dhcp-server
diff --git a/dhcprc/restart.sh b/dhcprc/restart.sh
new file mode 100755
--- /dev/null
+++ ./dhcprc/restart.sh
@@ -0,0 +1,4 @@
+#!/bin/zsh 
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
diff --git a/do_install_cubbit.sh b/do_install_cubbit.sh
new file mode 100755
--- /dev/null
+++ ./do_install_cubbit.sh
@@ -0,0 +1,105 @@
+#!/bin/bash
+
+set -e
+
+function clog
+{
+    echo "${BLUE}${UNDERLINE}$1${RESET}"
+}
+
+function cerror
+{
+    echo "${RED}${UNDERLINE}$1${RESET}"
+}
+
+function titlize
+{
+    echo "${YELLOW}$1${RESET}"
+}
+
+######## COLORS ########
+YELLOW=`tput setaf 3`
+BLUE=`tput setaf 4`
+RED=`tput setaf 1`
+UNDERLINE=`tput smul`
+RESET=`tput sgr0`
+######## END COLORS ########
+
+base_url="https://get.cubbit.io/desktop/linux"
+default_file_manager=`xdg-mime query default inode/directory | tr '[:upper:]' '[:lower:]'`
+
+clog "[3.1] Detecting default file manager"
+if [[ $default_file_manager = *"nemo"* ]]; then
+    file_manager="nemo"
+elif [[ $default_file_manager = *"nautilus"* ]]; then
+    file_manager="nautilus"
+elif [[ $default_file_manager = *"caja"* ]]; then
+    file_manager="caja"
+else
+    cerror "File manager not supported"
+    file_manager="skip"
+fi
+
+if [[ $file_manager != "skip" ]]; then
+
+    clog "[3.2] File manager detected: $file_manager. Downloading and installing dependencies"
+
+    sudo apt-get update -y &>/dev/null
+    sudo apt-get install -y libappindicator1 &>/dev/null
+
+    if [ $(apt-cache search python3-$file_manager | wc -l) -ne 0 ]; then
+        sudo apt-get install -y python3-$file_manager &>/dev/null
+    else
+        sudo apt-get install -y python-$file_manager &>/dev/null
+    fi
+
+    tmp_dir=$(mktemp -d -t cubbit-XXXXXX)
+    wget "$base_url/deps.tar.gz" -O "$tmp_dir/deps.tar.gz" &>/dev/null
+    tar xf "$tmp_dir/deps.tar.gz" -C "$tmp_dir"
+
+    capitalized_file_manager="$(tr '[:lower:]' '[:upper:]' <<< ${file_manager:0:1})${file_manager:1}"
+    assets_dir="$tmp_dir/deps/assets"
+
+    clog "[3.3] Copying extension icons"
+    for icon_size in `ls $assets_dir`; do
+        sudo cp $assets_dir/$icon_size/* /usr/share/icons/hicolor/$icon_size/emblems/
+    done
+    sudo gtk-update-icon-cache /usr/share/icons/hicolor/ &>/dev/null
+
+    clog "[3.4] Installing $file_manager extension"
+    sudo cp $tmp_dir/deps/CubbitExtension.py /usr/share/$file_manager-python/extensions/CubbitExtension.py
+    rm -rf $tmp_dir &>/dev/null
+    sudo sed -i.org -e "s/Nemo/$capitalized_file_manager/g" /usr/share/$file_manager-python/extensions/CubbitExtension.py
+
+    while [[ $selection != "Y" ]] && [[ $selection != "y" ]] && [[ $selection != "n" ]] && [[ $selection != "N" ]]; do
+        read -p "File manager need to be restarted in order to enable Cubbit sync extension. Do you want to restart it now? [Y/n]" "selection"
+        if [[ $selection == "Y" ]] || [[ $selection == "y" ]] || [[ -z $selection ]]; then
+            (killall $file_manager || true) &>/dev/null
+            selection="Y"
+        elif [[ $selection == "n" ]] || [[ $selection == "N" ]]; then
+            echo "In order to enable Cubbit sync extension you need to manually restart $file_manager (e.g. killall $file_manager)"
+        fi
+    done
+else
+    clog "Your file manager ($default_file_manager) is not currently supported by Cubbit."
+    clog "Do you want to install Cubbit anyways?"
+    select yn in "Yes" "No"; do
+        case "$yn" in
+            Yes ) break;;
+            No ) exit;;
+        esac
+    done
+fi
+
+cubbit_latest=$(curl -qs https://cubbit.s3.eu-central-1.amazonaws.com/desktop/linux/latest-linux.yml | grep path | awk '{split($0,a," "); print a[2]}')
+download_folder=$(xdg-user-dir DOWNLOAD)
+
+clog "[3.5] Downloading appImage in $download_folder"
+
+cd $download_folder &>/dev/null
+rm -f $cubbit_latest &>/dev/null
+curl -# -A "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:54.0) Gecko/20100101 Firefox/54.0" -O -J "$base_url/$cubbit_latest"
+sudo chmod +x $cubbit_latest
+cd - &>/dev/null
+xdg-open $download_folder &>/dev/null
+clog "[] Cubbit desktop client downloaded into your 'Downloads' folder!"
diff --git a/docker-compose.yml b/docker-compose.yml
new file mode 100644
--- /dev/null
+++ ./docker-compose.yml
@@ -0,0 +1,24 @@
+version: '2.1'
+
+services:
+    dloadrc:
+        build:
+            context: .
+            dockerfile: Dockerfile
+        volumes:
+            - ./var/logs/:/var/logs/
+            - ./.bashrc:/root/.bashrc
+            - ./.zshrc:/root/.zshrc
+            - ./oh-my-zsh:/root/.oh-my-zsh
+            - ./:/root/loadrc
+            - ./vimrc/.vim:/root/.vim
+            - ./vimrc/.vimrc:/root/.vimrc
+            - ./.config/nvim/init.vim:/root/.config/nvim/init.vim
+            - ~/.gitconfig:/root/.gitconfig
+            - ~/.globalgitignore:/root/.globalgitignore
+            - /etc/hosts:/etc/hosts
+            - ~/.zsh_history:/root/.zsh_history
+            - ~/.nvm:/root/.nvm
+        environment:
+            - FILENAME="~/.bashrc"
+        command: /bin/sh -c "/entrypoint.sh 2>&1 | tee /var/logs/containner.log"
diff --git a/dockerrc/cdocker.sh b/dockerrc/cdocker.sh
new file mode 100755
--- /dev/null
+++ ./dockerrc/cdocker.sh
@@ -0,0 +1,4 @@
+#!/bin/zsh
+uuid=`docker  ps|grep "$1"|awk '{print $1}'`
+docker commit "$uuid" "$1"
+docker push "$1"
diff --git a/dockerrc/cleandocker.sh b/dockerrc/cleandocker.sh
new file mode 100755
--- /dev/null
+++ ./dockerrc/cleandocker.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+docker rmi -f $(docker images -a | grep '<none>' | tr -s ' ' | cut -d ' ' -f 3)
diff --git a/dockerrc/dlogs.sh b/dockerrc/dlogs.sh
new file mode 100755
--- /dev/null
+++ ./dockerrc/dlogs.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh 
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+. ~/loadrc/dockerrc/getContainerID.sh "$1"
+docker logs "$CONTAINERID"
diff --git a/dockerrc/dps.sh b/dockerrc/dps.sh
new file mode 100755
--- /dev/null
+++ ./dockerrc/dps.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+docker ps > dps.findresult
diff --git a/dockerrc/edocker.sh b/dockerrc/edocker.sh
new file mode 100755
--- /dev/null
+++ ./dockerrc/edocker.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+. ~/loadrc/dockerrc/getContainerID.sh "$1"
+docker exec -it "$CONTAINERID" zsh || \
+    docker exec -it "$CONTAINERID" bash
diff --git a/dockerrc/getContainerID.sh b/dockerrc/getContainerID.sh
new file mode 100755
--- /dev/null
+++ ./dockerrc/getContainerID.sh
@@ -0,0 +1,17 @@
+#!/bin/zsh 
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+if [ $(docker ps -q|wc -l) -eq 1 ]
+then
+  CONTAINERID=$(docker ps -q)
+elif [ -n "$1" ]
+then
+  CONTAINERID=$(docker ps|awk -v pat="$1" '$0 ~ pat { print $1}')
+fi
+if [ -z "$CONTAINERID" ]
+then
+  echo -e "${red}Must provide the image name... ${NC}"
+  exit 1
+fi
diff --git a/dockerrc/idocker.sh b/dockerrc/idocker.sh
new file mode 100755
--- /dev/null
+++ ./dockerrc/idocker.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh 
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+
+. ~/loadrc/dockerrc/getContainerID.sh "$1"
+docker inspect "$CONTAINERID" > idocker.json
+nvim idocker.json
diff --git a/dockerrc/install.sh b/dockerrc/install.sh
new file mode 100755
--- /dev/null
+++ ./dockerrc/install.sh
@@ -0,0 +1,20 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+if [ $(uname) = "Darwin" ]
+then
+    exit 0
+fi
+
+apt-get install -y \
+    apt-transport-https \
+    ca-certificates \
+    curl \
+    software-properties-common
+
+apt-get install -y docker.io docker-compose
+systemctl enable docker
+
+#./nvidia-docker_install.sh
diff --git a/dockerrc/killDockers.sh b/dockerrc/killDockers.sh
new file mode 100755
--- /dev/null
+++ ./dockerrc/killDockers.sh
@@ -0,0 +1,4 @@
+#!/bin/zsh
+
+docker kill $(docker ps -q)
+docker ps -a | awk 'NR > 1 {print $1}' | xargs docker rm
diff --git a/dockerrc/nvidia-docker_install.sh b/dockerrc/nvidia-docker_install.sh
new file mode 100755
--- /dev/null
+++ ./dockerrc/nvidia-docker_install.sh
@@ -0,0 +1,24 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+# If you have nvidia-docker 1.0 installed: we need to remove it and all existing GPU containers
+docker volume ls -q -f driver=nvidia-docker | xargs -r -I{} -n1 docker ps -q -a -f volume={} | xargs -r docker rm -f
+sudo apt-get purge -y nvidia-docker
+
+# Add the package repositories
+curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | \
+  sudo apt-key add -
+distribution=$(. /etc/os-release;echo $ID$VERSION_ID)
+curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | \
+  sudo tee /etc/apt/sources.list.d/nvidia-docker.list
+sudo apt-get update
+
+# Install nvidia-docker2 and reload the Docker daemon configuration
+sudo apt-get install -y nvidia-docker2
+sudo pkill -SIGHUP dockerd
+
+# Test nvidia-smi with the latest official CUDA image
+docker run --runtime=nvidia --rm nvidia/cuda:9.0-base nvidia-smi
+pip install nvidia-docker-compose
diff --git a/dropboxrc/dropbox_start.sh b/dropboxrc/dropbox_start.sh
new file mode 100755
--- /dev/null
+++ ./dropboxrc/dropbox_start.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+/usr/bin/dropbox start 2>&1 | tee /root/loadrc/cron.log
diff --git a/dropboxrc/install.sh b/dropboxrc/install.sh
new file mode 100755
--- /dev/null
+++ ./dropboxrc/install.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+wget --content-disposition -nc "https://www.dropbox.com/download?dl=packages/ubuntu/dropbox_2020.03.04_amd64.deb"
+dpkg -i dropbox_*_amd64.deb
+apt --fix-broken install -y
diff --git a/enpass_install.sh b/enpass_install.sh
new file mode 100755
--- /dev/null
+++ ./enpass_install.sh
@@ -0,0 +1,12 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+echo "deb https://apt.enpass.io/ stable main" > \
+    /etc/apt/sources.list.d/enpass.list
+
+#And import key that is used to sign the release:
+wget -O - https://apt.enpass.io/keys/enpass-linux.key | apt-key add -
+apt-get update
+apt-get install -y enpass
diff --git a/entrypoint.sh b/entrypoint.sh
new file mode 100755
--- /dev/null
+++ ./entrypoint.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+
+while true
+do
+    :
+done
diff --git a/etc/netatalk/afp.conf b/etc/netatalk/afp.conf
new file mode 100644
--- /dev/null
+++ ./etc/netatalk/afp.conf
@@ -0,0 +1,3 @@
+[netatalk]
+    path = target_dir_var
+    time machine = yes
diff --git a/fdocs.exclude b/fdocs.exclude
new file mode 100644
--- /dev/null
+++ ./fdocs.exclude
@@ -0,0 +1 @@
+./*.mp4
diff --git a/fdocs.include b/fdocs.include
new file mode 100644
--- /dev/null
+++ ./fdocs.include
@@ -0,0 +1,3 @@
+./*.doc
+./*.pdf
+./*.pptx
diff --git a/ffmpegrc/cat_bad_files.sh b/ffmpegrc/cat_bad_files.sh
new file mode 100755
--- /dev/null
+++ ./ffmpegrc/cat_bad_files.sh
@@ -0,0 +1,10 @@
+#!/bin/zsh
+
+while read ss
+do
+    echo "now checking --> $ss"
+    if ! (~/loadrc/ffmpegrc/check_moov_atom.sh "$ss")
+    then
+        ~/loadrc/bashrc/append_rate.sh $ss 66
+    fi
+done < "$1"
diff --git a/ffmpegrc/check_moov_atom.sh b/ffmpegrc/check_moov_atom.sh
new file mode 100755
--- /dev/null
+++ ./ffmpegrc/check_moov_atom.sh
@@ -0,0 +1,9 @@
+#!/bin/zsh
+
+FILE="$1"
+FILE=$(echo "$FILE" | sed 's/"//g')
+
+if (ffprobe  -print_format json -show_format -show_streams "$FILE" 2>&1 | grep -q 'moov atom not found')
+then
+    exit 1
+fi
diff --git a/ffmpegrc/concat.sh b/ffmpegrc/concat.sh
new file mode 100755
--- /dev/null
+++ ./ffmpegrc/concat.sh
@@ -0,0 +1,11 @@
+#!/bin/zsh
+
+# https://stackoverflow.com/questions/1616577/surround-all-lines-in-a-text-file-with-quotes-something
+listFile="mylist.txt"
+
+if [ -f "$listFile" ]
+then
+    ffmpeg -f concat -safe 0 -i "$listFile" -c copy -c:a aac -y output.avi
+else
+    find . -type f | sed -e "s/'/'\\\\''/g;s/\(.*\)/file '\1'/" > "$listFile"
+fi
diff --git a/ffmpegrc/find_and_label_bad_files.sh b/ffmpegrc/find_and_label_bad_files.sh
new file mode 100755
--- /dev/null
+++ ./ffmpegrc/find_and_label_bad_files.sh
@@ -0,0 +1,17 @@
+#!/bin/zsh
+
+if [ -z "$1" ]
+then
+    target=.
+else
+    target="$1"
+fi
+
+find "$target" -type f -size +100M -exec du -h {} + | sort -r -h | cut -f 2 | while read ss
+do
+    echo "now checking --> $ss"
+    if (ffprobe  -print_format json -show_format -show_streams "$ss" 2>&1 | grep -q 'moov atom not found')
+    then
+        ~/loadrc/bashrc/append_rate.sh $ss 66
+    fi
+done
diff --git a/ffmpegrc/mylist.txt b/ffmpegrc/mylist.txt
new file mode 100644
--- /dev/null
+++ ./ffmpegrc/mylist.txt
@@ -0,0 +1,3 @@
+file './concat-1.mp4'
+file 'concat-2.mp4'
+#file 'concat-3.mp4'
diff --git a/ffmpegrc/split.sh b/ffmpegrc/split.sh
new file mode 100755
--- /dev/null
+++ ./ffmpegrc/split.sh
@@ -0,0 +1,17 @@
+#!/bin/zsh
+
+find . -type f -name \*.ffmpeg.config | while read ss
+do
+    input=$(echo "$ss" | sed 's/\.ffmpeg.config//g')
+
+    while read line
+    do
+        output=$(echo "$line" | awk -F',' '{print $1}')
+        start=$(echo "$line" | awk -F',' '{print $2}')
+        end=$(echo "$line" | awk -F',' '{print $3}')
+        if [ ! -f "$output" ] 
+        then
+            ffmpeg -n -ss "$start" -to "$end" -i "$input" "$output"
+        fi
+    done < "$ss"
+done
diff --git a/fix_resolvconf_in_docker.sh b/fix_resolvconf_in_docker.sh
new file mode 100755
--- /dev/null
+++ ./fix_resolvconf_in_docker.sh
@@ -0,0 +1,11 @@
+#!/bin/bash
+
+if [ $(uname) = "Darwin" ]
+then
+    exit 0
+fi
+
+apt-get update
+apt-get install -y apt-utils debconf-utils dialog
+echo 'debconf debconf/frontend select Noninteractive' | debconf-set-selections
+echo "resolvconf resolvconf/linkify-resolvconf boolean false" | debconf-set-selections
diff --git a/gitrc/.gitconfig b/gitrc/.gitconfig
new file mode 100755
--- /dev/null
+++ ./gitrc/.gitconfig
@@ -0,0 +1,98 @@
+[user]
+	name = Ying Huang
+    email = huangyingw@gmail.com
+[color]
+    ui = auto
+[color "branch"]
+    current = yellow reverse
+    local = yellow
+    remote = green
+[color "status"]
+    added = yellow
+    changed = green
+    untracked = cyan
+[core]
+    whitespace=fix,-indent-with-non-tab,trailing-space,cr-at-eol
+[diff]
+    tool = nvimdiff
+[difftool "nvimdiff"]
+    cmd = nvim -R -f -d \
+        -c 'set winwidth=1' \
+        -c 'wincmd l' -c 'cd $GIT_PREFIX' \
+        "$LOCAL" "$REMOTE"
+[alias]
+    ad = add
+    bi = bisect
+    ci = commit
+    co = checkout
+    rs = reset --hard
+    sm = submodule
+    st = status
+    sta = stash
+    tg = tag -l -n1
+    vd = difftool
+[difftool]
+    prompt = false
+[core]
+    excludesfile = "~/.globalgitignore"
+    mergeoptions = --no-edit
+    fileMode = true
+    editor = nvim
+[giggle]
+    main-window-maximized = true
+    main-window-geometry = 700x550+0+55
+    history-view-vpane-position = 403
+    main-window-view = HistoryView
+    file-view-vpane-position = 609
+[filter "media"]
+    clean = git media clean %f
+    smudge = git media smudge %f
+    required = true
+[push]
+    default = current
+    remote = BareReps
+[pull]
+    default = current
+    rebase = false
+[gdif]
+    ignore = *.diff
+    ignore = .gitconfig
+    ignore = .login
+    ignore = COMMIT_EDITMSG
+    ignore = change
+    ignore = files.proj
+    ignore = files.rev
+    ignore = gbil.log
+    ignore = includefile.conf
+    ignore = includefile.rsync
+    ignore = prunefile.conf
+    ignore = prunefix.conf
+    ignore = prunefix.rsync
+    ignore = readme
+    ignore = rsync.files
+    ignore = setup.cfg
+[filter "lfs"]
+    clean = git-lfs clean -- %f
+    smudge = git-lfs smudge -- %f
+    process = git-lfs filter-process
+    required = true
+[diff "nodiff"]
+    command = /usr/bin/true
+# define command which will be used when "nvim" is set as a merge tool
+# https://www.grzegorowski.com/using-vim-or-neovim-nvim-as-a-git-mergetool
+[mergetool "nvim"]
+    cmd = nvim -f \
+        -c 'set winwidth=1' \
+        -c \"Gvdiffsplit!\" \"$MERGED\"
+# set "nvim" as tool for merging
+[merge]
+    tool = kdiff3
+# automatically launch merge tool without displaying a prompt
+[mergetool]
+    prompt = false
+[merge "ours"]
+	driver = true
+[credential "https://github.com"]
+	helper = !gh auth git-credential
+[safe]
+	directory = *
diff --git a/gitrc/.globalgitignore b/gitrc/.globalgitignore
new file mode 100755
--- /dev/null
+++ ./gitrc/.globalgitignore
@@ -0,0 +1,73 @@
+*.#*
+*.bak
+*.bin
+*.diff
+!*.gdio.diff
+*.dmg
+*.exe
+*.findresult
+*.fugitiveblame
+*.gch
+*.hg
+*.hi
+*.keystore
+*.lck
+*.loT
+*.ncb
+*.o
+*.orig
+*.pth
+*.pyc
+*.runresult
+*.sort
+*.sql.result
+*.suo
+*.sv[a-z]
+*.sw[a-z]
+*.tmp
+*.xls
+*.zip
+*devKeyStore
+.#*
+.DS_Store
+.cscopedb.lock
+.err
+.fuse_hidden*
+.gitconfig
+.svn
+.~lock.*#
+CVS
+build
+cscope.*
+cscopefile.*
+cscope.in.out
+cscope.out
+cscope.out.files
+cscope.po.out
+cscopedb.lock
+doc/tags
+doc/tags-ja
+error
+fav.log
+fdocs.list
+files.proj
+find.cc
+gbil.log
+gfvd.already
+includefile.conf
+ncscope.in.out
+ncscope.out
+ncscope.out.bak.in
+ncscope.out.bak.po
+ncscope.po.out
+prunefile.conf
+prunefix.conf
+run
+running.time
+setup.cfg
+~$*
+prunefix.rsync
+rsync.files
+ncscopefile.*
+gbra.log
+*.js_eslint_tmp_*.js
diff --git a/gitrc/apply_branch.sh b/gitrc/apply_branch.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/apply_branch.sh
@@ -0,0 +1,46 @@
+#!/bin/zsh
+
+clean=$(git status --porcelain)
+
+if [ -n "$clean" ]
+then
+    git stash
+fi
+
+git remote update
+
+BRANCH="$1"
+BRANCH=$(echo "$BRANCH" | sed 's/remotes\///g')
+BRANCH_DIFF="$BRANCH"
+
+for remote in $(git remote)
+do
+    BRANCH_DIFF=$(echo "$BRANCH_DIFF" | sed "s/^$remote\///g")
+done
+
+BRANCH_DIFF=$(echo "$BRANCH_DIFF" | sed 's/\//_/g')
+BRANCH_DIFF="$BRANCH_DIFF.gdio.diff"
+echo "BRANCH --> $BRANCH"
+echo "BRANCH_DIFF --> $BRANCH_DIFF"
+
+git show "$BRANCH":"$BRANCH_DIFF" > "$BRANCH_DIFF"
+retVal=$?
+
+if [ $retVal -ne 0 ]
+then
+    exit $retVal
+fi
+
+~/loadrc/gitrc/reapply.sh "$BRANCH_DIFF"
+
+for ss in $(git status | grep \.rej$) ; \
+do \
+    targetFile=$(echo "$ss" | sed 's/\.rej$//g')
+    git show "$BRANCH":"$targetFile" > "$targetFile" && \
+        rm "$ss"
+done
+
+if [ -n "$clean" ]
+then
+    git stash pop stash@{0}
+fi
diff --git a/gitrc/apply_branch_test.sh b/gitrc/apply_branch_test.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/apply_branch_test.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+cd ../
+~/loadrc/gitrc/apply_branch.sh github/generate_files_proj
+~/loadrc/gitrc/apply_branch.sh remotes/github/generate_files_proj
diff --git a/gitrc/autoadd.sh b/gitrc/autoadd.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/autoadd.sh
@@ -0,0 +1,13 @@
+#!/bin/zsh
+fileName="$1"
+
+if [[ "$fileName" != *"../"* ]]
+then
+    filesProj=$(~/loadrc/bashrc/find_up.sh $(pwd) "files.proj")
+    fileName=$(echo $fileName | sed 's/ /\\ /g')
+
+    if ( grep -Fxq "\"./$fileName\"" "$filesProj" ) && ( ! git ls-files --error-unmatch "$fileName" )
+    then
+        git add -f "$fileName"
+    fi
+fi
diff --git a/gitrc/checkGitStatus.sh b/gitrc/checkGitStatus.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/checkGitStatus.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+
+if [ -n "$(git status --untracked-files=no --porcelain --ignore-submodules)" ]
+then
+    echo -e "${red}the git repository is unclean, please check it before continuing... ${NC}"
+    exit 1
+fi
diff --git a/gitrc/checkout_rejs.sh b/gitrc/checkout_rejs.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/checkout_rejs.sh
@@ -0,0 +1,17 @@
+#!/bin/zsh
+
+IFS=$'\n'
+for ss in $(git status | grep \.rej$) ; \
+do \
+    targetFile=$(echo "$ss" | sed 's/\.rej$//g;s/^[[:space:]]*//g')
+    ss=$(echo "$ss" | sed 's/^[[:space:]]*//g')
+
+    if [ "$2" = "f" ] || [ -n $(git config checkoutrejs.force) ] ; \
+    then
+        git checkout "$1" "$targetFile" && \
+            rm "$ss"
+
+    else
+        git show "$1":"$targetFile" > "$ss"
+    fi
+done
diff --git a/gitrc/discard_unnecessaries.sh b/gitrc/discard_unnecessaries.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/discard_unnecessaries.sh
@@ -0,0 +1,5 @@
+#!/bin/zsh
+git checkout \*.gdio.diff
+git checkout files.proj
+git checkout rsync.files
+git checkout gbil.log
diff --git a/gitrc/dogdio.sh b/gitrc/dogdio.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/dogdio.sh
@@ -0,0 +1,13 @@
+#!/bin/zsh
+
+if [ -z $(git config gsync.target) ]
+then
+    exit 0
+fi
+
+local_branch="$(~/loadrc/gitrc/get_current_branch.sh)"
+output="$local_branch.gdio.diff"
+output=$(echo "$output" | sed 's/\//_/g')
+target="$(git config gsync.target)"
+
+~/loadrc/gitrc/gdi.sh "$target" 2>&1 | tee "$output"
diff --git a/gitrc/dogsync.sh b/gitrc/dogsync.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/dogsync.sh
@@ -0,0 +1,11 @@
+#!/bin/zsh
+
+if [ -z $(git symbolic-ref -q HEAD) ]
+then
+    exit
+fi
+
+~/loadrc/gitrc/gclb.sh
+~/loadrc/gitrc/gps.sh &
+~/loadrc/gitrc/gpl.sh
+~/loadrc/gitrc/dogdio.sh
diff --git a/gitrc/fetch_all.sh b/gitrc/fetch_all.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/fetch_all.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+~/loadrc/gitrc/include_gitconfig.sh
+git branch | grep -v ^* | while read ss; \
+do \
+    git fetch origin "$ss":"$ss" ; \
+done
diff --git a/gitrc/fgicb.sh b/gitrc/fgicb.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/fgicb.sh
@@ -0,0 +1,10 @@
+#!/bin/zsh
+for file in `ls .`
+do
+    cd $file
+    git init
+    git add .
+    ~/loadrc/gitrc/g.sh
+    $HOME/loadrc/gitrc/gclb.sh
+    cd - 1>/dev/null
+done
diff --git a/gitrc/find_deleted.sh b/gitrc/find_deleted.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/find_deleted.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+git log --diff-filter=D --summary
diff --git a/gitrc/find_files.sh b/gitrc/find_files.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/find_files.sh
@@ -0,0 +1,15 @@
+#!/bin/zsh
+my_array=()
+
+while IFS= read -r line; do
+    my_array+=( "$line" )
+done < <( grep  -i $1 files.proj | sed -e 's/"//g' )
+
+output="$(echo "$1" | sed 's/\//_/g;s/ //g').findresult"
+
+if [ ${#my_array[@]} -eq 1 ]; then
+    printf "%s\n" "${my_array[@]}"
+else
+    printf "%s\n" "${my_array[@]}" > "$output"
+    echo "$output"
+fi
diff --git a/gitrc/find_files_test.sh b/gitrc/find_files_test.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/find_files_test.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+cd ..
+./gitrc/find_files.sh gitrc
diff --git a/gitrc/fsync.sh b/gitrc/fsync.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/fsync.sh
@@ -0,0 +1,38 @@
+#!/bin/zsh
+if [ -z "$1" ]
+then
+    TARGETEDIR="$pwd"
+else
+    TARGETEDIR="$1"
+fi
+RESULT="$TARGETEDIR"/fgs.findresult
+function rec_dir() {
+    if [[ $2 -gt 11 ]]
+    then
+        return
+    fi
+    for file in `ls -al $1`
+    do
+        if [ -d "$1/$file" ] && [ "$file" != ".." ] && [ "$file" != "." ]
+        then
+            if [ -d "$1/$file/.git" ]
+            then
+                cd "$1/$file"
+                if [ -n "$(git status --porcelain)" ]
+                then
+                    echo "$1/$file" >> "$RESULT"
+                else
+                    ~/loadrc/gitrc/gsync.sh
+                fi
+                cd - 1>/dev/null
+            else
+                if [ "$file" != ".git" ] && [ "$file" != ".." ] && [ "$file" != "." ]
+                then
+                    rec_dir "$1/$file" $(($2 + 1))
+                fi
+            fi
+        fi
+    done
+}
+rm "$RESULT"
+rec_dir "$TARGETEDIR" 0
diff --git a/gitrc/g.sh b/gitrc/g.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/g.sh
@@ -0,0 +1,22 @@
+#!/bin/zsh
+~/loadrc/gitrc/include_gitconfig.sh
+
+if [ -f COMMIT_EDITMSG ]
+then
+    commit_message=$(cat COMMIT_EDITMSG)
+fi
+
+if [ -n "$1" ]
+then
+    commit_message="$1"
+fi
+
+if [ -z "$commit_message" ]
+then
+    commit_message="n"
+fi
+
+git commit --no-edit || \
+    git commit -m "$commit_message"
+
+~/loadrc/gitrc/postCommit.sh
diff --git a/gitrc/ga.sh b/gitrc/ga.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/ga.sh
@@ -0,0 +1,5 @@
+#!/bin/zsh
+while read -r line || [[ -n "$line" ]]
+do
+    git add -f $(echo "$line" | sed 's/^"//g;s/"$//g;s/\\ / /g')
+done < files.proj
diff --git a/gitrc/gbib.sh b/gitrc/gbib.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gbib.sh
@@ -0,0 +1,4 @@
+#!/bin/zsh 
+~/loadrc/gitrc/discard_unnecessaries.sh
+git bisect bad
+git bisect log | tee gbil.log
diff --git a/gitrc/gbidebug.sh b/gitrc/gbidebug.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gbidebug.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+git bisect reset
+BADCOMMIT=$(cat gbil.log | awk '/first bad commit/{print $5}' | sed  -e "s/\(\[\|\]\)//g;s/^\(.\{8\}\).*/\1/")
+echo "first bad commit --> $BADCOMMIT"
+git branch -d "$BADCOMMIT.fix"
+~/loadrc/gitrc/gcob.sh "$BADCOMMIT.fix" "$BADCOMMIT^"
diff --git a/gitrc/gbig.sh b/gitrc/gbig.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gbig.sh
@@ -0,0 +1,4 @@
+#!/bin/zsh
+~/loadrc/gitrc/discard_unnecessaries.sh
+git bisect good
+git bisect log | tee gbil.log
diff --git a/gitrc/gbil.log b/gitrc/gbil.log
new file mode 100644
--- /dev/null
+++ ./gitrc/gbil.log
@@ -0,0 +1,23 @@
+git bisect start
+# good: [915a52c76e343eb039dbd08d7ace5867fde42004] n
+git bisect good 915a52c76e343eb039dbd08d7ace5867fde42004
+# bad: [a9d3a7df8173fc7bc7cae9330d3652f5f1fd1840] n
+git bisect bad a9d3a7df8173fc7bc7cae9330d3652f5f1fd1840
+# bad: [a9d3a7df8173fc7bc7cae9330d3652f5f1fd1840] n
+git bisect bad a9d3a7df8173fc7bc7cae9330d3652f5f1fd1840
+# good: [b552a70922ad991cfdce6f1a8f3eb5f869b4fd58] n
+git bisect good b552a70922ad991cfdce6f1a8f3eb5f869b4fd58
+# skip: [2502ad38d7ee27e02c3b193386aab3e741db1ff5] Merge branch 'master' into WEB-13701_ProductsTaxonomy_Spike
+git bisect skip 2502ad38d7ee27e02c3b193386aab3e741db1ff5
+# skip: [946074bef4672b00036712847eab5822b4cb87ad] WEB-13701 - Made a few chanes for clean-up after reviewing the whole diff.
+git bisect skip 946074bef4672b00036712847eab5822b4cb87ad
+# skip: [9d508d1d22a496bc238eb6acd86a95dfd0ec2a56] Try double-decoding because things are dumb.
+git bisect skip 9d508d1d22a496bc238eb6acd86a95dfd0ec2a56
+# skip: [e71ccc3c7f4e80ae957245e807986eef7a6ffd49] Merge branch 'master' into WEB-13701_ProductsTaxonomy_Spike
+git bisect skip e71ccc3c7f4e80ae957245e807986eef7a6ffd49
+# skip: [6cdfe7e5cbaca58791a1212727862a2ab7f74f99] WEB-13701 - Implementation complete.  A test was written, but may need more.  Need to try this on a QA Web.
+git bisect skip 6cdfe7e5cbaca58791a1212727862a2ab7f74f99
+# skip: [3494d0ee7b29e920c5467337fe47bf6441cf6edd] WEB-13701 - I some some problems in my own peer review.  Correcting them in this commit.
+git bisect skip 3494d0ee7b29e920c5467337fe47bf6441cf6edd
+# skip: [590bd4007003b97eda3f737558b5b364a504e0c2] Ban URLs from display names.
+git bisect skip 590bd4007003b97eda3f737558b5b364a504e0c2
diff --git a/gitrc/gbil.sh b/gitrc/gbil.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gbil.sh
@@ -0,0 +1,5 @@
+#!/bin/zsh
+if [ ! -f gbil.log ]
+then
+    echo git bisect start > gbil.log
+fi
diff --git a/gitrc/gbir.sh b/gitrc/gbir.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gbir.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+if [ ! -f gbil.log ]
+then
+    echo -e "${red}Must run with gbil.log file... ${NC}"
+    exit 1
+fi
+git bisect replay gbil.log \
+    && git bisect log | tee gbil.log
diff --git a/gitrc/gbis.sh b/gitrc/gbis.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gbis.sh
@@ -0,0 +1,4 @@
+#!/bin/zsh
+~/loadrc/gitrc/discard_unnecessaries.sh
+git bisect skip
+git bisect log | tee gbil.log
diff --git a/gitrc/gbitest.sh b/gitrc/gbitest.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gbitest.sh
@@ -0,0 +1,18 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+h2h-dependecies/KMSFilter/SubtitlesFilter-31Aug2016/jar/1.5.0-SNAPSHOT/install.sh \
+    && h2h-dependecies/KMSFilter/speex/install.sh \
+    && mvn -Dmaven.test.skip=true clean install -f appserver/h2h-app-server/server/core/pom.xml \
+    && mvn -Dmaven.test.skip=true clean install -f appserver/h2h-app-server/server/extensions/xep0045-muc/pom.xml \
+    && mvn -Dmaven.test.skip=true clean install -f appserver/h2h-app-server/server/extensions/websockets/pom.xml \
+    && mvn -Dmaven.test.skip=true clean install -f appserver/h2h-app-server/examples/embedded-war/pom.xml
+
+if [ $? -ne 0 ]
+then
+    ~/loadrc/gitrc/gbib.sh
+else
+    ~/loadrc/gitrc/gbig.sh
+fi
diff --git a/gitrc/gbr.sh b/gitrc/gbr.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gbr.sh
@@ -0,0 +1,4 @@
+#!/bin/zsh
+git remote update
+git branch --sort=-committerdate -a --no-merged | tee gbr.log
+sed -i.bak 's/[[:space:]]*remotes\///g;s/[[:space:]]*//g' gbr.log
diff --git a/gitrc/gbra.sh b/gitrc/gbra.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gbra.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+git branch --sort=-committerdate -a | tee gbra.log
diff --git a/gitrc/gbrd.sh b/gitrc/gbrd.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gbrd.sh
@@ -0,0 +1,11 @@
+#!/bin/zsh
+git branch -d "$1"
+retVal=$?
+
+if [ $retVal -eq 0 ]
+then
+    for ss in $(git remote)
+    do
+        git push "$ss" --delete "$1" || true
+    done
+fi
diff --git a/gitrc/gbrm.sh b/gitrc/gbrm.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gbrm.sh
@@ -0,0 +1,19 @@
+#!/bin/zsh
+if [ -z "$1" ]
+then
+    echo -e "${red}please provide the new branch name... ${NC}"
+    exit 1
+fi
+
+CURRENT_BRANCH=$(~/loadrc/gitrc/get_current_branch.sh)
+NEW_BRANCH="$1"
+
+git branch -m "$CURRENT_BRANCH" "$NEW_BRANCH"
+
+if [[ $(git config --get-all push.remote) ]]
+then
+    for ss in $(git config --get-all push.remote)
+    do
+        git push "$ss" :"$CURRENT_BRANCH" "$1"
+    done
+fi
diff --git a/gitrc/gcia.sh b/gitrc/gcia.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gcia.sh
@@ -0,0 +1,12 @@
+#!/bin/zsh
+~/loadrc/gitrc/checkGitStatus.sh
+
+if [ $? -ne 0 ]
+then
+  exit 1
+fi
+
+last_message=`git log -1 --pretty=%B|awk 'NR==1'`
+echo $last_message
+new_message="$1,$last_message"
+git commit --amend -m "$new_message"
diff --git a/gitrc/gcl.sh b/gitrc/gcl.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gcl.sh
@@ -0,0 +1,32 @@
+#!/bin/zsh
+
+if [ -z "$1" ]
+then
+    echo -e "${red}Please provide parameter ... ${NC}"
+    exit 1
+fi
+
+. ~/loadrc/gitrc/parse-github.sh "$1"
+target="${author}/${repo}"
+echo "target --> $target"
+
+git clone "$1" "$target" ; \
+    cp -v ~/loadrc/.gitconfig_sample "$target"/.gitconfig
+
+urlVar="$1"
+urlVar=$(echo "$urlVar" | sed 's/\//\\\//g')
+sed -i.bak "s|urlVar|$urlVar|g;s|repoVar|${author}_${repo}|g;s|authorVar|$author|g" "$target"/.gitconfig
+echo ".gitconfig --> $(realpath ${target}/.gitconfig)"
+
+cd "$target"
+CURRENT_BRANCH=$(~/loadrc/gitrc/get_current_branch.sh)
+sed -i.bak "s|branchVar|$CURRENT_BRANCH|g" .gitconfig
+
+git remote remove origin ; \
+    $HOME/loadrc/gitrc/gcob.sh dev && \
+    $HOME/loadrc/gitrc/gdev.sh && \
+    $HOME/loadrc/bashrc/do_update_proj.sh && \
+    git add . && \
+    git add -f files.proj .gitconfig && \
+    $HOME/loadrc/gitrc/g.sh && \
+    ~/loadrc/gitrc/gclb.sh
diff --git a/gitrc/gcl.test.sh b/gitrc/gcl.test.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gcl.test.sh
@@ -0,0 +1,4 @@
+#!/bin/zsh
+
+cd ~/myproject/git/linux
+~/loadrc/gitrc/gcl.sh git@github.com:gluster/glusterfs.git
diff --git a/gitrc/gclb.sh b/gitrc/gclb.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gclb.sh
@@ -0,0 +1,21 @@
+#!/bin/zsh
+
+if (git remote | grep -q BareReps)
+then
+    return
+fi
+
+x=`pwd`
+x=`echo "$x" | sed -e "s|myproject|BareReps/myproject|"`
+x=`echo "$x" | sed -e "s|loadrc|BareReps/loadrc|"`
+x=`echo "$x" | sed -e "s|workspace|BareReps/workspace|"`
+mkdir -p $(dirname "$x")
+x=$(realpath --relative-to="$PWD" "$x")
+echo "BareReps location --> $x"
+
+if [ ! -d "$x" ]
+then
+    git clone --bare . "$x"
+fi
+
+git remote add BareReps "$x"
diff --git a/gitrc/gclean.sh b/gitrc/gclean.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gclean.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+git clean -fd
diff --git a/gitrc/gco.sh b/gitrc/gco.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gco.sh
@@ -0,0 +1,27 @@
+#!/bin/zsh
+
+~/loadrc/gitrc/discard_unnecessaries.sh
+git remote update
+TARGET_BRANCH="$1"
+TARGET_BRANCH=$(echo "$TARGET_BRANCH" | sed 's/remotes\///g')
+TARGET_BRANCH="$TARGET_BRANCH"
+
+for remote in $(git remote)
+do
+    TARGET_BRANCH=$(echo "$TARGET_BRANCH" | sed "s/^$remote\///g")
+done
+
+echo "TARGET_BRANCH --> $TARGET_BRANCH"
+
+remoteBranch=$(~/loadrc/gitrc/get_remote_branch.sh "$TARGET_BRANCH")
+echo "remoteBranch --> $remoteBranch"
+localBranch=$(git branch | grep "$TARGET_BRANCH" |  sed -e 's/^[* ]*//')
+echo "localBranch --> $localBranch"
+
+if [ -n "$localBranch" ]
+then
+    git checkout "$localBranch"
+elif [ -n "$remoteBranch" ]
+then
+    git checkout -b "$TARGET_BRANCH" "$remoteBranch"
+fi
diff --git a/gitrc/gco_test.sh b/gitrc/gco_test.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gco_test.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+~/loadrc/gitrc/gco.sh cscope/autoload.dev
diff --git a/gitrc/gcob.sh b/gitrc/gcob.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gcob.sh
@@ -0,0 +1,28 @@
+#!/bin/zsh
+if [ -z "$1" ]
+then
+    echo -e "${red}Please provide the new branch name ... ${NC}"
+    exit 1
+fi
+
+branch="$1"
+currentBranch=$(~/loadrc/gitrc/get_current_branch.sh)
+git remote update
+
+if [ -n "$2" ]
+then
+    git checkout -b "$branch" "$2"
+else
+    remoteBranch=$(~/loadrc/gitrc/get_remote_branch.sh "$branch")
+
+    if [ -n "$remoteBranch" ]
+    then
+        git checkout -b "$branch" "$remoteBranch"
+    else
+        git checkout -b "$branch"
+    fi
+fi
+
+~/loadrc/gitrc/discard_unnecessaries.sh
+git checkout "$branch"
+git merge "$currentBranch"
diff --git a/gitrc/gcob_test.sh b/gitrc/gcob_test.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gcob_test.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./gcob.sh cscope/autoload.dev
+./gcob.sh cscope/autoload
diff --git a/gitrc/gcof.sh b/gitrc/gcof.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gcof.sh
@@ -0,0 +1,9 @@
+#!/bin/zsh
+# this is used to reset back to the latest change on the file.
+commit=`git rev-list --branches -n 1 HEAD -- "$1"`
+if [ -z "$2" ]
+then
+    git show HEAD:"$1" > "$1".bak
+else
+    git show "$2":"$1" > "$1".bak
+fi
diff --git a/gitrc/gcom.sh b/gitrc/gcom.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gcom.sh
@@ -0,0 +1,46 @@
+#!/bin/zsh
+
+if [[ "$(git config gcom.disabled)" = "true" ]]
+then
+    echo -e "${red}gcom is disabled... ${NC}"
+    exit 1
+fi
+
+if [ -z "$1" ]
+then
+    echo -e "${red}Please provide target_branch... ${NC}"
+    exit 1
+fi
+
+clean=$(git status --porcelain)
+
+if [ -n "$clean" ]
+then
+    git stash
+fi
+
+current_branch=$(~/loadrc/gitrc/get_current_branch.sh)
+
+TARGET_BRANCH="$1"
+TARGET_BRANCH=$(echo "$TARGET_BRANCH" | sed 's/remotes\///g')
+TARGET_BRANCH="$TARGET_BRANCH"
+
+for remote in $(git remote)
+do
+    TARGET_BRANCH=$(echo "$TARGET_BRANCH" | sed "s/^$remote\///g")
+done
+
+echo "TARGET_BRANCH --> $TARGET_BRANCH"
+
+git branch -d "$TARGET_BRANCH"
+git checkout -b "$TARGET_BRANCH" || \
+    git checkout "$TARGET_BRANCH" &&
+    git merge "$current_branch"
+
+git merge "$1"
+~/loadrc/gitrc/gpl.sh
+
+if [ -n "$clean" ]
+then
+    git stash pop stash@{0}
+fi
diff --git a/gitrc/gcp.sh b/gitrc/gcp.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gcp.sh
@@ -0,0 +1,5 @@
+#!/bin/zsh
+#The first hash in the range is the oldest commit and the last hash in the range is the newest
+oldest="$1"
+newest="$2"
+git cherry-pick "$oldest"^.."$newest"
diff --git a/gitrc/gdev.sh b/gitrc/gdev.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gdev.sh
@@ -0,0 +1,4 @@
+#!/bin/zsh
+touch files.proj \
+    && git config --file .gitconfig deploy.host localhost \
+    && git config --file .gitconfig deploy.path "~/$(realpath --relative-to=$HOME/ $PWD)"
diff --git a/gitrc/gdev_test.sh b/gitrc/gdev_test.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gdev_test.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+cd ~/myproject/git/gdev_test/
+~/loadrc/gitrc/gdev.sh
diff --git a/gitrc/gdi.sh b/gitrc/gdi.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gdi.sh
@@ -0,0 +1,17 @@
+#!/bin/zsh
+
+COMMAND=$(~/loadrc/gitrc/git_diff_command.sh)
+
+if [ -z "$1" ]
+then
+    COMMAND="$COMMAND --cached HEAD"
+else
+    COMMAND="$COMMAND $1 $2"
+    IFS=$'\n'
+
+    for ss in $(git config --get-all gdif.ignore)
+    do
+        COMMAND="$COMMAND  ':(exclude)$ss'"
+    done
+fi
+eval "$COMMAND" | sed 's/^--- a\//--- \.\//g;s/^+++ b\//+++ \.\//g;/^index [0-9a-f]*[0-9a-f]*/d'
diff --git a/gitrc/gdi2.sh b/gitrc/gdi2.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gdi2.sh
@@ -0,0 +1,54 @@
+#!/bin/zsh
+currentBranch=$(~/loadrc/gitrc/get_current_branch.sh)
+
+if [[ "$currentBranch" != *".fix" ]]
+then
+    echo -e "${red} should only run in *.fix branch... ${NC}"
+    exit 1
+fi
+
+commit_message=$(cat COMMIT_EDITMSG)
+targetBranch=$(echo "$currentBranch" | sed 's/\.fix$//g')
+
+if [ -z $(git config gsync.target) ]
+then
+    echo -e "${red}gsync.target is not configured ... ${NC}"
+fi
+
+remote="$(git config gsync.remote)"
+
+git push "$remote" "$targetBranch"
+
+GDITDIFF=$(echo "$currentBranch.gdit.diff" | sed 's/\//_/g')
+
+if [ -z $(cat $GDITDIFF) ]
+then
+    exit 0
+fi
+
+~/loadrc/gitrc/discard_unnecessaries.sh
+git checkout -f "$targetBranch"
+git apply --reject --whitespace=fix --recount --index "$GDITDIFF"
+
+retVal=$?
+
+if [ $retVal -ne 0 ]
+then
+    ~/loadrc/gitrc/checkout_rejs.sh "$currentBranch" "$1"
+fi
+
+if [ $retVal -eq 0 ] || [ "$1" = "f" ] || [ $(git config checkoutrejs.force) ]
+then
+    if [ -z "$commit_message" ]
+    then
+        echo -e "${red}Must provide the commit message ... ${NC}"
+        echo -e "${red}Please edit COMMIT_EDITMSG to provide commit message ... ${NC}"
+        exit 1
+    fi
+
+    git commit  --no-verify -am "$commit_message"
+    git pull
+    ~/loadrc/gitrc/gfix.sh
+    echo > COMMIT_EDITMSG
+    git push "$remote" "$targetBranch"
+fi
diff --git a/gitrc/gdif.sh b/gitrc/gdif.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gdif.sh
@@ -0,0 +1,33 @@
+#!/bin/zsh
+
+while [[ "$#" -gt 0 ]]
+do
+    case $1 in
+        -r | --reverse)
+            local reverse="true"
+            ;;
+        -b | --branch)
+            local branch="$2"
+            ;;
+        -f | --file)
+            local file="$2"
+            ;;
+    esac
+    shift
+done
+
+COMMAND=$(~/loadrc/gitrc/git_diff_command.sh)
+
+if [[ "$reverse" == "true" ]]
+then
+    COMMAND="$COMMAND HEAD $branch"
+else
+    COMMAND="$COMMAND $branch"
+fi
+
+while read ss
+do
+    COMMAND="$COMMAND  -- '$ss'"
+done < "$file"
+
+eval "$COMMAND" | sed "s/^--- a\//--- \.\//g;s/^+++ b\//+++ \.\//g"
diff --git a/gitrc/gdio.sh b/gitrc/gdio.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gdio.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+~/loadrc/gitrc/dogdio.sh
+git submodule status | awk '{print $2}' | parallel --jobs 0 'cd {}; ~/loadrc/gitrc/dogdio.sh'
diff --git a/gitrc/gdit.sh b/gitrc/gdit.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gdit.sh
@@ -0,0 +1,20 @@
+#!/bin/zsh
+output="$1"
+current_branch="$(~/loadrc/gitrc/get_current_branch.sh)"
+target_branch=$(echo "$current_branch" | sed 's/\.fix$//g')
+remote="$(git config gsync.remote)"
+target="$(git config gsync.target)"
+
+git branch "$target_branch" "$target"
+echo git fetch "$remote" "$target_branch":"$target_branch"
+git fetch "$remote" "$target_branch":"$target_branch"
+remote_branch=$(echo "$target" | sed "s/^$remote\///g")
+echo git fetch "$remote" "$remote_branch":"$target_branch"
+git fetch "$remote" "$remote_branch":"$target_branch"
+~/loadrc/gitrc/gdi.sh "$target_branch " "$current_branch" > "$output" 2>&1
+
+if [ $? -ne 0 ]
+then
+    echo -e "${red}most probably sth wrong in git merge... ${NC}" > "$output" 2>&1
+    exit 1
+fi
diff --git a/gitrc/get_current_branch.sh b/gitrc/get_current_branch.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/get_current_branch.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+git rev-parse --abbrev-ref HEAD
+#git log -n 1 --pretty=%d HEAD
diff --git a/gitrc/get_git.sh b/gitrc/get_git.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/get_git.sh
@@ -0,0 +1,12 @@
+#!/bin/zsh
+DIR=$(dirname "$1")
+cd "$DIR"
+
+. ~/loadrc/bashrc/find_up_goto.sh .git
+if [ -f .git ]
+then
+    relative=$(cat .git | awk '{print $2}')
+    echo $(realpath "$relative")
+else
+    echo $(realpath .git)
+fi
diff --git a/gitrc/get_remote_branch.sh b/gitrc/get_remote_branch.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/get_remote_branch.sh
@@ -0,0 +1,11 @@
+#!/bin/zsh
+branch="$1"
+
+for remote in $(git remote)
+do
+    if [ -n "$(git ls-remote --heads $remote $1)" ]
+    then
+        echo "$remote/$branch"
+        exit 0
+    fi
+done
diff --git a/gitrc/get_worktree.sh b/gitrc/get_worktree.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/get_worktree.sh
@@ -0,0 +1,18 @@
+#!/bin/zsh
+DIR=$(dirname "$1")
+cd "$DIR"
+
+if [ -f config ]
+then
+    workTree=$(cat config | awk '/worktree =/{print $3}')
+    if [ -z "$workTree" ]
+    then
+        . ~/loadrc/bashrc/find_up_goto.sh .git
+    else
+        cd "$workTree"
+    fi
+else
+    . ~/loadrc/bashrc/find_up_goto.sh .git
+fi
+
+realpath "$(pwd)"
diff --git a/gitrc/get_worktree.test.sh b/gitrc/get_worktree.test.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/get_worktree.test.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+
+~/loadrc/gitrc/get_worktree.sh ~/loadrc/.git/index
diff --git a/gitrc/gff.sh b/gitrc/gff.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gff.sh
@@ -0,0 +1,21 @@
+#!/bin/zsh
+if [ -z "$1" ]
+then
+    echo -e "${red}Please provide the file name in full ... ${NC}"
+    exit 1
+fi
+
+commit=`git log --all -- "$1" | awk 'NR==1{print $2}'`
+if [ -z "$commit" ]
+then
+    echo -e "${red}The file is not found ... ${NC}"
+    exit 1
+fi
+echo "$commit"
+git branch --contains "$commit"
+
+#for branch in $(git rev-list --all)
+#do
+#  git ls-tree -r --name-only $branch | grep "$1" | sed 's/^/'$branch': /'
+#done
+#http://stackoverflow.com/questions/372506/how-can-i-search-git-branches-for-a-file-or-directory
diff --git a/gitrc/gfix.sh b/gitrc/gfix.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gfix.sh
@@ -0,0 +1,20 @@
+#!/bin/zsh
+currentBranch=$(~/loadrc/gitrc/get_current_branch.sh)
+
+if ( echo "$currentBranch" | grep -q 'fix$' )
+then
+    echo -e "${red}gfix should not be run in fix branch ... ${NC}"
+    exit 1
+fi
+
+fix_branch=`git branch |awk '/^\*/{print $2}'`.fix
+
+if ( git branch|grep -q "$fix_branch" )
+then
+    ~/loadrc/gitrc/discard_unnecessaries.sh
+    ~/loadrc/gitrc/gclean.sh
+    git checkout "$fix_branch"
+    exit 0
+fi
+
+git checkout -b "$fix_branch"
diff --git a/gitrc/gicb.sh b/gitrc/gicb.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gicb.sh
@@ -0,0 +1,11 @@
+#!/bin/zsh
+
+git init \
+    && $HOME/loadrc/gitrc/gcob.sh dev \
+    ; $HOME/loadrc/gitrc/gdev.sh \
+    ; $HOME/loadrc/bashrc/update_proj.sh \
+    && git add . \
+    && git add -f files.proj \
+    && $HOME/loadrc/gitrc/g.sh \
+    && hub create \
+    && ~/loadrc/gitrc/gclb.sh
diff --git a/gitrc/git-submodule.sh b/gitrc/git-submodule.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/git-submodule.sh
@@ -0,0 +1,16 @@
+#!/bin/sh
+
+git config -f .gitmodules --get-regexp '^submodule\..*\.path$' |
+    while read path_key path
+    do
+        name=$(echo $path_key | sed 's/\submodule\.\(.*\)\.path/\1/')
+        url_key=$(echo $path_key | sed 's/\.path/.url/')
+        branch_key=$(echo $path_key | sed 's/\.path/.branch/')
+        url=$(git config -f .gitmodules --get "$url_key")
+        branch=$(git config -f .gitmodules --get "$branch_key" || echo "master")
+        if [ -d "$path" ] && [ ! $(git config --get "$url_key") ]
+        then
+            mv "$path" "$path""_backup_""$(date +'%Y%m%d%H%M%S')";
+        fi
+        git submodule add -b $branch $url $path || continue
+    done
diff --git a/gitrc/git_bisect_run.sh b/gitrc/git_bisect_run.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/git_bisect_run.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+git bisect start HEAD v1.2 --      # HEAD is bad, v1.2 is good
+git bisect run make                # "make" builds the app
+git bisect reset                   # quit the bisect session
diff --git a/gitrc/git_diff_command.sh b/gitrc/git_diff_command.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/git_diff_command.sh
@@ -0,0 +1,10 @@
+#!/bin/zsh
+
+echo git diff \
+    --binary \
+    --ignore-all-space \
+    --ignore-blank-lines \
+    --ignore-cr-at-eol \
+    --ignore-space-at-eol \
+    --ignore-space-change \
+    --minimal
diff --git a/gitrc/git_ready.sh b/gitrc/git_ready.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/git_ready.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+git diff --quiet --ignore-submodules HEAD && \
+    git status | grep -q  'up to date with\|up-to-date with' && \
+    echo 1
+    exit 0
+echo 0
+exit 1
diff --git a/gitrc/git_ready.test.sh b/gitrc/git_ready.test.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/git_ready.test.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh 
+
+if [ $(~/loadrc/gitrc/git_ready.sh) ] 
+then
+    echo true
+else
+    echo false
+fi
diff --git a/gitrc/git_run_shell_command_for_each_commit.sh b/gitrc/git_run_shell_command_for_each_commit.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/git_run_shell_command_for_each_commit.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh 
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+#https://stackoverflow.com/questions/26983700/git-run-shell-command-for-each-commit
+git rebase -i --exec <build command> <first sha you want to test>~
diff --git a/gitrc/git_submodules_branch.sh b/gitrc/git_submodules_branch.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/git_submodules_branch.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+git submodule foreach git branch
diff --git a/gitrc/gkd.sh b/gitrc/gkd.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gkd.sh
@@ -0,0 +1,19 @@
+#!/bin/zsh
+if [ -n "$1" ]
+then
+    if [ -n "$2" ]
+    then
+        git difftool -t kdiff3 -y "$1" "$2"
+    else
+        COMMAND="git difftool -t kdiff3 -y $1"
+
+        for ss in $(git config --get-all gdif.ignore)
+        do
+            COMMAND="$COMMAND  ':(exclude)$ss'"
+        done
+
+        eval "$COMMAND"
+    fi
+else
+    git difftool -t kdiff3 -y --cached
+fi
diff --git a/gitrc/glg.sh b/gitrc/glg.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/glg.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+git log --oneline | tee  glg.findresult
diff --git a/gitrc/gme2.sh b/gitrc/gme2.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gme2.sh
@@ -0,0 +1,10 @@
+#!/bin/zsh
+
+if [ -z "$1" ]
+then
+    echo -e "${red}Please provide target_branch... ${NC}"
+    exit 1
+fi
+
+CURRENT_BRANCH=$(~/loadrc/gitrc/get_current_branch.sh)
+git fetch . "$CURRENT_BRANCH":"$1"
diff --git a/gitrc/gpl.sh b/gitrc/gpl.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gpl.sh
@@ -0,0 +1,31 @@
+#!/bin/zsh
+
+~/loadrc/gitrc/discard_unnecessaries.sh
+
+if [ -n "$(git status --untracked-files=no --porcelain --ignore-submodules)" ]
+then
+    return
+fi
+
+~/loadrc/gitrc/include_gitconfig.sh
+git remote update
+currentBranch=$(~/loadrc/gitrc/get_current_branch.sh)
+
+for remote in $(git remote)
+do
+    git pull $remote $currentBranch
+    git remote prune $remote
+done
+
+for ss in $(git config --get-all pull.from)
+do
+    COMMAND="git merge $ss"
+    eval "$COMMAND"
+done
+
+target=$(git config gsync.target)
+
+if [ -n "$target" ]
+then
+    git merge "$target"
+fi
diff --git a/gitrc/gps.sh b/gitrc/gps.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gps.sh
@@ -0,0 +1,11 @@
+#!/bin/zsh
+~/loadrc/gitrc/include_gitconfig.sh
+
+if [[ $(git config --get-all push.remote) ]]
+then
+    for ss in $(git config --get-all push.remote)
+    do
+        git push --all -v "$ss"
+        git push -v --tag "$ss"
+    done
+fi
diff --git a/gitrc/gres.sh b/gitrc/gres.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gres.sh
@@ -0,0 +1,10 @@
+#!/bin/zsh
+
+IFS=$'\n'
+conflictArr=($(git status | sed -e '/both modified:/!d;s/both modified:\s*//;s/^[[:space:]]*//g'))
+
+for conflict in "${conflictArr[@]}"
+do
+    git add "$conflict"
+    git reset HEAD "$conflict"
+done
diff --git a/gitrc/grm.sh b/gitrc/grm.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/grm.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+git rm --cached "$1" && echo "$1" >> .gitignore
diff --git a/gitrc/grsh.sh b/gitrc/grsh.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/grsh.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+git reset --hard $1
diff --git a/gitrc/gs.sh b/gitrc/gs.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gs.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+if [ -n "$1" ]
+then
+    git status "$1" 2>&1 | tee gs.findresult
+else
+    git status 2>&1 | tee gs.findresult
+fi
diff --git a/gitrc/gsave.sh b/gitrc/gsave.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gsave.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+git stash \
+    && git stash apply stash@{0}
diff --git a/gitrc/gsearch.sh b/gitrc/gsearch.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gsearch.sh
@@ -0,0 +1,10 @@
+#!/bin/zsh
+
+filesStr=($(< $3))
+git log --binary \
+    --ignore-all-space \
+    --ignore-blank-lines \
+    --ignore-cr-at-eol \
+    --ignore-space-at-eol \
+    --ignore-space-change \
+    -p -G "$1" -- "${filesStr[@]}" > "$2"
diff --git a/gitrc/gsearch.test.sh b/gitrc/gsearch.test.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gsearch.test.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./gsearch.sh GitSearch ~/loadrc/gitsearch.findresult ~/loadrc/gitsearch.findresult.tmp
diff --git a/gitrc/gsh.sh b/gitrc/gsh.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gsh.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+if [ -z "$1" ]
+then
+    echo -e "${red}please specify the file name ... ${NC}"
+    exit 1
+fi
+commits=( $(git log --oneline --format=%H --follow -- "$1") )
+for (( i=0; i<${#commits[@]}; i++ )); do echo ${commits[i]};git difftool -y ${commits[i]}^! "$1"; done
diff --git a/gitrc/gshow.sh b/gitrc/gshow.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gshow.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+git show --minimal -w "$1" | sed "s/^--- a\//--- \.\//g;s/^+++ b\//+++ \.\//g"
diff --git a/gitrc/gsquash.sh b/gitrc/gsquash.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gsquash.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+git merge --squash 4096194ad79
+git commit --no-edit
diff --git a/gitrc/gst.sh b/gitrc/gst.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gst.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+git stash -p
diff --git a/gitrc/gsta.sh b/gitrc/gsta.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gsta.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+if [ -n "$1" ]
+then
+    git stash apply stash@{"$1"}
+    exit 0
+fi
+git stash apply
diff --git a/gitrc/gstf.sh b/gitrc/gstf.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gstf.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+if [ -n "$1" ]
+then
+    git diff --name-status stash@{"$1"}^!
+    exit 0
+fi
+git diff --name-status stash@{0}^!
diff --git a/gitrc/gsti.sh b/gitrc/gsti.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gsti.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+git stash --keep-index
diff --git a/gitrc/gstl.sh b/gitrc/gstl.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gstl.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+git stash list | tee gstl.findresult
diff --git a/gitrc/gstlv.sh b/gitrc/gstlv.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gstlv.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+total=$(( `git stash list|wc -l` - 1 ))
+echo -e "${green}total --> ${total} ${NC}"
+for ((index=0 ; index < $total ; index++))
+do
+  echo -e "${green}current index --> ${index} ${NC}"
+  $HOME/loadrc/gitrc/gstv.sh ${index}
+done
diff --git a/gitrc/gstp.sh b/gitrc/gstp.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gstp.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+if [ -z "$1" ]
+then
+    git stash show -p stash@{0} | git apply --reject --whitespace=fix --recount && git stash drop stash@{0}
+else
+    git stash show -p stash@{"$1"} | git apply --reject --whitespace=fix --recount && git stash drop stash@{"$1"}
+fi
diff --git a/gitrc/gstv.sh b/gitrc/gstv.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gstv.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+if [ -n "$1" ]
+then
+    git difftool -y stash@{"$1"}^!
+    exit 0
+fi
+git difftool -y stash@{0}^!
+touch gstv.ready
diff --git a/gitrc/gsync.sh b/gitrc/gsync.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gsync.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+~/loadrc/gitrc/dogsync.sh
+git submodule status | awk '{print $2}' | parallel --jobs 0 'cd {}; ~/loadrc/gitrc/dogsync.sh; cd -'
diff --git a/gitrc/gtag.sh b/gitrc/gtag.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gtag.sh
@@ -0,0 +1,13 @@
+#!/bin/zsh
+if [ -z "$1" ]
+then
+    echo -e "${red}Please provide tag name... ${NC}"
+    exit 1
+fi
+if [ -z "$2" ]
+then
+    echo -e "${red}Please provide commit message... ${NC}"
+    exit 1
+fi
+git tag "$1" -m "$2"
+~/loadrc/gitrc/gps.sh
diff --git a/gitrc/gvd.sh b/gitrc/gvd.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gvd.sh
@@ -0,0 +1,19 @@
+#!/bin/zsh
+if [ -n "$1" ]
+then
+    if [ -n "$2" ]
+    then
+        git difftool -y "$1" "$2"
+    else
+        COMMAND="git difftool -y $1"
+
+        for ss in $(git config --get-all gdif.ignore)
+        do
+            COMMAND="$COMMAND  ':(exclude)$ss'"
+        done
+
+        eval "$COMMAND"
+    fi
+else
+    git difftool -y --cached
+fi
diff --git a/gitrc/gvlg.sh b/gitrc/gvlg.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gvlg.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+COMMIT="$1"
+git difftool -y "$COMMIT"^!
diff --git a/gitrc/gwap.sh b/gitrc/gwap.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/gwap.sh
@@ -0,0 +1,4 @@
+#!/bin/zsh
+git reset HEAD && \
+    git diff -w --no-color | \
+    git apply --cached --ignore-whitespace
diff --git a/gitrc/include_gitconfig.sh b/gitrc/include_gitconfig.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/include_gitconfig.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+if [ ! -f .gitconfig ]
+then
+    exit 0
+fi
+
+config=$(~/loadrc/gitrc/get_git.sh)
+git config --local include.path $(realpath --relative-to="$config" .gitconfig)
diff --git a/gitrc/parse-github.sh b/gitrc/parse-github.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/parse-github.sh
@@ -0,0 +1,5 @@
+#!/bin/zsh
+repo=$(echo "$1" | sed 's/.*\/\([^\/]*\)\.git/\1/g') 
+author=$(echo "$1" | sed 's/.*[:/]\([^\/]*\)\/[^\/]*\.git/\1/g')
+echo "repo --> $repo"
+echo "author --> $author"
diff --git a/gitrc/parse-github.test.sh b/gitrc/parse-github.test.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/parse-github.test.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./parse-github.sh git@github.com:gluster/glusterfs.git
+./parse-github.sh https://github.com/gluster/glusterfs.git
diff --git a/gitrc/postCommit.sh b/gitrc/postCommit.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/postCommit.sh
@@ -0,0 +1,4 @@
+#!/bin/zsh
+
+~/loadrc/gitrc/gsync.sh
+~/loadrc/bashrc/update_proj.sh
diff --git a/gitrc/reapply.sh b/gitrc/reapply.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/reapply.sh
@@ -0,0 +1,22 @@
+#!/bin/zsh
+
+DIFF="$1"
+cp -fv "$DIFF" "$DIFF".tmp
+clean=$(git status --porcelain)
+
+if [ -n "$clean" ]
+then
+    git stash
+fi
+
+~/loadrc/gitrc/restore.sh
+cp -fv "$DIFF".tmp "$DIFF"
+
+git apply --reject --whitespace=fix --recount "$DIFF" || \
+    echo "git apply failed" && \
+    exit 1
+
+if [ -n "$clean" ]
+then
+    git stash pop stash@{0}
+fi
diff --git a/gitrc/rediff.sh b/gitrc/rediff.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/rediff.sh
@@ -0,0 +1,4 @@
+#!/bin/zsh
+
+DIFF_FILE="$1"
+rediff "$DIFF_FILE" | sponge "$DIFF_FILE"
diff --git a/gitrc/restore.sh b/gitrc/restore.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/restore.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+
+CURRET_BRANCH_DIFF="$(~/loadrc/gitrc/get_current_branch.sh).gdio.diff"
+~/loadrc/gitrc/gdio.sh
+git apply --reject --whitespace=fix --recount --reverse "$CURRET_BRANCH_DIFF" || \
+    echo "git reverse apply failed" && \
+    exit 1
diff --git a/gitrc/restore_deleted.sh b/gitrc/restore_deleted.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/restore_deleted.sh
@@ -0,0 +1,11 @@
+#!/bin/zsh
+
+if [ -z "$1" ]
+then
+    echo -e "${red}Please provide the relative path to file ... ${NC}"
+    exit 1
+fi
+
+# this is used to reset back to the latest change on the file.
+commit=`git rev-list --branches -n 1 HEAD -- "$1"`
+git show "$commit"^:"$1" > "$1"
diff --git a/gitrc/retached.sh b/gitrc/retached.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/retached.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh 
+git branch -a --contains $(git rev-parse HEAD) |grep -v detached
diff --git a/gitrc/subfolder_2_repository.sh b/gitrc/subfolder_2_repository.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/subfolder_2_repository.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+git filter-branch --subdirectory-filter <directory 1> -- --all
diff --git a/gitrc/submodule_update.sh b/gitrc/submodule_update.sh
new file mode 100755
--- /dev/null
+++ ./gitrc/submodule_update.sh
@@ -0,0 +1,5 @@
+#!/bin/zsh
+git submodule init
+git submodule sync
+git submodule foreach ~/loadrc/gitrc/gps.sh || : 
+git submodule foreach ~/loadrc/gitrc/gsync.sh || :
diff --git a/gpurc/.gpurc b/gpurc/.gpurc
new file mode 100644
--- /dev/null
+++ ./gpurc/.gpurc
@@ -0,0 +1,2 @@
+export CUDA_HOME=/usr/local/cuda
+export LD_LIBRARY_PATH=/usr/local/cuda-9.1/lib64:$LD_LIBRARY_PATH
diff --git a/gpurc/etc/modprobe.d/blacklist.conf b/gpurc/etc/modprobe.d/blacklist.conf
new file mode 100644
--- /dev/null
+++ ./gpurc/etc/modprobe.d/blacklist.conf
@@ -0,0 +1,61 @@
+# This file lists those modules which we don't want to be loaded by
+# alias expansion, usually so some other driver will be loaded for the
+# device instead.
+
+# evbug is a debug tool that should be loaded explicitly
+blacklist evbug
+
+# these drivers are very simple, the HID drivers are usually preferred
+blacklist usbmouse
+blacklist usbkbd
+
+# replaced by e100
+blacklist eepro100
+
+# replaced by tulip
+blacklist de4x5
+
+# causes no end of confusion by creating unexpected network interfaces
+blacklist eth1394
+
+# snd_intel8x0m can interfere with snd_intel8x0, doesn't seem to support much
+# hardware on its own (Ubuntu bug #2011, #6810)
+blacklist snd_intel8x0m
+
+# Conflicts with dvb driver (which is better for handling this device)
+blacklist snd_aw2
+
+# causes failure to suspend on HP compaq nc6000 (Ubuntu: #10306)
+blacklist i2c_i801
+
+# replaced by p54pci
+blacklist prism54
+
+# replaced by b43 and ssb.
+blacklist bcm43xx
+
+# most apps now use garmin usb driver directly (Ubuntu: #114565)
+blacklist garmin_gps
+
+# replaced by asus-laptop (Ubuntu: #184721)
+blacklist asus_acpi
+
+# low-quality, just noise when being used for sound playback, causes
+# hangs at desktop session start (Ubuntu: #246969)
+blacklist snd_pcsp
+
+# ugly and loud noise, getting on everyone's nerves; this should be done by a
+# nice pulseaudio bing (Ubuntu: #77010)
+blacklist pcspkr
+
+# EDAC driver for amd76x clashes with the agp driver preventing the aperture
+# from being initialised (Ubuntu: #297750). Blacklist so that the driver
+# continues to build and is installable for the few cases where its
+# really needed.
+blacklist amd76x_edac
+
+blacklist vga16fb
+blacklist nouveau
+blacklist rivafb
+blacklist rivatv
+blacklist nvidiafb
diff --git a/gpurc/etc/pm/sleep.d/nvidia-reload b/gpurc/etc/pm/sleep.d/nvidia-reload
new file mode 100755
--- /dev/null
+++ ./gpurc/etc/pm/sleep.d/nvidia-reload
@@ -0,0 +1,9 @@
+#! /bin/sh
+# Workaround for not working nvidia cuda after suspend
+case $1 in
+    resume|thaw)
+        sudo rmmod nvidia_uvm
+        sudo modprobe nvidia_uvm
+        /etc/init.d/zerotier-one restart
+        ;;
+esac
diff --git a/gpurc/install.sh b/gpurc/install.sh
new file mode 100755
--- /dev/null
+++ ./gpurc/install.sh
@@ -0,0 +1,11 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+if [ $(uname) = "Darwin" ]
+then
+    exit 0
+fi
+
+./install_driver.sh
diff --git a/gpurc/install_driver.sh b/gpurc/install_driver.sh
new file mode 100755
--- /dev/null
+++ ./gpurc/install_driver.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+add-apt-repository ppa:graphics-drivers/ppa -y
+apt-get update
+apt-get -y install $(ubuntu-drivers devices|awk '/recommended/{print $3}')
diff --git a/gpurc/kill_nvidia.sh b/gpurc/kill_nvidia.sh
new file mode 100755
--- /dev/null
+++ ./gpurc/kill_nvidia.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+
+kill -9 $(lsof -t /dev/nvidia0)
diff --git a/gpurc/restart.sh b/gpurc/restart.sh
new file mode 100755
--- /dev/null
+++ ./gpurc/restart.sh
@@ -0,0 +1,5 @@
+#!/bin/zsh
+
+~/loadrc/gpurc/kill_nvidia.sh
+rmmod nvidia_uvm
+modprobe nvidia_uvm
diff --git a/hgrc/hdi.sh b/hgrc/hdi.sh
new file mode 100755
--- /dev/null
+++ ./hgrc/hdi.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+hg diff
diff --git a/host_links/COH-LC172TVQ6J/Users/ying.huang/.gitconfig b/host_links/COH-LC172TVQ6J/Users/ying.huang/.gitconfig
new file mode 100755
--- /dev/null
+++ ./host_links/COH-LC172TVQ6J/Users/ying.huang/.gitconfig
@@ -0,0 +1,96 @@
+[user]
+	name = Ying Huang
+	email = ying.huang@cohesity.com
+[color]
+    ui = auto
+[color "branch"]
+    current = yellow reverse
+    local = yellow
+    remote = green
+[color "status"]
+    added = yellow
+    changed = green
+    untracked = cyan
+[core]
+    whitespace=fix,-indent-with-non-tab,trailing-space,cr-at-eol
+[diff]
+    tool = nvimdiff
+[difftool "nvimdiff"]
+    cmd = nvim -R -f -d \
+        -c 'set winwidth=1' \
+        -c 'wincmd l' -c 'cd $GIT_PREFIX' \
+        "$LOCAL" "$REMOTE"
+[alias]
+    ad = add
+    bi = bisect
+    ci = commit
+    co = checkout
+    rs = reset --hard
+    sm = submodule
+    st = status
+    sta = stash
+    tg = tag -l -n1
+    vd = difftool
+[difftool]
+    prompt = false
+[core]
+    excludesfile = "~/.globalgitignore"
+    mergeoptions = --no-edit
+    fileMode = true
+    editor = nvim
+[giggle]
+    main-window-maximized = true
+    main-window-geometry = 700x550+0+55
+    history-view-vpane-position = 403
+    main-window-view = HistoryView
+    file-view-vpane-position = 609
+[filter "media"]
+    clean = git media clean %f
+    smudge = git media smudge %f
+    required = true
+[push]
+    default = current
+    remote = BareReps
+[pull]
+    default = current
+    rebase = false
+[gdif]
+    ignore = *.diff
+    ignore = .gitconfig
+    ignore = .login
+    ignore = COMMIT_EDITMSG
+    ignore = change
+    ignore = files.proj
+    ignore = files.rev
+    ignore = gbil.log
+    ignore = includefile.conf
+    ignore = includefile.rsync
+    ignore = prunefile.conf
+    ignore = prunefix.conf
+    ignore = prunefix.rsync
+    ignore = readme
+    ignore = rsync.files
+    ignore = setup.cfg
+[filter "lfs"]
+    clean = git-lfs clean -- %f
+    smudge = git-lfs smudge -- %f
+    process = git-lfs filter-process
+    required = true
+[diff "nodiff"]
+    command = /usr/bin/true
+# define command which will be used when "nvim" is set as a merge tool
+# https://www.grzegorowski.com/using-vim-or-neovim-nvim-as-a-git-mergetool
+[mergetool "nvim"]
+    cmd = nvim -f \
+        -c 'set winwidth=1' \
+        -c \"Gvdiffsplit!\" \"$MERGED\"
+# set "nvim" as tool for merging
+[merge]
+    tool = kdiff3
+# automatically launch merge tool without displaying a prompt
+[mergetool]
+    prompt = false
+[merge "ours"]
+	driver = true
+[credential "https://github.com"]
+	helper = !gh auth git-credential
diff --git a/host_links/lint-sandbox/etc/hosts b/host_links/lint-sandbox/etc/hosts
new file mode 100644
--- /dev/null
+++ ./host_links/lint-sandbox/etc/hosts
@@ -0,0 +1,14 @@
+127.0.0.1	localhost
+127.0.1.1	lint-sandbox
+
+# The following lines are desirable for IPv6 capable hosts
+::1     localhost ip6-localhost ip6-loopback
+ff02::1 ip6-allnodes
+ff02::2 ip6-allrouters
+127.0.0.1     localhost.imvu.com
+127.0.0.1     adminlocalhost.imvu.com
+127.0.0.1     avatarlocalhost.imvu.com
+127.0.0.1     feedslocalhost.imvu.com
+127.0.0.1     roomslocalhost.imvu.com
+127.0.0.1     local-customer-sandbox.com
+127.0.0.1     api.localhost.imvu.com
diff --git a/host_links/lint-sandbox/etc/network/interfaces_bak b/host_links/lint-sandbox/etc/network/interfaces_bak
new file mode 100644
--- /dev/null
+++ ./host_links/lint-sandbox/etc/network/interfaces_bak
@@ -0,0 +1,23 @@
+# This file describes the network interfaces available on your system
+# and how to activate them. For more information, see interfaces(5).
+
+# The loopback network interface
+auto lo
+iface lo inet loopback
+
+# The primary network interface
+auto eth0
+iface eth0 inet dhcp
+
+auto eth1
+iface eth1 inet static
+address 192.168.112.14
+netmask 255.255.255.0
+
+#VAGRANT-BEGIN
+# The contents below are automatically generated by Vagrant. Do not modify.
+auto eth1
+iface eth1 inet static
+      address 192.168.112.14
+      netmask 255.255.255.0
+#VAGRANT-END
diff --git a/host_links/mini/etc/default/isc-dhcp-server b/host_links/mini/etc/default/isc-dhcp-server
new file mode 100644
--- /dev/null
+++ ./host_links/mini/etc/default/isc-dhcp-server
@@ -0,0 +1,18 @@
+# Defaults for isc-dhcp-server (sourced by /etc/init.d/isc-dhcp-server)
+
+# Path to dhcpd's config file (default: /etc/dhcp/dhcpd.conf).
+#DHCPDv4_CONF=/etc/dhcp/dhcpd.conf
+#DHCPDv6_CONF=/etc/dhcp/dhcpd6.conf
+
+# Path to dhcpd's PID file (default: /var/run/dhcpd.pid).
+#DHCPDv4_PID=/var/run/dhcpd.pid
+#DHCPDv6_PID=/var/run/dhcpd6.pid
+
+# Additional options to start dhcpd with.
+#	Don't use options -cf or -pf here; use DHCPD_CONF/ DHCPD_PID instead
+#OPTIONS=""
+
+# On what interfaces should the DHCP server (dhcpd) serve DHCP requests?
+#	Separate multiple interfaces with spaces, e.g. "eth0 eth1".
+INTERFACESv4="enp0s25"
+INTERFACESv6="enp0s25"
diff --git a/host_links/mini/etc/dhcp/dhcpd.conf b/host_links/mini/etc/dhcp/dhcpd.conf
new file mode 100644
--- /dev/null
+++ ./host_links/mini/etc/dhcp/dhcpd.conf
@@ -0,0 +1,134 @@
+# dhcpd.conf
+#
+# Sample configuration file for ISC dhcpd
+#
+# Attention: If /etc/ltsp/dhcpd.conf exists, that will be used as
+# configuration file instead of this file.
+#
+
+# option definitions common to all supported networks...
+option domain-name "example.org";
+option domain-name-servers ns1.example.org, ns2.example.org;
+
+default-lease-time 600;
+max-lease-time 7200;
+
+# The ddns-updates-style parameter controls whether or not the server will
+# attempt to do a DNS update when a lease is confirmed. We default to the
+# behavior of the version 2 packages ('none', since DHCP v2 didn't
+# have support for DDNS.)
+ddns-update-style none;
+
+# If this DHCP server is the official DHCP server for the local
+# network, the authoritative directive should be uncommented.
+#authoritative;
+
+# Use this to send dhcp log messages to a different log file (you also
+# have to hack syslog.conf to complete the redirection).
+#log-facility local7;
+
+# No service will be given on this subnet, but declaring it helps the 
+# DHCP server to understand the network topology.
+
+#subnet 10.152.187.0 netmask 255.255.255.0 {
+#}
+
+# This is a very basic subnet declaration.
+
+#subnet 10.254.239.0 netmask 255.255.255.224 {
+#  range 10.254.239.10 10.254.239.20;
+#  option routers rtr-239-0-1.example.org, rtr-239-0-2.example.org;
+#}
+
+# This declaration allows BOOTP clients to get dynamic addresses,
+# which we don't really recommend.
+
+#subnet 10.254.239.32 netmask 255.255.255.224 {
+#  range dynamic-bootp 10.254.239.40 10.254.239.60;
+#  option broadcast-address 10.254.239.31;
+#  option routers rtr-239-32-1.example.org;
+#}
+
+# A slightly different configuration for an internal subnet.
+#subnet 10.5.5.0 netmask 255.255.255.224 {
+#  range 10.5.5.26 10.5.5.30;
+#  option domain-name-servers ns1.internal.example.org;
+#  option domain-name "internal.example.org";
+#  option subnet-mask 255.255.255.224;
+#  option routers 10.5.5.1;
+#  option broadcast-address 10.5.5.31;
+#  default-lease-time 600;
+#  max-lease-time 7200;
+#}
+
+# Hosts which require special configuration options can be listed in
+# host statements.   If no address is specified, the address will be
+# allocated dynamically (if possible), but the host-specific information
+# will still come from the host declaration.
+
+#host passacaglia {
+#  hardware ethernet 0:0:c0:5d:bd:95;
+#  filename "vmunix.passacaglia";
+#  server-name "toccata.example.com";
+#}
+
+# Fixed IP addresses can also be specified for hosts.   These addresses
+# should not also be listed as being available for dynamic assignment.
+# Hosts for which fixed IP addresses have been specified can boot using
+# BOOTP or DHCP.   Hosts for which no fixed address is specified can only
+# be booted with DHCP, unless there is an address range on the subnet
+# to which a BOOTP client is connected which has the dynamic-bootp flag
+# set.
+#host fantasia {
+#  hardware ethernet 08:00:07:26:c0:a5;
+#  fixed-address fantasia.example.com;
+#}
+
+# You can declare a class of clients and then do address allocation
+# based on that.   The example below shows a case where all clients
+# in a certain class get addresses on the 10.17.224/24 subnet, and all
+# other clients get addresses on the 10.0.29/24 subnet.
+
+#class "foo" {
+#  match if substring (option vendor-class-identifier, 0, 4) = "SUNW";
+#}
+
+#shared-network 224-29 {
+#  subnet 10.17.224.0 netmask 255.255.255.0 {
+#    option routers rtr-224.example.org;
+#  }
+#  subnet 10.0.29.0 netmask 255.255.255.0 {
+#    option routers rtr-29.example.org;
+#  }
+#  pool {
+#    allow members of "foo";
+#    range 10.17.224.10 10.17.224.250;
+#  }
+#  pool {
+#    deny members of "foo";
+#    range 10.0.29.10 10.0.29.230;
+#  }
+#}
+
+option domain-name "tecmint.lan";
+option domain-name-servers ns1.tecmint.lan, ns2.tecmint.lan;
+default-lease-time 3600; 
+max-lease-time 7200;
+authoritative;
+
+subnet 192.168.2.0 netmask 255.255.255.0 {
+    option subnet-mask              255.255.255.0;
+    option domain-search            "tecmint.lan";
+    range   192.168.2.10   192.168.2.100;
+    range   192.168.2.110   192.168.2.200;
+}
+
+host imac-node {
+    hardware ethernet 78:7b:8a:ce:e4:01;
+    fixed-address 192.168.2.10;
+}
+
+host server-node {
+    hardware ethernet 10:7b:44:f0:e7:2f;
+    fixed-address 192.168.2.12;
+}
diff --git a/host_links/mini/etc/hosts b/host_links/mini/etc/hosts
new file mode 100644
--- /dev/null
+++ ./host_links/mini/etc/hosts
@@ -0,0 +1,35 @@
+127.0.0.1       localhost
+127.0.1.1       mini
+#192.168.2.2 server
+#192.168.2.144 mldonkey
+#192.168.2.1 ddwrt
+#172.27.83.234 sb
+192.168.112.14 sb
+192.168.122.102 u1804
+192.168.122.65 master-node
+192.168.122.136 slave-node
+192.168.122.244 zsh
+192.168.31.191 work
+172.27.217.162 localhost.imvu.com
+192.168.31.31 server
+192.168.31.147 imacpro
+172.27.68.119 imac
+172.27.118.58 vagrant
+192.168.31.99 mldonkey
+192.168.31.41 u2004
+10.211.55.5 macos
+192.168.123.177 ubuntu20.04
+192.168.31.168 mbp # wifi
+#192.168.31.96 mbp # wired
+192.168.123.80 u2110
+192.168.31.99 haikou
+192.168.31.223 transmission
+192.168.31.29 mba
+192.168.31.56 pikvm
+
+# The following lines are desirable for IPv6 capable hosts
+::1     ip6-localhost ip6-loopback
+fe00::0 ip6-localnet
+ff00::0 ip6-mcastprefix
+ff02::1 ip6-allnodes
+ff02::2 ip6-allrouters
diff --git a/host_links/mini/etc/netplan/00-installer-config.yaml_bak b/host_links/mini/etc/netplan/00-installer-config.yaml_bak
new file mode 100644
--- /dev/null
+++ ./host_links/mini/etc/netplan/00-installer-config.yaml_bak
@@ -0,0 +1,12 @@
+network:
+  ethernets:
+    eth0:
+      addresses:
+        - 192.168.31.140/24
+  version: 2
+
+  bridges:
+    br0:
+      interfaces: [eth0]
+      addresses:
+        - 192.168.31.140/24
diff --git a/host_links/mini/root/.fastai/config.yml b/host_links/mini/root/.fastai/config.yml
new file mode 100644
--- /dev/null
+++ ./host_links/mini/root/.fastai/config.yml
@@ -0,0 +1,5 @@
+archive_path: /media/volgrp/fastai/archive/
+data_path: /media/volgrp/fastai/data/
+model_path: /media/volgrp/fastai/models/
+storage_path: /tmp
+version: 2
diff --git a/host_links/movie/etc/network/interfaces_bak b/host_links/movie/etc/network/interfaces_bak
new file mode 100644
--- /dev/null
+++ ./host_links/movie/etc/network/interfaces_bak
@@ -0,0 +1,14 @@
+# interfaces(5) file used by ifup(8) and ifdown(8)
+auto lo
+iface lo inet loopback
+
+auto enp5s7
+iface enp5s7 inet static
+address 192.168.1.2
+netmask 255.255.255.0
+
+#auto enp4s0
+#iface enp4s0 inet static
+#address 192.168.2.125
+#netmask 255.255.255.0
+#iface enp4s0 inet manual
diff --git a/host_links/server/etc/hosts b/host_links/server/etc/hosts
new file mode 100644
--- /dev/null
+++ ./host_links/server/etc/hosts
@@ -0,0 +1,23 @@
+127.0.0.1       localhost
+127.0.1.1       server
+192.168.31.127 u1804
+192.168.31.111 u2004
+172.27.217.162 localhost.imvu.com
+192.168.31.140 mini
+192.168.123.132 minds
+192.168.31.153 gluster00
+192.168.31.129 gluster01
+192.168.31.115 gluster02
+192.168.31.99 mldonkey
+192.168.31.147 imacpro
+172.27.68.119 imac
+192.168.31.96 mbp
+192.168.31.162 mbp2
+192.168.31.88 transmission
+
+# The following lines are desirable for IPv6 capable hosts
+::1     ip6-localhost ip6-loopback
+fe00::0 ip6-localnet
+ff00::0 ip6-mcastprefix
+ff02::1 ip6-allnodes
+ff02::2 ip6-allrouters
diff --git a/host_links/server/etc/network/interfaces_bak b/host_links/server/etc/network/interfaces_bak
new file mode 100644
--- /dev/null
+++ ./host_links/server/etc/network/interfaces_bak
@@ -0,0 +1,20 @@
+# interfaces(5) file used by ifup(8) and ifdown(8)
+auto lo
+iface lo inet loopback
+
+#auto br0
+#iface br0 inet static
+#address 192.168.2.2
+#bridge_ports eth0
+#bridge_stp off
+#bridge_fd 0
+#bridge_maxwait 0
+
+#auto eth0
+#iface eth0 inet static
+#address 192.168.2.2
+#auto br0
+#iface br0 inet dhcp
+#   bridge_ports eth0
+#   bridge_stp on
+#   bridge_fd 0.0
diff --git a/host_links/server/root/.fastai/config.yml b/host_links/server/root/.fastai/config.yml
new file mode 100644
--- /dev/null
+++ ./host_links/server/root/.fastai/config.yml
@@ -0,0 +1,5 @@
+archive_path: /media/nvme/fastai/archive
+data_path: /media/nvme/fastai/data/
+model_path: /media/nvme/fastai/models/
+storage_path: /tmp
+version: 2
diff --git a/host_links/toshiba/etc/systemd/logind.conf b/host_links/toshiba/etc/systemd/logind.conf
new file mode 100644
--- /dev/null
+++ ./host_links/toshiba/etc/systemd/logind.conf
@@ -0,0 +1,37 @@
+#  This file is part of systemd.
+#
+#  systemd is free software; you can redistribute it and/or modify it
+#  under the terms of the GNU Lesser General Public License as published by
+#  the Free Software Foundation; either version 2.1 of the License, or
+#  (at your option) any later version.
+#
+# Entries in this file show the compile time defaults.
+# You can change settings by editing this file.
+# Defaults can be restored by simply deleting this file.
+#
+# See logind.conf(5) for details.
+
+[Login]
+#NAutoVTs=6
+#ReserveVT=6
+#KillUserProcesses=no
+#KillOnlyUsers=
+#KillExcludeUsers=root
+#InhibitDelayMaxSec=5
+#HandlePowerKey=poweroff
+#HandleSuspendKey=suspend
+#HandleHibernateKey=hibernate
+HandleLidSwitch=ignore
+#HandleLidSwitchDocked=ignore
+#PowerKeyIgnoreInhibited=no
+#SuspendKeyIgnoreInhibited=no
+#HibernateKeyIgnoreInhibited=no
+#LidSwitchIgnoreInhibited=yes
+#HoldoffTimeoutSec=30s
+#IdleAction=ignore
+#IdleActionSec=30min
+#RuntimeDirectorySize=10%
+#RemoveIPC=yes
+#InhibitorsMax=8192
+#SessionsMax=8192
+#UserTasksMax=33%
diff --git a/host_links/ubuntu/etc/hosts b/host_links/ubuntu/etc/hosts
new file mode 100644
--- /dev/null
+++ ./host_links/ubuntu/etc/hosts
@@ -0,0 +1,10 @@
+127.0.0.1	localhost
+127.0.1.1	ubuntu
+192.168.2.2 server 	
+
+# The following lines are desirable for IPv6 capable hosts
+::1     ip6-localhost ip6-loopback
+fe00::0 ip6-localnet
+ff00::0 ip6-mcastprefix
+ff02::1 ip6-allnodes
+ff02::2 ip6-allrouters
diff --git a/host_links/ubuntu/etc/network/interfaces_bak b/host_links/ubuntu/etc/network/interfaces_bak
new file mode 100644
--- /dev/null
+++ ./host_links/ubuntu/etc/network/interfaces_bak
@@ -0,0 +1,8 @@
+# interfaces(5) file used by ifup(8) and ifdown(8)
+auto lo
+iface lo inet loopback
+
+auto enp0s6
+iface enp0s6 inet static
+address 192.168.1.4
+netmask 255.255.255.0
diff --git a/host_links/ubuntu/home/parallels/.config/smplayer/smplayer.ini b/host_links/ubuntu/home/parallels/.config/smplayer/smplayer.ini
new file mode 100644
--- /dev/null
+++ ./host_links/ubuntu/home/parallels/.config/smplayer/smplayer.ini
@@ -0,0 +1,626 @@
+[%General]
+add_blackborders_on_fullscreen=false
+alang=
+audio_equalizer=0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+autoload_m4a=true
+autoq=6
+autosync=false
+autosync_factor=100
+config_version=5
+disable_screensaver=true
+driver\audio_output=
+driver\vo=
+file_settings_method=hash
+global_audio_equalizer=true
+global_volume=true
+mc_value=0
+min_step=4
+mplayer_bin=/usr/bin/mplayer
+mute=false
+osd=0
+osd_bar_pos=80
+osd_delay=5000
+osd_fractions=false
+osd_scale=1
+osd_show_filename_duration=2000
+remember_media_settings=true
+remember_stream_settings=true
+remember_time_pos=true
+screenshot_folder=/home/parallels/Pictures/smplayer_screenshots
+screenshot_format=jpg
+screenshot_template=cap_%F_%p_%02n
+slang=
+softvol_max=110
+subfont_osd_scale=3
+tablet_mode=false
+use_audio_equalizer=false
+use_direct_rendering=false
+use_double_buffer=true
+use_hwac3=false
+use_mc=false
+use_scaletempo=-1
+use_screenshot=true
+use_slices=false
+use_soft_video_eq=false
+use_soft_vol=true
+vdpau_disable_video_filters=true
+vdpau_ffh264vdpau=true
+vdpau_ffhevcvdpau=false
+vdpau_ffmpeg12vdpau=true
+vdpau_ffodivxvdpau=false
+vdpau_ffvc1vdpau=true
+vdpau_ffwmv3vdpau=true
+volume=200
+
+[actions]
+ab_menu=
+about_smplayer=
+add_bookmark=Ctrl+A
+add_letterbox=
+add_noise=
+angles_menu=
+aspect_11%3A8=
+aspect_14%3A10=
+aspect_14%3A9=
+aspect_16%3A10=
+aspect_16%3A9=
+aspect_1%3A1=
+aspect_2.35%3A1=
+aspect_3%3A2=
+aspect_4%3A3=
+aspect_5%3A4=
+aspect_detect=
+aspect_menu=
+aspect_none=
+audio_delay=
+audio_equalizer=
+audiochannels_menu=
+audiofilter_menu=
+audiotrack_menu=
+auto_zoom=Shift+W
+autodetect_phase=
+blur=
+bookmarks_menu=
+cc_ch_1=
+cc_ch_2=
+cc_ch_3=
+cc_ch_4=
+cc_none=
+channels_default=
+channels_ful51=
+channels_ful61=
+channels_ful71=
+channels_stereo=
+channels_surround=
+chapters_menu=
+check_updates=
+cl_options=
+clear_ab_markers=
+clear_recents=
+close=Ctrl+X
+closed_captions_menu=
+compact=Ctrl+C
+deblock=
+dec_audio_delay=-
+dec_brightness=3
+dec_contrast=1
+dec_gamma=
+dec_hue=5
+dec_osd_scale=Shift+Y
+dec_saturation=7
+dec_speed=[
+dec_speed_1=
+dec_speed_4=
+dec_sub_delay=Z
+dec_sub_pos=R
+dec_sub_scale=Shift+R
+dec_sub_step=G
+dec_zoom=W
+decrease_volume="-, /, Volume Down"
+deinterlace_kern=
+deinterlace_l5=
+deinterlace_lb=
+deinterlace_menu=
+deinterlace_none=
+deinterlace_yadif0=
+deinterlace_yadif1=
+denoise_menu=
+denoise_none=
+denoise_normal=
+denoise_soft=
+dering=
+disc_menu=
+donate=
+double_speed=}
+earwax_filter=
+edit_bookmarks=
+edit_control1=
+edit_control2=
+edit_floating_control=
+edit_main_toolbar=
+edit_radio_list=
+edit_tv_list=
+exit_fullscreen=Esc
+extrastereo_filter=
+faq=
+favorites_menu=
+first_steps=
+flip=
+forward1="Right, Ctrl+Shift+F"
+forward2="H, Up"
+forward3="J, PgUp"
+frame_back_step=","
+frame_step=.
+fullscreen="F, Ctrl+T"
+gradfun=
+halve_speed={
+inc_audio_delay=+
+inc_brightness=4
+inc_contrast=2
+inc_gamma=
+inc_hue=6
+inc_osd_scale=Shift+U
+inc_saturation=8
+inc_speed=]
+inc_speed_1=
+inc_speed_4=
+inc_sub_delay=X
+inc_sub_pos=T
+inc_sub_scale=Shift+T
+inc_sub_step=Y
+inc_zoom=E
+increase_volume="=, *, Volume Up"
+jump_radio_list=
+jump_to=G
+jump_tv_list=
+karaoke_filter=
+left_channel=
+load_audio_file=
+load_subs=
+mirror=
+mono=
+move_down=Alt+Down
+move_left=Alt+Left
+move_right=Alt+Right
+move_up=Alt+Up
+multiple_screenshots=Shift+D
+mute="M, Volume Mute"
+next_aspect=A
+next_audio=
+next_bookmark=Ctrl+N
+next_chapter=@@
+next_osd=O
+next_radio=Shift+H
+next_subtitle=
+next_tv=
+next_video=
+next_wheel_function=
+normal_speed=Backspace
+on_top_always=
+on_top_never=
+on_top_playing=
+ontop_menu=
+open_audio_cd=
+open_bluray=
+open_bluray_folder=
+open_directory=
+open_dvd=
+open_dvd_folder=
+open_file=Ctrl+F
+open_playlist=
+open_url=Ctrl+U
+open_vcd=
+osd_fractions=
+osd_menu=
+osd_none=
+osd_seek=
+osd_timer=
+osd_total=
+pause="Space, Media Pause"
+pause_and_frame_step=
+pl_add_current=
+pl_add_directory=
+pl_add_files=
+pl_add_urls=
+pl_chromecast=
+pl_copy_url=
+pl_delete_from_disk=
+pl_edit=
+pl_move_down=
+pl_move_up=
+pl_next=N
+pl_open=
+pl_open_folder=
+pl_open_url=
+pl_play=
+pl_prev=P
+pl_remove_all=
+pl_remove_selected=
+pl_repeat=
+pl_save=
+pl_save_as=
+pl_show_duration_column=
+pl_show_filename_column=
+pl_show_name_column=
+pl_show_position_column=
+pl_show_search=
+pl_shuffle=
+play=P
+play_next=">, Media Next"
+play_on_chromecast=
+play_or_pause="Media Play, Toggle Media Play/Pause"
+play_prev="<, Media Previous"
+postprocessing=
+prev_bookmark=Ctrl+B
+prev_chapter=!
+previous_radio=Shift+L
+previous_tv=
+quick_access_menu=
+quit=N
+radio_menu=
+recents_menu=
+repeat=
+reset_audio_equalizer=
+reset_video_equalizer=
+reset_zoom=Shift+E
+restore\hide=
+reverse_channels=
+rewind1="Left, Ctrl+Shift+B"
+rewind2="Down, L"
+rewind3="K, PgDown"
+right_channel=
+rotate_clockwise=
+rotate_clockwise_flip=
+rotate_counterclockwise=
+rotate_counterclockwise_flip=
+rotate_menu=
+rotate_none=
+screens_info=
+screenshot=S
+screenshot_with_subtitles=Ctrl+Shift+S
+screenshot_without_subtitles=Ctrl+Alt+S
+secondary_subtitles_track_menu=
+seek_next_sub=Ctrl+Right
+seek_prev_sub=Ctrl+Left
+send_audio_menu=
+send_to_screen_1=
+send_to_screen_menu=
+set_a_marker=
+set_b_marker=
+sharpen=
+show_config=
+show_context_menu=
+show_file_properties=Ctrl+I
+show_filename_osd=Shift+O
+show_find_sub_dialog=
+show_info_osd=Shift+I
+show_main_toolbar=F5
+show_mplayer_log=Ctrl+M
+show_playlist=Ctrl+L
+show_preferences=Ctrl+P
+show_smplayer_log=Ctrl+S
+show_time=I
+show_tray_icon=
+show_tube_browser=F11
+size_100=Ctrl+1
+size_125=
+size_150=
+size_175=
+size_200=Ctrl+2
+size_300=
+size_400=
+size_50=
+size_75=
+speed_menu=
+stereo=
+stereo_3d_filter=
+stereomode_menu=
+stop=Media Stop
+sub_delay=
+sub_fps_23976=
+sub_fps_24=
+sub_fps_25=
+sub_fps_29970=
+sub_fps_30=
+sub_fps_none=
+subfps_menu=
+subtitle_visibility=V
+subtitlestrack_menu=
+tablet_mode=
+titles_menu=
+toggle_bitrate_info=
+toggle_deinterlacing=D
+toggle_double_size=Ctrl+D
+toggle_format_info=
+toggle_frame_counter=
+toggle_stay_on_top=
+toggle_video_info=
+tv_menu=
+unload_audio_file=
+unload_subs=
+unsharp_menu=
+unsharp_off=
+upload_subtitles=
+upscaling=
+use_custom_sub_style=
+use_forced_subs_only=
+use_milliseconds=
+video_equalizer=Ctrl+E
+video_preview=
+videofilter_menu=
+videosize_menu=
+videotrack_menu=
+volnorm_filter=
+zoom_169=Shift+A
+zoom_235=Shift+S
+zoom_menu=
+
+[advanced]
+actions_to_run=
+autosave_mplayer_log=false
+change_video_equalizer_on_startup=true
+correct_pts=-1
+emulate_mplayer_ab_section=false
+log_filter=.*
+log_mplayer=true
+log_smplayer=true
+monitor_aspect=
+mplayer_additional_audio_filters=
+mplayer_additional_options=
+mplayer_additional_video_filters=
+mplayer_log_saveto=
+mplayer_osd_media_info=
+mpv_osd_media_info=
+prefer_ipv4=true
+repaint_video_background=true
+save_smplayer_log=false
+show_tag_in_window_title=true
+time_to_kill_player=5000
+use_edl_files=true
+use_idx=false
+use_lavf_demuxer=false
+use_mplayer_window=false
+use_mpris2=true
+use_native_open_dialog=true
+use_pausing_keep_force=true
+use_playlist_option=false
+use_short_pathnames=false
+verbose_log=false
+
+[base_gui_plus]
+compact_playlist_was_visible=false
+fullscreen_playlist_was_floating=true
+fullscreen_playlist_was_visible=false
+ignore_playlist_events=false
+mainwindow_visible=true
+show_tray_icon=false
+trayicon_playlist_was_visible=false
+widgets_size=144
+
+[chromecast]
+server\directory_listing=true
+server\local_address=
+server\port=8010
+subtitles\autoconvert_to_vtt=true
+subtitles\overwrite_vtt=false
+subtitles\position=-1
+subtitles\position_on_screen=93
+subtitles\text_filter=
+subtitles\use_sub_filter=true
+
+[default_gui]
+actions\controlwidget\1=play_or_pause, stop, separator, rewindbutton_action, timeslider_action, forwardbutton_action, separator, fullscreen, mute, volumeslider_action
+actions\controlwidget_mini\1=play_or_pause, stop, separator, rewind1, timeslider_action, forward1, separator, mute, volumeslider_action
+actions\floating_control\1=play_or_pause, stop, separator, rewind1, current_timelabel_action, timeslider_action, total_timelabel_action, forward1, separator, fullscreen, mute, volumeslider_action
+actions\toolbar1\2=open_file, open_url, favorites_menu, separator, screenshot, separator, show_file_properties, show_playlist, show_tube_browser, separator, show_preferences, separator, play_prev, play_next, separator, audiotrack_menu, subtitlestrack_menu
+bitrate_info=false
+compact_toolbar1_was_visible=true
+format_info=false
+frame_counter=false
+fullscreen_toolbar1_was_visible=true
+pos=@Point(0 0)
+size=@Size(5120 2880)
+state=2
+toolbars_icon_size\controlwidget=@Size(40 40)
+toolbars_icon_size\controlwidget_mini=@Size(24 24)
+toolbars_icon_size\floating_control=@Size(48 48)
+toolbars_icon_size\toolbar1=@Size(32 32)
+toolbars_state=@ByteArray(\0\0\0\xff\0\0\x17\x11\xfd\0\0\0\x1\0\0\0\x3\0\0\0\0\0\0\0\0\xfc\x1\0\0\0\x1\xfb\0\0\0\x18\0p\0l\0\x61\0y\0l\0i\0s\0t\0\x64\0o\0\x63\0k\x2\0\0\0\0\0\0\0\0\0\0\0\x64\0\0\0\x1e\0\0\x14\0\0\0\n\xb0\0\0\0\x4\0\0\0\x4\0\0\0\b\0\0\0\b\xfc\0\0\0\x2\0\0\0\x2\0\0\0\x1\0\0\0\x10\0t\0o\0o\0l\0\x62\0\x61\0r\0\x31\x1\0\0\0\0\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\0\x3\0\0\0\x2\0\0\0\x1a\0\x63\0o\0n\0t\0r\0o\0l\0w\0i\0\x64\0g\0\x65\0t\x1\0\0\0\0\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\0$\0\x63\0o\0n\0t\0r\0o\0l\0w\0i\0\x64\0g\0\x65\0t\0_\0m\0i\0n\0i\0\0\0\0\0\xff\xff\xff\xff\0\0\0\0\0\0\0\0)
+use_milliseconds=false
+video_info=false
+
+[defaults]
+audio_channels=0
+initial_audio_equalizer=0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+initial_blackborders=false
+initial_brightness=0
+initial_contrast=0
+initial_deinterlace=0
+initial_gamma=0
+initial_hue=0
+initial_postprocessing=false
+initial_saturation=0
+initial_stereo_mode=0
+initial_sub_pos=100
+initial_sub_scale=5
+initial_sub_scale_ass=1
+initial_volnorm=false
+initial_volume=200
+initial_zoom_factor=1
+preferred_audio_track=0
+preferred_subtitle_track=0
+
+[directories]
+last_dvd_directory=
+save_dirs=true
+
+[drives]
+bluray_device=
+cdrom_device=/dev/cdrom
+dvd_device=/dev/dvd
+vcd_initial_title=2
+
+[filter_options]
+acompressor=
+blur=lc:-1.5
+deblock=vb/hb
+denoise_normal=
+denoise_soft=2:1:2
+gradfun=
+noise=9ah:5ah
+sharpen=lc:1.5
+volnorm=1
+
+[floating_control]
+activation_area=1
+animated=true
+display_in_compact_mode=false
+hide_delay=3000
+margin=0
+width=100
+
+[gui]
+allow_video_movement=false
+auto_add_to_playlist=true
+auto_shutdown_pc=false
+balloon_count=5
+center_window=false
+center_window_if_outside=false
+close_on_finish=true
+compact_mode=false
+default_font=
+default_size=@Size(683 509)
+delay_left_click=false
+dockable_playlist=true
+drag_function=1
+fullscreen=false
+global_shortcuts_grabbed_keys=511
+gui=DefaultGUI
+gui_minimum_width=0
+hide_video_window_on_audio_files=true
+iconset=H2O
+language=
+media_to_add_to_playlist=0
+mouse_double_click_function=fullscreen
+mouse_left_click_function=
+mouse_middle_click_function=mute
+mouse_right_click_function=show_context_menu
+mouse_wheel_function=2
+mouse_xbutton1_click_function=
+mouse_xbutton2_click_function=
+pause_when_hidden=false
+precise_seeking=true
+qt_style=Fusion
+relative_seeking=false
+report_mplayer_crashes=true
+report_player_crashes=true
+reported_mplayer_is_old=false
+reset_stop=false
+resize_method=0
+restore_pos_after_fullscreen=false
+save_window_size_on_exit=true
+seeking1=10
+seeking2=60
+seeking3=600
+seeking4=30
+size_factor=100
+start_in_fullscreen=false
+stay_on_top=0
+time_slider_drag_delay=100
+update_while_seeking=false
+use_global_shortcuts=false
+use_player_shortcuts_in_playlist=false
+wheel_function_cycle=30
+wheel_function_seeking_reverse=false
+
+[history]
+recents\max_items=10
+urls=@Invalid()
+urls\max_items=50
+
+[instances]
+single_instance_enabled=true
+
+[mplayer_info]
+is_mplayer2=false
+mplayer2_detected_version=
+mplayer_detected_version=37540
+mplayer_user_supplied_version=-1
+
+[performance]
+HD_height=720
+cache_auto=true
+cache_for_audiocds=1024
+cache_for_dvds=0
+cache_for_files=2048
+cache_for_streams=2048
+cache_for_tv=3000
+cache_for_vcds=1024
+coreavc=false
+frame_drop=false
+h264_skip_loop_filter=1
+hard_frame_drop=false
+hwdec=no
+threads=1
+
+[proxy]
+host=
+password=
+port=0
+type=3
+use_proxy=false
+username=
+
+[reminder]
+count=5
+
+[streaming]
+streaming\youtube\quality=22
+streaming\youtube\resolution=4
+streaming\youtube\use_dash=true
+streaming\youtube\user_agent=
+streaming\youtube\yt_use_https_main=false
+streaming\youtube\yt_use_https_vi=false
+streaming\youtube\yt_user_agent="Mozilla/5.0 (X11; Linux x86_64; rv:5.0.1) Gecko/20100101 Firefox/5.0.1"
+streaming_type=1
+ytdl_quality=
+
+[subtitles]
+ass_line_spacing=0
+autoload_sub=true
+change_sub_scale_should_restart=-1
+enable_ass_styles=true
+enca_lang=
+fast_load_sub=true
+force_ass_styles=false
+freetype_support=true
+styles\backcolor\argb=ff000000
+styles\backgroundcolor\argb=ff000000
+styles\bold=false
+styles\borderstyle=1
+styles\fontname=Arial
+styles\fontsize=20
+styles\halignment=2
+styles\italic=false
+styles\marginl=20
+styles\marginr=20
+styles\marginv=8
+styles\outline=0.3
+styles\outlinecolor\argb=ff000000
+styles\primarycolor\argb=ffffffff
+styles\shadow=1
+styles\valignment=0
+sub_visibility=false
+subcp=ISO-8859-1
+subfuzziness=1
+subtitles_on_screenshots=false
+use_ass_subtitles=true
+use_enca=false
+use_forced_subs_only=false
+user_forced_ass_style=
+
+[tv]
+check_channels_conf_on_startup=true
+initial_tv_deinterlace=4
+last_dvb_channel=
+last_tv_channel=
diff --git a/host_links/ubuntu/todos.sh b/host_links/ubuntu/todos.sh
new file mode 100755
--- /dev/null
+++ ./host_links/ubuntu/todos.sh
@@ -0,0 +1,17 @@
+#!/bin/zsh
+
+mkdir -p ~/.local/share/shotwell/data/
+ln -fs /media/psf/Dropbox/.local/share/shotwell/data/photo.db ~/.local/share/shotwell/data/photo.db
+ln -fs /media/psf/Dropbox/.config/smplayer ~/.config/smplayer
+apt-get purge -y totem totem-plugins
+apt-get install -y \
+    ibus-table \
+    ibus-table-wubi \
+    mosh \
+    mplayer \
+    realpath  \
+    smplayer \
+    ssh \
+    sshfs \
+    tmux \
+    vim-gnome
diff --git a/host_links/vserver/etc/network/interfaces b/host_links/vserver/etc/network/interfaces
new file mode 100644
--- /dev/null
+++ ./host_links/vserver/etc/network/interfaces
@@ -0,0 +1,12 @@
+# interfaces(5) file used by ifup(8) and ifdown(8)
+auto lo
+iface lo inet loopback
+
+auto br0
+iface br0 inet dhcp
+bridge_ports enp2s0
+bridge_stp off
+bridge_fd 0
+bridge_maxwait 0
+
+iface wlp3s0 inet manual
diff --git a/hosts/imac/Library/Application Support/ZeroTier/One/identity.public b/hosts/imac/Library/Application Support/ZeroTier/One/identity.public
new file mode 100644
--- /dev/null
+++ ./hosts/imac/Library/Application Support/ZeroTier/One/identity.public	
@@ -0,0 +1 @@
+3514f4059a:0:2b3519372919a1e3770cf451f601b87dc9fd42bb91e96acfc3ab6ad5cde1287d14d273a44e970dba45e6b02d4c0a3c7a9bd432a8ea917b02233df3baf61c318e
\ No newline at end of file
diff --git a/hosts/imac/Library/Application Support/ZeroTier/One/identity.secret b/hosts/imac/Library/Application Support/ZeroTier/One/identity.secret
new file mode 100644
--- /dev/null
+++ ./hosts/imac/Library/Application Support/ZeroTier/One/identity.secret	
@@ -0,0 +1 @@
+3514f4059a:0:2b3519372919a1e3770cf451f601b87dc9fd42bb91e96acfc3ab6ad5cde1287d14d273a44e970dba45e6b02d4c0a3c7a9bd432a8ea917b02233df3baf61c318e:e77005a01420c408655c9278f5387574b64cfa8d6c240a3114f381189d02e073176646b0223067c3ed1ed5f8623022368fae109f37c8be6c9b262012137a2cae
\ No newline at end of file
diff --git a/hosts/imacpro/Users/huangyingw/.config/karabiner/karabiner.json b/hosts/imacpro/Users/huangyingw/.config/karabiner/karabiner.json
new file mode 100644
--- /dev/null
+++ ./hosts/imacpro/Users/huangyingw/.config/karabiner/karabiner.json
@@ -0,0 +1,185 @@
+{
+    "global": {
+        "check_for_updates_on_startup": true,
+        "show_in_menu_bar": true,
+        "show_profile_name_in_menu_bar": false
+    },
+    "profiles": [
+        {
+            "complex_modifications": {
+                "parameters": {
+                    "basic.simultaneous_threshold_milliseconds": 50,
+                    "basic.to_delayed_action_delay_milliseconds": 500,
+                    "basic.to_if_alone_timeout_milliseconds": 1000,
+                    "basic.to_if_held_down_threshold_milliseconds": 500,
+                    "mouse_motion_to_scroll.speed": 100
+                },
+                "rules": []
+            },
+            "devices": [
+                {
+                    "disable_built_in_keyboard_if_exists": false,
+                    "fn_function_keys": [],
+                    "identifiers": {
+                        "is_keyboard": true,
+                        "is_pointing_device": false,
+                        "product_id": 50475,
+                        "vendor_id": 1133
+                    },
+                    "ignore": false,
+                    "manipulate_caps_lock_led": false,
+                    "simple_modifications": [
+                        {
+                            "from": {
+                                "key_code": "right_option"
+                            },
+                            "to": {
+                                "key_code": "right_control"
+                            }
+                        }
+                    ]
+                },
+                {
+                    "disable_built_in_keyboard_if_exists": false,
+                    "fn_function_keys": [],
+                    "identifiers": {
+                        "is_keyboard": true,
+                        "is_pointing_device": true,
+                        "product_id": 45913,
+                        "vendor_id": 1133
+                    },
+                    "ignore": false,
+                    "manipulate_caps_lock_led": false,
+                    "simple_modifications": []
+                }
+            ],
+            "fn_function_keys": [
+                {
+                    "from": {
+                        "key_code": "f1"
+                    },
+                    "to": {
+                        "key_code": "display_brightness_decrement"
+                    }
+                },
+                {
+                    "from": {
+                        "key_code": "f2"
+                    },
+                    "to": {
+                        "key_code": "display_brightness_increment"
+                    }
+                },
+                {
+                    "from": {
+                        "key_code": "f3"
+                    },
+                    "to": {
+                        "key_code": "f3"
+                    }
+                },
+                {
+                    "from": {
+                        "key_code": "f4"
+                    },
+                    "to": {
+                        "key_code": "f5"
+                    }
+                },
+                {
+                    "from": {
+                        "key_code": "f5"
+                    },
+                    "to": {
+                        "key_code": "f5"
+                    }
+                },
+                {
+                    "from": {
+                        "key_code": "f6"
+                    },
+                    "to": {
+                        "key_code": "f5"
+                    }
+                },
+                {
+                    "from": {
+                        "key_code": "f7"
+                    },
+                    "to": {
+                        "key_code": "rewind"
+                    }
+                },
+                {
+                    "from": {
+                        "key_code": "f8"
+                    },
+                    "to": {
+                        "key_code": "play_or_pause"
+                    }
+                },
+                {
+                    "from": {
+                        "key_code": "f9"
+                    },
+                    "to": {
+                        "key_code": "f9"
+                    }
+                },
+                {
+                    "from": {
+                        "key_code": "f10"
+                    },
+                    "to": {
+                        "key_code": "mute"
+                    }
+                },
+                {
+                    "from": {
+                        "key_code": "f11"
+                    },
+                    "to": {
+                        "key_code": "volume_decrement"
+                    }
+                },
+                {
+                    "from": {
+                        "key_code": "f12"
+                    },
+                    "to": {
+                        "key_code": "volume_increment"
+                    }
+                }
+            ],
+            "name": "Default profile",
+            "parameters": {
+                "delay_milliseconds_before_open_device": 1000
+            },
+            "selected": true,
+            "simple_modifications": [
+                {
+                    "from": {
+                        "key_code": "caps_lock"
+                    },
+                    "to": {
+                        "key_code": "tab"
+                    }
+                },
+                {
+                    "from": {
+                        "key_code": "right_option"
+                    },
+                    "to": {
+                        "key_code": "right_control"
+                    }
+                }
+            ],
+            "virtual_hid_keyboard": {
+                "caps_lock_delay_milliseconds": 0,
+                "country_code": 0,
+                "keyboard_type": "ansi",
+                "mouse_key_xy_scale": 100
+            }
+        }
+    ]
+}
\ No newline at end of file
diff --git a/hosts/imacpro/var/lib/zerotier-one/identity.public b/hosts/imacpro/var/lib/zerotier-one/identity.public
new file mode 100644
--- /dev/null
+++ ./hosts/imacpro/var/lib/zerotier-one/identity.public
@@ -0,0 +1 @@
+8f033dafd3:0:afa8b46ec2fd00ba524f5d549bf4e8d34263c96ca48630e6c6a107961e7a2c54e754f7d25a526114734923290166b12d90d41e0218fa5ddef9dbc3bdff717a60
\ No newline at end of file
diff --git a/hosts/imacpro/var/lib/zerotier-one/identity.secret b/hosts/imacpro/var/lib/zerotier-one/identity.secret
new file mode 100644
--- /dev/null
+++ ./hosts/imacpro/var/lib/zerotier-one/identity.secret
@@ -0,0 +1 @@
+8f033dafd3:0:afa8b46ec2fd00ba524f5d549bf4e8d34263c96ca48630e6c6a107961e7a2c54e754f7d25a526114734923290166b12d90d41e0218fa5ddef9dbc3bdff717a60:dadcbbfc2bf3a0f0f43defe79f1fc4a9f4a938e26f0f95d1460215be4e4cd2be229bfd008ff6d4643a0c380c7f482bb4fcf78735490e4cc8262dd7e806446169
\ No newline at end of file
diff --git a/hosts/lint-sandbox/var/lib/zerotier-one/identity.public b/hosts/lint-sandbox/var/lib/zerotier-one/identity.public
new file mode 100644
--- /dev/null
+++ ./hosts/lint-sandbox/var/lib/zerotier-one/identity.public
@@ -0,0 +1 @@
+8d65312453:0:3b55354a89f6c816e643d9eda89a21ec4c4843e825114c5e65fadd9580383e247cb6d0e363288f00f17a1d5e75a0fc9e1119c27167843b183789ab8d36847389
\ No newline at end of file
diff --git a/hosts/lint-sandbox/var/lib/zerotier-one/identity.secret b/hosts/lint-sandbox/var/lib/zerotier-one/identity.secret
new file mode 100644
--- /dev/null
+++ ./hosts/lint-sandbox/var/lib/zerotier-one/identity.secret
@@ -0,0 +1 @@
+8d65312453:0:3b55354a89f6c816e643d9eda89a21ec4c4843e825114c5e65fadd9580383e247cb6d0e363288f00f17a1d5e75a0fc9e1119c27167843b183789ab8d36847389:88fdf0c71cfb397cf692295a6526dd29cee4bf34711e2edba5528a2aa05f1d0baa1ad6ea97ceaac5111e71c84004b8dc99d47846a2760a424b0ee1c852789b94
\ No newline at end of file
diff --git a/hosts/mba/Library/Application Support/ZeroTier/One/identity.public b/hosts/mba/Library/Application Support/ZeroTier/One/identity.public
new file mode 100644
--- /dev/null
+++ ./hosts/mba/Library/Application Support/ZeroTier/One/identity.public	
@@ -0,0 +1 @@
+3c406cd616:0:35b1d5aca7458f28bdc13c2a0072ab8d6569e2703d06ded63185335bd55ef7037ea25275ad76ff70fa4cac760507a8dca84cd48a86a0d2f582cf684565b1affc
\ No newline at end of file
diff --git a/hosts/mba/Library/Application Support/ZeroTier/One/identity.secret b/hosts/mba/Library/Application Support/ZeroTier/One/identity.secret
new file mode 100644
--- /dev/null
+++ ./hosts/mba/Library/Application Support/ZeroTier/One/identity.secret	
@@ -0,0 +1 @@
+3c406cd616:0:35b1d5aca7458f28bdc13c2a0072ab8d6569e2703d06ded63185335bd55ef7037ea25275ad76ff70fa4cac760507a8dca84cd48a86a0d2f582cf684565b1affc:c7395f2c12e36b151dd0b358005b1e86d0ee0bca5488c19fc3d1bf317473359a578d6ed7404035f8ece286115ef60a9ef33667f4cdc6adb607edeaf640780089
\ No newline at end of file
diff --git a/hosts/mbp2/Library/Application Support/ZeroTier/One/identity.public b/hosts/mbp2/Library/Application Support/ZeroTier/One/identity.public
new file mode 100644
--- /dev/null
+++ ./hosts/mbp2/Library/Application Support/ZeroTier/One/identity.public	
@@ -0,0 +1 @@
+1e95a2d9fe:0:8034bed74da2e9afccdc3e92957bb5d0cc632b03f1eac11f79166c5a51d1c30e22907658b0726436934d77b39e6646705c0fd9f9473344dd730ba1f18225a4a0
\ No newline at end of file
diff --git a/hosts/mbp2/Library/Application Support/ZeroTier/One/identity.secret b/hosts/mbp2/Library/Application Support/ZeroTier/One/identity.secret
new file mode 100644
--- /dev/null
+++ ./hosts/mbp2/Library/Application Support/ZeroTier/One/identity.secret	
@@ -0,0 +1 @@
+1e95a2d9fe:0:8034bed74da2e9afccdc3e92957bb5d0cc632b03f1eac11f79166c5a51d1c30e22907658b0726436934d77b39e6646705c0fd9f9473344dd730ba1f18225a4a0:f6b50f5dcac2647699d089e2bb353dba00869a34bee41e2f8d3eeef1b0ff64dcb6e8ffd07bde5d094aa76a211917c1f237038780f431e0e486bd280a4e825590
\ No newline at end of file
diff --git a/hosts/mini/var/lib/zerotier-one/identity.public b/hosts/mini/var/lib/zerotier-one/identity.public
new file mode 100644
--- /dev/null
+++ ./hosts/mini/var/lib/zerotier-one/identity.public
@@ -0,0 +1 @@
+ac153ac391:0:75ee3ccadf5e05dafcf7c59fe24293dabc374db398f87187c02d16ae2b73075bcc5e058c2a8439f6fabc3c8e1b809d84cec7949aa2295902ed0fffa0c3339d75
\ No newline at end of file
diff --git a/hosts/mini/var/lib/zerotier-one/identity.secret b/hosts/mini/var/lib/zerotier-one/identity.secret
new file mode 100644
--- /dev/null
+++ ./hosts/mini/var/lib/zerotier-one/identity.secret
@@ -0,0 +1 @@
+ac153ac391:0:75ee3ccadf5e05dafcf7c59fe24293dabc374db398f87187c02d16ae2b73075bcc5e058c2a8439f6fabc3c8e1b809d84cec7949aa2295902ed0fffa0c3339d75:9d79bbebfe2cc8af44b1b37fb6b575a7cf26a0b6a06c40927ac18f00e9168d3ea40fcb16da5f06cf731f26d256424595c0b6d1f42a479ca166ba060a8779a080
\ No newline at end of file
diff --git a/hosts/mldonkey/var/lib/zerotier-one/identity.public b/hosts/mldonkey/var/lib/zerotier-one/identity.public
new file mode 100644
--- /dev/null
+++ ./hosts/mldonkey/var/lib/zerotier-one/identity.public
@@ -0,0 +1 @@
+60f76331b8:0:dcae06080f92c8b1033156e4ab93daf131934860d1047c1d61fece075c4b3a2884af314bd1ceb85b70caa14ced6193989caea3f1391bd88396cd142a4a6b8761
\ No newline at end of file
diff --git a/hosts/mldonkey/var/lib/zerotier-one/identity.secret b/hosts/mldonkey/var/lib/zerotier-one/identity.secret
new file mode 100644
--- /dev/null
+++ ./hosts/mldonkey/var/lib/zerotier-one/identity.secret
@@ -0,0 +1 @@
+60f76331b8:0:dcae06080f92c8b1033156e4ab93daf131934860d1047c1d61fece075c4b3a2884af314bd1ceb85b70caa14ced6193989caea3f1391bd88396cd142a4a6b8761:473a868be331620a54dfabe79f122e725a2939e0988db3bdaca32b8083b79e4113f86cbf05394931ae9a28e48eea40283e0a87f05990d75c41a1408e02011217
\ No newline at end of file
diff --git a/hosts/movie/var/lib/zerotier-one/identity.public b/hosts/movie/var/lib/zerotier-one/identity.public
new file mode 100644
--- /dev/null
+++ ./hosts/movie/var/lib/zerotier-one/identity.public
@@ -0,0 +1 @@
+c9354e7268:0:fd1bbb41b683a30f2915b147fccb1eea68f63088fcf3c2afa0662b59f0797c1a6ceb6986b153eaebde9c3976d08e035a78792b21bc32984c9d10e162b88b829c
\ No newline at end of file
diff --git a/hosts/movie/var/lib/zerotier-one/identity.secret b/hosts/movie/var/lib/zerotier-one/identity.secret
new file mode 100644
--- /dev/null
+++ ./hosts/movie/var/lib/zerotier-one/identity.secret
@@ -0,0 +1 @@
+c9354e7268:0:fd1bbb41b683a30f2915b147fccb1eea68f63088fcf3c2afa0662b59f0797c1a6ceb6986b153eaebde9c3976d08e035a78792b21bc32984c9d10e162b88b829c:e93108067cb5a595a83e7054526378bc63df5558ffe7fcb32fdb84f56b8cf0d599e5a15d906614deb6b45957375f2a0e7d2234b4954627a338d1413e4dc047f3
\ No newline at end of file
diff --git a/hosts/pikvm/var/lib/zerotier-one/identity.public b/hosts/pikvm/var/lib/zerotier-one/identity.public
new file mode 100644
--- /dev/null
+++ ./hosts/pikvm/var/lib/zerotier-one/identity.public
@@ -0,0 +1 @@
+c3ac8da1fa:0:7af52fe48ed1613731078324d9af26220b18ed7b481725929f4ffa93e984460c4d6e5cb6a7325490be71d937a87e0ca796ebc39a24f9ed9145f1b1bc0817d157
\ No newline at end of file
diff --git a/hosts/pikvm/var/lib/zerotier-one/identity.secret b/hosts/pikvm/var/lib/zerotier-one/identity.secret
new file mode 100644
--- /dev/null
+++ ./hosts/pikvm/var/lib/zerotier-one/identity.secret
@@ -0,0 +1 @@
+c3ac8da1fa:0:7af52fe48ed1613731078324d9af26220b18ed7b481725929f4ffa93e984460c4d6e5cb6a7325490be71d937a87e0ca796ebc39a24f9ed9145f1b1bc0817d157:44a4a32f4690d9393311149be68a2be9769aa70830b36e73c443dec25168cc67ba9fc494599f19fccc2abbc0348519c8e1d590b6636c090ea975f354e912f911
\ No newline at end of file
diff --git a/hosts/sandbox/var/lib/zerotier-one/identity.public b/hosts/sandbox/var/lib/zerotier-one/identity.public
new file mode 100644
--- /dev/null
+++ ./hosts/sandbox/var/lib/zerotier-one/identity.public
@@ -0,0 +1 @@
+ce5f7964e6:0:29758feca1409752a717c0b06886b5dcc6e7d6cff34053324f949f4df5a1ad22035f9d036c473722659769b736750d134793ea86adf26b5a6c359b4ceb96481b
\ No newline at end of file
diff --git a/hosts/sandbox/var/lib/zerotier-one/identity.secret b/hosts/sandbox/var/lib/zerotier-one/identity.secret
new file mode 100644
--- /dev/null
+++ ./hosts/sandbox/var/lib/zerotier-one/identity.secret
@@ -0,0 +1 @@
+ce5f7964e6:0:29758feca1409752a717c0b06886b5dcc6e7d6cff34053324f949f4df5a1ad22035f9d036c473722659769b736750d134793ea86adf26b5a6c359b4ceb96481b:409983b9a3982d1fd46cc7aa6246dc420acc978881bbd577967237719593433e0baa4d221c63373fda70a04b3ae3bd4e44fba83663d0a10e5ab0c27a10a7af30
\ No newline at end of file
diff --git a/hosts/server/var/lib/zerotier-one/identity.public b/hosts/server/var/lib/zerotier-one/identity.public
new file mode 100644
--- /dev/null
+++ ./hosts/server/var/lib/zerotier-one/identity.public
@@ -0,0 +1 @@
+ed0979a312:0:5d0f17fa53c4e624bdfdeaaf7860a0fcbf252acaf54e87c5603a9369ab50a32f0a582d713b3e5bdb8080f90ecc5e1970fcb04b2820fa4d40ba779e67e3fd882f
\ No newline at end of file
diff --git a/hosts/server/var/lib/zerotier-one/identity.secret b/hosts/server/var/lib/zerotier-one/identity.secret
new file mode 100644
--- /dev/null
+++ ./hosts/server/var/lib/zerotier-one/identity.secret
@@ -0,0 +1 @@
+ed0979a312:0:5d0f17fa53c4e624bdfdeaaf7860a0fcbf252acaf54e87c5603a9369ab50a32f0a582d713b3e5bdb8080f90ecc5e1970fcb04b2820fa4d40ba779e67e3fd882f:ffb437eb0000527c0f08affec246e50d2a19a02d2a91fb712ca8abccd2230ea6ce05732e1ca23e16a89cff60fc23f5d9ca7bf1c9e4d9f8feadfe632366dcdf45
\ No newline at end of file
diff --git a/hosts/studio/Library/Application Support/ZeroTier/One/identity.public b/hosts/studio/Library/Application Support/ZeroTier/One/identity.public
new file mode 100644
--- /dev/null
+++ ./hosts/studio/Library/Application Support/ZeroTier/One/identity.public	
@@ -0,0 +1 @@
+1a4f35693a:0:6f7068f883c9b26fdb6fd56cb7b1e0a365438b6ad2fa23d97dc52bc7a55494201f35ba3fa2e11151b6ff48337fbb823fc676e6edcc4d2b9b857e3b7021c04bbe
\ No newline at end of file
diff --git a/hosts/studio/Library/Application Support/ZeroTier/One/identity.secret b/hosts/studio/Library/Application Support/ZeroTier/One/identity.secret
new file mode 100644
--- /dev/null
+++ ./hosts/studio/Library/Application Support/ZeroTier/One/identity.secret	
@@ -0,0 +1 @@
+1a4f35693a:0:6f7068f883c9b26fdb6fd56cb7b1e0a365438b6ad2fa23d97dc52bc7a55494201f35ba3fa2e11151b6ff48337fbb823fc676e6edcc4d2b9b857e3b7021c04bbe:e75398cc2af984a61ea2db61d500c6968d50e23c3cf30d41fdca99507bdc972608c3b2075d29b17f443f41c2b118ad5daf10d71374f536442dbd4ae703100784
\ No newline at end of file
diff --git a/hosts/toshiba/var/lib/zerotier-one/identity.public b/hosts/toshiba/var/lib/zerotier-one/identity.public
new file mode 100644
--- /dev/null
+++ ./hosts/toshiba/var/lib/zerotier-one/identity.public
@@ -0,0 +1 @@
+daf17191fd:0:44d4af658c677750be6aca47f1448156ae842dac4838188b3bfaf4ecf1c92a3af3b0cae5ed773a14391630fd02486ecc1bab56a8d8dfb13895408773fe2a1c10
\ No newline at end of file
diff --git a/hosts/toshiba/var/lib/zerotier-one/identity.secret b/hosts/toshiba/var/lib/zerotier-one/identity.secret
new file mode 100644
--- /dev/null
+++ ./hosts/toshiba/var/lib/zerotier-one/identity.secret
@@ -0,0 +1 @@
+daf17191fd:0:44d4af658c677750be6aca47f1448156ae842dac4838188b3bfaf4ecf1c92a3af3b0cae5ed773a14391630fd02486ecc1bab56a8d8dfb13895408773fe2a1c10:c568b0749dea9339870f1d79dd7da75e841753fd93a5a57a68f91fc4fb466ba593408dd2f5440206edce0387daec8f6a9d1a4ea126c77fa77f9c4388864c6b10
\ No newline at end of file
diff --git a/hosts/u1604/var/lib/zerotier-one/identity.public b/hosts/u1604/var/lib/zerotier-one/identity.public
new file mode 100644
--- /dev/null
+++ ./hosts/u1604/var/lib/zerotier-one/identity.public
@@ -0,0 +1 @@
+5f21aff876:0:d87a8788500aa73bc1e39564824d2c9bfc079e49defe00d6648a6e317cb47d2cf65e3465f856bf1016ce09912534e7f66f3e54373531c32f80f9dc24888b2537
\ No newline at end of file
diff --git a/hosts/u1604/var/lib/zerotier-one/identity.secret b/hosts/u1604/var/lib/zerotier-one/identity.secret
new file mode 100644
--- /dev/null
+++ ./hosts/u1604/var/lib/zerotier-one/identity.secret
@@ -0,0 +1 @@
+5f21aff876:0:d87a8788500aa73bc1e39564824d2c9bfc079e49defe00d6648a6e317cb47d2cf65e3465f856bf1016ce09912534e7f66f3e54373531c32f80f9dc24888b2537:900c394c691b218eca30f5f11d9db4fb8580be2b7f4ee3c91bf335a0ab0760fbebc0aea1d035765c764d88bb4904d1d39814d4d68efd73eeb79e8f49802a44a5
\ No newline at end of file
diff --git a/hosts/u1710/var/lib/zerotier-one/identity.public b/hosts/u1710/var/lib/zerotier-one/identity.public
new file mode 100644
--- /dev/null
+++ ./hosts/u1710/var/lib/zerotier-one/identity.public
@@ -0,0 +1 @@
+e222d78d3e:0:c6fa1dae0a9bf2b37e0ada3c55c18a5bd24feb37fb118959e2630002507a446325144a54dd31489b380de3a3483c82c33890262258fed4b0e042a5a3be90c54b
\ No newline at end of file
diff --git a/hosts/u1710/var/lib/zerotier-one/identity.secret b/hosts/u1710/var/lib/zerotier-one/identity.secret
new file mode 100644
--- /dev/null
+++ ./hosts/u1710/var/lib/zerotier-one/identity.secret
@@ -0,0 +1 @@
+e222d78d3e:0:c6fa1dae0a9bf2b37e0ada3c55c18a5bd24feb37fb118959e2630002507a446325144a54dd31489b380de3a3483c82c33890262258fed4b0e042a5a3be90c54b:839dffe983676ed7d4376c0aabe77bb09e93812ba5300f18d538ad3ce0feb4bff5361d4ccaef679a30e2f341e9b1953291dddb33fc58579007929aa716db1679
\ No newline at end of file
diff --git a/hosts/u1804/var/lib/zerotier-one/identity.public b/hosts/u1804/var/lib/zerotier-one/identity.public
new file mode 100644
--- /dev/null
+++ ./hosts/u1804/var/lib/zerotier-one/identity.public
@@ -0,0 +1 @@
+2ea3023692:0:c5a7246047db0a5d36fe4b2e26f3323fcfb38f01260b7dea5fd9000b4e611c1f81c18a2e800acae8fa58a97b19949466971b8598780d5fdb4e3d3551694a1fcf
\ No newline at end of file
diff --git a/hosts/u1804/var/lib/zerotier-one/identity.secret b/hosts/u1804/var/lib/zerotier-one/identity.secret
new file mode 100644
--- /dev/null
+++ ./hosts/u1804/var/lib/zerotier-one/identity.secret
@@ -0,0 +1 @@
+2ea3023692:0:c5a7246047db0a5d36fe4b2e26f3323fcfb38f01260b7dea5fd9000b4e611c1f81c18a2e800acae8fa58a97b19949466971b8598780d5fdb4e3d3551694a1fcf:493c069d840689e267a284218f0f825887eccb1746410a20dbd486b5e49ac5e6c0de40a8ea0547fd3715e59a0591368cb25bfe0a964f7cd5dd77032f7936067d
\ No newline at end of file
diff --git a/hosts/u2004/var/lib/zerotier-one/identity.public b/hosts/u2004/var/lib/zerotier-one/identity.public
new file mode 100644
--- /dev/null
+++ ./hosts/u2004/var/lib/zerotier-one/identity.public
@@ -0,0 +1 @@
+8414efd65b:0:1ae70e353e7b0e3dc9be1630ee0f3fd28849a1342f45fa289ff1a3cdd362677208029a287017e897cb076a0e0ee34f8f16084ddd365fbd40cba0583d3ab200d1
\ No newline at end of file
diff --git a/hosts/u2004/var/lib/zerotier-one/identity.secret b/hosts/u2004/var/lib/zerotier-one/identity.secret
new file mode 100644
--- /dev/null
+++ ./hosts/u2004/var/lib/zerotier-one/identity.secret
@@ -0,0 +1 @@
+8414efd65b:0:1ae70e353e7b0e3dc9be1630ee0f3fd28849a1342f45fa289ff1a3cdd362677208029a287017e897cb076a0e0ee34f8f16084ddd365fbd40cba0583d3ab200d1:0db6a42863a1f6a1619ea0eff9501c27d31616a1dfb051f6d657f0d5b2e1dd5f68c7e0f029c78449470c27bc2b3b3acfbdcab05133df9d9ca6238aeaec053b70
\ No newline at end of file
diff --git a/hosts/vserver/var/lib/zerotier-one/identity.public b/hosts/vserver/var/lib/zerotier-one/identity.public
new file mode 100644
--- /dev/null
+++ ./hosts/vserver/var/lib/zerotier-one/identity.public
@@ -0,0 +1 @@
+4702163bdf:0:4cc9a138ebb14c53e90e5fc83b070fb511da60c427e3765751eba9223f8c0318bdc32092a2ace52789739a02a53c70d13f29db85c3294c14698b53cdc96fd5ae
\ No newline at end of file
diff --git a/hosts/vserver/var/lib/zerotier-one/identity.secret b/hosts/vserver/var/lib/zerotier-one/identity.secret
new file mode 100644
--- /dev/null
+++ ./hosts/vserver/var/lib/zerotier-one/identity.secret
@@ -0,0 +1 @@
+4702163bdf:0:4cc9a138ebb14c53e90e5fc83b070fb511da60c427e3765751eba9223f8c0318bdc32092a2ace52789739a02a53c70d13f29db85c3294c14698b53cdc96fd5ae:acace6f7eca199bf672284635432fcb9a368e7345bbbd778196e9b5f6feed2692df0564561b4ad619212971e776dd3185db318ede50dbd0eb2a3d474e6f813be
\ No newline at end of file
diff --git a/htmlrc/convert_all_htmls.sh b/htmlrc/convert_all_htmls.sh
new file mode 100755
--- /dev/null
+++ ./htmlrc/convert_all_htmls.sh
@@ -0,0 +1,12 @@
+#!/bin/zsh
+find "$1" -type f -name \*.html | while read ss
+do
+    targetFile=$(echo $ss | sed 's/\.html$/\.pdf/g')
+
+    if [ ! -f "$targetFile" ]
+    then
+        wkhtmltopdf "$ss" "$targetFile" && rm "$ss"
+    else
+        rm "$ss"
+    fi
+done
diff --git a/htmlrc/convert_all_htmls_test.sh b/htmlrc/convert_all_htmls_test.sh
new file mode 100755
--- /dev/null
+++ ./htmlrc/convert_all_htmls_test.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./convert_all_htmls.sh ../vimrc/.vim/bundle/vim-autoformat/
diff --git a/imvurc/Vagrantfile b/imvurc/Vagrantfile
new file mode 100644
--- /dev/null
+++ ./imvurc/Vagrantfile
@@ -0,0 +1,113 @@
+# -*- mode: ruby -*-
+# vi: set ft=ruby :
+
+# All Vagrant configuration is done below. The "2" in Vagrant.configure
+# configures the configuration version (we support older styles for
+# backwards compatibility). Please don't change it unless you know what
+# you're doing.
+Vagrant.configure("2") do |config|
+    # The most common configuration options are documented and commented below.
+    # For a complete reference, please see the online documentation at
+    # https://docs.vagrantup.com.
+
+    # Every Vagrant development environment requires a box. You can search for
+    # boxes at https://vagrantcloud.com/search.
+    config.vm.box = "lint-sandbox"
+    config.vm.provider "virtualbox"
+
+    # Disable automatic box update checking. If you disable this, then
+    # boxes will only be checked for updates when the user runs
+    # `vagrant box outdated`. This is not recommended.
+    config.vm.box_check_update = false
+
+    # Create a forwarded port mapping which allows access to a specific port
+    # within the machine from a port on the host machine. In the example below,
+    # accessing "localhost:8080" will access port 80 on the guest machine.
+    # NOTE: This will enable public access to the opened port
+    # config.vm.network "forwarded_port", guest: 80, host: 8080
+
+    # Create a forwarded port mapping which allows access to a specific port
+    # within the machine from a port on the host machine and only allow access
+    # via 127.0.0.1 to disable public access
+    #config.vm.network "forwarded_port", guest: 80, host: 80, host_ip: "127.0.0.1"
+
+    # Create a private network, which allows host-only access to the machine
+    # using a specific IP.
+    config.vm.network "private_network", ip: "192.168.112.14"
+
+    # Vagrant ssh
+    config.ssh.username = "cit"
+    config.ssh.private_key_path = "/Users/huangyingw/.ssh/github_id_rsa"
+
+    # Create a public network, which generally matched to bridged network.
+    # Bridged networks make the machine appear as another physical device on
+    # your network.
+    # config.vm.network "public_network"
+
+    # Share an additional folder to the guest VM. The first argument is
+    # the path on the host to the actual folder. The second argument is
+    # the path on the guest to mount the folder. And the optional third
+    # argument is a set of non-required options.
+    # Not recommended
+    # config.vm.synced_folder "../imvu/website-project/website", "/home/cit/imvu/website-project/website"
+
+    # Provider-specific configuration so you can fine-tune various
+    # backing providers for Vagrant. These expose provider-specific options.
+    # Example for VirtualBox:
+    #
+    # config.vm.provider "virtualbox" do |vb|
+    #   # Display the VirtualBox GUI when booting the machine
+    #   vb.gui = true
+    #
+    #   # Customize the amount of memory on the VM:
+    #   vb.memory = "1024"
+    # end
+    #
+    # View the documentation for the provider you are using for more
+    # information on available options.
+
+    # Enable provisioning with a shell script. Additional provisioners such as
+    # Puppet, Chef, Ansible, Salt, and Docker are also available. Please see the
+    # documentation for more information about their specific syntax and use.
+    # config.vm.provision "process", type:"shell", privileged: false,
+    #     inline: <<-SHELL
+    #    git clone ssh://git@bitbucket.corp.imvu.com:7999/infra/process.git /home/cit/imvu/process
+    # SHELL
+
+    # config.vm.provision "imq", type:"shell", privileged: false,
+    #     inline: <<-SHELL
+    #    git clone git@github.com:imvu/imq.git  /home/cit/imvu/imq
+    #    pushd /home/cit/imvu/imq
+    #    git submodule init && git submodule update
+    #    popd
+    # SHELL
+
+    # config.vm.provision "slave_bootstrap", type:"shell", privileged: false,
+    #     inline: <<-SHELL
+    #    git clone ssh://git@bitbucket.corp.imvu.com:7999/infra/slave_bootstrap.git /home/cit/imvu/slave_bootstrap
+    # SHELL
+
+    # config.vm.provision "cfagent", type:"shell",
+    #     inline: <<-SHELL
+    #    cfagent
+    # SHELL
+
+    # config.vm.provision "website-project", type:"shell", privileged: false,
+    #     inline: <<-SHELL
+    #    pushd /home/cit/imvu
+    #    git clone ssh://git@bitbucket.corp.imvu.com:7999/eng/website.git website-project/website
+    #    pushd website
+    #    iclient --insanity sync
+    #    popd
+    #    popd
+    # SHELL
+
+    # config.vm.provision "install-samba", type:"shell", run: "never", privileged: true,
+    #     inline: <<-SHELL
+    #    apt-get -y install samba
+    #    cp /home/cit/smb.conf /etc/samba
+    #    restart smbd
+    #    restart nmbd
+    # SHELL
+
+end
diff --git a/imvurc/generate.sh b/imvurc/generate.sh
new file mode 100755
--- /dev/null
+++ ./imvurc/generate.sh
@@ -0,0 +1,13 @@
+#!/bin/zsh
+
+file=$(realpath "$1")
+target="$1.lsh"
+
+if [ ! -f "$target" ]
+then
+    cp -nv ~/loadrc/imvurc/generate_sh.template "$target"
+    rootFolder=$(~/loadrc/bashrc/find_up_folder.sh "$file" "files.proj")
+    relative_path=$(realpath --relative-to="$rootFolder" "$file")
+    relative_path=$(echo "$relative_path" | sed 's/\//\\\//g')
+    sed -i.bak "s/relative_path_var/$relative_path/g" "$target"
+fi
diff --git a/imvurc/generate_sh.template b/imvurc/generate_sh.template
new file mode 100755
--- /dev/null
+++ ./imvurc/generate_sh.template
@@ -0,0 +1,6 @@
+#!/bin/bash
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+w3m -dump http://localhost.imvu.com/relative_path_var
diff --git a/imvurc/ghypo.sh b/imvurc/ghypo.sh
new file mode 100755
--- /dev/null
+++ ./imvurc/ghypo.sh
@@ -0,0 +1,32 @@
+#!/bin/zsh
+
+if [[ "$(git config remote.origin.url)" != *'website.git' ]]
+then
+    echo -e "${red}ghypo only run for imvu website repo... ${NC}"
+    exit 1
+fi
+
+if [ $(hostname) != "linb-sandbox" ]
+then
+    if [[ -n "$host" ]] && [[ "$host" != "localhost" ]]
+    then
+        ssh -nY "$host" "cd $rpath ; ~/loadrc/imvurc/ghypo.sh $1"
+    fi
+else
+    ~/loadrc/gitrc/grsh.sh
+    ~/loadrc/gitrc/gclean.sh
+    git checkout -f master
+    git branch -D "$1"
+    git remote update
+    git checkout -b "$1" origin/"$1"
+    git checkout -f "$1"
+    git branch -u origin/"$1"
+    git merge -X theirs origin/"$1" 
+
+    if [ $(~/loadrc/gitrc/git_ready.sh) ]
+    then
+        s/hypo_best
+        # s/hypo
+        # s/hypo --buildbot=hypo2
+    fi
+fi
diff --git a/imvurc/restart.sh b/imvurc/restart.sh
new file mode 100755
--- /dev/null
+++ ./imvurc/restart.sh
@@ -0,0 +1,4 @@
+#!/bin/zsh 
+~/loadrc/bashrc/kill_top_processes.sh
+cd ~/vagrant/
+vagrant up
diff --git a/imvurc/sb_setup.sh b/imvurc/sb_setup.sh
new file mode 100755
--- /dev/null
+++ ./imvurc/sb_setup.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+vagrant box add "https://artifactory.corp.imvu.com/artifactory/api/vagrant/vagrant-imvu/lint-sandbox" --name lint-sandbox
+vagrant up
diff --git a/imvurc/vpn.sh b/imvurc/vpn.sh
new file mode 100755
--- /dev/null
+++ ./imvurc/vpn.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+openvpn --config ~/.ssh/client.ovpn --auth-user-pass --auth-retry interact
diff --git a/includefile_template.conf b/includefile_template.conf
new file mode 100644
--- /dev/null
+++ ./includefile_template.conf
@@ -0,0 +1,3 @@
+*.git*config
+*.git*info/exclude
+*.gitignore
diff --git a/install_basic.sh b/install_basic.sh
new file mode 100755
--- /dev/null
+++ ./install_basic.sh
@@ -0,0 +1,34 @@
+#!/bin/bash
+SCRIPT=$(realpath "$0") && \
+    SCRIPTPATH=$(dirname "$SCRIPT") && \
+    cd "$SCRIPTPATH" || cd ~/loadrc/
+
+./install_basic_linux.sh
+./install_basic_macos.sh
+./configure_gitk.sh
+./swith-2-zsh.sh
+
+pip install \
+    autoflake \
+    autopep8 \
+    ipynb-py-convert \
+    pdftotext \
+    proxybroker
+
+pip3 install \
+    autoflake \
+    autopep8 \
+    ipynb-py-convert \
+    pdftotext \
+    proxybroker
+
+pip3 install git+https://github.com/gaborvecsei/pdf-split-merge.git
+
+npm -g install \
+    csvtojson \
+    js-beautify \
+    json2csv
+
+./zerotierrc/all.sh
+./deploy_configurations.sh
+./crontabrc/install.sh
diff --git a/install_basic_linux.sh b/install_basic_linux.sh
new file mode 100755
--- /dev/null
+++ ./install_basic_linux.sh
@@ -0,0 +1,23 @@
+#!/bin/bash
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+
+if [ $(uname) = "Darwin" ]
+then
+    exit 0
+fi
+
+./setup_remote.sh
+./install_prerequisite.sh
+./install_gh.sh
+./install_hub.sh
+./install_nodejs.sh
+./install_time_machine.sh
+./enpass_install.sh
+./nxrc/install.sh
+./kubernetesrc/install.sh
+cp -fv /bin/true /usr/bin/true
+cp -fv ./wifirc/autoconnect.sh /etc/NetworkManager/dispatcher.d/
+systemctl disable NetworkManager-wait-online.service
diff --git a/install_basic_macos.sh b/install_basic_macos.sh
new file mode 100755
--- /dev/null
+++ ./install_basic_macos.sh
@@ -0,0 +1,82 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0") && \
+    SCRIPTPATH=$(dirname "$SCRIPT") && \
+    cd "$SCRIPTPATH" || cd ~/loadrc/
+
+if [ $(uname) = "Linux" ]
+then
+    exit 0
+fi
+
+xcode-select --install
+
+/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
+git -C $(brew --repository homebrew/core) checkout master
+brew update
+brew upgrade
+brew install \
+    mosh \
+    tmux
+
+./deploy_configurations.sh
+
+brew install \
+    Caskroom/cask/xquartz \
+    astyle \
+    azure-cli \
+    blueutil \
+    brightness \
+    clipper \
+    coreutils \
+    dialog \
+    dos2unix \
+    ffmpeg \
+    git \
+    git-gui \
+    graphviz \
+    hg \
+    htop \
+    hub \
+    iperf \
+    iperf3 \
+    jq \
+    jupyterlab \
+    kubectl \
+    kubernetes-cli \
+    libtool \
+    lynx \
+    minikube \
+    openssl \
+    parallel \
+    patchutils \
+    php \
+    poppler \
+    pv \
+    redis \
+    rename \
+    rsync \
+    sbt \
+    slurm \
+    sponge \
+    tig \
+    w3m \
+    wakeonlan \
+    watch \
+    wget \
+    xclip \
+    xmlto \
+    yq
+
+brew cask install \
+    kdiff3 \
+    libreoffice \
+    lynxlet \
+    wkhtmltopdf
+
+brew tap redis-stack/redis-stack
+brew install --cask redis-stack
+
+sudo easy_install pip
+sudo pip install --upgrade pip
+
+#./install_nx.sh
diff --git a/install_cubbit.sh b/install_cubbit.sh
new file mode 100755
--- /dev/null
+++ ./install_cubbit.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+
+bash -c "echo $(curl -fsSl https://get.cubbit.io/desktop/linux/)"
diff --git a/install_flacon.sh b/install_flacon.sh
new file mode 100755
--- /dev/null
+++ ./install_flacon.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+sudo add-apt-repository -y ppa:flacon
+sudo apt-get update
+sudo apt-get install -y flacon
diff --git a/install_gh.sh b/install_gh.sh
new file mode 100755
--- /dev/null
+++ ./install_gh.sh
@@ -0,0 +1,6 @@
+#!/bin/bash
+
+curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg |  gpg --dearmor -o /usr/share/keyrings/githubcli-archive-keyring.gpg
+echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" |  tee /etc/apt/sources.list.d/github-cli.list > /dev/null
+apt update
+apt install gh
diff --git a/install_hub.sh b/install_hub.sh
new file mode 100755
--- /dev/null
+++ ./install_hub.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+add-apt-repository  -y ppa:cpick/hub
+apt-get update -y
+apt-get install -y hub
diff --git a/install_nodejs.sh b/install_nodejs.sh
new file mode 100755
--- /dev/null
+++ ./install_nodejs.sh
@@ -0,0 +1,13 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+. ~/.zshrc
+nvm install node
+OTHER_NODE="/usr/local/bin/node"
+
+if [ -f "$OTHER_NODE" ]
+then
+    mv -v "$OTHER_NODE" "$OTHER_NODE".bak
+fi
diff --git a/install_nx.sh b/install_nx.sh
new file mode 100755
--- /dev/null
+++ ./install_nx.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+wget -nc https://download.nomachine.com/download/6.12/MacOSX/nomachine_6.12.3_8.dmg
+sudo hdiutil attach nomachine_6.12.3_8.dmg
+sudo installer -package /Volumes/NoMachine/NoMachine.pkg -target /
diff --git a/install_prerequisite.sh b/install_prerequisite.sh
new file mode 100755
--- /dev/null
+++ ./install_prerequisite.sh
@@ -0,0 +1,88 @@
+#!/bin/bash
+
+apt-get upgrade -y
+apt-get purge -y totem totem-plugins
+apt-get install -y \
+    aptitude \
+    aria2 \
+    astyle \
+    automake \
+    autotools-dev \
+    binutils \
+    build-essential \
+    cmake \
+    coreutils \
+    cryptsetup \
+    curl \
+    datamash \
+    dialog \
+    dkms \
+    dos2unix \
+    exuberant-ctags \
+    ffmpeg \
+    gdebi-core \
+    git \
+    git-gui \
+    gparted \
+    graphviz \
+    hashcat \
+    hfsprogs \
+    htop \
+    inetutils-traceroute \
+    iperf \
+    iperf3 \
+    iputils-ping \
+    jq \
+    kdiff3 \
+    libsecret-1-dev \
+    libsecret-tools \
+    locales \
+    manpages-pl \
+    mdadm \
+    moreutils \
+    mplayer \
+    mysql-client \
+    net-tools \
+    nfs-kernel-server \
+    npm \
+    openvpn \
+    p7zip-full \
+    p7zip-rar \
+    parallel \
+    patchutils \
+    perl \
+    pm-utils \
+    pv \
+    pwgen \
+    python3-autopep8 \
+    python3-software-properties \
+    rarcrack \
+    resolvconf \
+    rsync \
+    slurm \
+    smplayer \
+    software-properties-common \
+    sshfs \
+    tig \
+    transmission-cli \
+    transmission-common \
+    transmission-daemon \
+    unrar \
+    w3m \
+    w3m-img \
+    wakeonlan \
+    wget \
+    zsh
+
+apt-get install -y \
+    manpages-fr-extra \
+    netcat
+
+pacman -Syy && \
+    pacman --noconfirm -Sy \
+    cryptsetup \
+    gnu-netcat
+
+modprobe wl
+update-initramfs -u
+locale-gen en_US.UTF-8
diff --git a/install_time_machine.sh b/install_time_machine.sh
new file mode 100755
--- /dev/null
+++ ./install_time_machine.sh
@@ -0,0 +1,14 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+TARGET_DIR="/media/volgrp/"
+TARGET_DIR_FOR_SED=$(echo "$TARGET_DIR" | sed 's/\//\\\//g')
+apt install -y netatalk avahi-daemon
+cp -fv ./etc/netatalk/afp.conf /etc/netatalk/afp.conf
+sed -i.bak "s/target_dir_var/$TARGET_DIR_FOR_SED/g" /etc/netatalk/afp.conf
+
+mkdir -p "$TARGET_DIR"
+
+service netatalk restart
diff --git a/install_vagrant.sh b/install_vagrant.sh
new file mode 100755
--- /dev/null
+++ ./install_vagrant.sh
@@ -0,0 +1,18 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+if [ $(uname) != "Darwin" ]
+then
+    apt-get build-dep -y vagrant ruby-libvirt
+    apt install -y \
+        vagrant \
+        virtualbox
+
+    apt-get install -y qemu libvirt-bin ebtables dnsmasq
+    apt-get install -y libxslt-dev libxml2-dev libvirt-dev zlib1g-dev ruby-dev
+    vagrant plugin install vagrant-libvirt
+else
+    brew cask install virtualbox vagrant
+fi
diff --git a/ipynbrc/generate_ipynb.sh b/ipynbrc/generate_ipynb.sh
new file mode 100755
--- /dev/null
+++ ./ipynbrc/generate_ipynb.sh
@@ -0,0 +1,5 @@
+#!/bin/zsh
+input="$1"
+output=$(echo "$input" | sed 's/\.py$/\.ipynb/g')
+
+ipynb-py-convert "$input" "$output"
diff --git a/ipynbrc/jupytext.sh b/ipynbrc/jupytext.sh
new file mode 100755
--- /dev/null
+++ ./ipynbrc/jupytext.sh
@@ -0,0 +1,16 @@
+#!/bin/zsh
+TARGET="$PWD"
+
+if [ -n "$1" ]
+then
+    TARGET="$1"
+fi
+
+find "$TARGET" -type f -name \*.ipynb | while read ss
+do
+    pyfile=$(echo "$ss" | sed 's/\.ipynb$/\.py/g')
+    rm "$pyfile"
+    jupytext --sync "$ss"
+    autopep8 --in-place "$pyfile"
+    sed -i.bak '/!pip install/d' "$pyfile"
+done
diff --git a/ipynbrc/jupytext.test.sh b/ipynbrc/jupytext.test.sh
new file mode 100755
--- /dev/null
+++ ./ipynbrc/jupytext.test.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+cd ~/myproject/git/AI/fastai/fastbook/
+~/loadrc/ipynbrc/jupytext.sh
diff --git a/iterm2rc/movescreen.py b/iterm2rc/movescreen.py
new file mode 100644
--- /dev/null
+++ ./iterm2rc/movescreen.py
@@ -0,0 +1,106 @@
+#!/usr/bin/env python3.7
+
+import iterm2
+import objc
+from AppKit import *
+# To install packages from PyPI, use this command, changing package_name to the package you
+# wish to install:
+#   "~/Library/ApplicationSupport/iTerm2/Scripts/movescreen/iterm2env/versions/3.7.2/bin/pip3" install package_name
+
+
+async def main(connection):
+    app = await iterm2.async_get_app(connection)
+
+    def screenFrames():
+        return list(map(lambda screen: screen.frame(), NSScreen.screens()))
+
+    def intersection(f1, f2):
+        origin = iterm2.Point(max(f1.origin.x, f2.origin.x), max(f1.origin.y, f2.origin.y))
+        limit = iterm2.Point(min(f1.origin.x + f1.size.width, f2.origin.x + f2.size.width),
+                             min(f1.origin.y + f1.size.height, f2.origin.y + f2.size.height))
+        size = iterm2.Size(max(0, limit.x - origin.x),
+                           max(0, limit.y - origin.y))
+        return iterm2.Frame(origin, size)
+
+    def intersectionArea(f1, f2):
+        i = intersection(f1, f2)
+        return i.size.width * i.size.height
+
+    def indexOfScreenWithFrame(frame):
+        frames = screenFrames()
+        bestArea = 0
+        bestScreen = 0
+        i = 0
+        print("Trying to figure out the screen with window frame {}".format(str(frame)))
+        for screenFrame in screenFrames():
+            area = intersectionArea(screenFrame, frame)
+            if area > bestArea:
+                print("Screen {} looks good. Area overlap is {}. Its frame is {}".format(i, area, screenFrame))
+                bestScreen = i
+                bestArea = area
+            i += 1
+        print("Conclusion: the screen with frame {} is {}".format(frame, bestScreen))
+        return bestScreen
+
+    async def firstWindowOnScreen(i):
+        screenFrame = NSScreen.screens()[i].frame()
+        print("Looking for windows on screen {} with frame {}".format(i, screenFrame))
+        for window in app.terminal_windows:
+            frame = window.frame
+            windowArea = frame.size.width * frame.size.height
+            if intersectionArea(frame, screenFrame) > windowArea * 0.5:
+                print("YES: Window {} is mostly on that screen".format(window))
+                return window
+            print("NO: Window {} is not mostly on that screen".format(window))
+        return None
+
+    async def move_current_tab_by_n_screens(delta):
+        tab_to_move = app.current_terminal_window.current_tab
+        window_with_tab_to_move = app.get_window_for_tab(tab_to_move.tab_id)
+        await window_with_tab_to_move.async_set_fullscreen(False)
+        i = app.terminal_windows.index(window_with_tab_to_move)
+        print("Window has index {}".format(i))
+        n = len(app.terminal_windows)
+        j = (i + delta) % n
+        print("Will move to {}".format(j))
+
+        currentScreenIndex = indexOfScreenWithFrame(await window_with_tab_to_move.async_get_frame())
+        numberOfScreens = len(NSScreen.screens())
+        desiredScreenIndex = (currentScreenIndex + delta) % numberOfScreens
+
+        print("Want to move from screen {} to screen {}".format(currentScreenIndex, desiredScreenIndex))
+
+        if currentScreenIndex == desiredScreenIndex:
+            print("Already there, I guess there is only one screen")
+            return
+
+        windowAlreadyOnDesiredScreen = await firstWindowOnScreen(desiredScreenIndex)
+        if (windowAlreadyOnDesiredScreen):
+            print("There is already a window on that screen. Adding the tab to it")
+            tabs = windowAlreadyOnDesiredScreen.tabs + [tab_to_move]
+            await windowAlreadyOnDesiredScreen.async_set_tabs(windowAlreadyOnDesiredScreen.tabs + [tab_to_move])
+            return
+
+        print("No window is on the desired screen. Create a new one")
+        window = await tab_to_move.async_move_to_window()
+        await window.async_set_fullscreen(False)
+        nsframe = NSScreen.screens()[desiredScreenIndex].frame()
+        frame = iterm2.Frame(
+            iterm2.Point(nsframe.origin.x, nsframe.origin.y),
+            iterm2.Size(nsframe.size.width, nsframe.size.height))
+        await window.async_set_frame(frame)
+        await window.async_set_fullscreen(False)
+
+    @iterm2.RPC
+    async def move_current_tab_to_next_screen():
+        await move_current_tab_by_n_screens(1)
+    await move_current_tab_to_next_screen.async_register(connection)
+
+    @iterm2.RPC
+    async def move_current_tab_to_previous_screen():
+        n = len(NSScreen.screens())
+        if n > 0:
+            await move_current_tab_by_n_screens(n - 1)
+    await move_current_tab_to_previous_screen.async_register(connection)
+
+iterm2.run_forever(main)
diff --git a/keys b/keys
new file mode 160000
--- /dev/null
+++ ./keys
@@ -0,0 +1 @@
+Subproject commit 8bd26714a6e587041c8d2c98475982087c1145a8
diff --git a/kubernetesrc/install.sh b/kubernetesrc/install.sh
new file mode 100755
--- /dev/null
+++ ./kubernetesrc/install.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./install_kubectl.sh
+./install_gofish.sh
+./install_helm.sh
diff --git a/kubernetesrc/install_gofish.sh b/kubernetesrc/install_gofish.sh
new file mode 100755
--- /dev/null
+++ ./kubernetesrc/install_gofish.sh
@@ -0,0 +1,9 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+curl -fsSL https://raw.githubusercontent.com/fishworks/gofish/main/scripts/install.sh | bash 
+gofish init
+gofish install gofish
+gofish upgrade gofish
diff --git a/kubernetesrc/install_helm.sh b/kubernetesrc/install_helm.sh
new file mode 100755
--- /dev/null
+++ ./kubernetesrc/install_helm.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+gofish install helm
+helm repo add stable https://kubernetes-charts.storage.googleapis.com
+helm repo add incubator https://kubernetes-charts-incubator.storage.googleapis.com
diff --git a/kubernetesrc/install_kubectl.sh b/kubernetesrc/install_kubectl.sh
new file mode 100755
--- /dev/null
+++ ./kubernetesrc/install_kubectl.sh
@@ -0,0 +1,10 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add
+apt install -y curl
+
+apt-add-repository "deb http://apt.kubernetes.io/ kubernetes-xenial main"
+apt install -y kubeadm
diff --git a/kvmrc/install.sh b/kvmrc/install.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/install.sh
@@ -0,0 +1,18 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+if [ $(uname) = "Darwin" ]
+then
+    exit 0
+fi
+
+apt-get update ; \
+    apt-get install -y \
+    bridge-utils \
+    libvirt-clients \
+    libvirt-daemon \
+    qemu \
+    qemu-kvm \
+    virt-manager
diff --git a/kvmrc/usb_disk.xml b/kvmrc/usb_disk.xml
new file mode 100644
--- /dev/null
+++ ./kvmrc/usb_disk.xml
@@ -0,0 +1,113 @@
+<!--
+WARNING: THIS IS AN AUTO-GENERATED FILE. CHANGES TO IT ARE LIKELY TO BE
+OVERWRITTEN AND LOST. Changes to this xml configuration should be made using:
+  virsh edit u1704
+or other application using the libvirt API.
+-->
+
+<domain type='kvm'>
+  <name>u1704</name>
+  <uuid>4dcbcee7-33e0-40d2-9527-8e8fe59c8224</uuid>
+  <memory unit='KiB'>1048576</memory>
+  <currentMemory unit='KiB'>1048576</currentMemory>
+  <vcpu placement='static'>1</vcpu>
+  <os>
+    <type arch='x86_64' machine='pc-i440fx-artful'>hvm</type>
+  </os>
+  <features>
+    <acpi/>
+    <apic/>
+    <vmport state='off'/>
+  </features>
+  <cpu mode='custom' match='exact' check='partial'>
+    <model fallback='allow'>Haswell-noTSX</model>
+  </cpu>
+  <clock offset='utc'>
+    <timer name='rtc' tickpolicy='catchup'/>
+    <timer name='pit' tickpolicy='delay'/>
+    <timer name='hpet' present='no'/>
+  </clock>
+  <on_poweroff>destroy</on_poweroff>
+  <on_reboot>restart</on_reboot>
+  <on_crash>restart</on_crash>
+  <pm>
+    <suspend-to-mem enabled='no'/>
+    <suspend-to-disk enabled='no'/>
+  </pm>
+  <devices>
+    <emulator>/usr/bin/kvm-spice</emulator>
+    <disk type='file' device='disk'>
+      <driver name='qemu' type='qcow2'/>
+      <source file='/media/volgrp/kvm/u64.17.04/u64.17.04.qcow2'/>
+      <target dev='vda' bus='virtio'/>
+      <address type='pci' domain='0x0000' bus='0x00' slot='0x07' function='0x0'/>
+    </disk>
+    <disk type='block' device='disk'>
+      <driver name='qemu' type='raw'/>
+      <source dev='/dev/disk/by-id/ata-ST1000LM014-1EJ164_W3814JXM'/>
+      <target dev='vdb' bus='virtio'/>
+      <boot order='1'/>
+      <address type='pci' domain='0x0000' bus='0x00' slot='0x09' function='0x0'/>
+    </disk>
+    <controller type='usb' index='0' model='ich9-ehci1'>
+      <address type='pci' domain='0x0000' bus='0x00' slot='0x05' function='0x7'/>
+    </controller>
+    <controller type='usb' index='0' model='ich9-uhci1'>
+      <master startport='0'/>
+      <address type='pci' domain='0x0000' bus='0x00' slot='0x05' function='0x0' multifunction='on'/>
+    </controller>
+    <controller type='usb' index='0' model='ich9-uhci2'>
+      <master startport='2'/>
+      <address type='pci' domain='0x0000' bus='0x00' slot='0x05' function='0x1'/>
+    </controller>
+    <controller type='usb' index='0' model='ich9-uhci3'>
+      <master startport='4'/>
+      <address type='pci' domain='0x0000' bus='0x00' slot='0x05' function='0x2'/>
+    </controller>
+    <controller type='pci' index='0' model='pci-root'/>
+    <controller type='virtio-serial' index='0'>
+      <address type='pci' domain='0x0000' bus='0x00' slot='0x06' function='0x0'/>
+    </controller>
+    <interface type='bridge'>
+      <mac address='52:54:00:c2:b2:83'/>
+      <source bridge='br0'/>
+      <model type='virtio'/>
+      <address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/>
+    </interface>
+    <serial type='pty'>
+      <target port='0'/>
+    </serial>
+    <console type='pty'>
+      <target type='serial' port='0'/>
+    </console>
+    <channel type='spicevmc'>
+      <target type='virtio' name='com.redhat.spice.0'/>
+      <address type='virtio-serial' controller='0' bus='0' port='1'/>
+    </channel>
+    <input type='tablet' bus='usb'>
+      <address type='usb' bus='0' port='1'/>
+    </input>
+    <input type='mouse' bus='ps2'/>
+    <input type='keyboard' bus='ps2'/>
+    <graphics type='spice' autoport='yes'>
+      <listen type='address'/>
+      <image compression='off'/>
+    </graphics>
+    <sound model='ich6'>
+      <address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/>
+    </sound>
+    <video>
+      <model type='qxl' ram='65536' vram='65536' vgamem='16384' heads='1' primary='yes'/>
+      <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x0'/>
+    </video>
+    <redirdev bus='usb' type='spicevmc'>
+      <address type='usb' bus='0' port='2'/>
+    </redirdev>
+    <redirdev bus='usb' type='spicevmc'>
+      <address type='usb' bus='0' port='3'/>
+    </redirdev>
+    <memballoon model='virtio'>
+      <address type='pci' domain='0x0000' bus='0x00' slot='0x08' function='0x0'/>
+    </memballoon>
+  </devices>
+</domain>
diff --git a/kvmrc/uvmount.sh b/kvmrc/uvmount.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/uvmount.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+for ss in $(fdisk /dev/nbd0 -l | awk '/nbd0p/{print $1}')
+do
+    umount $ss
+done
+qemu-nbd --disconnect /dev/nbd0
diff --git a/kvmrc/vclone.sh b/kvmrc/vclone.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vclone.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+if [ -z "$1" ] || [ -z "$2" ] 
+then
+    echo -e "${red}Please provide both source and target vm name ... ${NC}"
+    exit 1
+fi
+
+virt-clone --original "$1" --auto-clone --name "$2" 
diff --git a/kvmrc/vdestroy.sh b/kvmrc/vdestroy.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vdestroy.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+if [ -z "$1" ]
+then
+    virsh list|awk '/[running|paused]/{print $2}'|while read ss; do virsh destroy "$ss" ; done
+else
+    TARGET=$1
+    virsh destroy "$TARGET"
+fi
diff --git a/kvmrc/vdisk.sh b/kvmrc/vdisk.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vdisk.sh
@@ -0,0 +1,23 @@
+#!/bin/zsh
+TARGET=$(basename "$1")
+DIRECTORY=$(dirname "$1")
+
+if [ ! -d "$DIRECTORY" ]
+then
+    mkdir -p "$DIRECTORY"
+fi
+
+size=500G
+
+if [ -n "$2" ]
+then
+    size="$2"
+fi
+
+minimumsize=500
+fSize=$(du -k "$1" | cut -f 1)
+
+if [ ! -f "$1" ] || [ $fSize -lt $minimumsize ]
+then
+    qemu-img create -f qcow2 "$1" "$size"
+fi
diff --git a/kvmrc/vmdk2qcow2.sh b/kvmrc/vmdk2qcow2.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vmdk2qcow2.sh
@@ -0,0 +1,14 @@
+#!/bin/zsh
+if [ -z "$1" ]
+then
+    echo -e "${red}Please provide vmdk file ... ${NC}"
+    exit 1
+fi
+
+if [ -z "$2" ]
+then
+    echo -e "${red}Please provide qcow2 file ... ${NC}"
+    exit 1
+fi
+
+qemu-img convert -p -f vmdk -O qcow2 "$1" "$2"
diff --git a/kvmrc/vmdk3-hack.sh b/kvmrc/vmdk3-hack.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vmdk3-hack.sh
@@ -0,0 +1,19 @@
+#!/bin/zsh
+VMDK=$1
+FULLSIZE=`stat -c%s "$VMDK"`
+VMDKFOOTER=$[$FULLSIZE - 0x400]
+VMDKFOOTERVER=$[$VMDKFOOTER + 4]
+
+case "`xxd -ps -s $VMDKFOOTERVER -l 1 \"$VMDK\"`" in
+  03)
+    echo -e "$VMDK is VMDK3.\n Patching to VMDK2.\n Run this script again when you're done to patch it back."
+    echo -en '\x02' | dd conv=notrunc status=none oflag=seek_bytes seek=$[VMDKFOOTERVER] of="$VMDK"
+    ;;
+  02)
+    echo "File is VMDK2. Patching to VMDK3."
+    echo -en '\x03' | dd conv=notrunc status=none oflag=seek_bytes seek=$[VMDKFOOTERVER] of="$VMDK"
+    ;;
+  default)
+    echo "$VMDK is not VMDK3 or patched-VMDK3.\n"
+    ;;
+esac
diff --git a/kvmrc/vmount.sh b/kvmrc/vmount.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vmount.sh
@@ -0,0 +1,17 @@
+#!/bin/zsh
+if [ ! -f "$1" ] || [ -z "$1" ]
+then
+    echo -e "${red}Please provide the full path to qcow2 file... ${NC}"
+    exit 1
+fi
+modprobe nbd max_part=8
+~/loadrc/kvmrc/uvmount.sh
+qcow2File="$1"
+qemu-nbd --connect=/dev/nbd0 "$qcow2File"
+
+for ss in $(fdisk /dev/nbd0 -l | awk '/nbd0p/{print $1}')
+do
+    echo $ss
+    mkdir -p /media/$ss
+    mount $ss /media/$ss
+done
diff --git a/kvmrc/vmount_test.sh b/kvmrc/vmount_test.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vmount_test.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./vmount.sh /media/volgrp/kvm/win7/win7.qcow2
diff --git a/kvmrc/vmsetup.sh b/kvmrc/vmsetup.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vmsetup.sh
@@ -0,0 +1,23 @@
+#!/bin/zsh
+
+if [ ! -f "$1" ] || [ -z "$1" ]
+then
+    echo -e "${red}Please provide the full path to qcow2 file... ${NC}"
+    exit 1
+fi
+
+qcow2File="$1"
+~/loadrc/kvmrc/uvmount.sh
+~/loadrc/kvmrc/vmount.sh "$qcow2File"
+nbd0p=$(df -TH | awk '/\/dev\/nbd0.*ext4/{print $7}')
+
+if [ -n "$nbd0p" ]
+then
+    mkdir -p "$nbd0p"/root/loadrc/ 
+    rsync -aHSv --progress --delete-before --force ~/.ssh/ "$nbd0p"/root/.ssh/
+    rsync -aHSv --progress ~/loadrc/.tmux.conf "$nbd0p"/root/
+    rsync -aHSv --progress ~/loadrc/ "$nbd0p"/root/loadrc/
+    rsync -aHSv --progress ~/loadrc/linux/etc/ssh/ "$nbd0p"/etc/ssh/
+fi
+
+~/loadrc/kvmrc/uvmount.sh
diff --git a/kvmrc/vmsetup_test.sh b/kvmrc/vmsetup_test.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vmsetup_test.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./vmsetup.sh /var/lib/libvirt/images/u2004.qcow2
diff --git a/kvmrc/vreset.sh b/kvmrc/vreset.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vreset.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+if [ -z "$1" ]
+then
+    virsh list|awk '/running/{print $2}'|while read ss; do virsh destroy "$ss" ; virsh start "$ss"; done
+else
+    TARGET=$1
+    virsh destroy "$TARGET" ; virsh start "$TARGET"
+fi
diff --git a/kvmrc/vrestore.sh b/kvmrc/vrestore.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vrestore.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+if [ -z "$1" ]
+then
+    find ~/kvm/ -type f -maxdepth 2 -name \*.save|while read ss; do virsh restore "$ss" && rm -v "$ss"; done
+else
+    virsh restore ~/kvm/"$1"/"$1".save \
+        && rm -v ~/kvm/"$1"/"$1".save
+fi
diff --git a/kvmrc/vresume.sh b/kvmrc/vresume.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vresume.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+if [ -z "$1" ]
+then
+    virsh list|awk '/paused/{print $2}'|while read ss; do virsh resume $ss; done
+else
+    virsh resume  "$1"
+fi
diff --git a/kvmrc/vsave.sh b/kvmrc/vsave.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vsave.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+$HOME/loadrc/kvmrc/vresume.sh
+if [ -z "$1" ]
+then
+    virsh list|awk '/running/{print $2}'|while read ss; do virsh save "$ss" ~/kvm/"$ss"/$ss.save --verbose; done
+else
+    virsh save "$1" ~/kvm/"$1"/"$1".save --verbose
+fi
diff --git a/kvmrc/vsd.py b/kvmrc/vsd.py
new file mode 100644
--- /dev/null
+++ ./kvmrc/vsd.py
@@ -0,0 +1,6 @@
+#!/usr/bin/env python3
+from lxml import etree
+import sys
+
+tree = etree.parse(sys.argv[1])
+print tree.xpath('string(/domain/name/text())')
diff --git a/kvmrc/vsd.sh b/kvmrc/vsd.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vsd.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+XMLFILE=$1
+DOMAIN=$(python ~/loadrc/kvmrc/vsd.py $XMLFILE)
+virsh destroy "$DOMAIN" \
+    ; virsh define "$XMLFILE" \
+    ; virsh start "$DOMAIN"
diff --git a/kvmrc/vsdx.sh b/kvmrc/vsdx.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vsdx.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+virsh dumpxml $1
diff --git a/kvmrc/vshrink.sh b/kvmrc/vshrink.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vshrink.sh
@@ -0,0 +1,13 @@
+#!/bin/zsh
+if [ -z "$1" ]
+then
+    echo -e "${red}Please provide the qcow2 file ... ${NC}"
+    exit 1
+fi
+
+TARGET=$(realpath "$1")
+BAK="$TARGET".tmp
+
+mv -v "$TARGET" "$BAK" \
+    && qemu-img convert -O qcow2 -c "$BAK" "$TARGET" \
+    && rm "$BAK"
diff --git a/kvmrc/vsl.sh b/kvmrc/vsl.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vsl.sh
@@ -0,0 +1,11 @@
+#!/bin/zsh
+
+virsh list
+virsh list --state-running --name | while read ss
+do
+    if [ ! -z "$ss" ]
+    then
+        echo "$ss :\n"
+        virsh domifaddr "$ss"
+    fi
+done
diff --git a/kvmrc/vss.sh b/kvmrc/vss.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vss.sh
@@ -0,0 +1,5 @@
+#!/bin/zsh
+~/loadrc/kvmrc/uvmount.sh
+DOMAIN=$1
+$HOME/loadrc/kvmrc/vrestore.sh "$DOMAIN" \
+    ;virsh start "$DOMAIN"
diff --git a/kvmrc/vssc.sh b/kvmrc/vssc.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vssc.sh
@@ -0,0 +1,5 @@
+#!/bin/zsh
+DOMAIN=$1
+SNAPSHOT=$2
+virsh snapshot-create-as "$DOMAIN" "$SNAPSHOT" \
+  && virsh snapshot-list --tree "$DOMAIN"
diff --git a/kvmrc/vsscu.sh b/kvmrc/vsscu.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vsscu.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+DOMAIN=$1
+virsh snapshot-current --name "$DOMAIN"
diff --git a/kvmrc/vssd.sh b/kvmrc/vssd.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vssd.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+DOMAIN=$1
+SNAPSHOT=$2
+virsh destroy "$DOMAIN" \
+  ; virsh snapshot-delete "$DOMAIN" "$SNAPSHOT" \
+  && virsh start "$DOMAIN" \
+  && virsh snapshot-list --tree "$DOMAIN"
diff --git a/kvmrc/vssi.sh b/kvmrc/vssi.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vssi.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+virsh snapshot-info $1 --current
diff --git a/kvmrc/vssl.sh b/kvmrc/vssl.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vssl.sh
@@ -0,0 +1,4 @@
+#!/bin/zsh
+DOMAIN=$1
+
+virsh snapshot-list --tree "$DOMAIN"
diff --git a/kvmrc/vssp.sh b/kvmrc/vssp.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vssp.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+DOMAIN=$1
+virsh snapshot-current --name "$DOMAIN"
diff --git a/kvmrc/vssr.sh b/kvmrc/vssr.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vssr.sh
@@ -0,0 +1,5 @@
+#!/bin/zsh
+DOMAIN=$1
+SNAPSHOT=$2
+
+virsh snapshot-revert --force "$DOMAIN" --snapshotname "$SNAPSHOT"
diff --git a/kvmrc/vssu.sh b/kvmrc/vssu.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vssu.sh
@@ -0,0 +1,5 @@
+#!/bin/zsh
+DOMAIN=$1
+SNAPSHOT=$2
+~/loadrc/kvmrc/vssd.sh "$DOMAIN" "$SNAPSHOT"
+~/loadrc/kvmrc/vssc.sh "$DOMAIN" "$SNAPSHOT"
diff --git a/kvmrc/vsuspend.sh b/kvmrc/vsuspend.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vsuspend.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+if [ -z "$1" ]
+then
+    virsh list|awk '/running/{print $2}'|while read ss; do virsh suspend $ss; done
+else
+    virsh suspend "$1"
+fi
diff --git a/kvmrc/vview.sh b/kvmrc/vview.sh
new file mode 100755
--- /dev/null
+++ ./kvmrc/vview.sh
@@ -0,0 +1,9 @@
+#!/bin/zsh
+if [ -z "$1" ]
+then
+    host=`virsh list --state-running`
+else
+    host="$1"
+fi
+port=`~/loadrc/kvmrc/vsdx.sh $host |grep vnc|grep -ow '[0-9]\{4\}'`
+vncviewer localhost:$port
diff --git a/leetcoderc/KdiffFile.py b/leetcoderc/KdiffFile.py
new file mode 100755
--- /dev/null
+++ ./leetcoderc/KdiffFile.py
@@ -0,0 +1,17 @@
+#!/usr/bin/env python3
+import re
+import os
+import sys
+
+fileName = sys.argv[1]
+lines = [line.rstrip('\n') for line in open(fileName) ]
+
+accepts = {}
+for line in lines:
+    num = re.findall(r'\/(\d+)', line)[0]
+    accepts.setdefault(num, []).append(line)
+
+for k in sorted(accepts, key=lambda k: len(accepts[k]), reverse=True):
+    for i, val in enumerate(accepts[k]):
+        for j in range(i + 1, len(accepts[k])):
+            os.system('kdiff3' + ' ' + accepts[k][i] + ' ' + accepts[k][j])
diff --git a/leetcoderc/do_post_submit.sh b/leetcoderc/do_post_submit.sh
new file mode 100755
--- /dev/null
+++ ./leetcoderc/do_post_submit.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+NUM="$1"
+
+~/loadrc/leetcoderc/submission.sh "$NUM"
+~/loadrc/leetcoderc/restore.sh "$NUM"
+~/loadrc/leetcoderc/remove_dup.sh "$NUM"
diff --git a/leetcoderc/handle.sh b/leetcoderc/handle.sh
new file mode 100755
--- /dev/null
+++ ./leetcoderc/handle.sh
@@ -0,0 +1,4 @@
+#!/bin/zsh
+FILE="$1"
+
+~/loadrc/leetcoderc/submit.sh "$FILE"
diff --git a/leetcoderc/handle_test.sh b/leetcoderc/handle_test.sh
new file mode 100755
--- /dev/null
+++ ./leetcoderc/handle_test.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./handle.sh /Users/huangyingw/leetcode-cli/submissions/1.two-sum.260837994.Accepted.leetcode.py
diff --git a/leetcoderc/post_submit.sh b/leetcoderc/post_submit.sh
new file mode 100755
--- /dev/null
+++ ./leetcoderc/post_submit.sh
@@ -0,0 +1,5 @@
+#!/bin/zsh
+FILE="$1"
+NUM=$(echo "$FILE" | sed 's/^\([0-9]*\)\..*/\1/g')
+
+~/loadrc/bashrc/check_running.sh ~/loadrc/leetcoderc/do_post_submit.sh "$NUM"
diff --git a/leetcoderc/remove_dup.sh b/leetcoderc/remove_dup.sh
new file mode 100755
--- /dev/null
+++ ./leetcoderc/remove_dup.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+NUM="$1"
+cd ../submissions/"$NUM"
+
+~/loadrc/leetcoderc/remove_gabages.sh
+find . -type f \( -name \*.orig -o -name \*.bak \) -delete
+jdupes -1dNr .
diff --git a/leetcoderc/remove_gabages.sh b/leetcoderc/remove_gabages.sh
new file mode 100755
--- /dev/null
+++ ./leetcoderc/remove_gabages.sh
@@ -0,0 +1,12 @@
+#!/bin/zsh
+
+find . -type f -name \*.py | while read ss
+do
+    autopep8 --in-place "$ss"
+    if $(~/loadrc/pythonrc/remove_comments.py "$ss")
+    then
+        mv -fv "$ss.strip" "$ss"
+        sed -i.bak '/print.*(/d;/^_author_/d;/__main__/d;/ = Solution()/d;/^_project_/d;/\bprint\b/d;s/#--//g;s/##//g;s/ \/= /\/\/=/g;s/ \/ /\/\//g;/^$/d;/^\s*$/d' "$ss"
+        autopep8 --in-place "$ss"
+    fi
+done
diff --git a/leetcoderc/restore.sh b/leetcoderc/restore.sh
new file mode 100755
--- /dev/null
+++ ./leetcoderc/restore.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+NUM="$1"
+
+rsync -aHv --progress \
+    ../downloads/"$NUM"/ \
+    ../submissions/"$NUM"/
diff --git a/leetcoderc/submission.sh b/leetcoderc/submission.sh
new file mode 100755
--- /dev/null
+++ ./leetcoderc/submission.sh
@@ -0,0 +1,4 @@
+#!/bin/zsh
+NUM="$1"
+mkdir -p ../downloads/"$NUM"/
+leetcode submission "$NUM" -o ../downloads/"$NUM"/
diff --git a/leetcoderc/submit.sh b/leetcoderc/submit.sh
new file mode 100755
--- /dev/null
+++ ./leetcoderc/submit.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+FILE="$1"
+leetcode submit "$FILE"
diff --git a/leetcoderc/submit_delete.sh b/leetcoderc/submit_delete.sh
new file mode 100755
--- /dev/null
+++ ./leetcoderc/submit_delete.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+find ~/.lc -type f -name problems.json -delete
+find ~/myproject/git/interview/leetcode_solutions/ -type f -name "[0-9]*.py" | while read ss
+do
+    leetcode submit -d "$ss"
+done
diff --git a/linux.conf b/linux.conf
new file mode 100644
--- /dev/null
+++ ./linux.conf
@@ -0,0 +1,5 @@
+/etc/NetworkManager/system-connections/dd-wrt
+/etc/crypttab
+/etc/default/grub
+/etc/resolvconf/resolv.conf.d/base
+/etc/resolvconf/resolv.conf.d/head 
diff --git a/linux/etc/locale.gen b/linux/etc/locale.gen
new file mode 100644
--- /dev/null
+++ ./linux/etc/locale.gen
@@ -0,0 +1,507 @@
+# This file lists locales that you wish to have built. You can find a list
+# of valid supported locales at /usr/share/i18n/SUPPORTED, and you can add
+# user defined locales to /usr/local/share/i18n/SUPPORTED. If you change
+# this file, you need to rerun locale-gen.
+#
+
+# C.UTF-8 UTF-8
+# aa_DJ ISO-8859-1
+# aa_DJ.UTF-8 UTF-8
+# aa_ER UTF-8
+# aa_ER@saaho UTF-8
+# aa_ET UTF-8
+# af_ZA ISO-8859-1
+# af_ZA.UTF-8 UTF-8
+# agr_PE UTF-8
+# ak_GH UTF-8
+# am_ET UTF-8
+# an_ES ISO-8859-15
+# an_ES.UTF-8 UTF-8
+# anp_IN UTF-8
+# ar_AE ISO-8859-6
+# ar_AE.UTF-8 UTF-8
+# ar_BH ISO-8859-6
+# ar_BH.UTF-8 UTF-8
+# ar_DZ ISO-8859-6
+# ar_DZ.UTF-8 UTF-8
+# ar_EG ISO-8859-6
+# ar_EG.UTF-8 UTF-8
+# ar_IN UTF-8
+# ar_IQ ISO-8859-6
+# ar_IQ.UTF-8 UTF-8
+# ar_JO ISO-8859-6
+# ar_JO.UTF-8 UTF-8
+# ar_KW ISO-8859-6
+# ar_KW.UTF-8 UTF-8
+# ar_LB ISO-8859-6
+# ar_LB.UTF-8 UTF-8
+# ar_LY ISO-8859-6
+# ar_LY.UTF-8 UTF-8
+# ar_MA ISO-8859-6
+# ar_MA.UTF-8 UTF-8
+# ar_OM ISO-8859-6
+# ar_OM.UTF-8 UTF-8
+# ar_QA ISO-8859-6
+# ar_QA.UTF-8 UTF-8
+# ar_SA ISO-8859-6
+# ar_SA.UTF-8 UTF-8
+# ar_SD ISO-8859-6
+# ar_SD.UTF-8 UTF-8
+# ar_SS UTF-8
+# ar_SY ISO-8859-6
+# ar_SY.UTF-8 UTF-8
+# ar_TN ISO-8859-6
+# ar_TN.UTF-8 UTF-8
+# ar_YE ISO-8859-6
+# ar_YE.UTF-8 UTF-8
+# as_IN UTF-8
+# ast_ES ISO-8859-15
+# ast_ES.UTF-8 UTF-8
+# ayc_PE UTF-8
+# az_AZ UTF-8
+# az_IR UTF-8
+# be_BY CP1251
+# be_BY.UTF-8 UTF-8
+# be_BY@latin UTF-8
+# bem_ZM UTF-8
+# ber_DZ UTF-8
+# ber_MA UTF-8
+# bg_BG CP1251
+# bg_BG.UTF-8 UTF-8
+# bhb_IN.UTF-8 UTF-8
+# bho_IN UTF-8
+# bho_NP UTF-8
+# bi_VU UTF-8
+# bn_BD UTF-8
+# bn_IN UTF-8
+# bo_CN UTF-8
+# bo_IN UTF-8
+# br_FR ISO-8859-1
+# br_FR.UTF-8 UTF-8
+# br_FR@euro ISO-8859-15
+# brx_IN UTF-8
+# bs_BA ISO-8859-2
+# bs_BA.UTF-8 UTF-8
+# byn_ER UTF-8
+# ca_AD ISO-8859-15
+# ca_AD.UTF-8 UTF-8
+# ca_ES ISO-8859-1
+# ca_ES.UTF-8 UTF-8
+# ca_ES@euro ISO-8859-15
+# ca_ES@valencia UTF-8
+# ca_FR ISO-8859-15
+# ca_FR.UTF-8 UTF-8
+# ca_IT ISO-8859-15
+# ca_IT.UTF-8 UTF-8
+# ce_RU UTF-8
+# chr_US UTF-8
+# ckb_IQ UTF-8
+# cmn_TW UTF-8
+# crh_UA UTF-8
+# cs_CZ ISO-8859-2
+# cs_CZ.UTF-8 UTF-8
+# csb_PL UTF-8
+# cv_RU UTF-8
+# cy_GB ISO-8859-14
+# cy_GB.UTF-8 UTF-8
+# da_DK ISO-8859-1
+# da_DK.UTF-8 UTF-8
+# de_AT ISO-8859-1
+# de_AT.UTF-8 UTF-8
+# de_AT@euro ISO-8859-15
+# de_BE ISO-8859-1
+# de_BE.UTF-8 UTF-8
+# de_BE@euro ISO-8859-15
+# de_CH ISO-8859-1
+# de_CH.UTF-8 UTF-8
+# de_DE ISO-8859-1
+# de_DE.UTF-8 UTF-8
+# de_DE@euro ISO-8859-15
+# de_IT ISO-8859-1
+# de_IT.UTF-8 UTF-8
+# de_LI.UTF-8 UTF-8
+# de_LU ISO-8859-1
+# de_LU.UTF-8 UTF-8
+# de_LU@euro ISO-8859-15
+# doi_IN UTF-8
+# dsb_DE UTF-8
+# dv_MV UTF-8
+# dz_BT UTF-8
+# el_CY ISO-8859-7
+# el_CY.UTF-8 UTF-8
+# el_GR ISO-8859-7
+# el_GR.UTF-8 UTF-8
+# el_GR@euro ISO-8859-7
+# en_AG UTF-8
+# en_AU ISO-8859-1
+# en_AU.UTF-8 UTF-8
+# en_BW ISO-8859-1
+# en_BW.UTF-8 UTF-8
+# en_CA ISO-8859-1
+# en_CA.UTF-8 UTF-8
+# en_DK ISO-8859-1
+# en_DK.ISO-8859-15 ISO-8859-15
+# en_DK.UTF-8 UTF-8
+# en_GB ISO-8859-1
+# en_GB.ISO-8859-15 ISO-8859-15
+# en_GB.UTF-8 UTF-8
+# en_HK ISO-8859-1
+# en_HK.UTF-8 UTF-8
+# en_IE ISO-8859-1
+# en_IE.UTF-8 UTF-8
+# en_IE@euro ISO-8859-15
+# en_IL UTF-8
+# en_IN UTF-8
+# en_NG UTF-8
+# en_NZ ISO-8859-1
+# en_NZ.UTF-8 UTF-8
+# en_PH ISO-8859-1
+# en_PH.UTF-8 UTF-8
+# en_SC.UTF-8 UTF-8
+# en_SG ISO-8859-1
+# en_SG.UTF-8 UTF-8
+# en_US ISO-8859-1
+# en_US.ISO-8859-15 ISO-8859-15
+en_US.UTF-8 UTF-8
+# en_ZA ISO-8859-1
+# en_ZA.UTF-8 UTF-8
+# en_ZM UTF-8
+# en_ZW ISO-8859-1
+# en_ZW.UTF-8 UTF-8
+# eo UTF-8
+# eo_US.UTF-8 UTF-8
+# es_AR ISO-8859-1
+# es_AR.UTF-8 UTF-8
+# es_BO ISO-8859-1
+# es_BO.UTF-8 UTF-8
+# es_CL ISO-8859-1
+# es_CL.UTF-8 UTF-8
+# es_CO ISO-8859-1
+# es_CO.UTF-8 UTF-8
+# es_CR ISO-8859-1
+# es_CR.UTF-8 UTF-8
+# es_CU UTF-8
+# es_DO ISO-8859-1
+# es_DO.UTF-8 UTF-8
+# es_EC ISO-8859-1
+# es_EC.UTF-8 UTF-8
+# es_ES ISO-8859-1
+# es_ES.UTF-8 UTF-8
+# es_ES@euro ISO-8859-15
+# es_GT ISO-8859-1
+# es_GT.UTF-8 UTF-8
+# es_HN ISO-8859-1
+# es_HN.UTF-8 UTF-8
+# es_MX ISO-8859-1
+# es_MX.UTF-8 UTF-8
+# es_NI ISO-8859-1
+# es_NI.UTF-8 UTF-8
+# es_PA ISO-8859-1
+# es_PA.UTF-8 UTF-8
+# es_PE ISO-8859-1
+# es_PE.UTF-8 UTF-8
+# es_PR ISO-8859-1
+# es_PR.UTF-8 UTF-8
+# es_PY ISO-8859-1
+# es_PY.UTF-8 UTF-8
+# es_SV ISO-8859-1
+# es_SV.UTF-8 UTF-8
+# es_US ISO-8859-1
+# es_US.UTF-8 UTF-8
+# es_UY ISO-8859-1
+# es_UY.UTF-8 UTF-8
+# es_VE ISO-8859-1
+# es_VE.UTF-8 UTF-8
+# et_EE ISO-8859-1
+# et_EE.ISO-8859-15 ISO-8859-15
+# et_EE.UTF-8 UTF-8
+# eu_ES ISO-8859-1
+# eu_ES.UTF-8 UTF-8
+# eu_ES@euro ISO-8859-15
+# eu_FR ISO-8859-1
+# eu_FR.UTF-8 UTF-8
+# eu_FR@euro ISO-8859-15
+# fa_IR UTF-8
+# ff_SN UTF-8
+# fi_FI ISO-8859-1
+# fi_FI.UTF-8 UTF-8
+# fi_FI@euro ISO-8859-15
+# fil_PH UTF-8
+# fo_FO ISO-8859-1
+# fo_FO.UTF-8 UTF-8
+# fr_BE ISO-8859-1
+# fr_BE.UTF-8 UTF-8
+# fr_BE@euro ISO-8859-15
+# fr_CA ISO-8859-1
+# fr_CA.UTF-8 UTF-8
+# fr_CH ISO-8859-1
+# fr_CH.UTF-8 UTF-8
+# fr_FR ISO-8859-1
+# fr_FR.UTF-8 UTF-8
+# fr_FR@euro ISO-8859-15
+# fr_LU ISO-8859-1
+# fr_LU.UTF-8 UTF-8
+# fr_LU@euro ISO-8859-15
+# fur_IT UTF-8
+# fy_DE UTF-8
+# fy_NL UTF-8
+# ga_IE ISO-8859-1
+# ga_IE.UTF-8 UTF-8
+# ga_IE@euro ISO-8859-15
+# gd_GB ISO-8859-15
+# gd_GB.UTF-8 UTF-8
+# gez_ER UTF-8
+# gez_ER@abegede UTF-8
+# gez_ET UTF-8
+# gez_ET@abegede UTF-8
+# gl_ES ISO-8859-1
+# gl_ES.UTF-8 UTF-8
+# gl_ES@euro ISO-8859-15
+# gu_IN UTF-8
+# gv_GB ISO-8859-1
+# gv_GB.UTF-8 UTF-8
+# ha_NG UTF-8
+# hak_TW UTF-8
+# he_IL ISO-8859-8
+# he_IL.UTF-8 UTF-8
+# hi_IN UTF-8
+# hif_FJ UTF-8
+# hne_IN UTF-8
+# hr_HR ISO-8859-2
+# hr_HR.UTF-8 UTF-8
+# hsb_DE ISO-8859-2
+# hsb_DE.UTF-8 UTF-8
+# ht_HT UTF-8
+# hu_HU ISO-8859-2
+# hu_HU.UTF-8 UTF-8
+# hy_AM UTF-8
+# hy_AM.ARMSCII-8 ARMSCII-8
+# ia_FR UTF-8
+# id_ID ISO-8859-1
+# id_ID.UTF-8 UTF-8
+# ig_NG UTF-8
+# ik_CA UTF-8
+# is_IS ISO-8859-1
+# is_IS.UTF-8 UTF-8
+# it_CH ISO-8859-1
+# it_CH.UTF-8 UTF-8
+# it_IT ISO-8859-1
+# it_IT.UTF-8 UTF-8
+# it_IT@euro ISO-8859-15
+# iu_CA UTF-8
+# ja_JP.EUC-JP EUC-JP
+# ja_JP.UTF-8 UTF-8
+# ka_GE GEORGIAN-PS
+# ka_GE.UTF-8 UTF-8
+# kab_DZ UTF-8
+# kk_KZ PT154
+# kk_KZ.RK1048 RK1048
+# kk_KZ.UTF-8 UTF-8
+# kl_GL ISO-8859-1
+# kl_GL.UTF-8 UTF-8
+# km_KH UTF-8
+# kn_IN UTF-8
+# ko_KR.EUC-KR EUC-KR
+# ko_KR.UTF-8 UTF-8
+# kok_IN UTF-8
+# ks_IN UTF-8
+# ks_IN@devanagari UTF-8
+# ku_TR ISO-8859-9
+# ku_TR.UTF-8 UTF-8
+# kw_GB ISO-8859-1
+# kw_GB.UTF-8 UTF-8
+# ky_KG UTF-8
+# lb_LU UTF-8
+# lg_UG ISO-8859-10
+# lg_UG.UTF-8 UTF-8
+# li_BE UTF-8
+# li_NL UTF-8
+# lij_IT UTF-8
+# ln_CD UTF-8
+# lo_LA UTF-8
+# lt_LT ISO-8859-13
+# lt_LT.UTF-8 UTF-8
+# lv_LV ISO-8859-13
+# lv_LV.UTF-8 UTF-8
+# lzh_TW UTF-8
+# mag_IN UTF-8
+# mai_IN UTF-8
+# mai_NP UTF-8
+# mfe_MU UTF-8
+# mg_MG ISO-8859-15
+# mg_MG.UTF-8 UTF-8
+# mhr_RU UTF-8
+# mi_NZ ISO-8859-13
+# mi_NZ.UTF-8 UTF-8
+# miq_NI UTF-8
+# mjw_IN UTF-8
+# mk_MK ISO-8859-5
+# mk_MK.UTF-8 UTF-8
+# ml_IN UTF-8
+# mn_MN UTF-8
+# mni_IN UTF-8
+# mnw_MM UTF-8
+# mr_IN UTF-8
+# ms_MY ISO-8859-1
+# ms_MY.UTF-8 UTF-8
+# mt_MT ISO-8859-3
+# mt_MT.UTF-8 UTF-8
+# my_MM UTF-8
+# nan_TW UTF-8
+# nan_TW@latin UTF-8
+# nb_NO ISO-8859-1
+# nb_NO.UTF-8 UTF-8
+# nds_DE UTF-8
+# nds_NL UTF-8
+# ne_NP UTF-8
+# nhn_MX UTF-8
+# niu_NU UTF-8
+# niu_NZ UTF-8
+# nl_AW UTF-8
+# nl_BE ISO-8859-1
+# nl_BE.UTF-8 UTF-8
+# nl_BE@euro ISO-8859-15
+# nl_NL ISO-8859-1
+# nl_NL.UTF-8 UTF-8
+# nl_NL@euro ISO-8859-15
+# nn_NO ISO-8859-1
+# nn_NO.UTF-8 UTF-8
+# nr_ZA UTF-8
+# nso_ZA UTF-8
+# oc_FR ISO-8859-1
+# oc_FR.UTF-8 UTF-8
+# om_ET UTF-8
+# om_KE ISO-8859-1
+# om_KE.UTF-8 UTF-8
+# or_IN UTF-8
+# os_RU UTF-8
+# pa_IN UTF-8
+# pa_PK UTF-8
+# pap_AW UTF-8
+# pap_CW UTF-8
+# pl_PL ISO-8859-2
+# pl_PL.UTF-8 UTF-8
+# ps_AF UTF-8
+# pt_BR ISO-8859-1
+# pt_BR.UTF-8 UTF-8
+# pt_PT ISO-8859-1
+# pt_PT.UTF-8 UTF-8
+# pt_PT@euro ISO-8859-15
+# quz_PE UTF-8
+# raj_IN UTF-8
+# ro_RO ISO-8859-2
+# ro_RO.UTF-8 UTF-8
+# ru_RU ISO-8859-5
+# ru_RU.CP1251 CP1251
+# ru_RU.KOI8-R KOI8-R
+# ru_RU.UTF-8 UTF-8
+# ru_UA KOI8-U
+# ru_UA.UTF-8 UTF-8
+# rw_RW UTF-8
+# sa_IN UTF-8
+# sah_RU UTF-8
+# sat_IN UTF-8
+# sc_IT UTF-8
+# sd_IN UTF-8
+# sd_IN@devanagari UTF-8
+# sd_PK UTF-8
+# se_NO UTF-8
+# sgs_LT UTF-8
+# shn_MM UTF-8
+# shs_CA UTF-8
+# si_LK UTF-8
+# sid_ET UTF-8
+# sk_SK ISO-8859-2
+# sk_SK.UTF-8 UTF-8
+# sl_SI ISO-8859-2
+# sl_SI.UTF-8 UTF-8
+# sm_WS UTF-8
+# so_DJ ISO-8859-1
+# so_DJ.UTF-8 UTF-8
+# so_ET UTF-8
+# so_KE ISO-8859-1
+# so_KE.UTF-8 UTF-8
+# so_SO ISO-8859-1
+# so_SO.UTF-8 UTF-8
+# sq_AL ISO-8859-1
+# sq_AL.UTF-8 UTF-8
+# sq_MK UTF-8
+# sr_ME UTF-8
+# sr_RS UTF-8
+# sr_RS@latin UTF-8
+# ss_ZA UTF-8
+# st_ZA ISO-8859-1
+# st_ZA.UTF-8 UTF-8
+# sv_FI ISO-8859-1
+# sv_FI.UTF-8 UTF-8
+# sv_FI@euro ISO-8859-15
+# sv_SE ISO-8859-1
+# sv_SE.ISO-8859-15 ISO-8859-15
+# sv_SE.UTF-8 UTF-8
+# sw_KE UTF-8
+# sw_TZ UTF-8
+# szl_PL UTF-8
+# ta_IN UTF-8
+# ta_LK UTF-8
+# tcy_IN.UTF-8 UTF-8
+# te_IN UTF-8
+# tg_TJ KOI8-T
+# tg_TJ.UTF-8 UTF-8
+# th_TH TIS-620
+# th_TH.UTF-8 UTF-8
+# the_NP UTF-8
+# ti_ER UTF-8
+# ti_ET UTF-8
+# tig_ER UTF-8
+# tk_TM UTF-8
+# tl_PH ISO-8859-1
+# tl_PH.UTF-8 UTF-8
+# tn_ZA UTF-8
+# to_TO UTF-8
+# tpi_PG UTF-8
+# tr_CY ISO-8859-9
+# tr_CY.UTF-8 UTF-8
+# tr_TR ISO-8859-9
+# tr_TR.UTF-8 UTF-8
+# ts_ZA UTF-8
+# tt_RU UTF-8
+# tt_RU@iqtelif UTF-8
+# ug_CN UTF-8
+# ug_CN@latin UTF-8
+# uk_UA KOI8-U
+# uk_UA.UTF-8 UTF-8
+# unm_US UTF-8
+# ur_IN UTF-8
+# ur_PK UTF-8
+# uz_UZ ISO-8859-1
+# uz_UZ.UTF-8 UTF-8
+# uz_UZ@cyrillic UTF-8
+# ve_ZA UTF-8
+# vi_VN UTF-8
+# wa_BE ISO-8859-1
+# wa_BE.UTF-8 UTF-8
+# wa_BE@euro ISO-8859-15
+# wae_CH UTF-8
+# wal_ET UTF-8
+# wo_SN UTF-8
+# xh_ZA ISO-8859-1
+# xh_ZA.UTF-8 UTF-8
+# yi_US CP1255
+# yi_US.UTF-8 UTF-8
+# yo_NG UTF-8
+# yue_HK UTF-8
+# yuw_PG UTF-8
+# zh_CN GB2312
+# zh_CN.GB18030 GB18030
+# zh_CN.GBK GBK
+# zh_CN.UTF-8 UTF-8
+# zh_HK BIG5-HKSCS
+# zh_HK.UTF-8 UTF-8
+# zh_SG GB2312
+# zh_SG.GBK GBK
+# zh_SG.UTF-8 UTF-8
+# zh_TW BIG5
+# zh_TW.EUC-TW EUC-TW
+# zh_TW.UTF-8 UTF-8
+# zu_ZA ISO-8859-1
+# zu_ZA.UTF-8 UTF-8
diff --git a/linux/etc/netplan/00-installer-config.yaml_bak b/linux/etc/netplan/00-installer-config.yaml_bak
new file mode 100644
--- /dev/null
+++ ./linux/etc/netplan/00-installer-config.yaml_bak
@@ -0,0 +1,10 @@
+network:
+  ethernets:
+    eth0:
+      dhcp4: true
+  version: 2
+
+  bridges:
+    br0:
+      interfaces: [eth0]
+      dhcp4: yes
diff --git a/linux/etc/ssh/ssh_config b/linux/etc/ssh/ssh_config
new file mode 100644
--- /dev/null
+++ ./linux/etc/ssh/ssh_config
@@ -0,0 +1,56 @@
+
+# This is the ssh client system-wide configuration file.  See
+# ssh_config(5) for more information.  This file provides defaults for
+# users, and the values can be changed in per-user configuration files
+# or on the command line.
+
+# Configuration data is parsed as follows:
+#  1. command line options
+#  2. user-specific file
+#  3. system-wide file
+# Any configuration value is only changed the first time it is set.
+# Thus, host-specific definitions should be at the beginning of the
+# configuration file, and defaults at the end.
+
+# Site-wide defaults for some commonly used options.  For a comprehensive
+# list of available options, their meanings and defaults, please see the
+# ssh_config(5) man page.
+
+Host *
+#   ForwardAgent no
+#   ForwardX11 no
+#   ForwardX11Trusted yes
+#   RhostsRSAAuthentication no
+#   RSAAuthentication yes
+#   PasswordAuthentication yes
+#   HostbasedAuthentication no
+#   GSSAPIAuthentication no
+#   GSSAPIDelegateCredentials no
+#   GSSAPIKeyExchange no
+#   GSSAPITrustDNS no
+#   BatchMode no
+#   CheckHostIP yes
+#   AddressFamily any
+#   ConnectTimeout 0
+StrictHostKeyChecking no
+#   IdentityFile ~/.ssh/identity
+#   IdentityFile ~/.ssh/id_rsa
+#   IdentityFile ~/.ssh/id_dsa
+#   IdentityFile ~/.ssh/id_ecdsa
+#   IdentityFile ~/.ssh/id_ed25519
+#   Port 22
+#   Protocol 2
+#   Cipher 3des
+#   Ciphers aes128-ctr,aes192-ctr,aes256-ctr,arcfour256,arcfour128,aes128-cbc,3des-cbc
+#   MACs hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160
+#   EscapeChar ~
+#   Tunnel no
+#   TunnelDevice any:any
+#   PermitLocalCommand no
+#   VisualHostKey no
+#   ProxyCommand ssh -q -W %h:%p gateway.example.com
+#   RekeyLimit 1G 1h
+    SendEnv LANG LC_*
+    HashKnownHosts yes
+    GSSAPIAuthentication yes
+    GSSAPIDelegateCredentials no
diff --git a/linux/etc/ssh/sshd_config b/linux/etc/ssh/sshd_config
new file mode 100644
--- /dev/null
+++ ./linux/etc/ssh/sshd_config
@@ -0,0 +1,88 @@
+# Package generated configuration file
+# See the sshd_config(5) manpage for details
+
+# What ports, IPs and protocols we listen for
+Port 22
+# Use these options to restrict which interfaces/protocols sshd will bind to
+#ListenAddress ::
+#ListenAddress 0.0.0.0
+Protocol 2
+# HostKeys for protocol version 2
+HostKey /etc/ssh/ssh_host_rsa_key
+HostKey /etc/ssh/ssh_host_dsa_key
+HostKey /etc/ssh/ssh_host_ecdsa_key
+HostKey /etc/ssh/ssh_host_ed25519_key
+#Privilege Separation is turned on for security
+UsePrivilegeSeparation yes
+
+# Lifetime and size of ephemeral version 1 server key
+KeyRegenerationInterval 3600
+ServerKeyBits 1024
+
+# Logging
+SyslogFacility AUTH
+LogLevel INFO
+
+# Authentication:
+LoginGraceTime 120
+PermitRootLogin yes
+StrictModes no
+
+RSAAuthentication yes
+PubkeyAuthentication yes
+#AuthorizedKeysFile	%h/.ssh/authorized_keys
+
+# Don't read the user's ~/.rhosts and ~/.shosts files
+IgnoreRhosts yes
+# For this to work you will also need host keys in /etc/ssh_known_hosts
+RhostsRSAAuthentication no
+# similar for protocol version 2
+HostbasedAuthentication no
+# Uncomment if you don't trust ~/.ssh/known_hosts for RhostsRSAAuthentication
+#IgnoreUserKnownHosts yes
+
+# To enable empty passwords, change to yes (NOT RECOMMENDED)
+PermitEmptyPasswords no
+
+# Change to yes to enable challenge-response passwords (beware issues with
+# some PAM modules and threads)
+ChallengeResponseAuthentication no
+
+# Change to no to disable tunnelled clear text passwords
+#PasswordAuthentication yes
+
+# Kerberos options
+#KerberosAuthentication no
+#KerberosGetAFSToken no
+#KerberosOrLocalPasswd yes
+#KerberosTicketCleanup yes
+
+# GSSAPI options
+#GSSAPIAuthentication no
+#GSSAPICleanupCredentials yes
+
+X11Forwarding yes
+X11DisplayOffset 10
+PrintMotd no
+PrintLastLog yes
+TCPKeepAlive yes
+#UseLogin no
+
+#MaxStartups 10:30:60
+#Banner /etc/issue.net
+
+# Allow client to pass locale environment variables
+AcceptEnv LANG LC_*
+
+Subsystem sftp /usr/lib/openssh/sftp-server
+
+# Set this to 'yes' to enable PAM authentication, account processing,
+# and session processing. If this is enabled, PAM authentication will
+# be allowed through the ChallengeResponseAuthentication and
+# PasswordAuthentication.  Depending on your PAM configuration,
+# PAM authentication via ChallengeResponseAuthentication may bypass
+# the setting of "PermitRootLogin without-password".
+# If you just want the PAM account and session checks to run without
+# PAM authentication, then enable this but set PasswordAuthentication
+# and ChallengeResponseAuthentication to 'no'.
+UsePAM yes
diff --git a/linux/etc/sudoers b/linux/etc/sudoers
new file mode 100644
--- /dev/null
+++ ./linux/etc/sudoers
@@ -0,0 +1,32 @@
+#
+# This file MUST be edited with the 'visudo' command as root.
+#
+# Please consider adding local content in /etc/sudoers.d/ instead of
+# directly modifying this file.
+#
+# See the man page for details on how to write a sudoers file.
+#
+Defaults	env_reset
+Defaults	mail_badpass
+Defaults	secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin"
+
+# Host alias specification
+
+# User alias specification
+
+# Cmnd alias specification
+
+# User privilege specification
+root	ALL=(ALL:ALL) ALL
+
+# Members of the admin group may gain root privileges
+%admin ALL=(ALL) ALL
+
+# Allow members of group sudo to execute any command
+%sudo	ALL=(ALL:ALL) ALL
+
+# See sudoers(5) for more information on "#include" directives:
+
+#includedir /etc/sudoers.d
+huangyingw     ALL=(ALL)       NOPASSWD: ALL
+admin     ALL=(ALL)       NOPASSWD: ALL
diff --git a/linux/usr/lib/systemd/system/NetworkManager-wait-online.service b/linux/usr/lib/systemd/system/NetworkManager-wait-online.service
new file mode 100644
--- /dev/null
+++ ./linux/usr/lib/systemd/system/NetworkManager-wait-online.service
@@ -0,0 +1,14 @@
+[Unit]
+Description=Network Manager Wait Online
+Documentation=man:nm-online(1)
+Requires=NetworkManager.service
+After=NetworkManager.service
+Before=network-online.target
+
+[Service]
+Type=oneshot
+ExecStart=/usr/bin/nm-online -s -q --timeout=10
+RemainAfterExit=yes
+
+[Install]
+WantedBy=network-online.target
diff --git a/linux_links/etc/crypttab b/linux_links/etc/crypttab
new file mode 100644
--- /dev/null
+++ ./linux_links/etc/crypttab
@@ -0,0 +1,21 @@
+archive1_crypt      /dev/disk/by-uuid/12d4b3f6-8ce1-49bc-ac5b-10a081822f90  /root/loadrc/keys/keyfile   luks
+archive2_crypt      /dev/disk/by-uuid/766063ea-304e-4fef-9954-7a638c946229  /root/loadrc/keys/keyfile   luks
+mldonkey      /dev/disk/by-uuid/17a98493-8e53-449e-bdfb-4358aceac548  /root/loadrc/keys/keyfile   luks
+mirror1      /dev/disk/by-uuid/1557210c-fd5f-4e61-9880-02b754f69dd6  /root/loadrc/keys/keyfile   luks
+mirror2      /dev/disk/by-uuid/695d4b27-0a6e-4563-a738-a6f1de7d8de6  /root/loadrc/keys/keyfile   luks
+usb_archive      /dev/disk/by-uuid/e6addd78-0027-4f36-9251-0788301303c6  /root/loadrc/keys/keyfile   luks
+usb_backup_crypt_4T      /dev/disk/by-uuid/4e0d72a2-2f98-4c11-becd-beaa21ec1957  /root/loadrc/keys/keyfile   luks
+usb_backup_crypt_5T_1      /dev/disk/by-uuid/2d5978f9-063c-48af-b270-1cf69672d92a  /root/loadrc/keys/keyfile   luks
+transmission      /dev/disk/by-uuid/a840176a-b76a-4d0f-962c-439e68107670  /root/loadrc/keys/keyfile   luks
+vserver_crypt      /dev/disk/by-uuid/a4ff213e-f734-4c88-aba9-2ce733d0de76  /root/loadrc/keys/keyfile   luks
+usb_backup_crypt_8T_1      /dev/disk/by-uuid/e1a69d4d-dacb-413b-8361-d59b401b80ad  /root/loadrc/keys/keyfile   luks
+usb_backup_crypt_8T_2      /dev/disk/by-uuid/4e1163f1-0df8-4416-9afd-b674808f87f9  /root/loadrc/keys/keyfile   luks
+timemachine      /dev/disk/by-uuid/72eff5fa-e188-4b1a-8760-5f5ff828aa37  /root/loadrc/keys/keyfile   luks
+zarchive      /dev/disk/by-uuid/69251abc-347f-4b64-be99-809da622893a  /root/loadrc/keys/keyfile   luks
+av91 /dev/disk/by-uuid/4211b914-5367-403f-aaa2-3dba45f41209  /root/loadrc/keys/keyfile   luks
+av81 /dev/disk/by-uuid/75ee8da8-8454-4b2c-96ca-d88ef135657e  /root/loadrc/keys/keyfile   luks
+av71 /dev/disk/by-uuid/3410d798-71e6-4131-bbcb-1fa07a98320d  /root/loadrc/keys/keyfile   luks
+av92 /dev/disk/by-uuid/7e2f0dc4-86e1-41a1-ba81-f20288d82c85  /root/loadrc/keys/keyfile   luks
+av82 /dev/disk/by-uuid/824d11c2-e8af-4502-8717-46b6e283d790  /root/loadrc/keys/keyfile   luks
+115_disk      /dev/disk/by-uuid/723f12b0-24a9-4ad0-a1ca-04cc8ee38bfd  /root/loadrc/keys/keyfile   luks
+116_disk      /dev/disk/by-uuid/1e7ecbca-28bd-454b-903c-8c81af5de753  /root/loadrc/keys/keyfile   luks
diff --git a/linux_links/etc/default/grub b/linux_links/etc/default/grub
new file mode 100644
--- /dev/null
+++ ./linux_links/etc/default/grub
@@ -0,0 +1,33 @@
+# If you change this file, run 'update-grub' afterwards to update
+# /boot/grub/grub.cfg.
+# For full documentation of the options in this file, see:
+#   info -f grub -n 'Simple configuration'
+
+GRUB_DEFAULT=0
+GRUB_TIMEOUT_STYLE=hidden
+GRUB_TIMEOUT=0
+GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
+GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
+GRUB_CMDLINE_LINUX="net.ifnames=0 biosdevname=0"
+
+# Uncomment to enable BadRAM filtering, modify to suit your needs
+# This works with Linux (no patch required) and with any kernel that obtains
+# the memory map information from GRUB (GNU Mach, kernel of FreeBSD ...)
+#GRUB_BADRAM="0x01234567,0xfefefefe,0x89abcdef,0xefefefef"
+
+# Uncomment to disable graphical terminal (grub-pc only)
+#GRUB_TERMINAL=console
+
+# The resolution used on graphical terminal
+# note that you can use only modes which your graphic card supports via VBE
+# you can see them in real GRUB with the command `vbeinfo'
+#GRUB_GFXMODE=640x480
+
+# Uncomment if you don't want GRUB to pass "root=UUID=xxx" parameter to Linux
+#GRUB_DISABLE_LINUX_UUID=true
+
+# Uncomment to disable generation of recovery mode menu entries
+#GRUB_DISABLE_RECOVERY="true"
+
+# Uncomment to get a beep at grub start
+#GRUB_INIT_TUNE="480 440 1"
diff --git a/linux_links/etc/resolvconf/resolv.conf.d/base_bak b/linux_links/etc/resolvconf/resolv.conf.d/base_bak
new file mode 100644
--- /dev/null
+++ ./linux_links/etc/resolvconf/resolv.conf.d/base_bak
@@ -0,0 +1,2 @@
+nameserver 192.168.31.1
+nameserver 10.1.10.1
diff --git a/linux_links/etc/resolvconf/resolv.conf.d/head_bak b/linux_links/etc/resolvconf/resolv.conf.d/head_bak
new file mode 100644
--- /dev/null
+++ ./linux_links/etc/resolvconf/resolv.conf.d/head_bak
@@ -0,0 +1,6 @@
+# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
+#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
+# 127.0.0.53 is the systemd-resolved stub resolver.
+# run "systemd-resolve --status" to see details about the actual nameservers.
+nameserver 192.168.31.1
+nameserver 10.1.10.1
diff --git a/mac_sync.list b/mac_sync.list
new file mode 100644
--- /dev/null
+++ ./mac_sync.list
@@ -0,0 +1 @@
+~/Pictures/Photos Library.photoslibrary
diff --git a/macos.conf b/macos.conf
new file mode 100644
--- /dev/null
+++ ./macos.conf
@@ -0,0 +1 @@
+/etc/sudoers
diff --git a/macos/.bashrc b/macos/.bashrc
new file mode 120000
--- /dev/null
+++ ./macos/.bashrc
@@ -0,0 +1 @@
+/Users/huangyingw/Dropbox/loadrc.home/hosts/imacpro/Users/huangyingw/.bashrc
\ No newline at end of file
diff --git a/macos/etc/sudoers b/macos/etc/sudoers
new file mode 100644
--- /dev/null
+++ ./macos/etc/sudoers
@@ -0,0 +1,48 @@
+# sudoers file.
+#
+# This file MUST be edited with the 'visudo' command as root.
+# Failure to use 'visudo' may result in syntax or file permission errors
+# that prevent sudo from running.
+#
+# See the sudoers man page for the details on how to write a sudoers file.
+#
+
+# Host alias specification
+
+# User alias specification
+
+# Cmnd alias specification
+
+# Defaults specification
+Defaults	env_reset
+Defaults	env_keep += "BLOCKSIZE"
+Defaults	env_keep += "COLORFGBG COLORTERM"
+Defaults	env_keep += "__CF_USER_TEXT_ENCODING"
+Defaults	env_keep += "CHARSET LANG LANGUAGE LC_ALL LC_COLLATE LC_CTYPE"
+Defaults	env_keep += "LC_MESSAGES LC_MONETARY LC_NUMERIC LC_TIME"
+Defaults	env_keep += "LINES COLUMNS"
+Defaults	env_keep += "LSCOLORS"
+Defaults	env_keep += "SSH_AUTH_SOCK"
+Defaults	env_keep += "TZ"
+Defaults	env_keep += "DISPLAY XAUTHORIZATION XAUTHORITY"
+Defaults	env_keep += "EDITOR VISUAL"
+Defaults	env_keep += "HOME MAIL"
+
+# Runas alias specification
+
+# User privilege specification
+root	ALL=(ALL) ALL
+%admin	ALL=(ALL) ALL
+
+# Uncomment to allow people in group wheel to run all commands
+# %wheel	ALL=(ALL) ALL
+
+# Same thing without a password
+# %wheel	ALL=(ALL) NOPASSWD: ALL
+
+# Samples
+# %users  ALL=/sbin/mount /cdrom,/sbin/umount /cdrom
+# %users  localhost=/sbin/shutdown -h now
+huangyingw     ALL=(ALL)       NOPASSWD: ALL
+admin     ALL=(ALL)       NOPASSWD: ALL
+ying.huang     ALL=(ALL)       NOPASSWD: ALL
diff --git a/macosrc/configure_mosh.sh b/macosrc/configure_mosh.sh
new file mode 100755
--- /dev/null
+++ ./macosrc/configure_mosh.sh
@@ -0,0 +1,13 @@
+#!/bin/zsh
+BINPATH=$(realpath $(which mosh-server))
+
+# Turn the firewall off
+/usr/bin/sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setglobalstate off
+
+# Enable the firewall rules (make sure you are using your actual path)
+/usr/bin/sudo /usr/libexec/ApplicationFirewall/socketfilterfw --add "$BINPATH"
+
+/usr/bin/sudo /usr/libexec/ApplicationFirewall/socketfilterfw --unblockapp "$BINPATH"
+
+# Turn the firewall back on
+/usr/bin/sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setglobalstate on
diff --git a/macosrc/configure_ssh.sh b/macosrc/configure_ssh.sh
new file mode 100755
--- /dev/null
+++ ./macosrc/configure_ssh.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+sudo cp -nv /etc/ssh/sshd_config /etc/ssh/sshd_config.bak
+sudo cp -fv ./etc/ssh/sshd_config /etc/ssh/sshd_config
diff --git a/macosrc/enable_screen_sharing.sh b/macosrc/enable_screen_sharing.sh
new file mode 100755
--- /dev/null
+++ ./macosrc/enable_screen_sharing.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+sudo defaults write /var/db/launchd.db/com.apple.launchd/overrides.plist com.apple.screensharing -dict Disabled -bool false
+sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.screensharing.plist
diff --git a/macosrc/etc/ssh/sshd_config b/macosrc/etc/ssh/sshd_config
new file mode 100644
--- /dev/null
+++ ./macosrc/etc/ssh/sshd_config
@@ -0,0 +1,120 @@
+#	$OpenBSD: sshd_config,v 1.103 2018/04/09 20:41:22 tj Exp $
+
+# This is the sshd server system-wide configuration file.  See
+# sshd_config(5) for more information.
+
+# This sshd was compiled with PATH=/usr/bin:/bin:/usr/sbin:/sbin
+
+# The strategy used for options in the default sshd_config shipped with
+# OpenSSH is to specify options with their default value where
+# possible, but leave them commented.  Uncommented options override the
+# default value.
+
+#Port 22
+#AddressFamily any
+#ListenAddress 0.0.0.0
+#ListenAddress ::
+
+#HostKey /etc/ssh/ssh_host_rsa_key
+#HostKey /etc/ssh/ssh_host_ecdsa_key
+#HostKey /etc/ssh/ssh_host_ed25519_key
+
+# Ciphers and keying
+#RekeyLimit default none
+
+# Logging
+#SyslogFacility AUTH
+#LogLevel INFO
+
+# Authentication:
+
+#LoginGraceTime 2m
+#PermitRootLogin prohibit-password
+#StrictModes yes
+#MaxAuthTries 6
+#MaxSessions 10
+
+#PubkeyAuthentication yes
+
+# The default is to check both .ssh/authorized_keys and .ssh/authorized_keys2
+# but this is overridden so installations will only check .ssh/authorized_keys
+AuthorizedKeysFile	.ssh/authorized_keys
+
+#AuthorizedPrincipalsFile none
+
+#AuthorizedKeysCommand none
+#AuthorizedKeysCommandUser nobody
+
+# For this to work you will also need host keys in /etc/ssh/ssh_known_hosts
+#HostbasedAuthentication no
+# Change to yes if you don't trust ~/.ssh/known_hosts for
+# HostbasedAuthentication
+#IgnoreUserKnownHosts no
+# Don't read the user's ~/.rhosts and ~/.shosts files
+#IgnoreRhosts yes
+
+# To disable tunneled clear text passwords, change to no here!
+#PasswordAuthentication yes
+#PermitEmptyPasswords no
+
+# Change to no to disable s/key passwords
+#ChallengeResponseAuthentication yes
+
+# Kerberos options
+#KerberosAuthentication no
+#KerberosOrLocalPasswd yes
+#KerberosTicketCleanup yes
+#KerberosGetAFSToken no
+
+# GSSAPI options
+#GSSAPIAuthentication no
+#GSSAPICleanupCredentials yes
+
+# Set this to 'yes' to enable PAM authentication, account processing,
+# and session processing. If this is enabled, PAM authentication will
+# be allowed through the ChallengeResponseAuthentication and
+# PasswordAuthentication.  Depending on your PAM configuration,
+# PAM authentication via ChallengeResponseAuthentication may bypass
+# the setting of "PermitRootLogin without-password".
+# If you just want the PAM account and session checks to run without
+# PAM authentication, then enable this but set PasswordAuthentication
+# and ChallengeResponseAuthentication to 'no'.
+UsePAM yes
+
+#AllowAgentForwarding yes
+#AllowTcpForwarding yes
+#GatewayPorts no
+#X11Forwarding no
+#X11DisplayOffset 10
+#X11UseLocalhost yes
+#PermitTTY yes
+#PrintMotd yes
+#PrintLastLog yes
+#TCPKeepAlive yes
+#PermitUserEnvironment no
+#Compression delayed
+#ClientAliveInterval 0
+#ClientAliveCountMax 3
+#UseDNS no
+#PidFile /var/run/sshd.pid
+#MaxStartups 10:30:100
+#PermitTunnel no
+#ChrootDirectory none
+#VersionAddendum none
+
+# pass locale information
+AcceptEnv LANG LC_*
+
+# no default banner path
+#Banner none
+
+# override default of no subsystems
+Subsystem	sftp	/usr/libexec/sftp-server
+
+# Example of overriding settings on a per-user basis
+#Match User anoncvs
+#	X11Forwarding no
+#	AllowTcpForwarding no
+#	PermitTTY no
+#	ForceCommand cvs server
+PermitUserEnvironment PATH,LANG
diff --git a/macosrc/restart_ssh.sh b/macosrc/restart_ssh.sh
new file mode 100755
--- /dev/null
+++ ./macosrc/restart_ssh.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+
+sudo launchctl unload /System/Library/LaunchDaemons/ssh.plist
+sudo launchctl load -w /System/Library/LaunchDaemons/ssh.plist
+sudo launchctl stop com.openssh.sshd
+sudo launchctl start com.openssh.sshd
diff --git a/macrc/mac_sync.list b/macrc/mac_sync.list
new file mode 100644
--- /dev/null
+++ ./macrc/mac_sync.list
@@ -0,0 +1 @@
+~/Pictures/Photos\ Library.photoslibrary/
diff --git a/macrc/mac_sync.sh b/macrc/mac_sync.sh
new file mode 100755
--- /dev/null
+++ ./macrc/mac_sync.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+rsync -aHv --progress --delete-before --force  ~/Library/Application\ Support/Google/Chrome/Default/ mbp:"~/Library/Application\ Support/Google/Chrome/Default/"
diff --git a/macrc/mac_sync_test.sh b/macrc/mac_sync_test.sh
new file mode 100755
--- /dev/null
+++ ./macrc/mac_sync_test.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./mac_sync.sh mini
diff --git a/macrc/reboot_recovery.sh b/macrc/reboot_recovery.sh
new file mode 100755
--- /dev/null
+++ ./macrc/reboot_recovery.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh 
+sudo nvram "recovery-boot-mode=unused"
+sudo reboot recovery
diff --git a/mdadmrc/add.sh b/mdadmrc/add.sh
new file mode 100755
--- /dev/null
+++ ./mdadmrc/add.sh
@@ -0,0 +1,9 @@
+#!/bin/zsh
+mdadm --manage /dev/md0 --run
+mdadm --manage /dev/md0 --add /dev/sdf1
+mdadm -v --grow --raid-devices=5 /dev/md0
+mdadm --grow /dev/md0 --size=max
+
+reboot
+e2fsck -f /dev/mapper/md0_crypt
+resize2fs /dev/mapper/md0_crypt
diff --git a/mdadmrc/check_raid.sh b/mdadmrc/check_raid.sh
new file mode 100755
--- /dev/null
+++ ./mdadmrc/check_raid.sh
@@ -0,0 +1,17 @@
+#!/bin/zsh
+DEVICE=`mdadm -D --scan|awk '{print $2}'`
+
+if [ -z "$DEVICE" ]
+then
+    return
+fi
+
+raid_state=$(mdadm -D "$DEVICE" | awk '/State :/{print $3}')
+
+if [[ "$raid_state" != "clean" ]] && [[ "$raid_state" != "active" ]]
+then
+    echo dangerous
+    echo dangerous
+    echo dangerous
+fi
+# watch cat /proc/mdstat
diff --git a/mdadmrc/create.sh b/mdadmrc/create.sh
new file mode 100755
--- /dev/null
+++ ./mdadmrc/create.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+#mdadm: at least 4 raid-devices needed for level 6
+mdadm --create --verbose /dev/md0 --level=6 --raid-devices=4 /dev/sd[b-e]1
+cryptsetup luksAddKey /dev/md0 /root/loadrc/keys/keyfile
+mdadm --detail --scan >> /etc/mdadm/mdadm.conf
+update-initramfs -u
+reboot
diff --git a/mdadmrc/reactivate.sh b/mdadmrc/reactivate.sh
new file mode 100755
--- /dev/null
+++ ./mdadmrc/reactivate.sh
@@ -0,0 +1,4 @@
+#!/bin/zsh 
+#reactivate array
+mdadm --stop /dev/md0
+mdadm --assemble --force /dev/md0 /dev/sd[b-e]1
diff --git a/mdadmrc/replace.sh b/mdadmrc/replace.sh
new file mode 100755
--- /dev/null
+++ ./mdadmrc/replace.sh
@@ -0,0 +1,4 @@
+#!/bin/zsh
+mdadm /dev/md0 -f /dev/sda1
+mdadm --manage /dev/md0 --add /dev/sda1
+mdadm --manage /dev/md0 --remove /dev/sda1
diff --git a/musicrc/copy_test.sh b/musicrc/copy_test.sh
new file mode 100755
--- /dev/null
+++ ./musicrc/copy_test.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh 
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./copy.sh /media/volgrp/mirror/musics/ xiaomi:/data/data/com.arachnoid.sshelper/files/home/SDCard/music/ 
diff --git a/musicrc/move.sh b/musicrc/move.sh
new file mode 100755
--- /dev/null
+++ ./musicrc/move.sh
@@ -0,0 +1,17 @@
+#!/bin/zsh
+SOURCE=$1
+TARGET=$2
+
+doCopy () {
+    rsync -aHv --progress --remove-source-files --max-size="$1" --force \
+        --exclude \*.zip  \
+        --exclude \*.rar  \
+        "${SOURCE}" "${TARGET}"
+}
+
+COUNTER=10
+while [[  $COUNTER -lt 1900 ]]; do
+    MAXSIZE="$COUNTER""m"
+    doCopy "$MAXSIZE"
+    let COUNTER=COUNTER+10
+done
diff --git a/musicrc/move.test.sh b/musicrc/move.test.sh
new file mode 100755
--- /dev/null
+++ ./musicrc/move.test.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./move.sh mini:/media/mirror2/mirror2/musics/ "/Volumes/NO NAME/musics"
diff --git a/musicrc/unrar.sh b/musicrc/unrar.sh
new file mode 100755
--- /dev/null
+++ ./musicrc/unrar.sh
@@ -0,0 +1,20 @@
+#!/bin/zsh
+
+if [ -z "$1" ]
+then
+    echo -e "${red}Please provide the target folder ... ${NC}"
+    exit 1
+fi
+
+find "$1" -type f -iname \*.rar | \
+    while read ss
+    do
+        ss="$(realpath "$ss")" && \
+            cd "$(dirname "$ss")" && \
+            unrar x -r -pwww.pt80.net -o+ "$ss" && rm "$ss" ; \
+            unrar x -r -photnrg -o+ "$ss" && rm "$ss" ; \
+            unrar x -r -pwww.zasv.com- -o+ "$ss" && rm "$ss" ; \
+            unrar x -r -pwww.zasv.com -o+ "$ss" && rm "$ss" ; \
+            unrar x -r -p -o+ "$ss" && rm "$ss" ; \
+            unrar x -r -pUploadByK@TSDM.NET -o+ "$ss" && rm "$ss" ; \
+    done
diff --git a/musicrc/unrar_test.sh b/musicrc/unrar_test.sh
new file mode 100755
--- /dev/null
+++ ./musicrc/unrar_test.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./unrar.sh /media/volgrp/mirror/musics/
diff --git a/musicrc/unzip.sh b/musicrc/unzip.sh
new file mode 100755
--- /dev/null
+++ ./musicrc/unzip.sh
@@ -0,0 +1,14 @@
+#!/bin/zsh
+
+if [ -z "$1" ]
+then
+    echo -e "${red}Please provide the target folder ... ${NC}"
+    exit 1
+fi
+
+find "$1" -type f -iname \*.zip | \
+    while read ss
+    do
+        unzip -n -d "$(echo "$ss"|sed 's/\.zip$//g')" "$ss" && \
+            rm "$ss"
+    done
diff --git a/neovim b/neovim
new file mode 160000
--- /dev/null
+++ ./neovim
@@ -0,0 +1 @@
+Subproject commit 36d575f310c58292bdcff02db9ce8d8e71c94007-dirty
diff --git a/networkrc/ping.sh b/networkrc/ping.sh
new file mode 100755
--- /dev/null
+++ ./networkrc/ping.sh
@@ -0,0 +1,16 @@
+#!/bin/zsh
+((count = 10))                           # Maximum number to try.
+
+while [[ $count -ne 0 ]] ; do
+    /usr/bin/ping -c 1 8.8.8.8
+    rc=$?
+
+    if [[ $rc -eq 0 ]] ; then
+        ((count = 1))                    # If okay, flag loop exit.
+    else
+        sleep 1                          # Minimise network storm.
+    fi
+    ((count = count - 1))                # So we don't go forever.
+done
+
+exit $rc
diff --git a/networkrc/ping.test.sh b/networkrc/ping.test.sh
new file mode 100755
--- /dev/null
+++ ./networkrc/ping.test.sh
@@ -0,0 +1,14 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./ping.sh
+rc=$?
+
+if [[ $rc -eq 0 ]]
+then
+    echo "say The internet is back up."
+else
+    echo "say Timeout."
+fi
diff --git a/networkrc/temp.sh b/networkrc/temp.sh
new file mode 100755
--- /dev/null
+++ ./networkrc/temp.sh
@@ -0,0 +1,9 @@
+ifconfig wlan0 down
+ping -c 1 8.8.8.8
+rc=$?
+
+if [[ $rc -eq 0 ]] ; then
+    echo "network is working"
+else
+    echo "network is not working"
+fi
diff --git a/openrc.sh b/openrc.sh
--- ./openrc.sh
+++ ./openrc.sh
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/bin/zsh
 
 # With the addition of Keystone, to use an openstack cloud you should
 # authenticate against keystone, which returns a **Token** and **Service
diff --git a/osxrc/restart_bluetooth.sh b/osxrc/restart_bluetooth.sh
new file mode 100755
--- /dev/null
+++ ./osxrc/restart_bluetooth.sh
@@ -0,0 +1,20 @@
+#!/bin/zsh
+KeepConnect() {
+    ID="$1"
+    while [[ $(blueutil --is-connected "$ID") != 1 ]]
+    do
+        blueutil -p 1
+        blueutil --connect "$ID"
+    done
+}
+
+blueutil -p 0
+
+while [[ $(blueutil -p) != 1 ]]
+do
+    blueutil -p 1
+done
+
+KeepConnect 74-1a-e0-20-d3-b7 & # nuraphone 608
+KeepConnect 64-a5-c3-f2-5e-00 & # Ying Huangs Trackpad II
+KeepConnect 8c-85-90-f3-90-69 & # Magic Trackpad 2
diff --git a/osxrc/restart_wifi.sh b/osxrc/restart_wifi.sh
new file mode 100755
--- /dev/null
+++ ./osxrc/restart_wifi.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+sudo ifconfig en1 down && sudo ifconfig en1 up
diff --git a/pbpaste-remote b/pbpaste-remote
new file mode 100755
--- /dev/null
+++ ./pbpaste-remote
@@ -0,0 +1,2 @@
+#!/bin/sh
+nc localhost 2225
diff --git a/pdfrc/all_2_txt.sh b/pdfrc/all_2_txt.sh
new file mode 100755
--- /dev/null
+++ ./pdfrc/all_2_txt.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+
+find . -type f -iname \*.pdf | while read ss
+do
+    pdftotext "$ss" "$(echo "$ss" | sed 's/\.pdf/\.txt/g')"
+done
diff --git a/perlrc/replace.pl b/perlrc/replace.pl
new file mode 100644
--- /dev/null
+++ ./perlrc/replace.pl
@@ -0,0 +1,3 @@
+#!/usr/bin/perl
+find . -type f -name \*.java -exec perl -0777 -i.bak -pe 's/\@Test\n\s+public/\@Test\n  \@Ignore\n  public/igs' {} +
+find . -type f -name \*.java -exec perl -0777 -i.bak -pe 's/import org.junit.Test;/import org.junit.Ignore;\nimport org.junit.Test;/igs' {} +
diff --git a/post_setup.sh b/post_setup.sh
new file mode 100755
--- /dev/null
+++ ./post_setup.sh
@@ -0,0 +1,13 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+if [ $(uname) = "Darwin" ]
+then
+    ./bashrc/update_proj.sh
+fi
+
+./gitrc/gclean.sh
+chown $(whoami) -R ~/loadrc/oh-my-zsh/
+chown $(whoami) ~/.ssh/config
diff --git a/prunefile_template.conf b/prunefile_template.conf
new file mode 100644
--- /dev/null
+++ ./prunefile_template.conf
@@ -0,0 +1,7 @@
+"./.fugitiveblame"
+"./cscope"
+"./files.proj"
+"./gbra.log"
+"./running.lck"
+"./running.time"
+.err
diff --git a/prunefix_template.conf b/prunefix_template.conf
new file mode 100644
--- /dev/null
+++ ./prunefix_template.conf
@@ -0,0 +1,73 @@
+"./*.diff"
+"./*.fugitiveblame"
+"./*.log"
+"./*/running.time"
+"./cscope.*"
+*.7z
+*.JPG
+*.MF
+*.as
+*.bak
+*.bmp
+*.cache
+*.cer
+*.cfl
+*.class
+*.csv
+*.cvs
+*.db
+*.diff
+*.eot
+*.exe
+*.findresult
+*.fla
+*.flv
+*.gif
+*.git
+*.gz
+*.hb
+*.hb.js
+*.hg
+*.ico
+*.ipynb
+*.jar
+*.jpeg
+*.jpg
+*.js.map
+*.key
+*.lck
+*.metadata
+*.min.js
+*.min.map
+*.mo
+*.msi
+*.orig
+*.otf
+*.out
+*.pdf
+*.pem
+*.pickle
+*.png
+*.psd
+*.py[co]
+*.rar
+*.rdb
+*.runresult
+*.svn
+*.sw[a-z]
+*.tmp
+*.ts
+*.ttf
+*.woff
+*.zip
+*/.classpath
+*/.fugitiveblame
+*/.project
+*/.ropeproject/*
+*/.settings/*
+*/files.proj
+*/gbil.log
+./*/includefile.conf
+./*/prunefile.conf
+./*/prunefix.conf
+fav.log.*
diff --git a/pythonrc/autopep8-ipynb.py b/pythonrc/autopep8-ipynb.py
new file mode 100644
--- /dev/null
+++ ./pythonrc/autopep8-ipynb.py
@@ -0,0 +1,25 @@
+# -*- coding: utf-8 -*-
+# Author: Christopher Hench
+# command line program makes ipynb PEP-8 compliant
+
+import json
+import autopep8
+import sys
+import re
+
+file_path = sys.argv[1]
+notebook = json.load(open(file_path, 'r'))
+
+for c in notebook['cells']:
+    if c['cell_type'] == 'code':
+        cell_code = ''.join(c['source'])
+        pep8_code = autopep8.fix_code(cell_code, options={'aggressive': 1})
+        pep8_cell = re.split(r'(\n)', pep8_code)
+        pep8_cell = [x for x in pep8_cell if len(x) > 0]
+
+        if len(pep8_cell) > 0 and pep8_cell[-1] == "\n":
+            pep8_cell = pep8_cell[:-1]
+
+        c['source'] = pep8_cell
+
+json.dump(notebook, open(file_path, "w"))
diff --git a/pythonrc/handle_vtt.py b/pythonrc/handle_vtt.py
new file mode 100755
--- /dev/null
+++ ./pythonrc/handle_vtt.py
@@ -0,0 +1,22 @@
+#!/usr/bin/env python3
+from os import path
+import datetime
+import re
+
+
+def parse_vtt_str(time_string):
+    r2 = re.findall(r"\d+:\d+:\d+(?=[^:]*-->)", time_string)
+    date_time = datetime.datetime.strptime(r2[0], "%H:%M:%S")
+    a_timedelta = date_time - datetime.datetime(1900, 1, 1)
+    seconds = a_timedelta.total_seconds()
+    return seconds
+
+
+def find_vtt_video(filename):
+    regex = r".+(?=\.en\.(vtt|srt)$)"
+    matches = re.finditer(regex, filename, re.MULTILINE)
+    for matchNum, match in enumerate(matches, start=1):
+        for postfix in ["mp4", "mkv", "webm"]:
+            targetFile = match.group() + "." + postfix
+            if path.exists(targetFile):
+                return targetFile
diff --git a/pythonrc/handle_vtt_test.py b/pythonrc/handle_vtt_test.py
new file mode 100644
--- /dev/null
+++ ./pythonrc/handle_vtt_test.py
@@ -0,0 +1,22 @@
+#!/usr/bin/env python3
+from handle_vtt import *
+import unittest
+
+
+class TestHandle_Vtt(unittest.TestCase):
+    def test_parse_vtt_str(self):
+        time_string = "00:00:08.690 --> 00:00:08.700 align:start position:0%"
+        start = parse_vtt_str(time_string)
+        self.assertEqual(start, 8.0)
+        time_string = "00:10:08.690 --> 00:00:08.700 align:start position:0%"
+        start = parse_vtt_str(time_string)
+        self.assertEqual(start, 608.0)
+
+    def test_find_vtt_video(self):
+        fileVar = "/Users/huangyingw/Dropbox/learning/AI/fast.ai/Intro_to_Machine_Learning_-_Lesson_1.en.vtt"
+        videoFile = find_vtt_video(fileVar)
+        self.assertEqual(videoFile, '/Users/huangyingw/Dropbox/learning/AI/fast.ai/Intro_to_Machine_Learning_-_Lesson_1.mkv')
+
+
+if __name__ == '__main__':
+    unittest.main()
diff --git a/pythonrc/remove-unuses.sh b/pythonrc/remove-unuses.sh
new file mode 100755
--- /dev/null
+++ ./pythonrc/remove-unuses.sh
@@ -0,0 +1,9 @@
+#!/bin/zsh
+if [ -z "$1" ]
+then
+    echo -e "${red}Please provide TARGET ... ${NC}"
+    exit 1
+fi
+
+TARGET="$1"
+autoflake --in-place --remove-all-unused-imports "$TARGET"
diff --git a/pythonrc/remove_comments.py b/pythonrc/remove_comments.py
new file mode 100755
--- /dev/null
+++ ./pythonrc/remove_comments.py
@@ -0,0 +1,43 @@
+#!/usr/bin/env python3
+import sys
+import token
+import tokenize
+
+
+def do_file(fname):
+    """ Run on just one file.
+    """
+    source = open(fname)
+    mod = open(fname + ".strip", "w")
+
+    prev_toktype = token.INDENT
+    last_lineno = -1
+    last_col = 0
+
+    tokgen = tokenize.generate_tokens(source.readline)
+    for toktype, ttext, (slineno, scol), (elineno, ecol), ltext in tokgen:
+        if 0:   # Change to if 1 to see the tokens fly by.
+            print("%10s %-14s %-20r %r" % (
+                tokenize.tok_name.get(toktype, toktype),
+                "%d.%d-%d.%d" % (slineno, scol, elineno, ecol),
+                ttext, ltext
+            ))
+        if slineno > last_lineno:
+            last_col = 0
+        if scol > last_col:
+            mod.write(" " * (scol - last_col))
+        if toktype == token.STRING and prev_toktype == token.INDENT:
+            # Docstring
+            mod.write("#--")
+        elif toktype == tokenize.COMMENT:
+            # Comment
+            mod.write("##\n")
+        else:
+            mod.write(ttext)
+        prev_toktype = toktype
+        last_col = ecol
+        last_lineno = elineno
+
+
+if __name__ == '__main__':
+    do_file(sys.argv[1])
diff --git a/pythonrc/setup.cfg b/pythonrc/setup.cfg
new file mode 100644
--- /dev/null
+++ ./pythonrc/setup.cfg
@@ -0,0 +1,2 @@
+[pep8]
+select = E101,E111,E112,E113,E114,E115,E116,E121,E122,E123,E124,E125,E126,E127,E128,E129,E131,E133,E201,E202,E203,E211,E221,E222,E223,E224,E225,E226,E227,E228,E231,E241,E242,E251,E261,E262,E265,E266,E271,E272,E273,E274,E275,E301,E302,E303,E304,E305,E306,E401,E402,E502,E701,E702,E703,E704,E711,E712,E713,E714,E721,E722,E731,E741,E742,E743,E901,E902,W191,W291,W292,W293,W391,W503,W504,W601,W602,W603,W604,W605
diff --git a/pythonrc/setup.cfg.src b/pythonrc/setup.cfg.src
new file mode 100644
--- /dev/null
+++ ./pythonrc/setup.cfg.src
@@ -0,0 +1,113 @@
+code 	sample message
+E1 	Indentation
+E101 	indentation contains mixed spaces and tabs
+E111 	indentation is not a multiple of four
+E112 	expected an indented block
+E113 	unexpected indentation
+E114 	indentation is not a multiple of four (comment)
+E115 	expected an indented block (comment)
+E116 	unexpected indentation (comment)
+  	 
+E121 (*^) 	continuation line under-indented for hanging indent
+E122 (^) 	continuation line missing indentation or outdented
+E123 (*) 	closing bracket does not match indentation of opening brackets line
+E124 (^) 	closing bracket does not match visual indentation
+E125 (^) 	continuation line with same indent as next logical line
+E126 (*^) 	continuation line over-indented for hanging indent
+E127 (^) 	continuation line over-indented for visual indent
+E128 (^) 	continuation line under-indented for visual indent
+E129 (^) 	visually indented line with same indent as next logical line
+E131 (^) 	continuation line unaligned for hanging indent
+E133 (*) 	closing bracket is missing indentation
+  	 
+E2 	Whitespace
+E201 	whitespace after (
+E202 	whitespace before )
+E203 	whitespace before :
+  	 
+E211 	whitespace before (
+  	 
+E221 	multiple spaces before operator
+E222 	multiple spaces after operator
+E223 	tab before operator
+E224 	tab after operator
+E225 	missing whitespace around operator
+E226 (*) 	missing whitespace around arithmetic operator
+E227 	missing whitespace around bitwise or shift operator
+E228 	missing whitespace around modulo operator
+  	 
+E231 	missing whitespace after ,, ;, or :
+  	 
+E241 (*) 	multiple spaces after ,
+E242 (*) 	tab after ,
+  	 
+E251 	unexpected spaces around keyword / parameter equals
+  	 
+E261 	at least two spaces before inline comment
+E262 	inline comment should start with # 
+E265 	block comment should start with # 
+E266 	too many leading # for block comment
+  	 
+E271 	multiple spaces after keyword
+E272 	multiple spaces before keyword
+E273 	tab after keyword
+E274 	tab before keyword
+E275 	missing whitespace after keyword
+  	 
+E3 	Blank line
+E301 	expected 1 blank line, found 0
+E302 	expected 2 blank lines, found 0
+E303 	too many blank lines (3)
+E304 	blank lines found after function decorator
+E305 	expected 2 blank lines after end of function or class
+E306 	expected 1 blank line before a nested definition
+  	 
+E4 	Import
+E401 	multiple imports on one line
+E402 	module level import not at top of file
+  	 
+E5 	Line length
+E501 (^) 	line too long (82 > 79 characters)
+E502 	the backslash is redundant between brackets
+  	 
+E7 	Statement
+E701 	multiple statements on one line (colon)
+E702 	multiple statements on one line (semicolon)
+E703 	statement ends with a semicolon
+E704 (*) 	multiple statements on one line (def)
+E711 (^) 	comparison to None should be if cond is None:
+E712 (^) 	comparison to True should be if cond is True: or if cond:
+E713 	test for membership should be not in
+E714 	test for object identity should be is not
+E721 (^) 	do not compare types, use isinstance()
+E722 	do not use bare except, specify exception instead
+E731 	do not assign a lambda expression, use a def
+E741 	do not use variables named l, O, or I
+E742 	do not define classes named l, O, or I
+E743 	do not define functions named l, O, or I
+  	 
+E9 	Runtime
+E901 	SyntaxError or IndentationError
+E902 	IOError
+  	 
+W1 	Indentation warning
+W191 	indentation contains tabs
+  	 
+W2 	Whitespace warning
+W291 	trailing whitespace
+W292 	no newline at end of file
+W293 	blank line contains whitespace
+  	 
+W3 	Blank line warning
+W391 	blank line at end of file
+  	 
+W5 	Line break warning
+W503 (*) 	line break before binary operator
+W504 (*) 	line break after binary operator
+  	 
+W6 	Deprecation warning
+W601 	.has_key() is deprecated, use in
+W602 	deprecated form of raising exception
+W603 	<> is deprecated, use !=
+W604 	backticks are deprecated, use repr()
+W605 	invalid escape sequence x
diff --git a/pythonrc/vlc.py b/pythonrc/vlc.py
new file mode 100755
--- /dev/null
+++ ./pythonrc/vlc.py
@@ -0,0 +1,28 @@
+#!/usr/bin/env python3
+from handle_vtt import *
+from os import path
+import platform
+import subprocess
+import sys
+fileVar = sys.argv[1]
+lineVar = sys.argv[2]
+targetFile = path.dirname(fileVar) + '/' + lineVar
+
+
+def callvlc(targetFile, start=0):
+    if targetFile:
+        if platform.system() == 'Darwin':
+            if start == 0:
+                subprocess.check_call(['/Applications/VLC.app/Contents/MacOS/VLC', '--sub-language', 'Chinese', '--sub-autodetect-file', '-f', '--macosx-continue-playback=2', '--rate=2.0', targetFile])
+            else:
+                subprocess.check_call(['/Applications/VLC.app/Contents/MacOS/VLC', '--sub-language', 'Chinese', '--sub-autodetect-file', '-f', '--macosx-continue-playback=2', '--start-time=' + str(start), targetFile])
+        else:
+            subprocess.check_call(['smplayer', '-fullscreen', targetFile])
+
+
+if path.exists(targetFile):
+    callvlc(targetFile)
+else:
+    start = parse_vtt_str(lineVar)
+    targetFile = find_vtt_video(fileVar)
+    callvlc(targetFile, start)
diff --git a/pythonrc/vlc.py.sh b/pythonrc/vlc.py.sh
new file mode 100755
--- /dev/null
+++ ./pythonrc/vlc.py.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./vlc.py "/Users/huangyingw/Dropbox/learning/AI/fast.ai/fav.log" "Machine_Learning_1_-_Lesson_8.mkv"
+./vlc.py "/Users/huangyingw/Dropbox/learning/AI/fast.ai/Intro_to_Machine_Learning_-_Lesson_1.en.vtt" "00:11:12.620 --> 02:11:17.560"
diff --git a/rsync b/rsync
new file mode 160000
--- /dev/null
+++ ./rsync
@@ -0,0 +1 @@
+Subproject commit 722e846d30d1b6a0c3707479a9b53cca1907210c-dirty
diff --git a/ruleref.list b/ruleref.list
new file mode 100644
--- /dev/null
+++ ./ruleref.list
@@ -0,0 +1,68 @@
+Generic.Classes.DuplicateClassName
+Generic.CodeAnalysis.EmptyStatement
+Generic.CodeAnalysis.ForLoopShouldBeWhileLoop
+Generic.CodeAnalysis.ForLoopWithTestFunctionCall
+Generic.CodeAnalysis.JumbledIncrementer
+Generic.CodeAnalysis.UnconditionalIfStatement
+Generic.CodeAnalysis.UnnecessaryFinalModifier
+Generic.CodeAnalysis.UnusedFunctionParameter
+Generic.Commenting.Fixme
+Generic.Commenting.Todo
+Generic.ControlStructures.InlineControlStructure
+Generic.Formatting.DisallowMultipleStatements
+Generic.Formatting.SpaceAfterCast
+Generic.Functions.CallTimePassByReference
+Generic.Functions.OpeningFunctionBraceKernighanRitchie
+Generic.Metrics.NestingLevel
+Generic.NamingConventions.CamelCapsFunctionName
+Generic.NamingConventions.ConstructorName
+Generic.NamingConventions.UpperCaseConstantName
+Generic.PHP.DeprecatedFunctions
+Generic.PHP.DisallowShortOpenTag
+Generic.PHP.ForbiddenFunctions
+Generic.PHP.NoSilencedErrors
+Generic.Strings.UnnecessaryStringConcat
+Generic.WhiteSpace.DisallowTabIndent
+Generic.WhiteSpace.ScopeIndent
+MySource.PHP.EvalObjectFactory
+MySource.PHP.GetRequestData
+PEAR.Commenting.InlineComment
+PEAR.Formatting.MultiLineAssignment
+PEAR.Functions.ValidDefaultValue
+PEAR.NamingConventions.ValidClassName
+PEAR.NamingConventions.ValidFunctionName
+PEAR.NamingConventions.ValidVariableName
+PEAR.WhiteSpace.ObjectOperatorIndent
+PEAR.WhiteSpace.ScopeIndent
+PSR2.Classes.PropertyDeclaration
+PSR2.ControlStructures.ControlStructureSpacing
+PSR2.ControlStructures.ElseIfDeclaration
+PSR2.ControlStructures.SwitchDeclaration
+PSR2.Methods.MethodDeclaration
+PSR2.Namespaces.NamespaceDeclaration
+PSR2.Namespaces.UseDeclaration
+Squiz.ControlStructures.ControlSignature
+Squiz.Files.FileExtension
+Squiz.Functions.
+Squiz.Functions.FunctionDeclarationArgumentSpacing.
+Squiz.Functions.MultiLineFunctionDeclaration
+Squiz.PHP.DisallowComparisonAssignment
+Squiz.PHP.DisallowObEndFlush
+Squiz.PHP.DisallowSizeFunctionsInLoops
+Squiz.PHP.ForbiddenFunctions
+Squiz.PHP.GlobalKeyword
+Squiz.PHP.InnerFunctions
+Squiz.PHP.LowercasePHPFunctions
+Squiz.PHP.NonExecutableCode
+Squiz.Scope.MemberVarScope
+Squiz.Scope.MethodScope
+Squiz.Scope.StaticThisUsage
+Squiz.WhiteSpace.CastSpacing
+Squiz.WhiteSpace.LanguageConstructSpacing
+Squiz.WhiteSpace.LogicalOperatorSpacing
+Squiz.WhiteSpace.ObjectOperatorSpacing
+Squiz.WhiteSpace.OperatorSpacing
+Squiz.WhiteSpace.PropertyLabelSpacing
+Squiz.WhiteSpace.ScopeKeywordSpacing
+Squiz.WhiteSpace.SemicolonSpacing
+Zend.NamingConventions.ValidVariableName
diff --git a/set_host_configuration.sh b/set_host_configuration.sh
new file mode 100755
--- /dev/null
+++ ./set_host_configuration.sh
@@ -0,0 +1,15 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+find host_links/`hostname`/ -type f | while read ss; \
+do \
+    ~/loadrc/bashrc/ln_fs.sh "$ss" "/$(echo "$ss" | sed "s/host_links\/`hostname`\///g")"; \
+done
+
+HOSTTODOS=~/loadrc/host_links/"`hostname`/todos.sh"
+if [ -f "$HOSTTODOS" ]
+then
+    "$HOSTTODOS"
+fi
diff --git a/set_linux_configuration.sh b/set_linux_configuration.sh
new file mode 100755
--- /dev/null
+++ ./set_linux_configuration.sh
@@ -0,0 +1,22 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+if [ $(uname) != "Linux" ]
+then
+    exit 0
+fi
+
+find linux_links/ -type f | while read ss; \
+do \
+    sudo ~/loadrc/bashrc/ln_fs.sh "$ss" "/$(echo "$ss" | sed "s/linux_links\///g")"; \
+done
+
+find linux/ -type f | while read ss; \
+do \
+    sudo cp -fv --remove-destination "$ss" "/$(echo "$ss" | sed "s/linux\///g")"; \
+done
+
+sudo grub-mkconfig -o /boot/grub/grub.cfg
+gsettings set org.gnome.desktop.lockdown disable-lock-screen 'true'
diff --git a/set_macos_configuration.sh b/set_macos_configuration.sh
new file mode 100755
--- /dev/null
+++ ./set_macos_configuration.sh
@@ -0,0 +1,22 @@
+#!/bin/zsh 
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+if [ $(uname) != "Darwin" ]
+then
+    exit 0
+fi
+
+find macos_links/ -type f | while read ss; \
+do \
+    ~/loadrc/bashrc/ln_fs.sh "$ss" "/$(echo "$ss" | sed "s/macos_links\///g")"; \
+done
+
+find macos/ -type f | while read ss; \
+do \
+    sudo cp -fv "$ss" "/$(echo "$ss" | sed "s/macos\///g")"; \
+done
+
+./macosrc/configure_mosh.sh
+# ./macosrc/configure_ssh.sh
diff --git a/setup.sh b/setup.sh
new file mode 100755
--- /dev/null
+++ ./setup.sh
@@ -0,0 +1,18 @@
+#!/bin/bash
+SCRIPT=$(realpath "$0") && \
+    SCRIPTPATH=$(dirname "$SCRIPT") && \
+    cd "$SCRIPTPATH" || cd ~/loadrc/
+
+./install_basic.sh
+~/loadrc/gitrc/gpl.sh
+./neovim/install.sh
+./rsync/install.sh
+./gpurc/install.sh
+./install_vagrant.sh
+./install_flacon.sh
+./cscope/install-sh.sh
+./jdupes/install.sh
+./submodule_setup.sh
+./kvmrc/install.sh
+./dockerrc/install.sh
+./post_setup.sh
diff --git a/setup_bidirectional_clipboard.sh b/setup_bidirectional_clipboard.sh
new file mode 100755
--- /dev/null
+++ ./setup_bidirectional_clipboard.sh
@@ -0,0 +1,17 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0") && \
+    SCRIPTPATH=$(dirname "$SCRIPT") && \
+    cd "$SCRIPTPATH" || cd ~/loadrc/
+
+if [ -f ~/Library/LaunchAgents/pbcopy.plist  ]
+then
+    exit 0
+fi
+
+cp -fv ./Library/LaunchAgents/pbcopy.plist ~/Library/LaunchAgents/pbcopy.plist
+cp -fv ./Library/LaunchAgents/pbpaste.plist ~/Library/LaunchAgents/pbpaste.plist
+
+launchctl load ~/Library/LaunchAgents/pbcopy.plist
+launchctl load ~/Library/LaunchAgents/pbpaste.plist
+launchctl start ~/Library/LaunchAgents/pbcopy.plist
+launchctl start ~/Library/LaunchAgents/pbpaste.plist
diff --git a/setup_locale.sh b/setup_locale.sh
new file mode 100755
--- /dev/null
+++ ./setup_locale.sh
@@ -0,0 +1,4 @@
+#!/bin/zsh
+
+sudo cp -fv ./linux/etc/locale.gen /etc/locale.gen
+sudo locale-gen
diff --git a/setup_pbpaste-remote.sh b/setup_pbpaste-remote.sh
new file mode 100755
--- /dev/null
+++ ./setup_pbpaste-remote.sh
@@ -0,0 +1,13 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0") && \
+    SCRIPTPATH=$(dirname "$SCRIPT") && \
+    cd "$SCRIPTPATH" || cd ~/loadrc/
+
+mkdir -p ~/bin/
+
+if [ -f ~/bin/pbpaste-remote ]
+then
+    exit 0
+fi
+
+cp -fv ./pbpaste-remote ~/bin/pbpaste-remote
diff --git a/setup_remote.sh b/setup_remote.sh
new file mode 100755
--- /dev/null
+++ ./setup_remote.sh
@@ -0,0 +1,24 @@
+#!/bin/bash
+
+sudo apt-get update && \
+    sudo apt-get install -y \
+    mosh \
+    ssh \
+    tmux \
+    zsh
+
+rw ; \
+    sudo pacman -Syy ; \
+    sudo pacman --noconfirm -Sy \
+    mosh \
+    net-tools \
+    openssh \
+    rsync \
+    tmux \
+    zsh
+
+pacman -Syu
+
+./deploy_configurations.sh
+./setup_locale.sh
+./swith-2-zsh.sh
diff --git a/sqlrc/.login b/sqlrc/.login
new file mode 100644
--- /dev/null
+++ ./sqlrc/.login
@@ -0,0 +1,4 @@
+user=tg
+password=tg
+host=docker
+dbinstance=h2h
diff --git a/sqlrc/mysqlback.sh b/sqlrc/mysqlback.sh
new file mode 100755
--- /dev/null
+++ ./sqlrc/mysqlback.sh
@@ -0,0 +1,12 @@
+#!/bin/sh
+file=${1}
+loginFile=.login
+if [ -n "$2" ]
+then
+    loginFile=${2}/.login
+fi
+user=`cat ${loginFile} |awk -F'=' '/user/{print $2}'`
+password=`cat ${loginFile} |awk -F'=' '/password/{print $2}'`
+host=`cat ${loginFile} |awk -F'=' '/host/{print $2}'`
+dbinstance=`cat ${loginFile} |awk -F'=' '/dbinstance/{print $2}'`
+mysqldump -R -v -u"$user" -p"$password" -h${host} ${dbinstance} > ${file}
diff --git a/sqlrc/xsql.sh b/sqlrc/xsql.sh
new file mode 100755
--- /dev/null
+++ ./sqlrc/xsql.sh
@@ -0,0 +1,33 @@
+#!/bin/sh
+file="$1"
+loginFile=.login
+
+if [ -n "$2" ]
+then
+    loginFile=${2}/.login
+fi
+
+echo "loginFile --> $loginFile"
+user=`cat ${loginFile} |awk -F'=' '/user/{print $2}'`
+password=`cat ${loginFile} |awk -F'=' '/password/{print $2}'`
+host=`cat ${loginFile} |awk -F'=' '/host/{print $2}'`
+dbinstance=`cat ${loginFile} |awk -F'=' '/dbinstance/{print $2}'`
+protocol=`cat ${loginFile} |awk -F'=' '/protocol/{print $2}'`
+option=""
+
+if [ -z "$host" ]
+then
+    echo "dbinstance=$dbinstance" >> "$loginFile"
+    echo "host=$host" >> "$loginFile"
+    echo "password=$password" >> "$loginFile"
+    echo "user=$user" >> "$loginFile"
+    sort -u "$loginFile" -o "$loginFile"
+fi
+
+if [ -n "$protocol" ]
+then
+    option="--protocol=$protocol"
+fi
+
+cd "$(dirname "$file")"
+mysql -v "$option" -u"$user" -p"$password" -h${host} ${dbinstance} < ${file}
diff --git a/submodule_setup.sh b/submodule_setup.sh
new file mode 100755
--- /dev/null
+++ ./submodule_setup.sh
@@ -0,0 +1,10 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+git submodule init
+git submodule sync
+git submodule update
+git submodule foreach ~/loadrc/gitrc/gps.sh
+git submodule foreach ~/loadrc/gitrc/gsync.sh
diff --git a/svnrc/svnapply.sh b/svnrc/svnapply.sh
new file mode 100755
--- /dev/null
+++ ./svnrc/svnapply.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+patch -p0 -i svn.diff
diff --git a/svnrc/svndiff.sh b/svnrc/svndiff.sh
new file mode 100755
--- /dev/null
+++ ./svnrc/svndiff.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+fullfile="$1"
+if [ $(basename "$fullfile") = "index" ]
+then
+    svn diff -x -w --cl utest > svn.diff
+else
+    svn diff --diff-cmd kdiff3 "$fullfile"
+fi
diff --git a/svnrc/svnhistory.sh b/svnrc/svnhistory.sh
new file mode 100755
--- /dev/null
+++ ./svnrc/svnhistory.sh
@@ -0,0 +1,31 @@
+ #!/bin/zsh
+
+# history_of_file
+#
+# Outputs the full history of a given file as a sequence of
+# logentry/diff pairs.  The first revision of the file is emitted as
+# full text since there's not previous version to compare it to.
+
+function history_of_file() {
+    url=$1 # current url of file
+    svn log -q $url | grep -E -e "^r[[:digit:]]+" -o | cut -c2- | sort -n | {
+
+#       first revision as full text
+        echo
+        read r
+        svn log -r$r $url@HEAD
+        svn cat -r$r $url@HEAD
+        echo
+
+#       remaining revisions as differences to previous revision
+        while read r
+        do
+            echo
+            svn log -r$r $url@HEAD
+            svn diff -c$r $url@HEAD
+            echo
+        done
+    }
+}
+
+history_of_file $1
diff --git a/svnrc/svnreset.sh b/svnrc/svnreset.sh
new file mode 100755
--- /dev/null
+++ ./svnrc/svnreset.sh
@@ -0,0 +1,28 @@
+#!/bin/zsh
+resultFile="svnreset.findresult"
+svn status | tee "$resultFile"
+
+while read ss
+do
+    sed -i.bak "/^.*.$ss\$/d" "$resultFile"
+done < svnpostfix.ignore
+
+while read ss
+do
+    ss=$(echo $ss | sed  -e "s/\//\\\\\//g")
+    sed -i.bak "/$ss/d" "$resultFile"
+done < svn.diffiles
+
+while read ss
+do
+    ss=$(echo $ss | sed  -e "s/\//\\\\\//g")
+    sed -i.bak "/$ss/d" "$resultFile"
+done < svnfiles.ignore
+
+sed -i.bak "/^?/d" "$resultFile"
+sed -i.bak "/^$/d" "$resultFile"
+sed -i.bak "/Changelist/d" "$resultFile"
+sed -i.bak "s/\b[MD]\b/svn revert $1/g" "$resultFile"
+sed -i.bak "s/^!/svn revert $1/g" "$resultFile"
+sed -i.bak "s/\b[A]\b/rm $1/g" "$resultFile"
+sort -u "$resultFile" -o "$resultFile"
diff --git a/svnrc/svnrevert.sh b/svnrc/svnrevert.sh
new file mode 100755
--- /dev/null
+++ ./svnrc/svnrevert.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+svn revert "$1"
diff --git a/svnrc/svnst.sh b/svnrc/svnst.sh
new file mode 100755
--- /dev/null
+++ ./svnrc/svnst.sh
@@ -0,0 +1,19 @@
+#!/bin/zsh
+resultFile="svnst.findresult"
+svn status | tee "$resultFile"
+
+while read ss
+do
+    sed -i.bak "/^.*.$ss\$/d" "$resultFile"
+done < svnpostfix.ignore
+
+while read ss
+do
+    ss=$(echo $ss | sed  -e "s/\//\\\\\//g")
+    sed -i.bak "/$ss/d" "$resultFile"
+done < svnfiles.ignore
+
+sed -i.bak "/^$/d" "$resultFile"
+sed -i.bak "s/\b[M]\b/svn cl utest $1/g" "$resultFile"
+~/loadrc/svnrc/svnvdiff.sh
+svn diff -x -w --cl utest > svn.diff
diff --git a/svnrc/svnup.sh b/svnrc/svnup.sh
new file mode 100755
--- /dev/null
+++ ./svnrc/svnup.sh
@@ -0,0 +1,15 @@
+#!/bin/zsh
+
+if !(git status . | grep -q 'nothing to commit')
+then
+    echo -e "${red}the git repository is unclean, please check it before continuing... ${NC}"
+    exit 1
+fi
+
+svn up
+
+while IFS= read -r line
+do
+    git add $line
+done < <( comm -23 <(git status --porcelain | awk '{print $2}') <(sort svn.diffiles) )
+~/loadrc/gitrc/g.sh
diff --git a/svnrc/svnuserlog.sh b/svnrc/svnuserlog.sh
new file mode 100755
--- /dev/null
+++ ./svnrc/svnuserlog.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+svn log | sed -n '/yhuang/,/-----$/ p'
diff --git a/svnrc/svnvdiff.sh b/svnrc/svnvdiff.sh
new file mode 100755
--- /dev/null
+++ ./svnrc/svnvdiff.sh
@@ -0,0 +1,21 @@
+#!/bin/zsh
+svn status | tee svn.vdiff
+
+while read ss
+do
+    sed -i.bak "/^.*.$ss\$/d" svn.vdiff
+done < svnpostfix.ignore
+
+while read ss
+do
+    ss=$(echo $ss | sed  -e "s/\//\\\\\//g")
+    sed -i.bak "/$ss/d" svn.vdiff
+done < svnfiles.ignore
+
+sed -i.bak "/^$/d" svn.vdiff
+sed -i.bak "/Changelist/d" svn.vdiff
+sed -i.bak "s/\b[A|D|M]\b/svn diff --diff-cmd kdiff3 $1/g" svn.vdiff
+sort -u svn.vdiff -o svn.vdiff
+
+sed "s/svn diff --diff-cmd kdiff3        //g" svn.vdiff | tee svn.diffiles
+sort -u svn.diffiles -o svn.diffiles
diff --git a/swith-2-zsh.sh b/swith-2-zsh.sh
new file mode 100755
--- /dev/null
+++ ./swith-2-zsh.sh
@@ -0,0 +1,9 @@
+#!/bin/zsh
+
+ZSH=$(which zsh)
+
+if [ "$ZSH" != "$SHELL" ]
+then
+    sudo chsh -s "$ZSH"
+    sudo reboot
+fi
diff --git a/synergy.conf b/synergy.conf
new file mode 100644
--- /dev/null
+++ ./synergy.conf
@@ -0,0 +1,62 @@
+section: screens
+	imacpro:
+		halfDuplexCapsLock = false
+		halfDuplexNumLock = false
+		halfDuplexScrollLock = false
+		xtestIsXineramaUnaware = false
+		switchCorners = none
+		switchCornerSize = 0
+	COH-LC172TVQ6J:
+		halfDuplexCapsLock = false
+		halfDuplexNumLock = false
+		halfDuplexScrollLock = false
+		xtestIsXineramaUnaware = false
+		switchCorners = none
+		switchCornerSize = 0
+	studio:
+		halfDuplexCapsLock = false
+		halfDuplexNumLock = false
+		halfDuplexScrollLock = false
+		xtestIsXineramaUnaware = false
+		switchCorners = none
+		switchCornerSize = 0
+	mba:
+		halfDuplexCapsLock = false
+		halfDuplexNumLock = false
+		halfDuplexScrollLock = false
+		xtestIsXineramaUnaware = false
+		switchCorners = none
+		switchCornerSize = 0
+end
+
+section: aliases
+end
+
+section: links
+	imacpro:
+		down = studio
+	COH-LC172TVQ6J:
+		right = studio
+	studio:
+		right = mba
+		left = COH-LC172TVQ6J
+		up = imacpro
+	mba:
+		left = studio
+end
+
+section: options
+	relativeMouseMoves = false
+	win32KeepForeground = false
+	disableLockToScreen = false
+	clipboardSharing = false
+	clipboardSharingSize = 3072
+	switchDelay = 9999
+	switchCorners = none
+	switchCornerSize = 0
+	keystroke(Control+1) = switchToScreen(studio)
+	keystroke(Control+2) = switchToScreen(mba)
+	keystroke(Control+3) = switchToScreen(COH-LC172TVQ6J)
+	keystroke(Control+4) = switchToScreen(imacpro)
+	keystroke(Alt+Control+r) = restartServer(restart)
+end
diff --git a/tests/dirname/spaces  in dir name.txt b/tests/dirname/spaces  in dir name.txt
new file mode 100644
--- /dev/null
+++ ./tests/dirname/spaces  in dir name.txt	
@@ -0,0 +1,3 @@
+multiple spaces in file name.
+add one more line, to test the auto add feature.
+one more line to test ml command.
diff --git a/tests/space in dir name/test.txt b/tests/space in dir name/test.txt
new file mode 100644
--- /dev/null
+++ ./tests/space in dir name/test.txt	
@@ -0,0 +1 @@
+a txt file under folder with space in folder name. make some changes.
diff --git a/timemachinerc/deletelocalsnapshots.sh b/timemachinerc/deletelocalsnapshots.sh
new file mode 100755
--- /dev/null
+++ ./timemachinerc/deletelocalsnapshots.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+tmutil listlocalsnapshots / | grep -oE '\w{4}-\w{2}-[0-9]{2}-[0-9]{6}' | while read ss; do sudo tmutil deletelocalsnapshots "$ss"; done
diff --git a/timemachinerc/etc/netatalk/AppleVolumes.default b/timemachinerc/etc/netatalk/AppleVolumes.default
new file mode 100644
--- /dev/null
+++ ./timemachinerc/etc/netatalk/AppleVolumes.default
@@ -0,0 +1,2 @@
+:DEFAULT: options:upriv,usedots
+/media/timemachine/tm "tm's Time Machine" options:tm volsizelimit:300000 allow:tm
diff --git a/timemachinerc/etc/nsswitch.conf b/timemachinerc/etc/nsswitch.conf
new file mode 100644
--- /dev/null
+++ ./timemachinerc/etc/nsswitch.conf
@@ -0,0 +1,20 @@
+# /etc/nsswitch.conf
+#
+# Example configuration of GNU Name Service Switch functionality.
+# If you have the `glibc-doc-reference' and `info' packages installed, try:
+# `info libc "Name Service Switch"' for information about this file.
+
+passwd:         compat systemd
+group:          compat systemd
+shadow:         compat
+gshadow:        files
+
+hosts:          files mdns4_minimal [NOTFOUND=return] dns mdns4 mdns 
+networks:       files
+
+protocols:      db files
+services:       db files
+ethers:         db files
+rpc:            db files
+
+netgroup:       nis
diff --git a/timemachinerc/listlocalsnapshots.sh b/timemachinerc/listlocalsnapshots.sh
new file mode 100755
--- /dev/null
+++ ./timemachinerc/listlocalsnapshots.sh
@@ -0,0 +1,2 @@
+#!/bin/zsh
+tmutil listlocalsnapshots /
diff --git a/transmissionrc/auto_reboot.sh b/transmissionrc/auto_reboot.sh
new file mode 100755
--- /dev/null
+++ ./transmissionrc/auto_reboot.sh
@@ -0,0 +1,11 @@
+#!/bin/zsh
+
+/root/loadrc/networkrc/ping.sh
+rc=$?
+
+if [[ $rc -eq 0 ]]
+then
+    echo "say The internet is back up."
+else
+    /usr/sbin/reboot
+fi
diff --git a/transmissionrc/auto_restart.sh b/transmissionrc/auto_restart.sh
new file mode 100755
--- /dev/null
+++ ./transmissionrc/auto_restart.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+
+while ! (/etc/init.d/transmission-daemon status | grep -q "Active: active")
+do
+    /root/loadrc/bashrc/check_running.sh /root/loadrc/transmissionrc/restart.sh
+done
diff --git a/transmissionrc/restart.sh b/transmissionrc/restart.sh
new file mode 100755
--- /dev/null
+++ ./transmissionrc/restart.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+
+/etc/init.d/transmission-daemon restart
diff --git a/transmissionrc/start_all.sh b/transmissionrc/start_all.sh
new file mode 100755
--- /dev/null
+++ ./transmissionrc/start_all.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+
+transmission-remote -n 'transmission:transmission' --torrent all --start
diff --git a/uninstall_bidirectional_clipboard.sh b/uninstall_bidirectional_clipboard.sh
new file mode 100755
--- /dev/null
+++ ./uninstall_bidirectional_clipboard.sh
@@ -0,0 +1,18 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0") && \
+    SCRIPTPATH=$(dirname "$SCRIPT") && \
+    cd "$SCRIPTPATH" || cd ~/loadrc/
+
+if [ ! -f ~/Library/LaunchAgents/pbcopy.plist  ]
+then
+    exit 0
+fi
+
+launchctl stop ~/Library/LaunchAgents/pbcopy.plist
+launchctl stop ~/Library/LaunchAgents/pbpaste.plist
+
+launchctl unload ~/Library/LaunchAgents/pbcopy.plist
+launchctl unload ~/Library/LaunchAgents/pbpaste.plist
+
+rm ~/Library/LaunchAgents/pbcopy.plist
+rm ~/Library/LaunchAgents/pbpaste.plist
diff --git a/update.sh b/update.sh
new file mode 100755
--- /dev/null
+++ ./update.sh
@@ -0,0 +1,17 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+~/loadrc/gitrc/gpl.sh
+./install_basic.sh
+./install_nvim.sh
+./gpurc/install.sh
+./install_vagrant.sh
+./install_flacon.sh
+./cscope/build.sh
+./jdupes/install.sh
+. ./gitrc/submodule_update.sh
+./kvmrc/install.sh
+./dockerrc/install.sh
+./post_setup.sh
diff --git a/vimrc/.vim/autoload/SQLUtilities.vim b/vimrc/.vim/autoload/SQLUtilities.vim
new file mode 100755
--- /dev/null
+++ ./vimrc/.vim/autoload/SQLUtilities.vim
@@ -0,0 +1,2843 @@
+" SQLUtilities:   Variety of tools for writing SQL
+"   Author:	      David Fishburn <dfishburn dot vim at gmail dot com>
+"   Date:	      Nov 23, 2002
+"   Last Changed: 2012 Dec 03
+"   Version:	  7.0.0
+"   Script:	      http://www.vim.org/script.php?script_id=492
+"   License:      GPL (http://www.gnu.org/licenses/gpl.html)
+"
+"   Dependencies:
+"        Align.vim - Version 15 (as a minimum)
+"                  - Author: Charles E. Campbell, Jr.
+"                  - http://www.vim.org/script.php?script_id=294
+"   Documentation:
+"        :h SQLUtilities.txt 
+"
+
+" Prevent duplicate loading
+if exists("g:loaded_sqlutilities_auto")
+  finish
+endif
+if v:version < 700
+  echomsg "SQLUtilities: Version 2.0.0 or higher requires Vim7.  Version 1.4.1 can stil be used with Vim6."
+  finish
+endif
+let g:loaded_sqlutilities_auto = 700
+
+" Turn on support for line continuations when creating the script
+let s:cpo_save = &cpo
+set cpo&vim
+
+" SQLU_Formatter: align selected text based on alignment pattern(s)
+function! SQLUtilities#SQLU_Formatter(...) range
+  echom "SQLUtilities#SQLU_Formatter(...) 2"
+  let mode = 'n'
+  if a:0 > 0
+    let mode = (a:1 == ''?'n':(a:1))
+  endif
+
+  if ! exists( ':AlignCtrl' ) 
+    call s:SQLU_WarningMsg(
+          \ 'SQLU_Formatter - The Align plugin cannot be found'
+          \ )
+    return -1
+  endif
+
+  call s:SQLU_WrapperStart( a:firstline, a:lastline, mode )
+  " Store pervious value of highlight search
+  let hlsearch = &hlsearch
+  let &hlsearch = 0
+
+  " Store pervious value of gdefault
+  let gdefault = &gdefault
+  let &gdefault = 0
+
+  " save previous search string
+  let saveSearch = @/ 
+
+  " save previous format options and turn off automatic formating
+  let saveFormatOptions = &formatoptions
+  silent execute 'setlocal formatoptions-=a'
+
+  " Use the mark locations instead of storing the line numbers
+  " since these values can changes based on the reformatting 
+  " of the lines
+  let ret = s:SQLU_ReformatStatement()
+  if ret > -1
+    if g:sqlutil_indent_nested_blocks == 1
+      let ret = s:SQLU_IndentNestedBlocks()
+    endif
+  endif
+
+  " Restore default value
+  " And restore cursor position
+  let &hlsearch = hlsearch
+  call s:SQLU_WrapperEnd(mode)
+
+  " restore previous format options 
+  let &formatoptions = saveFormatOptions 
+
+  " restore previous search string
+  let @/ = saveSearch
+  let &gdefault = gdefault
+
+endfunction
+
+" SQLU_FormatStmts: 
+"    For a given range (default entire file), it find each SQL 
+"    statement an run SQLFormatter against it.
+"                 
+function! SQLUtilities#SQLU_FormatStmts(...) range
+  let mode = 'n'
+  if a:0 > 0
+    let mode = (a:1 == ''?'n':(a:1))
+  endif
+
+  let curline     = line(".")
+  let curcol      = virtcol(".")
+  let keepline_ms = line("'s")
+  let keepcol_ms  = virtcol("'s")
+  let keepline_me = line("'e")
+  let keepcol_me  = virtcol("'e")
+
+  silent! exec 'normal! '.a:lastline."G\<bar>0\<bar>"
+  " Add a new line to the bottom of the mark to be removed latter
+  put =''
+  silent! exec "ma e"
+  silent! exec 'normal! '.a:firstline."G\<bar>0\<bar>"
+  " Add a new line above the mark to be removed latter
+  put! = ''
+  silent! exec "ma s"
+  silent! exec "normal! 'sj"
+
+  " Store pervious value of highlight search
+  let hlsearch = &hlsearch
+  let &hlsearch = 0
+
+  " save previous search string
+  let saveSearch = @/ 
+
+  " save previous format options and turn off automatic formating
+  let saveFormatOptions = &formatoptions
+  silent execute 'setlocal formatoptions-=a'
+
+  " Must default the statements to query
+  let stmt_keywords = g:sqlutil_stmt_keywords
+
+  " Verify the string is in the correct format
+  " Strip off any trailing commas
+  let stmt_keywords =
+        \ substitute(stmt_keywords, ',$','','')
+  " Convert commas to regex ors
+  let stmt_keywords =
+        \ substitute(stmt_keywords, '\s*,\s*', '\\|', 'g')
+
+  let sql_commands = '\c\<\('.stmt_keywords.'\)\>'
+
+  " Find a line starting with SELECT|UPDATE|DELETE
+  "     .,-             - From that line backup one line due to :g
+  "     /;              - find the ending command delimiter
+  "     SQLUFormatter   - Use the SQLUtilities plugin to format it
+  let cmd = a:firstline.','.a:lastline.'g/^\s*\<\(' .
+        \ stmt_keywords . '\)\>/.,-/' .
+        \ g:sqlutil_cmd_terminator . '/SQLUFormatter'
+  exec cmd
+
+  " Restore default value
+  " And restore cursor position
+  let &hlsearch = hlsearch
+
+  " restore previous format options 
+  let &formatoptions = saveFormatOptions 
+
+  " restore previous search string
+  let @/ = saveSearch
+
+  silent! exe 'normal! '.curline."G\<bar>".(curcol-1).
+        \ ((curcol-1)>0 ? 'l' : '' )
+
+  if (mode != 'n')
+    " Reselect the visual area, so the user can us gv
+    " to operate over the region again
+    exec 'normal! '.(line("'s")+1).'gg'.'|'.
+          \ 'V'.(line("'e")-2-line("'s")).'j|'."\<Esc>"
+  endif
+
+  " Delete blanks lines added around the visually selected range
+  silent! exe "normal! 'sdd'edd"
+
+  silent! exe 'normal! '.curline."G\<bar>".(curcol-1).
+        \ ((curcol-1)>0 ? 'l' : '' )
+
+endfunction
+
+" This function will return a count of unmatched parenthesis
+" ie ( this ( funtion ) - will return 1 in this case
+function! s:SQLU_CountUnbalancedParan( line, paran_to_check )
+  let l = a:line
+  let lp = substitute(l, '[^(]', '', 'g')
+  let l = a:line
+  let rp = substitute(l, '[^)]', '', 'g')
+
+  if a:paran_to_check =~ ')'
+    " echom 'SQLU_CountUnbalancedParan ) returning: ' 
+    " \ . (strlen(rp) - strlen(lp))
+    return (strlen(rp) - strlen(lp))
+  elseif a:paran_to_check =~ '('
+    " echom 'SQLU_CountUnbalancedParan ( returning: ' 
+    " \ . (strlen(lp) - strlen(rp))
+    return (strlen(lp) - strlen(rp))
+  else
+    " echom 'SQLU_CountUnbalancedParan unknown paran to check: ' . 
+    " \ a:paran_to_check
+    return 0
+  endif
+endfunction
+
+" WS: wrapper start (internal)   Creates guard lines,
+"     stores marks y and z, and saves search pattern
+function! s:SQLU_WrapperStart( beginline, endline, mode )
+  let b:curline     = line(".")
+  let b:curcol      = virtcol(".")
+  let b:keepsearch  = @/
+  let b:keepline_mr = line("'r")
+  let b:keepcol_mr  = virtcol("'r")
+  let b:keepline_my = line("'y")
+  let b:keepcol_my  = virtcol("'y")
+  let b:keepline_mz = line("'z")
+  let b:keepcol_mz  = virtcol("'z")
+
+  silent! exec 'normal! '.a:endline."G\<bar>0\<bar>"
+  " Add a new line to the bottom of the mark to be removed later
+  put =''
+  silent! exec "ma z"
+  silent! exec 'normal! '.a:beginline."G\<bar>0\<bar>"
+  " Add a new line above the mark to be removed later
+  put! = ''
+  silent! exec "ma y"
+  let b:cmdheight= &cmdheight
+  set cmdheight=2
+  silent! exec "normal! 'zk"
+endfunction
+
+" WE: wrapper end (internal)   Removes guard lines,
+"     restores marks y and z, and restores search pattern
+function! s:SQLU_WrapperEnd(mode)
+  if (a:mode != 'n')
+    " Reselect the visual area, so the user can us gv
+    " to operate over the region again
+    " exec 'normal! '.(line("'y+1").'gg'.'|'.
+    "             \ 'V'.(line("'z")-2-line("'y")).'j|'."\<Esc>"
+    exec 'normal! gv'."\<Esc>"
+  endif
+
+  " Delete blanks lines added around the visually selected range
+  silent! exe "normal! 'ydd'zdd"
+  silent! exe "set cmdheight=".b:cmdheight
+  unlet b:cmdheight
+  let @/= b:keepsearch
+
+  silent! exe 'normal! '.b:curline."G\<bar>".(b:curcol-1).
+        \ ((b:curcol-1)>0 ? 'l' : '' )
+
+  unlet b:keepline_mr b:keepcol_mr
+  unlet b:keepline_my b:keepcol_my
+  unlet b:keepline_mz b:keepcol_mz
+  unlet b:curline     b:curcol
+endfunction
+
+" Generic Search and Replace uses syntax ID {{{
+function! s:SQLU_SearchReplace(exp_find_str, before_rplc_str, after_rplc_str, exp_srch_rplc_str)
+  call cursor( line("'y"), 1 )
+
+  let keepline_mo = line("'o")
+  let keepcol_mo  = virtcol("'o")
+  let keepline_mp = line("'p")
+  let keepcol_mp  = virtcol("'p")
+
+  " Find the string index position of the first match
+  " 'c'	accept a match at the cursor position
+  " 'W'	don't wrap around the end of the file
+  let search_flags = 'cW'
+  let index = search(a:exp_find_str, search_flags, (line("'z")))
+  while index > 0
+    " Reset to default, as the bottom repeat searches 
+    " can change the default
+    let search_flags = 'cW'
+    " Verify the cursor is within the range
+    if index >= line("'y") && index <= line("'z")
+
+      " Useful debug statment to see where on the line 
+      " and which keyword you are working on
+      " echo line(".") strpart(getline("."), col(".")-1)
+
+      let syn_element_list = split(g:sqlutil_syntax_elements, ',')
+
+      if !empty(syn_element_list)
+        let found_in_str = 0
+        for syn_element_name in syn_element_list
+          " Determine the ID for the name in the CSV list
+          let syn_element_id = hlID(syn_element_name)
+
+          " Grab the current syntax ID of the match
+          let childsynid  = synID(line("."),col("."),1)
+          let parentsynid = synIDtrans(synID(line("."),col("."),1)) 
+
+          if childsynid == syn_element_id || parentsynid == syn_element_id
+            let found_in_str = 1
+            break
+          endif
+        endfor
+        if found_in_str == 1
+          " Advance the cursor 1 position since we use 
+          " 'c' in the flags
+          call cursor( line("."), (col(".") + 1) )
+          let index = search(a:exp_find_str, search_flags, (line("'z")))
+          continue
+        endif
+      endif
+
+      " Mark the current position 
+      exec 'normal! mo'
+
+      " Find the string index position of the end of the match
+      " 'c'	accept a match at the cursor position
+      " 'e'	move to the End of the match
+      " 'W'	don't wrap around the end of the file
+      let search_flags = 'ceW'
+      let index = search(a:exp_find_str, search_flags, (line("'z")))
+
+      " Verify the cursor is within the range
+      if index >= line("'y") && index <= line("'z")
+        " Start a newline at the end of the match 
+        " and create the mark "p".  The mark needs to be
+        " on a newline since substitutions on a line
+        " with the mark looses the mark position which 
+        " prevents us from coming back to it after 
+        " our align first word option.
+        silent! exec "normal! a\<CR>\<Esc>mp"
+        " Return to the start of the match
+        exec 'normal! `o'
+        " Between the beginning mark "o" and the 
+        " ending mark "p" execute the regex expression 
+        " with the supplied substitution.
+        " For debugging:
+        "     echo line(".") col(".") index strpart(getline("."), col(".")-1, 5) getline(".")
+        try
+          exec "s/\\%'o\\(".a:after_rplc_str."\\)\\%'p/" . a:before_rplc_str
+        catch /.*/
+          call s:SQLU_WarningMsg(
+                \ 'SQLU_SR: Match not found on line #:' . 
+                \ line("'o") .
+                \ ' Error:' .
+                \ v:errmsg .
+                \ ' Line:' .
+                \ getline("'o")
+                \ )
+        endtry
+        " Return to the beginning of the match
+        exec 'normal! `o'
+        " Execute last search and and replace based on 
+        " the beginning mark.
+        " For debugging:
+        "     echo line(".") col(".") index strpart(getline("."), col(".")-1, 5) getline(".")
+        try
+          exec 's/' . a:exp_srch_rplc_str
+        catch /.*/
+          call s:SQLU_WarningMsg(
+                \ 'SQLU_SR: Match not found on line #:' . 
+                \ line("'o") .
+                \ ' Error:' .
+                \ v:errmsg .
+                \ ' Line:' .
+                \ getline("'o")
+                \ )
+        endtry
+        " Join the current line just substituted on
+        " and the line where we put the "p" mark.
+        " This effectively places the cursor at the end 
+        " of the initial match (regardless of align first word).
+        exec 'normal! J'
+        " Reset to default, as the bottom repeat searches 
+        " can change the default
+        let search_flags = 'cW'
+      else 
+        return
+      endif
+
+      let index = search(a:exp_find_str, search_flags, (line("'z")))
+    endif
+  endwhile
+
+endfunction 
+
+" Generic Search and Replace uses syntax ID {{{
+function! s:SQLU_SearchReplaceOld(exp_find_str, before_rplc_str, after_rplc_str, exp_srch_rplc_str)
+  call cursor( line("'y"), 1 )
+
+  let keepline_mo = line("'o")
+  let keepcol_mo  = virtcol("'o")
+  let keepline_mp = line("'p")
+  let keepcol_mp  = virtcol("'p")
+
+  " Find the string index position of the first match
+  " 'c'	accept a match at the cursor position
+  " 'W'	don't wrap around the end of the file
+  let search_flags = 'cW'
+  let index = search(a:exp_find_str, search_flags, (line("'z")))
+  while index > 0
+    " Reset to default, as the bottom repeat searches 
+    " can change the default
+    let search_flags = 'cW'
+    " Verify the cursor is within the range
+    if index >= line("'y") && index <= line("'z")
+
+      " Useful debug statment to see where on the line 
+      " and which keyword you are working on
+      " echo line(".") strpart(getline("."), col(".")-1)
+
+      let syn_element_list = split(g:sqlutil_syntax_elements, ',')
+
+      if !empty(syn_element_list)
+        let found_in_str = 0
+        for syn_element_name in syn_element_list
+          " Determine the ID for the name in the CSV list
+          let syn_element_id = hlID(syn_element_name)
+
+          " Grab the current syntax ID of the match
+          let childsynid  = synID(line("."),col("."),1)
+          let parentsynid = synIDtrans(synID(line("."),col("."),1)) 
+
+          if childsynid == syn_element_id || parentsynid == syn_element_id
+            let found_in_str = 1
+            break
+          endif
+        endfor
+        if found_in_str == 1
+          " Advance the cursor 1 position since we use 
+          " 'c' in the flags
+          call cursor( line("."), (col(".") + 1) )
+          let index = search(a:exp_find_str, search_flags, (line("'z")))
+          continue
+        endif
+      endif
+
+      " Mark the current position 
+      exec 'normal! mo'
+
+      " At the current cursor position \%#
+      exec 's/\%#/' . a:before_rplc_str
+
+      " Return to the start of the current match
+      exec 'normal! `o'
+
+      if a:after_rplc_str != ''
+        " Find the string index position of the end of the match
+        " 'c'	accept a match at the cursor position
+        " 'e'	move to the End of the match
+        " 'W'	don't wrap around the end of the file
+        let search_flags = 'ceW'
+        let index = search(a:exp_find_str, search_flags, (line("'z")))
+
+        " Verify the cursor is within the range
+        if index >= line("'y") && index <= line("'z")
+          " Mark the current position 
+          exec 'normal! mp'
+          " Return to the start of the current match
+          exec 'normal! ``'
+          " At the current cursor position \%#
+          exec 's/\%#/' . a:after_rplc_str
+          " Remove the 'c' to find the next match
+          let search_flags = 'W'
+          " Advance to the end of the current match
+          exec 'normal! `p'
+          " Move ahead the size of the replace text
+          exec 'normal! '.strlen(a:after_rplc_str).'l'
+        endif
+      elseif a:exp_srch_rplc_str != ''
+        " Find the string index position of the end of the match
+        " 'c'	accept a match at the cursor position
+        " 'e'	move to the End of the match
+        " 'W'	don't wrap around the end of the file
+        let search_flags = 'ceW'
+        let index = search(a:exp_find_str, search_flags, (line("'z")))
+
+        " Verify the cursor is within the range
+        if index >= line("'y") && index <= line("'z")
+          " Mark the current position 
+          exec 'normal! mp'
+          " Return to the start of the current match
+          exec 'normal! ``'
+          " At the current cursor position \%#
+          exec 's/\%#' . a:exp_srch_rplc_str
+          " Remove the 'c' to find the next match
+          let search_flags = 'W'
+          " Advance to the end of the current match
+          exec 'normal! `p'
+        endif
+      else
+        " Advance past the match
+        exec 'normal! w'
+      endif
+
+      let index = search(a:exp_find_str, search_flags, (line("'z")))
+    endif
+  endwhile
+
+endfunction 
+" }}}
+
+
+" Reformats the statements 
+" 1. Keywords (FROM, WHERE, AND, ... ) " are on new lines
+" 2. Keywords are right justified
+" 3. CASE statements are setup for alignment.
+" 4. Operators are lined up
+" 
+function! s:SQLU_ReformatStatement()
+  if exists("b:current_syntax") == 0 || g:sqlutil_use_syntax_support == 0
+    " Remove any lines that have comments on them since the comments
+    " could spill onto new lines and no longer have comment markers
+    " which would result in syntax errors
+    " Comments could also contain keywords, which would be split
+    " on to new lines
+    call cursor( line("'y"), 0 )
+    " Find the string index position of the first match
+    " 'W'	don't wrap around the end of the file
+    let search_flags = 'W'
+    let index = search('--', search_flags, (line("'z")))
+    if index > 0 
+      " Comments found, confirm with user to delete them
+      let choice = confirm( 
+            \ 'SQLU: Comments found, without syntax support these must be ' .
+            \ 'removed before formatting.  Is this Ok?'
+            \ , "&No\n&Yes\n&Cancel"
+            \ , 1
+            \ )
+      if choice != 2
+        return -1
+      endif
+      if exists("b:current_syntax") == 0 || g:sqlutil_use_syntax_support == 0
+        " First remove only comment lines
+        silent! 'y+1,'z-1g/^\s*--/d
+        " Now remove comments from the end of lines
+        silent! 'y+1,'z-1s/--.*$//ge
+      endif
+    endif
+  endif
+
+  " Check to see if multiple statements have been specified 
+  " by checking for ;.  If more than 1, show an error message.
+  call cursor( line("'y"), 0 )
+  " Find the string index position of the first match
+  " 'W'	don't wrap around the end of the file
+  let search_flags = 'W'
+  let index = search('\(;\|^go\>\)', search_flags, (line("'z")))
+  if index > 0 
+    let index = search('\(;\|^go\>\)', search_flags, (line("'z")))
+    if index > 0 
+      call s:SQLU_WarningMsg(
+            \ 'SQLU: You can only reformat one statement at a time, found multiple ";" or "go" '
+            \ )
+      return -1
+    endif
+  endif
+
+  " Removed in SQLUtilities 7.0
+  if exists("b:current_syntax") == 0 || g:sqlutil_use_syntax_support == 0
+    " Join block of text into 1 line
+    " All comments were removed earlier
+    silent! 'y+1,'z-1j
+  else
+    " If the line is only a comment, we leave it.
+    " If the comment is at the end of a line, we join
+    " as many lines as possible prior to it.
+    let only_comments = 1
+    let linenum = line("'y")+1
+    while linenum < line("'z")-1
+      if getline(linenum) !~ '--'
+        let only_comments = 0
+        exec 'silent! '.linenum.'j'
+      else
+        if only_comments == 1 && getline(linenum) =~ '^\s*--'
+          silent! s/^\s*\zs--/-@---/
+        elseif only_comments == 0 && getline(linenum) =~ '^\s*--'
+          silent! s/^\s*\zs--/-@- --/
+        endif
+        let linenum = linenum + 1
+      endif
+    endwhile
+  endif
+  " Reformat the commas, to remove any spaces before them
+  " As long as the line is not a comment
+  silent! 'y+1,'z-1v/^\s*--/s/\s*,/,/ge
+  " Change more than 1 space with just one except spaces at
+  " the beginning of the range
+  silent! 'y+1,'z-1v/^\s*--/s/\(\S\+\)\(\s\+\)/\1 /g
+  " Place a special marker at the start of the line
+  " of a comment for formatting purposes
+  " Don't do this as this will mess up the alignment 
+  " of comments.  Now, when we join the lines ignoring 
+  " comments, we will either put the marker in front 
+  " of the line, or the marker with a space following it 
+  " that will allow us to align properly.
+  " silent! 'y+1,'z-1s/^\s*\zs--/-@---/
+  " Go to the start of the block
+  silent! 'y+1
+
+  " Place an UPDATE on a newline, but not if it is preceeded by
+  " the existing statement.  Example:
+  "           INSERT INTO T1 (...)
+  "           ON EXISTING UPDATE
+  "           VALUES (...);
+  "           SELECT ...
+  "           FOR UPDATE
+  let sql_update_keywords = '' . 
+        \ '\%(\%(\<\%(for\|existing\)\s\+\)\@<!update\)'
+  " WINDOW clauses can be used in both the SELECT list
+  " and after the HAVING clause.
+  let sql_window_keywords = '' . 
+        \ 'over\|partition\s\+by\|' .
+        \ '\%(rows\|range\)\s\+' .
+        \ '\%(between\|unbounded\|current\|preceding\|following\)'
+  " INTO clause can be used in a SELECT statement as well 
+  " as an INSERT statement.  We do not want to place INTO
+  " on a newline if it is preceeded by INSERT
+  let sql_into_keywords = '' . 
+        \ '\%(\%(\<\%(insert\|merge\)\s\+\)\@<!into\)'
+  " Normally you would add put an AND statement on a new
+  " line.  But in the cases where you are dealing with
+  " a BETWEEN '1963-1-1' AND '1965-3-31', we no not want
+  " to put the AND on a new line
+  " Do not put AND on a new line if preceeded by
+  "      between<space><some text not including space><space>AND
+  let sql_and_between_keywords = '' . 
+        \ '\%(\%(\<between\s\+[^ ]\+\s\+\)\@<!and\)'
+  " For SQL Remote (ASA), this is valid syntax
+  "           SUBSCRIBE BY
+  "       OLD SUBSCRIBE BY
+  "       NEW SUBSCRIBE BY
+  let sql_subscribe_keywords = '' . 
+        \ '\%(\%(\<\%(old\|new\)\s\+\)\?subscribe\)'
+  " Oracle CONNECT BY statement
+  let sql_connect_by_keywords = '' . 
+        \ 'connect\s\+by\s\+\w\+'
+  " Oracle MERGE INTO statement
+  "      MERGE INTO ...
+  "      WHEN MATCHED THEN ...
+  "      WHEN NOT MATCHED THEN ....
+  " Match on the WHEN clause (with zero width) if it is followed
+  " by [not] matched
+  let sql_merge_keywords = '' . 
+        \ '\%(merge\s\+into\)\|\%(when\(\s\+\%(not\s\+\)\?matched\)\@=\)'
+  " Some additional Oracle keywords from the SQL Reference for SELECT
+  let sql_ora_keywords = '' .
+        \ '\%(dimension\s\+by\|' .
+        \ 'measures\s*(\|' .
+        \ 'iterate\s*(\|' .
+        \ 'within\s\+group\|' .
+        \ '\%(ignore\|keep\)\s\+nav\|' .
+        \ 'return\s\+\%(updated\|all\)\|' .
+        \ 'rules\s\+\%(upsert\|update\)\)'
+  " FROM clause can be used in a DELETE statement as well 
+  " as a SELECT statement.  We do not want to place FROM
+  " on a newline if it is preceeded by DELETE
+  let sql_from_keywords = '' . 
+        \ '\%(\%(\<delete\s\+\)\@<!from\)'
+  " Only place order on a newline if followed by "by"
+  " let sql_order_keywords = '' .  \ '\%(\%(\<order\s\+\)\@<!into\)'
+
+  " join type syntax from ASA help file
+  " INNER
+  " | LEFT [ OUTER ]
+  " | RIGHT [ OUTER ]
+  " | FULL [ OUTER ]
+  " LEFT, RIGHT, FULL can optional be followed by OUTER
+  " The entire expression is optional
+  let sql_join_type_keywords = '' . 
+        \ '\%(' .
+        \ '\%(inner\|' .
+        \ '\%(\%(\%(left\|right\|full\)\%(\s\+outer\)\?\s*\)\?\)' .
+        \ '\)\?\s*\)\?'
+  " Decho 'join types: ' . sql_join_type_keywords
+  " join operator syntax
+  " [ KEY | NATURAL ] [ join_type ] JOIN
+  " | CROSS JOIN
+  let sql_join_operator = '' .
+        \ '\%(' .
+        \ '\%(\%(\%(key\|natural\)\?\s*\)\?' .
+        \ sql_join_type_keywords .
+        \ 'join\)\|' .
+        \ '\%(\%(\%(cross\)\?\s*\)\?join\)' .
+        \ '\)'
+  " Decho 'join types: ' . sql_join_type_keywords
+  " join operator syntax
+  " [ KEY | NATURAL ] [ join_type ] JOIN
+  " | CROSS JOIN
+  " force each keyword onto a newline
+  let sql_keywords =  '\<\%(create\|drop\|call\|select\|set\|values\|declare\|cursor\|' .
+        \ sql_update_keywords . '\|' .
+        \ sql_into_keywords . '\|' .
+        \ sql_and_between_keywords . '\|' .
+        \ sql_from_keywords . '\|' .
+        \ sql_join_operator . '\|' .
+        \ sql_subscribe_keywords . '\|' .
+        \ sql_connect_by_keywords . '\|' .
+        \ sql_merge_keywords . '\|' .
+        \ sql_ora_keywords . '\|' .
+        \ 'on\|where\|or\|\%(order\|group\)\s\+\%(\w\+\s\+\)\?\<by\>\|'.
+        \ sql_window_keywords . '\|' .
+        \ 'having\|for\|insert\%(\s\+\|-@-\)into\|delete\%(\s\+\|-@-\)from\|using\|' .
+        \ 'intersect\|except\|window\|' .
+        \ '\%(union\%(\s\+all\)\?\)\|' .
+        \ 'start\s\+with\|' .
+        \ '\%(\%(\<start\s\+\)\@<!with\)\)\>'
+  " The user can specify whether to align the statements based on 
+  " the first word, or on the matching string.
+  "     let g:sqlutil_align_first_word = 0
+  "           select
+  "             from
+  "         union all
+  "     let g:sqlutil_align_first_word = 1
+  "           select
+  "             from
+  "            union all
+  let srch_exp = '\c\%(^\s*\)\?\zs\<\(' .
+        \ sql_keywords .
+        \ '\)\>\s*'
+
+  " Place all SQL keywords on a newline.
+  " The position of the -@- depends on the setting of 
+  " the g:sqlutil_align_first_word option.
+  " If 0, the -@- is at the start of the line.
+  " If 1, the -@- is after the first word.
+  if exists("b:current_syntax") == 0 || g:sqlutil_use_syntax_support == 0
+    let cmd = "'y+1,'z-1s/". srch_exp .
+          \ '/\r\1' .
+          \ ( g:sqlutil_align_first_word==0 ? '-@-' : ' ' ) .
+          \ '/ge'
+    " Decho cmd
+    silent! exec cmd
+    " Ensure keywords at the beginning of a line have a space after them
+    " This will ensure the Align program lines them up correctly
+    silent! 'y+1,'z-1s/^\([a-zA-Z0-9_]*\)(/\1 (/e
+
+    if g:sqlutil_align_first_word == 1
+      silent! 'y+1,'z-1s/^\s*\zs\([a-zA-Z0-9_]\+\)\>\s*/\1-@-/
+    endif
+  else
+    " This uses Vim's syntax support to determine if
+    " a match is found within a string (or comment) or not.
+    " Therefore only do it if syntax support is on
+    " which can be tested checking for the existance
+    " of the buffer local variable b:current_syntax
+    "    call s:SQLU_SearchReplace(srch_exp
+    "                \ , '\r\1'
+    "                \ , (g:sqlutil_align_first_word==0 ? '-@-' : '')
+    "                \ , (g:sqlutil_align_first_word==1 ? '\(\w\+\)\s*/\1-@-' : '')
+    "                \ )
+    if g:sqlutil_align_first_word == 0
+      call s:SQLU_SearchReplace(srch_exp, '\1-@-', '.*\n.*', '\(^\s*\)\@<!\%'."'".'o/\r/e' )
+    else
+      call s:SQLU_SearchReplace(srch_exp, '\2-@-\3', '\(\w\+\)\(.*\n.*\)', '\(^\s*\)\@<!\%'."'".'o/\r/e' )
+    endif
+  endif
+
+  " Ensure CASE statements also start on new lines
+  " CASE statements can also be nested, but we want these to align
+  " with column lists, not keywords, so the -@- is placed BEFORE
+  " the CASE keywords, not after
+  "
+  " The CASE statement and the Oracle MERGE statement are very similar.
+  " I have changed the WHEN clause to check to see if it is followed
+  " by [NOT] MATCHED, if so, do not match the WHEN
+  let sql_case_keywords = '\(\<end\s\+\)\@<!case' .
+        \ '\|\<when\>\(\%(-@-\)\?\s*\%(not\s\+\)\?matched\)\@!' .
+        \ '\|else\|end\(\s\+case\)\?' 
+
+  " echom 'case: '.sql_case_keywords
+  " The case keywords must not be proceeded by a -@-
+  " silent! exec "'y+1,'z-1".'s/'.
+  "             \ '\%(-@-\)\@<!'.
+  "             \ '\<\('.
+  "             \ sql_case_keywords.
+  "             \ '\)\>/\r-@-\1/gei'
+  let srch_exp = '\c\%(-@-\)\@<!'.
+        \ '\<\('.
+        \ sql_case_keywords.
+        \ '\)\>'
+
+  " For all CASE keywords, place them on a new line followed by the 
+  " alignment marker
+  if exists("b:current_syntax") == 0 || g:sqlutil_use_syntax_support == 0
+    let cmd = "'y+1,'z-1s/". srch_exp .
+          \ '/\r-@-\1' .
+          \ '/ge'
+    " Decho cmd
+    silent! exec cmd
+  else
+    " This uses Vim's syntax support to determine if
+    " a match is found within a string or not.
+    " Therefore only do it if syntax support is on
+    " which can be tested checking for the existance
+    " of the buffer local variable b:current_syntax
+    " call s:SQLU_SearchReplace(srch_exp, '\r-@-\1', '.*', '' )
+    " call s:SQLU_SearchReplace(srch_exp, '\2-@-\3', '\(\w\+\)\(.*\n\)', '\(^\s*\)\@<!\%'."'".'o/\r/e' )
+    call s:SQLU_SearchReplace(srch_exp, '-@-\2', '\(.*\n.*\)', '\(^\s*\)\@<!\%'."'".'o/\r/e' )
+  endif
+
+  " If g:sqlutil_align_first_word == 0, then we need only add the -@-
+  " on the first word, else we need to do it to the first word
+  " on each line
+  " silent! exec "'y+1," .  
+  "             \ ( g:sqlutil_align_first_word==0 ? "'y+1" : "'z-1" ) .  
+  "             \ 's/^\s*\<\w\+\>\zs\s*/-@-'
+  silent! exec "'y+1,'z-1".'v/-@-/s/^\s*\zs/-@-'
+
+  " AlignPush
+
+  " Using the Align.vim plugin, reformat the lines
+  " so that the keywords are RIGHT justified
+  AlignCtrl default
+
+  if g:sqlutil_align_comma == 1 
+    call s:SQLU_WrapAtCommas()
+  endif
+
+  if g:sqlutil_wrap_function_calls == 1 
+    call s:SQLU_WrapFunctionCalls()
+  endif
+
+  if g:sqlutil_split_unbalanced_paran == 1 
+    let ret = s:SQLU_SplitUnbalParan()
+    if ret < 0
+      " Undo any changes made so far since an error occurred
+      " silent! exec 'u'
+      return ret
+    endif
+  endif
+
+  if g:sqlutil_wrap_long_lines == 1
+    let ret = s:SQLU_WrapLongLines( '^'.sql_keywords )
+    if ret < 0
+      " Undo any changes made so far since an error occurred
+      " silent! exec 'u'
+      return ret
+    endif
+  endif
+
+  " Removed in SQLUtilities 7.0
+  if exists("b:current_syntax") == 1 || g:sqlutil_use_syntax_support == 1
+    " Comments before the first statement must be formatted 
+    " differently that comments within the SQL being formatted.
+    " To achieve this, any comment line beginning with -@--- 
+    " within a SQL statement should be changed to -@- --
+    " so that the formatting will change.  The fact the comment 
+    " is indented 1 additional space cannot be helped.
+    let only_comments = 1
+    let linenum = line("'y")+1
+    while linenum < line("'z")-1
+      if getline(linenum) !~ '^\s*-@---'
+        let only_comments = 0
+      else
+        if only_comments == 0 && getline(linenum) =~ '^\s*-@---'
+          silent! exec linenum.','.linenum.'s/-@---/-@- --/'
+        endif
+      endif
+      let linenum = linenum + 1
+    endwhile
+  endif
+
+  " When formatting, ignore lines beginning with a comment
+  AlignCtrl v ^\s*-@---
+
+  " Align these based on the special charater
+  " and the column names are LEFT justified
+  " Ip0P0l
+  "   I : retain only the first line's initial white space and
+  "       re-use it for subsequent lines
+  " p0P0: put no spaces both before and after separators
+  "   l : left-justify fields between separators, cyclically. Ie. llllllll...
+  let align_ctrl = 'Ip0P0'.(g:sqlutil_align_keyword_right==1?'r':'l').'l:'
+  silent! exec 'AlignCtrl '.align_ctrl
+  silent! 'y+1,'z-1Align -@-
+  silent! 'y+1,'z-1s/-@-/ /ge
+
+  " Now that we have removed the special alignment marker
+  " upper or lower case all the keywords only if the user
+  " has specified an override.
+  if g:sqlutil_keyword_case != ''
+    let cmd = "'y+1,'z-1".'s/\<\(' .
+          \ sql_keywords .
+          \ '\|' .
+          \ sql_case_keywords .
+          \ '\|' .
+          \ sql_join_type_keywords .
+          \ '\|' .
+          \ substitute(g:sqlutil_non_line_break_keywords, ',', '\\|', 'g') .
+          \ '\)\>/' .
+          \ g:sqlutil_keyword_case .
+          \ '\1/gei'
+    silent! exec cmd
+  endif
+
+  " Now align the operators 
+  " and the operators are CENTER justified
+  if g:sqlutil_align_where == 1
+    " If I may explain what you're doing with the commands you've given:
+    "     AlignCtrl default
+    "         This resets AlignCtrl to default settings
+    "     AlignCtrl g [!<>=]
+    "         This command says to only consider aligning lines containing
+    "         one of the characters matching [!<>=].  Lines without those
+    "         characters are ignored.
+    "     AlignCtrl Wp1P1l
+    "         W    : retain all selected lines' initial white space
+    "         p1P1 : put one space both before and after separators
+    "         l    : left-justify fields between separators, cyclically. Ie. llllllll...
+    " 
+    "     * The separators are  =  <  >  <>
+    "     * you only want the first separator to be active
+    " 
+    " So, to do this:
+    "     AlignCtrl default
+    "     AlignCtrl g [!<>=]
+    "     AlignCtrl Wp1P1l:
+    "     [range]Align =\|[!<>]\ze[^<>=]\|<>\|<=\|>=\|!>\|!<\|!=
+    " 
+    " I've added a ":" to the AlignCtrl field control pattern; this means
+    " that only one separator (ie. field - separator - field) is to be
+    " aligned.
+    " I've set up the separator pattern to recognize = < > and <> as
+    " separators.
+    " 
+    " This won't do the "< parameter >" conversion to "<parameter>"; it
+    " will preserve it whichever way its written.
+    AlignCtrl default
+    AlignCtrl g [!<>=]
+    AlignCtrl Wp1P1l:
+
+    " Change this to only attempt to align the last WHERE clause
+    " and not the entire SQL statement
+    " Valid operators are: 
+    "      =, >, <, >=, <=, !=, !<, !>, <> 
+    if search('\c\%(\%>'.line("'y").'l\%<'.line("'z").'l\)\&\<WHERE\>')
+      " v17.00 
+      " silent! exec line(".").",'z-1".'Align [!<>=]\(<\|>\|=\)'
+      " v18.00
+      silent! exec line(".").",'z-1".'Align =\|[!<>]\ze[^<>=]\|<>\|<=\|>=\|!>\|!<\|!='
+    endif
+  endif
+
+  " Reset back to defaults
+  AlignCtrl default
+
+  " Reset the alignment to what it was prior to 
+  " this function
+  " AlignPop
+
+  " Remove any trailing spaces which can be added 
+  " after aligning.
+  silent! 'y+1,'z-1s/\s\+$//
+  " Delete any blank lines
+  silent! 'y+1,'z-1g/^$/d
+
+  return 1
+endfunction
+
+" Check through the selected text for open ( and
+" indent if necessary
+function! s:SQLU_IndentNestedBlocks()
+
+  let org_textwidth = &textwidth
+  if &textwidth == 0 
+    " Get the width of the window
+    let &textwidth = winwidth(winnr())
+  endif
+
+  let sql_keywords = '\<\%(select\|set\|\%(insert\s\+\)\?into\|from\|values'.
+        \ '\|order\|group\|having\|return\|call\)\>'
+
+  " Indent nested blocks surrounded by ()s.
+  let linenum = line("'y")+1
+  while linenum <= line("'z")-1
+    let line = getline(linenum)
+    if line =~ '(\s*$'
+      let begin_paran = match( line, '(\s*$' )
+      if begin_paran > -1
+        let curline     = line(".")
+        let curcol      = begin_paran + 1
+        " echom 'begin_paran: '.begin_paran.
+        "             \ ' line: '.curline.
+        "             \ ' col: '.curcol
+        silent! exe 'normal! '.linenum."G\<bar>".curcol."l"
+        " v  - visual
+        " ib - inner block
+        " k  - backup on line
+        " >  - right shift
+        " .  - shift again
+        " silent! exe 'normal! vibk>.'
+        silent! exe 'normal! vibk>'
+
+        " If the following line begins with a keyword, 
+        " indent one additional time.  This is necessary since 
+        " keywords are right justified, so they need an extra
+        " indent
+        if getline(linenum+1) =~? '\c^\s*\('.sql_keywords.'\)'
+          silent! exe 'normal! .'
+        endif
+        " echom 'SQLU_IndentNestedBlocks - from: '.line("'<").' to: ' .
+        "             \ line("'>") 
+        " echom 'SQLU_IndentNestedBlocks - no match: '.getline(linenum)
+      endif
+    endif
+
+    let linenum = linenum + 1
+  endwhile
+
+  let ret = linenum
+
+  "
+  " Indent nested CASE blocks
+  "
+  let linenum = line("'y")+1
+  " Search for the beginning of a CASE statement
+  let begin_case = '\<\(\<end\s\+\)\@<!case\>'
+
+  silent! exe 'normal! '.linenum."G\<bar>0\<bar>"
+
+  while( search( begin_case, 'W' ) > 0 )
+    " Check to see if the CASE statement is inside a string
+    if synID(line("."),col("."),1) > 0
+      continue
+    endif
+    let curline = line(".")
+    if( (curline < line("'y")+1)  || (curline > line("'z")-1) )
+      " echom 'No case statements, leaving loop'
+      silent! exe 'normal! '.(line("'y")+1)."G\<bar>0\<bar>"
+      break
+    endif
+    " echom 'begin CASE found at: '.curline
+    let curline = curline + 1
+    let end_of_case = s:SQLU_IndentNestedCase( begin_case, curline, 
+          \ line("'z")-1 )
+    let end_of_case = end_of_case + 1
+    let ret = end_of_case
+    if( ret < 0 )
+      break
+    endif
+    silent! exe 'normal! '.end_of_case."G\<bar>0\<bar>"
+  endwhile
+
+  "
+  " Indent Oracle nested MERGE blocks
+  "
+  let linenum = line("'y")+1
+  " Search for the beginning of a CASE statement
+  let begin_merge = '\<merge\s\+into\>'
+
+  silent! exe 'normal! '.linenum."G\<bar>0\<bar>"
+
+  if( search( begin_merge, 'W' ) > 0 )
+    let curline = line(".")
+    if( (curline < line("'y")+1)  || (curline > line("'z")-1) )
+      " echom 'No case statements, leaving loop'
+      silent! exe 'normal! '.(line("'y")+1)."G\<bar>0\<bar>"
+    else
+      " echom 'begin CASE found at: '.curline
+      let curline = curline + 1
+
+      while 1==1
+        " Find the matching when statement
+        " let match_merge = searchpair('\<merge\s\+into\>', 
+        let match_merge = searchpair('\<merge\>', '',
+              \ '\<\%(when\s\+\%(not\s\+\)\?matched\)', 
+              \ 'W', '' )
+        if( (match_merge < curline) || (match_merge > line("'z-1")) )
+          silent! exec curline . "," . line("'z-1") . ">>"
+          break
+        else
+          if match_merge > (curline+1)
+            let savePos = 'normal! '.line(".").'G'.col(".")."\<bar>"
+            silent! exec curline . "," . (match_merge-1) . ">>"
+            silent! exec savePos
+          endif
+          let curline = match_merge + 1
+        endif
+      endwhile
+    endif
+  endif
+
+  let &textwidth = org_textwidth
+  return ret
+endfunction
+
+" Recursively indent nested case statements
+function! s:SQLU_IndentNestedCase( begin_case, start_line, end_line )
+
+  " Indent nested CASE blocks
+  let linenum = a:start_line
+
+  " Find the matching end case statement
+  let end_of_prev_case = searchpair(a:begin_case, '', 
+        \ '\<end\( case\)\?\>', 'W', '' )
+
+  if( (end_of_prev_case < a:start_line) || (end_of_prev_case > a:end_line) )
+    call s:SQLU_WarningMsg(
+          \ 'SQLU_IndentNestedCase - No matching end case for: ' .
+          \ getline((linenum-1))
+          \ )
+    return -1
+    " else
+    " echom 'Matching END found at: '.end_of_prev_case
+  endif
+
+  silent! exe 'normal! '.linenum."G\<bar>0\<bar>"
+
+  if( search( a:begin_case, 'W' ) > 0 )
+    let curline = line(".")
+    if( (curline > a:start_line) && (curline < end_of_prev_case) )
+      let curline = curline + 1
+      let end_of_case = s:SQLU_IndentNestedCase( a:begin_case, curline, 
+            \ line("'z-1") )
+      " echom 'SQLU_IndentNestedCase from: '.linenum.' to: '.end_of_case
+      silent! exec (curline-1) . "," . end_of_case . ">>"
+      " else
+      "     echom 'SQLU_IndentNestedCase No case statements, '.
+      "                 \ 'leaving SQLU_IndentNestedCase: '.linenum
+    endif
+  endif
+
+  return end_of_prev_case
+endfunction
+
+" For certain keyword lines (SELECT, ORDER BY, GROUP BY, ...)
+" Ensure the lines fit in the textwidth (or default 80), wrap
+" the lines where necessary and left justify the column names
+function! s:SQLU_WrapFunctionCalls()
+  " Check if this is a statement that can often be longer than 80 characters
+  " (select, set and so on), if so, ensure the column list is broken over as
+  " many lines as necessary and lined up with the other columns
+  let linenum = line("'y")+1
+
+  let org_textwidth = &textwidth
+  if org_textwidth == 0 
+    " Get the width of the window
+    let curr_textwidth = winwidth(winnr())
+  else
+    let curr_textwidth = org_textwidth
+  endif
+
+  let sql_keywords = '\<\%(select\|set\|\%(insert\(-@-\s*\)\?\)into' .
+        \ '\|from\|values'.
+        \ '\|order\|group\|having\|return\|with\)\>'
+
+  " Useful in the debugger
+  " echo linenum.' '.func_call.' '.virtcol(".").' 
+  " '.','.substitute(getline("."), '^ .*\(\%'.(func_call-1).'c...\).*', 
+  " '\1', '' ).', '.getline(linenum)
+
+  " call Decho(" Before column splitter 'y+1=".line("'<").
+  " \ ":".col("'<")."  'z-1=".line("'>").":".col("'>"))
+  while linenum <= line("'z")-1
+    let line = getline(linenum)
+
+    if strlen(line) < curr_textwidth
+      let linenum = linenum + 1
+      continue
+    endif
+
+    let get_func_nm = '[a-zA-Z_.]\+\s*('
+
+    " Use a special line textwidth, since if we split function calls
+    " any text within the parantheses will be indented 2 &shiftwidths
+    " so when calculating where to split, we must take that into
+    " account
+    let keyword_str = matchstr(
+          \ getline(linenum), '\c^\s*\('.sql_keywords.'\)' )
+
+    let line_textwidth = curr_textwidth - strlen(keyword_str)
+    let func_call = 0
+    while( strlen(getline(linenum)) > line_textwidth )
+
+      " Find the column # of the start of the function name
+      let func_call = match( getline(linenum), get_func_nm, func_call )
+      if func_call < 0 
+        " If no functions found, move on to next line
+        break
+      endif
+
+      let prev_func_call = func_call
+
+      " Position cursor at func_call
+      silent! exe 'normal! '.linenum."G\<bar>".func_call."l"
+
+      if search('(', 'W') > linenum
+        call s:SQLU_WarningMsg(
+              \ 'SQLU_WrapFunctionCalls - should have found a ('
+              \ )
+        let linenum = linenum + 1
+        break
+      endif
+
+      " Check to ensure the paran is not part of a string
+      " Otherwise ignore and move on to the next paran
+      if synID(line("."),col("."),1) == 0
+        " let end_paran = searchpair( '(', '', ')', '' )
+        " Ignore parans that are inside of strings
+        let end_paran = searchpair( '(', '', ')', '',
+              \ 'synID(line("."),col("."),1)>0' )
+        if end_paran < linenum || end_paran > linenum
+        " call s:SQLU_WarningMsg(
+        "             \ 'SQLU_WrapFunctionCalls - ' . 
+        "             \ 'should have found a matching ) for :' .
+        "             \ getline(linenum)
+        "             \ )
+        let linenum = linenum + 1
+        break
+      endif
+
+      " If the matching ) is past the textwidth
+      if virtcol(".") > line_textwidth
+        if (virtcol(".")-func_call) > line_textwidth
+          " Place the closing brace on a new line only if
+          " the entire length of the function call and 
+          " parameters is longer than a line
+          silent! exe "normal! i\r-@-\<esc>"
+        endif
+        " If the SQL keyword preceeds the function name don't
+        " bother placing it on a new line
+        let preceeded_by_keyword = 
+              \ '\c^\s*' .
+              \ '\(' .
+              \ sql_keywords .
+              \ '\|,' .
+              \ '\)' .
+              \ '\(-@-\)\?' .
+              \ '\s*' .
+              \ '\%'.(func_call+1).'c'
+        " echom 'preceeded_by_keyword: '.preceeded_by_keyword
+        " echom 'func_call:'.func_call.' Current 
+        " character:"'.getline(linenum)[virtcol(func_call)].'"  - 
+        " '.getline(linenum)
+        if getline(linenum) !~? preceeded_by_keyword
+          " Place the function name on a new line
+          silent! exe linenum.'s/\%'.(func_call+1).'c/\r-@-'
+          let linenum = linenum + 1
+          " These lines will be indented since they are wrapped
+          " in parantheses.  Decrease the line_textwidth by
+          " that amount to determine where to split nested 
+          " function calls
+          let line_textwidth = line_textwidth - (2 * &shiftwidth)
+          let func_call = 0
+          " Get the new offset of this function from the start
+          " of the newline it is on
+          let prev_func_call = match(
+                \ getline(linenum),get_func_nm,func_call)
+        endif
+      endif
+    endif
+
+    " Get the name of the previous function
+    let prev_func_call_str = matchstr(
+          \ getline(linenum), get_func_nm, prev_func_call )
+    " Advance the column by its length to find the next function
+    let func_call = prev_func_call +
+          \ strlen(prev_func_call_str) 
+
+  endwhile
+
+  let linenum = linenum + 1
+endwhile
+
+let &textwidth = org_textwidth
+return linenum
+endfunction
+
+" For certain keyword lines (SELECT, SET, INTO, FROM, VALUES)
+" put each comma on a new line and align it with the keyword 
+"     SELECT c1
+"          , c2
+"          , c3
+function! s:SQLU_WrapAtCommas()
+  let linenum    = line("'y")+1
+  let paran_done = 0
+
+  " These keywords typically have column lists:
+  " SELECT c1, c2, c3 
+  " SET c1 = 1, c2 = 2
+  " INTO var1, var2 
+  " FROM t1, t2
+  " VALUES( var1, var2 )
+  " INSERT INTO T1 (c1, c2)
+  " , - If we have already broken the line up
+  let sql_keywords = '\c^\s*\<\%(select\|set\|into\|from\|values\|insert\|,\)\>'
+
+  " call Decho(" Before column splitter 'y+1=".line("'<").
+  " \ ":".col("'<")."  'z-1=".line("'>").":".col("'>"))
+  while linenum <= line("'z-1")
+    let line = getline(linenum)
+    if line =~? '\w'
+      silent! exec linenum 
+      " Mark the start of the line
+      silent! exec "normal! mb"
+      " echom "line b - ".getline("'b")
+      " Mark the next line
+      silent! exec "normal! jmek"
+
+      let saved_linenum = linenum
+      " let index = match(getline(linenum), '[,(]')
+      " Find the first , or (
+      let index = match(getline(linenum), (g:sqlutil_align_comma==1?'[,(]':'[,]'))
+      while index > -1
+        " Go to the , or (
+        call cursor(linenum, (index+1))
+
+        " Assuming syntax is on, check to ensure the , or (
+        " is not a string
+        if getline(linenum)[col(".")-1] == '(' 
+          if synID(line("."),col("."),1) == 0
+            " When paran_done was set, it was for a particular keyword 
+            " as we move through the lines, the ending ) for that 
+            " keyword should reset the value for future keywords.
+            " Classic case is:
+            "     INSERT INTO T1 () <-- reset on closing )
+            "     VALUES ()
+            if line('"r') <= linenum
+              let paran_done = 0
+            endif
+
+            " Only do this once and only in the special cases of 
+            "    1.  INSERT INTO [owner].t1 (
+            "    2.  VALUES (
+            " If the opening ( is found after these cases, ignore
+            " the special processing of them
+            "     Starting at this linenum 
+            "     Look for the VALUES or INSERT patterns 
+            "     Followed by the ( at the exact column position
+            " Flags - Do not move cursor
+            if search( '\c^\%'.linenum.'l\s*\<\%(values\%(\s*\|-@-\)\|insert\%(\s\+\|-@-\)into\s\+\S\+\s*\)\%'.(index+1).'v(', 'n' ) == 0
+              let paran_done = 1
+            endif
+
+            " The paran is not part of a string.
+            " There can be 2 cases now.
+            "    1.  It is part of a statement (INSERT)
+            "    2.  It is the start of a function()
+
+            " Case 1
+            " Check if we are at a point where we expect commas
+            if paran_done == 0 && line =~? sql_keywords
+              " In case 1, we want to move to the matched 
+              " closing paran and place it on a newline so that 
+              " it will align with the commas.
+              if searchpair( '(', '', ')', '',
+                    \ 'synID(line("."),col("."),1)>0' ) > 0
+                let matched_linenum = line(".")
+                let matched_index   = col(".")
+
+                " But only do this if there is at least 1 comma 
+                " between these matched ()s.
+                " The pattern uses :h \%l
+                if search('\%(\%(\%'.linenum.'l\%>'.(index+1).'v\)\|\%(\%'.matched_linenum.'l\%<'.(matched_index+1).'v\)\)\&,')
+                  " Found a comma between these ()s,
+                  " therefore at the closing paran, move it 
+                  " on to a separate line
+                  silent! exec matched_linenum . ',' . matched_linenum . 
+                        \ 's/\%' . (matched_index) . 'c)\s*' .
+                        \ '/\r' .
+                        \ ')-@- '
+                  " \ (g:sqlutil_align_keyword_right == 1 ? ')-@-' : '-@-) ')
+                  let paran_done = 1
+                  silent! exec (matched_linenum+1).','.(matched_linenum+1).'mark r'
+                endif
+              endif
+
+              " Now that we have moved to the end of the matched 
+              " paranthesis, check again for our comma or paran
+              let index = index + 1
+              let index = match( getline(linenum), '[,(]', index )
+
+              continue
+            endif
+
+            " Case 2
+            " If part of a function skip to the end 
+            " of the paranthesis
+
+            " if searchpair( '(', '', ')', '' ) > 0
+            " Ignore parans that are inside of strings
+            if searchpair( '(', '', ')', '',
+                  \ 'synID(line("."),col("."),1)>0' ) > 0
+              let linenum = line(".")
+              let index   = col(".")
+
+              " Now that we have moved to the end of the matched 
+              " paranthesis, check again for our comma or paran
+              let index = match( getline(linenum), '[,(]', index )
+
+              continue
+            endif
+          else
+            " The ( found was within a comment, so advance
+            " the match, and find the next match
+            let index = index + 1
+            let index = match( getline(linenum), '[,(]', index )
+
+            continue
+          endif
+        elseif getline(linenum)[col(".")-1] == ','
+          if synID(line("."),col("."),1) != 0
+            " If the , is within a comment or string
+            let index = index + 1
+            let index = match( getline(linenum), '[,(]', index )
+            continue
+          endif
+        endif
+
+        " Only do this if the comma at this offset
+        " is not already at the start of the line
+        if match(getline(linenum), '\S') != index
+          " Given the current cursor position, replace
+          " the , and any following whitespace
+          " with a newline and the special -@- character
+          " for Align
+          silent! exec linenum . ',' . linenum . 
+                \ 's/\%' . (index + 1) . 'c,\s*' .
+                \ '/\r' .
+                \ (g:sqlutil_align_keyword_right == 1 ? ',-@-' : '-@-, ')
+          let linenum = linenum + 1
+
+          let index = 0
+          if g:sqlutil_align_keyword_right == 0
+            " If aligning the commas with the left justified 
+            " column names, we must skip ahead the index
+            " to be infront of the -@-
+            let index = 3
+          endif
+        endif
+        " Find the index of the first non-white space
+        " which should be the , we just put on the 
+        " newline
+        let index = match(getline(linenum), '\S', index)
+        let index = index + 1
+
+        " then continue on for the remainder of the line
+        " looking for the next , or (
+        "
+        " Must figure out what index value to start from
+        let index = match( getline(linenum), '[,(]', index )
+      endwhile
+      let linenum = saved_linenum 
+
+      " Go to the end of the new lines
+      silent! exec "'e-" 
+      let linenum = line("'e")-1
+    endif
+
+    let linenum = linenum + 1
+  endwhile
+
+  return linenum
+endfunction
+
+" For certain keyword lines (SELECT, SET, INTO, FROM, VALUES)
+" put each comma on a new line and align it with the keyword 
+"     SELECT c1
+"          , c2
+"          , c3
+function! s:SQLU_WrapLongLines( sql_keywords )
+  let linenum           = line("'y")+1
+  let paran_done        = 0
+  let restart_main_loop = 0
+  let max_width         = g:sqlutil_wrap_width
+  let comma_pattern     = '\c\(,\|(\|--\|\<\%(END\s\+\)\@<!CASE\>\|\<\%(END\s\+\)\@<!IF\>\)'
+
+  " These keywords typically have column lists:
+  " SELECT c1, c2, c3 
+  " SET c1 = 1, c2 = 2
+  " INTO var1, var2 
+  " FROM t1, t2
+  " VALUES( var1, var2 )
+  " INSERT INTO T1 (c1, c2)
+  " , - If we have already broken the line up
+  let sql_keywords = a:sql_keywords
+
+  " call Decho(" Before column splitter 'y+1=".line("'<").
+  " \ ":".col("'<")."  'z-1=".line("'>").":".col("'>"))
+  while linenum <= line("'z-1")
+    let line = getline(linenum)
+    if strlen(getline(linenum)) < max_width
+      let linenum = linenum + 1
+      continue
+    endif
+
+    " If the line does not start with a keyword it is a good 
+    " candidate to wrap.
+    " Experimentation with wrapping using Vim's qp results 
+    " in ugly code which is as bad as unformatted code.
+    " So instead, we are going to look for various special
+    " markers (, (, CASE, IF) and split the lines there.  
+    " But in this case, we will 
+    " leave the commas on the end of the lines as there 
+    " is a special option to put those at the start of the line.
+    silent! exec linenum 
+    " Mark the start of the line
+    silent! exec "normal! mb"
+    " echom "line b - ".getline("'b")
+    " Mark the next line
+    silent! exec "normal! jmek"
+
+    let saved_linenum = linenum
+    " Find the first , 
+    let index = match(getline(linenum), comma_pattern)
+    " Check to see if there is another , closer to 
+    " the max_width
+    while index > -1
+      let prev_match = line[index]
+      let prev_index = index 
+
+      " Check next match if current match is a ,
+      " Since a match on a ( can easily find a closing ) 
+      " on or near the end of the line
+      if getline(linenum)[index] != ','
+        break
+      endif
+
+      let index = match(getline(linenum), comma_pattern, (index+1))
+      if index > -1
+        let curr_match = line[index]
+
+        if synID(getline(linenum),index,1) != 0
+          " If within a comment, skip this match
+          let index = prev_index 
+          break
+        endif
+
+        if prev_match != curr_match
+          " If the match between a ( and , changes
+          " go back to the previous match
+          let index = prev_index 
+          break
+        endif
+        if index > max_width
+          " Use first match as this one is beyond 
+          " screen size
+          let index = prev_index 
+          break
+        else
+          continue
+        endif
+      else 
+        " Use previous match as no more are found
+        let index = prev_index
+        break 
+      endif
+    endwhile
+
+    while index > -1
+      " Go to the , or (
+      call cursor(linenum, (index+1))
+
+      " Assuming syntax is on, check to ensure the , or (
+      " is not a string
+      if getline(linenum)[col(".")-1] == '(' 
+        if synID(line("."),col("."),1) == 0
+          " Find closing paran
+          if searchpair( '(', '', ')', '',
+                \ 'synID(line("."),col("."),1)>0' ) > 0
+            let matched_linenum = line(".")
+            let matched_index   = col(".")
+
+            if matched_index > max_width
+              " But only do this if there is at least 1 comma 
+              " between these matched ()s.
+              " The pattern uses :h \%l
+              if search('\%(\%(\%'.linenum.'l\%>'.(index+1).'v\)\|\%(\%'.matched_linenum.'l\%<'.(matched_index+1).'v\)\)\&,')
+                " Found a comma between these ()s,
+                " therefore at the closing paran, move it 
+                " on to a separate line
+                silent! exec matched_linenum . ',' . matched_linenum . 
+                      \ 's/\%' . (matched_index) . 'c)\s*' .
+                      \ '/\r' .
+                      \ ')-@- '
+                " \ (g:sqlutil_align_keyword_right == 1 ? ')-@-' : '-@-) ')
+                let paran_done = 1
+                silent! exec (matched_linenum+1).','.(matched_linenum+1).'mark r'
+              endif
+            else 
+              " We are at the closing ) 
+              " And we still have not exceeded line
+              " length 
+              " So continue searching from this point forward
+              " only if we are stil on the same line
+              if linenum == line(".")
+                let index = matched_index
+              endif
+            endif
+          endif
+
+          " Now that we have moved to the end of the matched 
+          " paranthesis, check again for our comma or paran
+          let index = index + 1
+          let index = match( getline(linenum), comma_pattern, index )
+
+          continue
+        else
+          " The ( found was within a comment, so advance
+          " the match, and find the next match
+          let index = index + 1
+          let index = match( getline(linenum), comma_pattern, index )
+
+          continue
+        endif
+      elseif matchstr(getline(linenum), '\%'.(index+1).'v.\{4}') =~? '^CASE' 
+        " Moved to the CASE keywords to newlines
+        silent! exec linenum . ',' . linenum . 
+              \ 's/\<\(\%(END\s\+\)\@<!CASE\|WHEN\|ELSE\|END\%(\s\+CASE\)\?\)\>/\r-@-&/gi'
+
+        let index = index + 1
+        let index = match( getline(linenum), comma_pattern, index )
+        continue
+      elseif matchstr(getline(linenum), '\%'.(index+1).'v.\{4}') =~? '^IF' 
+        " Moved to the CASE keywords to newlines
+        silent! exec linenum . ',' . linenum . 
+              \ 's/\<\%(END\s\+\)\@<!IF\|ELSEIF\|ELSIF\|ELSE\|END\%(IF\|\s\+IF\)\>/\r-@-&/gi'
+
+        let index = index + 1
+        let index = match( getline(linenum), comma_pattern, index )
+        continue
+      elseif matchstr(getline(linenum), '\%'.(index+1).'v.\{4}') =~? '^--' 
+        " Start of a comment, ignore rest of line and move on
+        " to the next match
+        let index = match( getline(linenum), comma_pattern, index )
+        let linenum = linenum + 1
+        break
+      endif
+
+      " Only do this if the comma at this offset
+      " is not already at the start of the line
+      if match(getline(linenum), '\S') != index
+        " Given the current cursor position, replace
+        " the , and any following whitespace
+        " with a newline and the special -@- character
+        " for Align
+        silent! exec linenum . ',' . linenum . 
+              \ 's/\%' . (index + 1) . 'c,\s*' .
+              \ '/,\r' .
+              \ '-@-'
+        let linenum = linenum + 1
+
+        " If the newline is no longer long, kick
+        " out of the loop and work on the next line
+        if strlen(getline(linenum)) < max_width
+          let linenum = linenum + 1
+          break
+        else
+          let index = 0
+          let index = match( getline(linenum), comma_pattern, index )
+
+          if matchstr(getline(linenum), '\%'.(index+1).'v.\{1}') =~? '^,' 
+            " If our match is another comma, break out of this
+            " loop and perform the check to determine which comma
+            " to split the line on
+            let restart_main_loop = 1
+            break
+          endif
+        endif
+      else
+        let linenum = linenum + 1
+        let index = match( getline(linenum), comma_pattern, index )
+      endif
+      "          " Find the index of the first non-white space
+      "          " which should the substitute we just made
+      "          " newline
+      "          let index = match(getline(linenum), '\S', index)
+      "          let index = index + 1
+
+      "          " then continue on for the remainder of the line
+      "          " looking for the next , or (
+      "          "
+      "          " Must figure out what index value to start from
+      "          let index = match( getline(linenum), comma_pattern, index )
+      "          " Check to see if there is another , closer to 
+      "          " the max_width
+      "          while index > -1
+      "              let prev_index = index 
+      "              " Check next match
+      "              let index = match(getline(linenum), comma_pattern, (index+1))
+      "              if index > -1
+      "                  if index > max_width
+      "                      " Use first match as this one is beyond 
+      "                      " screen size
+      "                      let index = prev_index 
+      "                      break
+      "                  else
+      "                      continue
+      "                  endif
+      "              else 
+      "                  " Use previous match as no more are found
+      "                  let index = prev_index
+      "                  break 
+      "              endif
+      "          endwhile
+    endwhile
+
+    if restart_main_loop == 1
+      let restart_main_loop = 0
+      continue
+    endif
+
+    let linenum = saved_linenum 
+
+    " Go to the end of the new lines
+    silent! exec "'e-" 
+    let linenum = line("'e")-1
+
+    let linenum = linenum + 1
+  endwhile
+
+  return linenum
+endfunction
+
+" For certain keyword lines (SELECT, ORDER BY, GROUP BY, ...)
+" Ensure the lines fit in the textwidth (or default 80), wrap
+" the lines where necessary and left justify the column names
+function! s:SQLU_WrapExpressions()
+  " Check if this is a statement that can often by longer than 80 characters
+  " (select, set and so on), if so, ensure the column list is broken over as
+  " many lines as necessary and lined up with the other columns
+  let linenum = line("'y")+1
+
+  return 
+
+  let sql_keywords = '\<\%(select\)\>'
+  let sql_expression_operator = '' .
+        \ '\<\%(' .
+        \ '\%(end\s\+\)\@<!if\|else\%(if\)\?\|endif\|case\|when\|end' .
+        \ '\)\>'
+
+  " call Decho(" Before column splitter 'y+1=".line("'<").
+  " \ ":".col("'<")."  'z-1=".line("'>").":".col("'>"))
+  while linenum <= line("'z-1")
+    let line = getline(linenum)
+    if line =~? '\w'
+      " Decho 'linenum: ' . linenum . ' strlen: ' .
+      " \ strlen(line) . ' textwidth: ' . &textwidth .
+      " \ '  line: ' . line
+      " go to the current line
+      silent! exec linenum 
+      " Mark the start of the wide line
+      silent! exec "normal! mb"
+      let markb = linenum
+      " echom "line b - ".getline("'b")
+      " Mark the next line
+      silent! exec "normal! jmek"
+      " echom "line e - ".getline("'e")
+
+
+      if line =~? '\('.sql_expression_operator.'\)'
+        silent! exec linenum . ',' . linenum . 
+              \ 's/\c^\s*\('.sql_keywords.'\)\s*'.
+              \ '/\1-@-'
+        " Create a special marker for Align.vim
+        " to line up the columns with
+        silent! exec linenum . ',' . linenum . 
+              \ 's/\c'.sql_expression_operator.'/'.
+              \ '\r-@-&'
+
+      endif
+
+      " echom "end_line_nbr - ".end_line_nbr
+      " echom "normal! end_line_nbr - ".line(end_line_nbr)
+
+      " Append the special marker to the beginning of the line
+      " for Align.vim
+      " silent! exec "'b+," .end_line_nbr. 's/\s*\(.*\)/-@-\1'
+      " silent! exec "'b+," .end_line_nbr. 's/^\s*/-@-'
+      silent! exec ''.(markb+1)."," .end_line_nbr. 's/^\s*/-@-/g'
+      " silent! exec "'b+,'e-" . 's/\s*\(.*\)/-@-\1'
+      AlignCtrl Ip0P0rl:
+      " silent! 'b,'e-Align -@-
+      " silent! exec "'b,".end_line_nbr.'Align -@-'
+      silent! exec markb.",'e".'Align -@-'
+      " silent! 'b,'e-s/-@-/ /
+      silent! exec markb.",'e".'s/-@-/ /ge'
+      AlignCtrl default
+
+      " Advance the linenum to the end of the range
+      let linenum = line("'e") 
+    endif
+
+    let linenum = linenum + 1
+  endwhile
+
+  return linenum
+endfunction
+
+
+" For certain keyword lines (SELECT, ORDER BY, GROUP BY, ...)
+" Ensure the lines fit in the textwidth (or default 80), wrap
+" the lines where necessary and left justify the column names
+function! s:SQLU_WrapLongLinesQPP()
+  " Check if this is a statement that can often by longer than 80 characters
+  " (select, set and so on), if so, ensure the column list is broken over as
+  " many lines as necessary and lined up with the other columns
+  let linenum = line("'y")+1
+
+  " return
+
+  let org_textwidth = &textwidth
+  if &textwidth == 0 
+    " Get the width of the window
+    let &textwidth = winwidth(winnr())
+  endif
+
+  let sql_keywords = '\<\%(select\|set\|into\|from\|values'.
+        \ '\|order\|group\|having\|call\|with\)\>'
+
+  " call Decho(" Before column splitter 'y+1=".line("'<").
+  " \ ":".col("'<")."  'z-1=".line("'>").":".col("'>"))
+  while linenum <= line("'z-1")
+    let line = getline(linenum)
+    if line =~? '\w'
+      " Set the textwidth to current value
+      " minus an adjustment for select and set
+      " minus any indent value this may have
+      " echo 'tw: '.&textwidth.'  indent: '.indent(line)
+      " Decho 'line: '.line
+      " Decho 'tw: '.&textwidth.'  match at: '.
+      "             \ matchend(line, sql_keywords )
+      " let &textwidth = &textwidth - 10 - indent(line)
+      if line =~? '^\s*\('.sql_keywords.'\)'
+        let &textwidth = &textwidth - matchend(line, sql_keywords ) - 2
+        let line_length = strlen(line) - matchend(line, sql_keywords )
+      else
+        let line_length = strlen(line)
+      endif
+
+      if( line_length > &textwidth )
+        " Decho 'linenum: ' . linenum . ' strlen: ' .
+        " \ strlen(line) . ' textwidth: ' . &textwidth .
+        " \ '  line: ' . line
+        " go to the current line
+        silent! exec linenum 
+        " Mark the start of the wide line
+        silent! exec "normal! mb"
+        let markb = linenum
+        " echom "line b - ".getline("'b")
+        " Mark the next line
+        silent! exec "normal! jmek"
+        " echom "line e - ".getline("'e")
+        " echom "line length- ".strlen(getline(".")).
+        " \ "  tw=".&textwidth
+
+
+        if line =~? '^\s*\('.sql_keywords.'\)'
+          " Create a special marker for Align.vim
+          " to line up the columns with
+          silent! exec linenum . ',' . linenum . 's/\(\w\) /\1-@-'
+
+          " If the line begins with SET then force each
+          " column on a newline, instead of breaking them apart
+          " this will ensure that the col_name = ... is on the
+          " same line
+          if line =~? '^\s*\<set\>'
+            silent! 'b,'e-1s/,/,\r/ge
+          endif
+        else
+          " Place the special marker that the first non-whitespace
+          " characeter
+          if g:sqlutil_align_comma == 1  && line =~ '^\s*,'
+            " silent! exec linenum . ',' . linenum .
+            "             \ 's/^\s*\zs,\s*/,  -@-'
+            if g:sqlutil_align_keyword_right == 1 
+              silent! exec linenum . ',' . linenum .
+                    \ 's/^\s*\zs,\s*/,  -@-'
+            else
+              silent! exec linenum . ',' . linenum .
+                    \ 's/^\s*\zs,\s*/-@-, '
+            endif
+          else
+            if line !~ '-@-'
+              " If there is not a special marker on the line 
+              " yet, then add one
+              silent! exec linenum . ',' . linenum . 's/\S/-@-&'
+            endif
+          endif
+        endif
+
+        silent! exec linenum
+        " Reformat the line based on the textwidth
+        silent! exec "normal! gqq"
+
+        " echom "normal! mb - ".line("'b")
+        " echom "normal! me - ".line("'e")
+        " Sometimes reformatting does not change the line
+        " so we need to double check the end range to 
+        " ensure it does go backwards
+        let begin_line_nbr = (line("'b") + 1)
+        let begin_line_nbr = (markb + 1)
+        let end_line_nbr = (line("'e") - 1)
+        " echom "b- ".begin_line_nbr."  e- ".end_line_nbr
+        if end_line_nbr < begin_line_nbr
+          let end_line_nbr = end_line_nbr + 1
+          " echom "end_line_nbr adding 1 "
+        endif
+        " echom "end_line_nbr - ".end_line_nbr
+        " echom "normal! end_line_nbr - ".line(end_line_nbr)
+
+        " Reformat the commas
+        " silent! 'b,'e-s/\s*,/,/ge
+        " silent! exec "'b,".end_line_nbr.'s/\s*,/,/ge'
+        " Add a space after the comma
+        " silent! 'b,'e-s/,\(\w\)/, \1/ge
+        " silent! exec "'b,".end_line_nbr.'s/,\(\w\)/, \1/ge'
+        silent! exec markb.",".end_line_nbr.'s/,\(\w\)/, \1/ge'
+
+        " Append the special marker to the beginning of the line
+        " for Align.vim
+        " silent! exec "'b+," .end_line_nbr. 's/\s*\(.*\)/-@-\1'
+        " silent! exec "'b+," .end_line_nbr. 's/^\s*/-@-'
+        silent! exec ''.(markb+1)."," .end_line_nbr. 's/^\s*/-@-'
+        " silent! exec "'b+,'e-" . 's/\s*\(.*\)/-@-\1'
+        AlignCtrl Ip0P0rl:
+        " silent! 'b,'e-Align -@-
+        " silent! exec "'b,".end_line_nbr.'Align -@-'
+        silent! exec markb.",".end_line_nbr.'Align -@-'
+        " silent! 'b,'e-s/-@-/ /
+        if line =~? '^\s*\('.sql_keywords.'\)'
+          silent! exec markb.",".end_line_nbr.'s/-@-/ /ge'
+        else
+          silent! exec markb.",".end_line_nbr.'s/-@-/'.(g:sqlutil_align_comma == 1 ? ' ' : '' ).'/ge'
+        endif
+        AlignCtrl default
+
+        " Dont move to the end of the reformatted text
+        " since we also want to check for CASE statemtns
+        " let linenum = line("'e") - 1
+        " let linenum = line("'e")
+      endif
+    endif
+
+    let &textwidth = org_textwidth
+    if &textwidth == 0 
+      " Get the width of the window
+      let &textwidth = winwidth(winnr())
+    endif
+    let linenum = linenum + 1
+  endwhile
+
+  let &textwidth = org_textwidth
+  return linenum
+endfunction
+
+" Finds unbalanced paranthesis and put each one on a new line
+function! s:SQLU_SplitUnbalParan()
+  let linenum = line("'y")+1
+  while linenum <= line("'z")-1
+    let line = getline(linenum)
+    " echom 'SQLU_SplitUnbalParan: l: ' . linenum . ' t: '. getline(linenum)
+    if line !~ '('
+      " echom 'SQLU_SplitUnbalParan: no (s: '.linenum.'  : '.
+      " \ getline(linenum)
+      let linenum = linenum + 1
+      continue
+    endif
+
+    " echom 'SQLU_SplitUnbalParan: start line: '.linenum.' : '.line
+
+    let begin_paran = match( line, "(" )
+    while begin_paran > -1
+      " Check if the paran is inside a string
+      if synID(linenum,(begin_paran+1),1) > 0
+        " If it is, skip to the next paran
+        let begin_paran = match( getline(linenum), "(", (begin_paran+1) )
+        continue
+      endif
+
+      " let curcol      = begin_paran + 1
+      let curcol      = begin_paran
+      " echom 'begin_paran: '.begin_paran.
+      "             \ ' line: '.linenum.
+      "             \ ' col: '.curcol.
+      "             \ ' : '.line
+
+      " Place the cursor on the (
+      "silent! exe 'normal! '.linenum."G\<bar>".(curcol-1)."l"
+      " silent! exe 'normal! '.linenum."G\<bar>".curcol."l"
+      call cursor(linenum,(curcol+1))
+
+      " let indent_to = searchpair( '(', '', ')', '' )
+      " Find the matching closing )
+      " Ignore parans that are inside of strings
+      let indent_to = searchpair( '(', '', ')', 'W',
+            \ 'synID(line("."),col("."),1)>0' )
+
+      " If the match is outside of the range, this is an unmatched (
+      if indent_to < 1 || indent_to > line("'z-1")
+        " Return to previous location
+        " echom 'Unmatched parentheses on line: ' . getline(linenum)
+        call s:SQLU_WarningMsg(
+              \ 'SQLU_SplitUnbalParan: Unmatched parentheses' .
+              \ ' at line/col: (' . (linenum-1).','.(curcol+1). 
+              \ ') on line: ' . 
+              \ getline(linenum)
+              \ )
+        " echom 'Unmatched parentheses: Returning to: '.
+        "             \ linenum."G\<bar>".curcol."l"
+        "             \ " #: ".line(".")
+        "             \ " text: ".getline(".")
+        " silent! exe 'normal! '.linenum."G\<bar>".(curcol-1)."l"
+        silent! exe 'normal! '.linenum."G\<bar>".curcol."l"
+        return -1
+      endif
+
+      let matchline     = line(".")
+      let matchcol      = virtcol(".")
+      " echom 'SQLU_SplitUnbalParan searchpair: ' . indent_to.
+      "             \ ' col: '.matchcol.
+      "             \ ' line: '.getline(indent_to)
+
+      " If the match is on a DIFFERENT line
+      if indent_to != linenum
+        " If there are any characters before the matching
+        " ) place it on a newline
+        let index = match(getline(indent_to), '\S')
+        if index == -1 || index < col('.') 
+          " Place the paranethesis on a new line
+          silent! exec "normal! i\n\<Esc>"
+          let indent_to = indent_to + 1
+          " echom 'Indented closing line: '.getline(".")
+        endif
+        " Remove leading spaces
+        " echom "Removing leading spaces"
+        " exec 'normal! '.indent_to.','.indent_to.
+        "             \'s/^\s*//e'."\n"
+        silent! exec 's/^\s*//e'."\n"
+
+        " Place a marker at the beginning of the line so
+        " it can be Aligned with its matching paranthesis
+        if getline(".") !~ '^\s*-@-'
+          silent! exec "normal! i-@-\<Esc>"
+        endif
+        " echom 'Replacing ) with newline: '.line(".").
+        "             \ ' indent: '.curcol.' '
+        "             \ getline(indent_to)
+
+        " echom 'line:' . linenum . ' col:' . curcol
+        "echom linenum . ' ' . getline(linenum) . curcol . 
+        "\ ' ' . matchstr( getline(linenum),  
+        "\ '^.\{'.(curcol).'}\zs.*' )     
+
+
+        " Return to the original line
+        " Check if the line with the ( needs splitting
+        " as well
+        " Since the closing ) is on a different line, make sure
+        " this ( is the last character on the line, this is 
+        " necessary so that the blocks are correctly indented
+        " .\{8} - match any characters up to the 8th column
+        " \zs   - start the search in column 9
+        " \s*$  - If the line only has whitespace dont split
+
+        if getline(linenum) !~ '^.\{'.(curcol+1).'}\zs\s*$'     
+          " Return to previous location
+          silent! exe 'normal! '.linenum."G\<bar>".curcol."l"
+
+          " Place the paranethesis on a new line
+          " with the marker at the beginning so
+          " it can be Aligned with its matching paranthesis
+          silent! exec "normal! a\n-@-\<Esc>"
+
+          " Add 1 to the linenum since the remainder of this 
+          " line has been moved 
+          let linenum = linenum + 1
+          " Reset begin_paran since we are on a new line
+          let begin_paran = -1
+
+        endif
+      endif
+
+      " We have potentially changed the line we are on
+      " so get a new copy of the row to perform the match
+      " Add one to the curcol to look for the next (
+      let begin_paran = match( getline(linenum), "(", (begin_paran+1) )
+
+    endwhile
+
+    let linenum = linenum + 1
+  endwhile
+
+  " Never found matching close parenthesis
+  " return end of range
+  return linenum
+endfunction
+
+" If a comment is found, skip it
+function! SQLUtilities#SQLU_AlignSkip( lineno, indx )
+  if getline(a:lineno) =~ '^\s*--'
+    return 1
+  endif
+  return 0
+
+  let synid   = synID(a:lineno,a:indx+1,1)
+  let synname = synIDattr(synIDtrans(synid),"name")
+  let ret= (synname == "String")? 1 : 0
+  return ret
+endfunction
+
+" Puts a command separate list of columns given a table name
+" Will search through the file looking for the create table command
+" It assumes that each column is on a separate line
+" It places the column list in unnamed buffer
+function! SQLUtilities#SQLU_CreateColumnList(...)
+
+  " Mark the current line to return to
+  let curline     = line(".")
+  let curcol      = virtcol(".")
+  let curbuf      = bufnr(expand("<abuf>"))
+  let found       = 0
+
+  if(a:0 > 0) 
+    let table_name  = a:1
+  else
+    let table_name  = expand("<cword>")
+  endif
+
+  if(a:0 > 1) 
+    let only_primary_key = 1
+  else
+    let only_primary_key = 0
+  endif
+
+  let add_alias = ''
+  if(a:0 > 2) 
+    let add_alias = a:2
+  else
+    if 'da' =~? g:sqlutil_use_tbl_alias
+      if table_name =~ '_'
+        " Treat _ as separators since people often use these
+        " for word separators
+        let save_keyword = &iskeyword
+        setlocal iskeyword-=_
+
+        " Get the first letter of each word
+        " [[:alpha:]] is used instead of \w 
+        " to catch extended accented characters
+        "
+        let initials = substitute( 
+              \ table_name, 
+              \ '\<[[:alpha:]]\+\>_\?', 
+              \ '\=strpart(submatch(0), 0, 1)', 
+              \ 'g'
+              \ )
+        " Restore original value
+        let &iskeyword = save_keyword
+      elseif table_name =~ '\u\U'
+        let initials = substitute(
+              \ table_name, '\(\u\)\U*', '\1', 'g')
+      else
+        let initials = strpart(table_name, 0, 1)
+      endif
+
+      if 'a' =~? g:sqlutil_use_tbl_alias
+        let add_alias = inputdialog("Enter table alias:", initials)
+      else
+        let add_alias = initials
+      endif
+    endif
+  endif
+  " Following a word character, make sure there is a . and no spaces
+  let add_alias = substitute(add_alias, '\w\zs\.\?\s*$', '.', '')
+
+  " save previous search string
+  let saveSearch = @/
+  let saveZ      = @z
+  let columns    = ""
+  " Prevent the alternate buffer (<C-^>) from being set to this
+  " temporary file
+  let l:old_cpoptions = &cpoptions
+  setlocal cpo-=a
+
+  " ignore case
+  if( only_primary_key == 0 )
+    let srch_table = '\c^[ \t]*create.*table.*\<'.table_name.'\>'
+  else
+    " Regular expression breakdown
+    " Ingore case and spaces
+    " line begins with either create or alter
+    " followed by table and table_name (on the same line)
+    " Could be other lines inbetween these
+    " Look for the primary key clause (must be one)
+    " Start the match after the open paran
+    " The column list could span multiple lines
+    " End the match on the closing paran
+    " Could be other lines in between these
+    " Remove any newline characters for the command
+    " terminator (ie "\ngo" )
+    " Besides a CREATE TABLE statement, this expression
+    " should find statements like:
+    "     ALTER TABLE SSD.D_CENTR_ALLOWABLE_DAYS
+    "         ADD PRIMARY KEY (CUST_NBR, CAL_NBR, GRP_NBR,
+    "              EVENT_NBR, ALLOW_REVIS_NBR, ROW_REVIS_NBR);
+    let srch_table = '\c^[ \t]*' . 
+          \ '\(create\|alter\)' . 
+          \ '.*table.*' . 
+          \ table_name .                
+          \ '\_.\{-}' .    
+          \ '\%(primary key\)\{-1,}' . 
+          \ '\s*(\zs' . 
+          \ '\_.\{-}' . 
+          \ '\ze)' . 
+          \ '\_.\{-}' . 
+          \ substitute( g:sqlutil_cmd_terminator,
+          \ "[\n]", '', "g" )
+  endif
+
+  " Loop through all currenly open buffers to look for the 
+  " CREATE TABLE statement, if found build the column list
+  " or display a message saying the table wasn't found
+  " I am assuming a create table statement is of this format
+  " CREATE TABLE "cons"."sync_params" (
+  "   "id"                            integer NOT NULL,
+  "   "last_sync"                     timestamp NULL,
+  "   "sync_required"                 char(1) NOT NULL DEFAULT 'N',
+  "   "retries"                       smallint NOT NULL ,
+  "   PRIMARY KEY ("id")
+  " );
+  while( 1==1 )
+    " Mark the current line to return to
+    let buf_curline     = line(".")
+    let buf_curcol      = virtcol(".")
+    " From the top of the file
+    silent! exe "normal! 1G\<bar>0\<bar>"
+    if( search( srch_table, "W" ) ) > 0
+      if( only_primary_key == 0 )
+        " Find the create table statement
+        " let cmd = '/'.srch_create_table."\n"
+        " Find the opening ( that starts the column list
+        let cmd = 'normal! /('."\n".'Vib'."\<ESC>"
+        silent! exe cmd
+        " Decho 'end: '.getline(line("'>"))
+        let start_line = line("'<")
+        let end_line = line("'>")
+        silent! exe 'noh'
+        let found = 1
+
+        " Visually select until the following keyword are the beginning
+        " of the line, this should be at the bottom of the column list
+        " Start visually selecting columns
+        " let cmd = 'silent! normal! V'."\n"
+        let find_end_of_cols = 
+              \ '\(' .
+              \ g:sqlutil_cmd_terminator .
+              \ '\|' .
+              \ substitute(
+              \ g:sqlutil_col_list_terminators,
+              \ ',', '\\|\1', 'g' ) .
+              \ '\)' 
+
+        let separator = ""
+        let columns = ""
+
+        " Build comma separated list of input parameters
+        while start_line <= end_line
+          let line = getline(start_line)
+
+          " If the line has no words on it, skip it
+          if line !~ '\w' || line =~ '^\s*$'
+            let start_line = start_line + 1
+            continue
+          endif
+
+
+          " if any of the find_end_of_cols is found, leave this loop.
+          " This test is case insensitive.
+          if line =~? '^\s*\w\+\s\+\w\+\s\+'.find_end_of_cols
+            " Special case, the column name definition
+            " is part of the line
+          elseif line =~? find_end_of_cols
+            let end_line = start_line - 1
+            break
+          endif
+
+          let column_name = substitute( line, 
+                \ '[ \t"]*\(\<\w\+\>\).*', '\1', "g" )
+          let column_def = SQLU_GetColumnDatatype( line, 1 )
+
+          let columns = columns . separator . add_alias . column_name
+          let separator  = ", "
+          let start_line = start_line + 1
+        endwhile
+
+      else
+        " Find the primary key statement
+        " Visually select all the text until the 
+        " closing paranthesis
+        silent! exe 'silent! normal! v/)/e-1'."\n".'"zy'
+        let columns = @z
+        " Strip newlines characters
+        let columns = substitute( columns, 
+              \ "[\n]", '', "g" )
+        " Strip everything but the column list
+        let columns = substitute( columns, 
+              \ '\s*\(.*\)\s*', '\1', "g" )
+        " Remove double quotes
+        let columns = substitute( columns, '"', '', "g" )
+        let columns = substitute( columns, ',\s*', ', ', "g" )
+        let columns = substitute( columns, '^\s*', '', "g" )
+        let columns = substitute( columns, '\s*$', '', "g" )
+        let found = 1
+        silent! exe 'noh'
+      endif
+
+    endif
+
+    " Return to previous location
+    silent! exe 'normal! '.buf_curline."G\<bar>".buf_curcol."l"
+
+    if found == 1
+      break
+    endif
+
+    if &hidden == 0
+      call s:SQLU_WarningMsg(
+            \ "Cannot search other buffers with set nohidden"
+            \ )
+      break
+    endif
+
+    " Switch buffers to check to see if the create table
+    " statement exists
+    silent! exec "bnext"
+    if bufnr(expand("<abuf>")) == curbuf
+      break
+    endif
+  endwhile
+
+  silent! exec "buffer " . curbuf
+
+  " Return to previous location
+  silent! exe 'normal! '.curline."G\<bar>".(curcol-1).(((curcol-1) > 0)?"l":'')
+  silent! exe 'noh'
+
+  " restore previous search
+  let @/ = saveSearch
+  let @z = saveZ
+
+  " Restore previous cpoptions
+  let &cpoptions = l:old_cpoptions
+
+
+  redraw
+
+  if found == 0
+    let @@ = ""
+    if( only_primary_key == 0 )
+      call s:SQLU_WarningMsg(
+            \ "SQLU_CreateColumnList - Table: " .
+            \ table_name . 
+            \ " was not found"
+            \ )
+    else
+      call s:SQLU_WarningMsg(
+            \ "SQLU_CreateColumnList - Table: " .
+            \ table_name . 
+            \ " does not have a primary key"
+            \ )
+    endif
+    return ""
+  endif 
+
+  " If clipboard is pointing to the windows clipboard
+  " copy the results there.
+  if &clipboard == 'unnamed'
+    let @* = columns 
+  else
+    let @@ = columns 
+  endif
+
+  echo "Paste register: " . columns
+
+  return columns
+
+endfunction
+
+
+" Strip the datatype from a column definition line
+function! SQLUtilities#SQLU_GetColumnDatatype( line, need_type )
+
+  let pattern = '\c^\s*'  " case insensitve, white space at start of line
+  let pattern = pattern . '\S\+\w\+[ "\t]\+' " non white space (name with 
+  " quotes)
+
+  if a:need_type == 1
+    let pattern = pattern . '\zs'    " Start matching the datatype
+    let pattern = pattern . '.\{-}'  " include anything
+    let pattern = pattern . '\ze\s*'    " Stop matching when ...
+    let pattern = pattern . '\(NOT\|NULL\|DEFAULT\|'
+    let pattern = pattern . '\(\s*,\s*$\)' " Line ends with a comma 
+    let pattern = pattern . '\)' 
+  else
+    let pattern = pattern . '\zs'   " Start matching the datatype
+    let pattern = pattern . '.\{-}' " include anything
+    let pattern = pattern . '\ze'   " Stop matching when ...
+    let pattern = pattern . '\s*,\s*$' " Line ends with a comma 
+  endif
+
+  let datatype = matchstr( a:line, pattern )
+
+  return datatype
+endfunction
+
+
+" Puts a comma separated list of columns given a table name
+" Will search through the file looking for the create table command
+" It assumes that each column is on a separate line
+" It places the column list in unnamed buffer
+function! SQLUtilities#SQLU_GetColumnDef( ... )
+
+  " Mark the current line to return to
+  let curline     = line(".")
+  let curcol      = virtcol(".")
+  let curbuf      = bufnr(expand("<abuf>"))
+  let found       = 0
+
+  if(a:0 > 0) 
+    let col_name  = a:1
+  else
+    let col_name  = expand("<cword>")
+  endif
+
+  if(a:0 > 1) 
+    let need_type = a:2
+  else
+    let need_type = 0
+  endif
+
+  let srch_column_name = '^[ \t]*["]\?\<' . col_name . '\>["]\?\s\+\<\w\+\>'
+  let column_def = ""
+
+  " Loop through all currenly open buffers to look for the 
+  " CREATE TABLE statement, if found build the column list
+  " or display a message saying the table wasn't found
+  " I am assuming a create table statement is of this format
+  " CREATE TABLE "cons"."sync_params" (
+  "   "id"                            integer NOT NULL,
+  "   "last_sync"                     timestamp NULL,
+  "   "sync_required"                 char(1) NOT NULL DEFAULT 'N',
+  "   "retries"                       smallint NOT NULL ,
+  "   PRIMARY KEY ("id")
+  " );
+  while( 1==1 )
+    " Mark the current line to return to
+    let buf_curline     = line(".")
+    let buf_curcol      = virtcol(".")
+
+    " From the top of the file
+    silent! exe "normal! 1G\<bar>0\<bar>"
+
+    if( search( srch_column_name, "w" ) ) > 0
+      silent! exe 'noh'
+      let found = 1
+      let column_def = SQLU_GetColumnDatatype( getline("."), need_type )
+    endif
+
+    " Return to previous location
+    silent! exe 'normal! '.buf_curline."G\<bar>".buf_curcol."l"
+
+    if found == 1
+      break
+    endif
+
+    if &hidden == 0
+      call s:SQLU_WarningMsg(
+            \ "Cannot search other buffers with set nohidden"
+            \ )
+      break
+    endif
+
+    " Switch buffers to check to see if the create table
+    " statement exists
+    silent! exec "bnext"
+    if bufnr(expand("<abuf>")) == curbuf
+      break
+    endif
+  endwhile
+
+  silent! exec "buffer " . curbuf
+
+  " Return to previous location
+  silent! exe 'normal! '.curline."G\<bar>".curcol."l"
+
+  if found == 0
+    let @@ = ""
+    echo "Column: " . col_name . " was not found"
+    return ""
+  endif 
+
+  if &clipboard == 'unnamed'
+    let @* = column_def 
+  else
+    let @@ = column_def 
+  endif
+
+  " If a parameter has been passed, this means replace the 
+  " current word, with the column list
+  " if (a:0 > 0) && (found == 1)
+  " exec "silent! normal! viwp"
+  " if &clipboard == 'unnamed'
+  " let @* = col_name 
+  " else
+  " let @@ = col_name 
+  " endif
+  " echo "Paste register: " . col_name
+  " else
+  echo "Paste register: " . column_def
+  " endif
+
+  return column_def
+
+endfunction
+
+
+
+" Creates a procedure defintion into the unnamed buffer for the 
+" table that the cursor is currently under.
+function! SQLUtilities#SQLU_CreateProcedure(...)
+
+  " Mark the current line to return to
+  let curline     = line(".")
+  let curcol      = virtcol(".")
+  let curbuf      = bufnr(expand("<abuf>"))
+  let found       = 0
+  " save previous search string
+  let saveSearch=@/ 
+  " Prevent the alternate buffer (<C-^>) from being set to this
+  " temporary file
+  let l:old_cpoptions   = &cpoptions
+  let l:old_eventignore = &eventignore
+  setlocal cpo-=A
+  setlocal eventignore=BufRead,BufReadPre,BufEnter,BufNewFile
+
+
+
+  if(a:0 > 0) 
+    let table_name  = a:1
+  else
+    let table_name  = expand("<cword>")
+  endif
+
+  let i = 0
+  let indent_spaces = ''
+  while( i < &shiftwidth )
+    let indent_spaces = indent_spaces . ' '
+    let i = i + 1
+  endwhile
+
+  " ignore case
+  " let srch_create_table = '\c^[ \t]*create.*table.*\<' . table_name . '\>'
+  let srch_create_table = '\c^[ \t]*create.*table.*\<' . 
+        \ table_name . 
+        \ '\>'
+  let procedure_def = "CREATE PROCEDURE sp_" . table_name . "(\n"
+
+  " Loop through all currenly open buffers to look for the 
+  " CREATE TABLE statement, if found build the column list
+  " or display a message saying the table wasn't found
+  " I am assuming a create table statement is of this format
+  " CREATE TABLE "cons"."sync_params" (
+  "   "id"                            integer NOT NULL,
+  "   "last_sync"                     timestamp NULL,
+  "   "sync_required"                 char(1) NOT NULL DEFAULT 'N',
+  "   "retries"                       smallint NOT NULL,
+  "   PRIMARY KEY ("id")
+  " );
+  while( 1==1 )
+    " Mark the current line to return to
+    let buf_curline     = line(".")
+    let buf_curcol      = virtcol(".")
+
+    " From the top of the file
+    silent! exe "normal! 1G\<bar>0\<bar>"
+
+    if( search( srch_create_table, "w" ) ) > 0
+      " Find the create table statement
+      " let cmd = '/'.srch_create_table."\n"
+      " Find the opening ( that starts the column list
+      let cmd = 'normal! /('."\n".'Vib'."\<ESC>"
+      silent! exe cmd
+      " Decho 'end: '.getline(line("'>"))
+      let start_line = line("'<")
+      let end_line = line("'>")
+      silent! exe 'noh'
+      let found = 1
+
+      " Visually select until the following keyword are the beginning
+      " of the line, this should be at the bottom of the column list
+      " Start visually selecting columns
+      " let cmd = 'silent! normal! V'."\n"
+      let find_end_of_cols = 
+            \ '\(' .
+            \ g:sqlutil_cmd_terminator .
+            \ '\|' .
+            \ substitute(
+            \ g:sqlutil_col_list_terminators,
+            \ ',', '\\|\1', 'g' ) .
+            \ '\)' 
+
+      let separator = " "
+      let column_list = ""
+
+      " Build comma separated list of input parameters
+      while start_line <= end_line
+        let line = getline(start_line)
+
+        " If the line has no words on it, skip it
+        if line !~ '\w' || line =~ '^\s*$'
+          let start_line = start_line + 1
+          continue
+        endif
+
+        " if any of the find_end_of_cols is found, leave this loop.
+        " This test is case insensitive.
+        if line =~? find_end_of_cols
+          let end_line = start_line - 1
+          break
+        endif
+
+        let column_name = substitute( line, 
+              \ '[ \t"]*\(\<\w\+\>\).*', '\1', "g" )
+        let column_def = SQLU_GetColumnDatatype( line, 1 )
+
+        let column_list = column_list . separator . column_name
+        let procedure_def = procedure_def . 
+              \ indent_spaces .
+              \ separator .
+              \ "IN @" . column_name .
+              \ ' ' . column_def . "\n"
+
+        let separator  = ","
+        let start_line = start_line + 1
+      endwhile
+
+      let procedure_def = procedure_def .  ")\n"
+      let procedure_def = procedure_def . "RESULT(\n" 
+
+      let start_line = line("'<")
+      let separator  = " "
+
+      " Build comma separated list of datatypes
+      while start_line <= end_line
+        let line = getline(start_line)
+
+        " If the line has no words on it, skip it
+        if line !~ '\w' || line =~ '^\s*$'
+          let start_line = start_line + 1
+          continue
+        endif
+
+        let column_def = SQLU_GetColumnDatatype( line, 1 )
+
+        let procedure_def = procedure_def .
+              \ indent_spaces .
+              \ separator . 
+              \ column_def .
+              \ "\n"
+
+        let separator  = ","
+        let start_line = start_line + 1
+      endwhile
+
+      let procedure_def = procedure_def .  ")\n"
+      " Strip off any spaces
+      let column_list = substitute( column_list, ' ', '', 'g' )
+      " Ensure there is one space after each ,
+      let column_list = substitute( column_list, ',', ', ', 'g' )
+      let save_tbl_alias = g:sqlutil_use_tbl_alias
+      " Disable the prompt for the table alias
+      let g:sqlutil_use_tbl_alias = 'n'
+      let pk_column_list = SQLU_CreateColumnList(
+            \ table_name, 'primary_keys')
+      let g:sqlutil_use_tbl_alias = save_tbl_alias  
+
+      let procedure_def = procedure_def . "BEGIN\n\n" 
+
+      " Create a sample SELECT statement
+      let procedure_def = procedure_def . 
+            \ indent_spaces .
+            \ "SELECT " . column_list . "\n" .
+            \ indent_spaces .
+            \ "  FROM " . table_name . "\n"
+      let where_clause = indent_spaces . 
+            \ substitute( column_list, 
+            \ '^\(\<\w\+\>\)\(.*\)', " WHERE \\1 = \@\\1\\2", "g" )
+      let where_clause = 
+            \ substitute( where_clause, 
+            \ ', \(\<\w\+\>\)', 
+            \ "\n" . indent_spaces . "   AND \\1 = @\\1", "g" )
+      let procedure_def = procedure_def . where_clause . ";\n\n"
+
+      " Create a sample INSERT statement
+      let procedure_def = procedure_def . 
+            \ indent_spaces . 
+            \ "INSERT INTO " . table_name . "( " .
+            \ column_list .
+            \ " )\n"
+      let procedure_def = procedure_def . 
+            \ indent_spaces .
+            \ "VALUES( " .
+            \ substitute( column_list, '\(\<\w\+\>\)', '@\1', "g" ).
+            \ " );\n\n"
+
+      " Create a sample UPDATE statement
+      let procedure_def = procedure_def . 
+            \ indent_spaces .
+            \ "UPDATE " . table_name . "\n" 
+
+      " Now we must remove each of the columns in the pk_column_list
+      " from the column_list, to create the no_pk_column_list.  This is
+      " used by the UPDATE statement, since we do not SET columns in the
+      " primary key.
+      " The order of the columns in the pk_column_list is not guaranteed
+      " to be in the same order as the table list in the CREATE TABLE
+      " statement.  So we must remove each word one at a time.
+      let no_pk_column_list = SQLU_RemoveMatchingColumns(
+            \ column_list, pk_column_list )
+
+      " Check for the special case where there is no 
+      " primary key for the table (ie ,\? \? )
+      let set_clause = 
+            \ indent_spaces .
+            \ substitute( no_pk_column_list, 
+            \ ',\? \?\(\<\w\+\>\)', 
+            \ '   SET \1 = @\1', '' )
+      let set_clause = 
+            \ substitute( set_clause, 
+            \ ', \(\<\w\+\>\)', 
+            \ ",\n" . indent_spaces . '       \1 = @\1', "g" )
+
+      " Check for the special case where there is no 
+      " primary key for the table
+      if strlen(pk_column_list) > 0
+        let where_clause = 
+              \ indent_spaces .
+              \ substitute( pk_column_list, 
+              \ '^\(\<\w\+\>\)', ' WHERE \1 = @\1', "" ) 
+        let where_clause = 
+              \ substitute( where_clause, 
+              \ ', \(\<\w\+\>\)', 
+              \ "\n" . indent_spaces . '   AND \1 = @\1', "g" )
+      else
+        " If there is no primary key for the table place
+        " all columns in the WHERE clause
+        let where_clause = 
+              \ indent_spaces .
+              \ substitute( column_list, 
+              \ '^\(\<\w\+\>\)', ' WHERE \1 = @\1', "" ) 
+        let where_clause = 
+              \ substitute( where_clause, 
+              \ ', \(\<\w\+\>\)', 
+              \ "\n" . indent_spaces . '   AND \1 = @\1', "g" )
+      endif
+      let procedure_def = procedure_def . set_clause . "\n" 
+      let procedure_def = procedure_def . where_clause .  ";\n\n"
+
+      " Create a sample DELETE statement
+      let procedure_def = procedure_def . 
+            \ indent_spaces .
+            \ "DELETE FROM " . table_name . "\n" 
+      let procedure_def = procedure_def . where_clause . ";\n\n"
+
+      let procedure_def = procedure_def . "END;\n\n" 
+
+    endif
+
+    " Return to previous location
+    silent! exe 'normal! '.buf_curline."G\<bar>".buf_curcol."l"
+
+    if found == 1
+      break
+    endif
+
+    if &hidden == 0
+      call s:SQLU_WarningMsg(
+            \ "Cannot search other buffers with set nohidden"
+            \ )
+      break
+    endif
+
+    " Switch buffers to check to see if the create table
+    " statement exists
+    silent! exec "bnext"
+    if bufnr(expand("<abuf>")) == curbuf
+      break
+    endif
+  endwhile
+
+  silent! exec "buffer " . curbuf
+
+  " restore previous search string
+  let @/ = saveSearch
+  " Restore previous cpoptions
+  let &cpoptions   = l:old_cpoptions
+  let &eventignore = l:old_eventignore
+
+
+  " Return to previous location
+  silent! exe 'normal! '.curline."G\<bar>".curcol."l"
+
+  if found == 0
+    let @@ = ""
+    echo "Table: " . table_name . " was not found"
+    return ""
+  endif 
+
+  echo 'Procedure: sp_' . table_name . ' in unnamed buffer'
+  if &clipboard == 'unnamed'
+    let @* = procedure_def 
+  else
+    let @@ = procedure_def 
+  endif
+
+  return ""
+
+endfunction
+
+
+
+" Compares two strings, and will remove all names from the first 
+" parameter, if the same name exists in the second column name.
+" The 2 parameters take comma separated lists
+function! SQLUtilities#SQLU_RemoveMatchingColumns( full_col_list, dup_col_list )
+
+  let stripped_col_list = a:full_col_list
+  let pos = 0
+  " Find the string index position of the first match
+  let index = match( a:dup_col_list, '\w\+' )
+  while index > -1
+    " Get name of column
+    let dup_col_name = matchstr( a:dup_col_list, '\w\+', index )
+    let stripped_col_list = substitute( stripped_col_list,
+          \ dup_col_name.'[, ]*', '', 'g' )
+    " Advance the search after the word we just found and look for
+    " others.  
+    let index = match( a:dup_col_list, '\w\+', 
+          \ index + strlen(dup_col_name) )
+  endwhile
+
+  return stripped_col_list
+
+endfunction
+
+function! s:SQLU_WarningMsg(msg) "{{{
+  echohl WarningMsg
+  echomsg a:msg
+  echohl None
+endfunction "}}}
+
+let &cpo = s:cpo_save
+unlet s:cpo_save
+
+" vim:fdm=marker:nowrap:ts=4:expandtab:ff=unix:
diff --git a/vimrc/.vim/autoload/indexed_search.vim b/vimrc/.vim/autoload/indexed_search.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/autoload/indexed_search.vim
@@ -0,0 +1,114 @@
+function! s:milli_since(start)
+    " Use it like this:
+    "   :let s = reltime()
+    "   :sleep 100m
+    "   :let time_passed = s:milli_since(s)
+    " This would result in a Float which represents the milliseconds passed.
+
+    let rel_time = reltimestr(reltime(a:start))
+    let [sec, milli] = map(split(rel_time, '\ze\.'), 'str2float(v:val)')
+    return (sec + milli) * 1000
+endfunction
+
+function! s:colored_echo(msg, hl)
+    execute "echohl ". a:hl
+    echo a:msg
+    echohl None
+endfunction
+
+function! s:search(query, force)
+    let winview = winsaveview()
+    let line = winview["lnum"]
+    let col = winview["col"] + 1
+    let [total, exact, after] = [0, -1, 0]
+
+    call cursor(1, 1)
+    let [matchline, matchcol] = searchpos(a:query, 'Wc')
+    while matchline && (total <= g:indexed_search_max_hits || a:force)
+        let total += 1
+        if (matchline == line && matchcol == col)
+            let exact = total
+        elseif matchline < line || (matchline == line && matchcol < col)
+            let after = total
+        endif
+        let [matchline, matchcol] = searchpos(a:query, 'W')
+    endwhile
+
+    call winrestview(winview)
+    return [total, exact, after]
+endfunction
+
+function! s:index_message(total, exact, after, force)
+    let hl = "Directory"
+    let msg = ""
+
+    if !a:force && a:total > g:indexed_search_max_hits
+        let matches = "> ". g:indexed_search_max_hits
+        if a:exact < 0
+            return [hl, matches ." matches"]
+        endif
+    else
+        let matches = a:total
+    endif
+    let shortmatch = matches . (g:indexed_search_shortmess ? "" : " matches")
+
+    if a:total == 0
+        let hl = "Error"
+        let msg = "No matches"
+    elseif a:exact == 1 && a:total == 1
+        " hl remains default
+        let msg = "Single match"
+    elseif a:exact == 1
+        let hl = "Search"
+        let msg = "First of ". shortmatch
+    elseif a:exact == a:total
+        let hl = "LineNr"
+        let msg = "Last of ". shortmatch
+    elseif a:exact >= 0
+        let msg = (g:indexed_search_shortmess ? "" : "Match ")
+                 \. a:exact ." of ". matches
+    elseif a:after == 0
+        let hl = "MoreMsg"
+        let msg = "Before first match, of ". shortmatch
+        if a:total == 1 | let msg = "Before single match" | endif
+    elseif a:after == a:total
+        let hl = "WarningMsg"
+        let msg = "After last match of ". shortmatch
+        if a:total == 1 | let msg = "After single match" | endif
+    else
+        let msg = "Between matches ". a:after ."-". (a:after+1) ." of ". matches
+    endif
+
+    return [hl, msg."  /".@/."/"]
+endfunction
+
+function! s:current_index(force)
+    if @/ == '' || (!a:force && line('$') >= g:indexed_search_max_lines)
+        return ['', '']
+    endif
+
+    let [total, exact, after] = s:search(@/, a:force)
+    return s:index_message(total, exact, after, a:force)
+endfunction
+
+function! s:echo(force)
+    let [hl, msg] = s:current_index(a:force)
+    if msg != ''
+        call s:colored_echo(msg, (g:indexed_search_colors ? hl : "None"))
+    endif
+endfunction
+
+
+function! indexed_search#show_index(force)
+    let s:save_ut = &ut
+    let s:force = a:force
+
+    " 061116 &ut is sometimes not restored and drops permanently to 50. But how ?
+    if &ut > 200 | let &ut = 200 | endif
+    augroup IndexedSearchAutoCmds
+        autocmd CursorHold *
+            \ let &ut = s:save_ut      |
+            \ call s:echo(s:force)     |
+            \ autocmd! IndexedSearchAutoCmds
+    augroup END
+endfunction
diff --git a/vimrc/.vim/autoload/pathogen.vim b/vimrc/.vim/autoload/pathogen.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/autoload/pathogen.vim
@@ -0,0 +1,324 @@
+" pathogen.vim - path option manipulation
+" Maintainer:   Tim Pope <http://tpo.pe/>
+" Version:      2.2
+
+" Install in ~/.vim/autoload (or ~\vimfiles\autoload).
+"
+" For management of individually installed plugins in ~/.vim/bundle (or
+" ~\vimfiles\bundle), adding `execute pathogen#infect()` to the top of your
+" .vimrc is the only other setup necessary.
+"
+" The API is documented inline below.  For maximum ease of reading,
+
+if exists("g:loaded_pathogen") || &cp
+  finish
+endif
+let g:loaded_pathogen = 1
+
+function! s:warn(msg)
+  echohl WarningMsg
+  echomsg a:msg
+  echohl NONE
+endfunction
+
+" Point of entry for basic default usage.  Give a relative path to invoke
+" pathogen#incubate() (defaults to "bundle/{}"), or an absolute path to invoke
+" pathogen#surround().  For backwards compatibility purposes, a full path that
+" does not end in {} or * is given to pathogen#runtime_prepend_subdirectories()
+" instead.
+function! pathogen#infect(...) abort " {{{1
+  for path in a:0 ? reverse(copy(a:000)) : ['bundle/{}']
+    if path =~# '^[^\\/]\+$'
+      call s:warn('Change pathogen#infect('.string(path).') to pathogen#infect('.string(path.'/{}').')')
+      call pathogen#incubate(path . '/{}')
+    elseif path =~# '^[^\\/]\+[\\/]\%({}\|\*\)$'
+      call pathogen#incubate(path)
+    elseif path =~# '[\\/]\%({}\|\*\)$'
+      call pathogen#surround(path)
+    else
+      call s:warn('Change pathogen#infect('.string(path).') to pathogen#infect('.string(path.'/{}').')')
+      call pathogen#surround(path . '/{}')
+    endif
+  endfor
+  call pathogen#cycle_filetype()
+  return ''
+endfunction " }}}1
+
+" Split a path into a list.
+function! pathogen#split(path) abort " {{{1
+  if type(a:path) == type([]) | return a:path | endif
+  let split = split(a:path,'\\\@<!\%(\\\\\)*\zs,')
+  return map(split,'substitute(v:val,''\\\([\\,]\)'',''\1'',"g")')
+endfunction " }}}1
+
+" Convert a list to a path.
+function! pathogen#join(...) abort " {{{1
+  if type(a:1) == type(1) && a:1
+    let i = 1
+    let space = ' '
+  else
+    let i = 0
+    let space = ''
+  endif
+  let path = ""
+  while i < a:0
+    if type(a:000[i]) == type([])
+      let list = a:000[i]
+      let j = 0
+      while j < len(list)
+        let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
+        let path .= ',' . escaped
+        let j += 1
+      endwhile
+    else
+      let path .= "," . a:000[i]
+    endif
+    let i += 1
+  endwhile
+  return substitute(path,'^,','','')
+endfunction " }}}1
+
+" Convert a list to a path with escaped spaces for 'path', 'tag', etc.
+function! pathogen#legacyjoin(...) abort " {{{1
+  return call('pathogen#join',[1] + a:000)
+endfunction " }}}1
+
+" Remove duplicates from a list.
+function! pathogen#uniq(list) abort " {{{1
+  let i = 0
+  let seen = {}
+  while i < len(a:list)
+    if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
+      call remove(a:list,i)
+    elseif a:list[i] ==# ''
+      let i += 1
+      let empty = 1
+    else
+      let seen[a:list[i]] = 1
+      let i += 1
+    endif
+  endwhile
+  return a:list
+endfunction " }}}1
+
+" \ on Windows unless shellslash is set, / everywhere else.
+function! pathogen#separator() abort " {{{1
+  return !exists("+shellslash") || &shellslash ? '/' : '\'
+endfunction " }}}1
+
+" Convenience wrapper around glob() which returns a list.
+function! pathogen#glob(pattern) abort " {{{1
+  let files = split(glob(a:pattern),"\n")
+  return map(files,'substitute(v:val,"[".pathogen#separator()."/]$","","")')
+endfunction "}}}1
+
+" Like pathogen#glob(), only limit the results to directories.
+function! pathogen#glob_directories(pattern) abort " {{{1
+  return filter(pathogen#glob(a:pattern),'isdirectory(v:val)')
+endfunction "}}}1
+
+" Turn filetype detection off and back on again if it was already enabled.
+function! pathogen#cycle_filetype() " {{{1
+  if exists('g:did_load_filetypes')
+    filetype on
+  endif
+endfunction " }}}1
+
+" Check if a bundle is disabled.  A bundle is considered disabled if it ends
+" in a tilde or its basename or full name is included in the list
+" g:pathogen_disabled.
+function! pathogen#is_disabled(path) " {{{1
+  if a:path =~# '\~$'
+    return 1
+  elseif !exists("g:pathogen_disabled")
+    return 0
+  endif
+  let sep = pathogen#separator()
+  let blacklist = g:pathogen_disabled
+  return index(blacklist, strpart(a:path, strridx(a:path, sep)+1)) != -1 && index(blacklist, a:path) != 1
+endfunction "}}}1
+
+" Prepend the given directory to the runtime path and append its corresponding
+" after directory.  If the directory is already included, move it to the
+" outermost position.  Wildcards are added as is.  Ending a path in /{} causes
+" all subdirectories to be added (except those in g:pathogen_disabled).
+function! pathogen#surround(path) abort " {{{1
+  let sep = pathogen#separator()
+  let rtp = pathogen#split(&rtp)
+  if a:path =~# '[\\/]{}$'
+    let path = fnamemodify(a:path[0:-4], ':p:s?[\\/]\=$??')
+    let before = filter(pathogen#glob_directories(path.sep.'*'), '!pathogen#is_disabled(v:val)')
+    let after  = filter(reverse(pathogen#glob_directories(path.sep."*".sep."after")), '!pathogen#is_disabled(v:val[0:-7])')
+    call filter(rtp,'v:val[0:strlen(path)-1] !=# path')
+  else
+    let path = fnamemodify(a:path, ':p:s?[\\/]\=$??')
+    let before = [path]
+    let after = [path . sep . 'after']
+    call filter(rtp, 'index(before + after, v:val) == -1')
+  endif
+  let &rtp = pathogen#join(before, rtp, after)
+  return &rtp
+endfunction " }}}1
+
+" Prepend all subdirectories of path to the rtp, and append all 'after'
+" directories in those subdirectories.  Deprecated.
+function! pathogen#runtime_prepend_subdirectories(path) " {{{1
+  call s:warn('Change pathogen#runtime_prepend_subdirectories('.string(a:path).') to pathogen#surround('.string(a:path.'/{}').')')
+  return pathogen#surround(a:path . pathogen#separator() . '{}')
+endfunction " }}}1
+
+" For each directory in the runtime path, add a second entry with the given
+" argument appended.  If the argument ends in '/{}', add a separate entry for
+" each subdirectory.  The default argument is 'bundle/{}', which means that
+" .vim/bundle/*, $VIM/vimfiles/bundle/*, $VIMRUNTIME/bundle/*,
+" $VIM/vim/files/bundle/*/after, and .vim/bundle/*/after will be added (on
+" UNIX).
+function! pathogen#incubate(...) abort " {{{1
+  let sep = pathogen#separator()
+  let name = a:0 ? a:1 : 'bundle/{}'
+  if "\n".s:done_bundles =~# "\\M\n".name."\n"
+    return ""
+  endif
+  let s:done_bundles .= name . "\n"
+  let list = []
+  for dir in pathogen#split(&rtp)
+    if dir =~# '\<after$'
+      if name =~# '{}$'
+        let list +=  filter(pathogen#glob_directories(substitute(dir,'after$',name[0:-3],'').'*'.sep.'after'), '!pathogen#is_disabled(v:val[0:-7])') + [dir]
+      else
+        let list += [dir, substitute(dir, 'after$', '', '') . name . sep . 'after']
+      endif
+    else
+      if name =~# '{}$'
+        let list +=  [dir] + filter(pathogen#glob_directories(dir.sep.name[0:-3].'*'), '!pathogen#is_disabled(v:val)')
+      else
+        let list += [dir . sep . name, dir]
+      endif
+    endif
+  endfor
+  let &rtp = pathogen#join(pathogen#uniq(list))
+  return 1
+endfunction " }}}1
+
+" Deprecated alias for pathogen#incubate().
+function! pathogen#runtime_append_all_bundles(...) abort " {{{1
+  if a:0
+    call s:warn('Change pathogen#runtime_append_all_bundles('.string(a:1).') to pathogen#incubate('.string(a:1.'/{}').')')
+  else
+    call s:warn('Change pathogen#runtime_append_all_bundles() to pathogen#incubate()')
+  endif
+  return call('pathogen#incubate', map(copy(a:000),'v:val . "/{}"'))
+endfunction
+
+let s:done_bundles = ''
+" }}}1
+
+" Invoke :helptags on all non-$VIM doc directories in runtimepath.
+function! pathogen#helptags() abort " {{{1
+  let sep = pathogen#separator()
+  for glob in pathogen#split(&rtp)
+    for dir in split(glob(glob), "\n")
+      if (dir.sep)[0 : strlen($VIMRUNTIME)] !=# $VIMRUNTIME.sep && filewritable(dir.sep.'doc') == 2 && !empty(filter(split(glob(dir.sep.'doc'.sep.'*'),"\n>"),'!isdirectory(v:val)')) && (!filereadable(dir.sep.'doc'.sep.'tags') || filewritable(dir.sep.'doc'.sep.'tags'))
+        silent! execute 'helptags' pathogen#fnameescape(dir.'/doc')
+      endif
+    endfor
+  endfor
+endfunction " }}}1
+
+command! -bar Helptags :call pathogen#helptags()
+
+" Execute the given command.  This is basically a backdoor for --remote-expr.
+function! pathogen#execute(...) abort " {{{1
+  for command in a:000
+    execute command
+  endfor
+  return ''
+endfunction " }}}1
+
+" Like findfile(), but hardcoded to use the runtimepath.
+function! pathogen#runtime_findfile(file,count) abort "{{{1
+  let rtp = pathogen#join(1,pathogen#split(&rtp))
+  let file = findfile(a:file,rtp,a:count)
+  if file ==# ''
+    return ''
+  else
+    return fnamemodify(file,':p')
+  endif
+endfunction " }}}1
+
+" Backport of fnameescape().
+function! pathogen#fnameescape(string) abort " {{{1
+  if exists('*fnameescape')
+    return fnameescape(a:string)
+  elseif a:string ==# '-'
+    return '\-'
+  else
+    return substitute(escape(a:string," \t\n*?[{`$\\%#'\"|!<"),'^[+>]','\\&','')
+  endif
+endfunction " }}}1
+
+if exists(':Vedit')
+  finish
+endif
+
+let s:vopen_warning = 0
+
+function! s:find(count,cmd,file,lcd) " {{{1
+  let rtp = pathogen#join(1,pathogen#split(&runtimepath))
+  let file = pathogen#runtime_findfile(a:file,a:count)
+  if file ==# ''
+    return "echoerr 'E345: Can''t find file \"".a:file."\" in runtimepath'"
+  endif
+  if !s:vopen_warning
+    let s:vopen_warning = 1
+    let warning = '|echohl WarningMsg|echo "Install scriptease.vim to continue using :V'.a:cmd.'"|echohl NONE'
+  else
+    let warning = ''
+  endif
+  if a:lcd
+    let path = file[0:-strlen(a:file)-2]
+    execute 'lcd `=path`'
+    return a:cmd.' '.pathogen#fnameescape(a:file) . warning
+  else
+    return a:cmd.' '.pathogen#fnameescape(file) . warning
+  endif
+endfunction " }}}1
+
+function! s:Findcomplete(A,L,P) " {{{1
+  let sep = pathogen#separator()
+  let cheats = {
+        \'a': 'autoload',
+        \'d': 'doc',
+        \'f': 'ftplugin',
+        \'i': 'indent',
+        \'p': 'plugin',
+        \'s': 'syntax'}
+  if a:A =~# '^\w[\\/]' && has_key(cheats,a:A[0])
+    let request = cheats[a:A[0]].a:A[1:-1]
+  else
+    let request = a:A
+  endif
+  let pattern = substitute(request,'/\|\'.sep,'*'.sep,'g').'*'
+  let found = {}
+  for path in pathogen#split(&runtimepath)
+    let path = expand(path, ':p')
+    let matches = split(glob(path.sep.pattern),"\n")
+    call map(matches,'isdirectory(v:val) ? v:val.sep : v:val')
+    call map(matches,'expand(v:val, ":p")[strlen(path)+1:-1]')
+    for match in matches
+      let found[match] = 1
+    endfor
+  endfor
+  return sort(keys(found))
+endfunction " }}}1
+
+command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Ve       :execute s:find(<count>,'edit<bang>',<q-args>,0)
+command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vedit    :execute s:find(<count>,'edit<bang>',<q-args>,0)
+command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vopen    :execute s:find(<count>,'edit<bang>',<q-args>,1)
+command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vsplit   :execute s:find(<count>,'split',<q-args>,<bang>1)
+command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vvsplit  :execute s:find(<count>,'vsplit',<q-args>,<bang>1)
+command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vtabedit :execute s:find(<count>,'tabedit',<q-args>,<bang>1)
+command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vpedit   :execute s:find(<count>,'pedit',<q-args>,<bang>1)
+command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vread    :execute s:find(<count>,'read',<q-args>,<bang>1)
+
+" vim:set et sw=2:
diff --git a/vimrc/.vim/bundle/Dockerfile.vim b/vimrc/.vim/bundle/Dockerfile.vim
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/Dockerfile.vim
@@ -0,0 +1 @@
+Subproject commit 2a31e6bcea5977209c05c728c4253d82fd873c82
diff --git a/vimrc/.vim/bundle/LargeFile b/vimrc/.vim/bundle/LargeFile
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/LargeFile
@@ -0,0 +1 @@
+Subproject commit 18407c43846edea7b7964b0b99226ec04d00931f
diff --git a/vimrc/.vim/bundle/SQLUtilities/README b/vimrc/.vim/bundle/SQLUtilities/README
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/bundle/SQLUtilities/README
@@ -0,0 +1,271 @@
+This is a mirror of http://www.vim.org/scripts/script.php?script_id=492
+
+Various SQL Utilities.
+
+Version 2.0 requires Vim 7.
+
+1. A SQL formatter, to make SQL statements (select, insert, update, delete...) more readable.   
+2. Based on create table statements, will generate select lists for a table, as long as the definition exists in some open buffer.
+3. Creates a generic procedure that will perform an insert, update, delete and select based on the definition of a table (if already open in some buffer).  The format is ANSI.
+4.  Returns the column datatype definition for a specified column name (or supplied) based on the definition of a table (if already open in some buffer).
+
+Functions:
+[range]SQLUFormatter(..list..)
+                                                                            
+     Formats SQL statements into a easily readable form.
+     Breaks keywords onto new lines.
+     Forces column lists to be split over as many lines as
+     necessary to fit the current textwidth of the buffer,
+     so that lines do not wrap.
+     If parentheses are unbalanced (ie a subselect) it will
+     indent everything within the unbalanced paranthesis.
+     Works for SELECT, INSERT, UPDATE, DELETE statements.
+
+     Global variables to customization some aspects of the formatting:
+     sqlutil_align_where - aligns the =, >=, <=, ...
+     sqlutil_align_comma - places the column lists in select statement on new lines
+     sqlutil_align_first_word - see examples
+
+     You can change the case of the keywords while formatting.
+
+                                                                            
+Examples (these would look much better when using a fixed font):
+                                                                            
+  Original:
+  SELECT m.MSG_ID, m.PRIORITY_ID, CUST.CUST_NBR, CUST.CUST_NM, 
+  CUST.CUST_LEGAL_NM, CUST.STORE_ADDR_1, CUST.STORE_ADDR_2, 
+  CUST.CROSS_STREET, XMLELEMENT( 'Alerts', XMLELEMENT( 'Alert_alert_id', 
+  alert_id ), XMLELEMENT( 'Alert_agent_id', agent_id ), XMLELEMENT( 
+  'Alert_alert_type_id', alert_type_desc), XMLELEMENT( 
+  'Alert_alert_date', alert_date), XMLELEMENT( 
+  'Alert_url_reference', url_reference), XMLELEMENT( 
+  'Alert_read_status', read_status )) CUST.STORE_CITY, 
+  CUST.STORE_ST, CUST.POST_CODE, CUST.STORE_MGR_NM, FROM MESSAGES m JOIN 
+  PRIORITY_CD P WHERE m.to_person_id = ?  AND p.NAME = 'PRI_EMERGENCY' AND 
+  p.JOB = 'Plumber' AND m.status_id < ( SELECT s.STATUS_ID FROM 
+  MSG_STATUS_CD s WHERE s.NAME = 'MSG_READ') ORDER BY m.msg_id desc
+  
+                                                                            
+  Formatted:
+  SELECT m.MSG_ID, m.PRIORITY_ID, CUST.CUST_NBR, CUST.CUST_NM,
+         CUST.CUST_LEGAL_NM, CUST.STORE_ADDR_1, CUST.STORE_ADDR_2,
+         CUST.CROSS_STREET,
+         XMLELEMENT(
+             'Alerts', XMLELEMENT( 'Alert_alert_id', alert_id ),
+             XMLELEMENT( 'Alert_agent_id', agent_id ),
+             XMLELEMENT( 'Alert_alert_type_id', alert_type_desc),
+             XMLELEMENT( 'Alert_alert_date', alert_date),
+             XMLELEMENT(
+                 'Alert_url_reference', url_reference
+              ), XMLELEMENT( 'Alert_read_status', read_status )
+         ) CUST.STORE_CITY, CUST.STORE_ST, CUST.POST_CODE, 
+         CUST.STORE_MGR_NM
+    FROM MESSAGES m
+    JOIN PRIORITY_CD P
+   WHERE m.to_person_id = ?
+     AND p.NAME = 'PRI_EMERGENCY'
+     AND p.JOB = 'Plumber'
+     AND m.status_id < (
+          SELECT s.STATUS_ID
+            FROM MSG_STATUS_CD s
+           WHERE s.NAME = 'MSG_READ'
+         )
+   ORDER BY m.msg_id desc
+  
+  
+                                                                            
+  Original:
+  UPDATE "SERVICE_REQUEST" SET "BUILDING_ID" = ?, "UNIT_ID" = ?, 
+  "REASON_ID" = ?, "PERSON_ID" = ?, "PRIORITY_ID" = ?, "STATUS_ID" = ?, 
+  "CREATED" = ?, "REQUESTED" = ?, "ARRIVED" = ?  WHERE "REQUEST_ID" = ?
+                                                                            
+                                                                            
+  Formatted:
+  UPDATE "SERVICE_REQUEST"
+     SET "BUILDING_ID" = ?,
+         "UNIT_ID" = ?,
+         "REASON_ID" = ?,
+         "PERSON_ID" = ?,
+         "PRIORITY_ID" = ?,
+         "STATUS_ID" = ?,
+         "CREATED" = ?,
+         "REQUESTED" = ?,
+         "ARRIVED" = ?,
+   WHERE "REQUEST_ID"  = ?
+                                                                            
+                                                                            
+                                                                            
+  Original:
+  INSERT INTO "MESSAGES" ( "MSG_ID", "TO_PERSON_ID", 
+  "FROM_PERSON_ID", "REQUEST_ID", "CREATED", "PRIORITY_ID", 
+  "MSG_TYPE_ID", "STATUS_ID", "READ_WHEN", "TIMEOUT", 
+  "MSG_TXT", "RESEND_COUNT" ) VALUES ( ?, ?, ?, 
+  ?, ?, ?, ?, ?, ?, ?, ?, ? )
+                                                                            
+                                                                            
+  Formatted:
+  INSERT INTO "MESSAGES" ( "MSG_ID", "TO_PERSON_ID",
+         "FROM_PERSON_ID", "REQUEST_ID", "CREATED",
+         "PRIORITY_ID", "MSG_TYPE_ID", "STATUS_ID",
+         "READ_WHEN", "TIMEOUT", "MSG_TXT", "RESEND_COUNT" )
+  VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )
+                                                                            
+                                                                            
+Functions:
+SQLUCreateColumnList( optional parameter )
+                                                                            
+     Assumes either the current file, or any other open buffer, 
+     has a CREATE TABLE statement in a format similar to this:
+     CREATE TABLE customer (
+     	id	INT DEFAULT AUTOINCREMENT,
+     	last_modified TIMESTAMP NULL,
+     	first_name     	VARCHAR(30) NOT NULL,
+     	last_name	VARCHAR(60) NOT NULL,
+     	balance	        NUMERIC(10,2),
+     	PRIMARY KEY( id )
+     );
+     If you place the cursor on the word customer, then the 
+     unnamed buffer (also displayed by an echo statement) will 
+     contain:
+     id, last_modified, first_name, last_name, balance
+                                                                            
+     Optionally, it will replace the word with the above and place
+     the word in the unnamed buffer.  Calling the function with
+     a parameter enables this feature.
+                                                                            
+     This also uses the g:sqlutil_cmd_terminator to determine when
+     the create table statement ends if none of the following terms
+     are found before the final );
+            primary,reference,unique,check,foreign
+     sqlutil_cmd defaults to ";"
+                                                                            
+                                                                            
+Functions:
+SQLUGetColumnDef( optional parameter )
+SQLUGetColumnDataType( expand("<cword>"), 1 )
+                                                                            
+     Assumes either the current file, or any other open buffer, 
+     has a CREATE TABLE statement in a format similar to this:
+     CREATE TABLE customer (
+     	id	INT DEFAULT AUTOINCREMENT,
+     	last_modified TIMESTAMP NULL,
+     	first_name     	VARCHAR(30) NOT NULL,
+     	last_name	VARCHAR(60) NOT NULL,
+     	balance	        NUMERIC(10,2),
+     	PRIMARY KEY( id )
+     );
+     If you place the cursor on the word first_name, then the 
+     column definition will be placed in the unnamed buffer (and also
+     displayed by an echo statement).
+     VARCHAR(30) NOT NULL        
+                                                                            
+     If the command is called as SQLUGetColumnDef( expand("<cword>"), 1 )
+     or using the default mapping \scdt, just the datatype (instead
+     of the column definition) will be returned.  A separate command 
+     SQLUGetColumnDataType has been created for this.
+     VARCHAR(30) 
+                                                                            
+                                                                            
+Functions:
+SQLUCreateProcedure()
+                                                                            
+     Assumes either the current file, or any other open buffer, 
+     has a CREATE TABLE statement in a format similar to this:
+     CREATE TABLE customer (
+     	id	        INT DEFAULT AUTOINCREMENT,
+     	last_modified   TIMESTAMP NULL,
+     	first_name     	VARCHAR(30) NOT NULL,
+     	last_name	VARCHAR(60) NOT NULL,
+     	balance	        NUMERIC(10,2),
+     	PRIMARY KEY( id )
+     );
+     By calling SQLUCreateProcedure while on the name of a table
+     the unnamed buffer will contain the create procedure statement
+     for insert, update, delete and select statements.
+     Once pasted into the buffer, unneeded functionality can be 
+     removed.
+                                                                            
+                                                                            
+                                                                            
+Commands:
+[range]SQLUFormatter ..list..    
+                     : Reformats the SQL statements over the specified 
+                       range.  Statement will lined up given the 
+                       existing indent of the first word.
+SQLUCreateColumnList:  Creates a comma separated list of column names
+                       for the table name under the cursor, assuming
+                       the table definition exists in any open 
+                       buffer.  The column list is placed in the unnamed
+                       buffer.
+                       This also uses the g:sqlutil_cmd_terminator.
+                       By default a table alias will be added to each of the columns, this is 
+                       configurable, see documentation (new 1.3.7).
+                       This routine can optionally take 2 parameters
+                       SQLUCreateColumnList T1 
+                           Creates a column list for T1
+                       SQLUCreateColumnList T1 1
+                           Creates a column list for T1 but only for
+                           the primary keys for that table.
+SQLUGetColumnDef     : Displays the column definition of the column name
+                       under the cursor.  It assumes the CREATE TABLE
+                       statement is in an open buffer.
+SQLUGetColumnDataType
+                     : Displays the column datatype of the column name
+                       under the cursor.  It assumes the CREATE TABLE
+                       statement is in an open buffer.
+SQLUCreateProcedure  : Creates a stored procedure to perform standard
+                       operations against the table that the cursor
+                       is currently under.
+                       
+                                                                            
+
+Suggested Mappings:
+    vmap <silent>sf        <Plug>SQLU_Formatter<CR>
+    nmap <silent>scl       <Plug>SQLU_CreateColumnList<CR>
+    nmap <silent>scd       <Plug>SQLU_GetColumnDef<CR>
+    nmap <silent>scdt      <Plug>SQLU_GetColumnDataType<CR>
+    nmap <silent>scp       <Plug>SQLU_CreateProcedure<CR>
+                                                                            
+    mnemonic explanation
+    s - sql
+      f   - format
+      cl  - column list
+      cd  - column definition
+      cdt - column datatype
+      cp  - create procedure
+                                                                            
+    To prevent the default mappings from being created, place the 
+    following in your _vimrc:
+        let g:sqlutil_load_default_maps = 0
+                                                                            
+Customization:
+    By default this script assumes a command is terminated by a ;
+    If you are using Microsoft SQL Server a command terminator 
+    would be "go", or perhaps "\ngo".
+    To permenantly override the terminator in your _vimrc file you can add
+          let g:sqlutil_cmd_terminator = "\ngo"
+                                                                            
+                                                                            
+    When building a column list from a script file (ie CREATE TABLE 
+    statements), you can customize the script to detect when the 
+    column list finishes by creating the following in your _vimrc:
+          let g:sqlutil_col_list_terminators = 
+                       \ 'primary,reference,unique,check,foreign'
+                                                                            
+    This can be necessary in the following example:
+          CREATE TABLE customer (
+             id         INT DEFAULT AUTOINCREMENT,
+             first_name VARCHAR(30) NOT NULL,
+             last_name  VARCHAR(60) NOT NULL,
+             PRIMARY KEY( id )
+          ); 
+
+Dependencies:
+       Align.vim - Version 15
+                        - Author: Charles E. Campbell, Jr.
+                        - http://www.vim.org/script.php?script_id=294
+
+Suggested (Complementary) Plugins:
+     dbext.vim - Author: Peter Bagyinszki and David Fishburn
+                - http://www.vim.org/script.php?script_id=356
+
diff --git a/vimrc/.vim/bundle/SQLUtilities/autoload/SQLUtilities.vim b/vimrc/.vim/bundle/SQLUtilities/autoload/SQLUtilities.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/bundle/SQLUtilities/autoload/SQLUtilities.vim
@@ -0,0 +1,2133 @@
+" SQLUtilities:   Variety of tools for writing SQL
+"   Author:	      David Fishburn <dfishburn dot vim at gmail dot com>
+"   Date:	      Nov 23, 2002
+"   Last Changed: 2012 Oct 09
+"   Version:	  6.0.0
+"   Script:	      http://www.vim.org/script.php?script_id=492
+"   License:      GPL (http://www.gnu.org/licenses/gpl.html)
+"
+"   Dependencies:
+"        Align.vim - Version 15 (as a minimum)
+"                  - Author: Charles E. Campbell, Jr.
+"                  - http://www.vim.org/script.php?script_id=294
+"   Documentation:
+"        :h SQLUtilities.txt 
+"
+
+" Prevent duplicate loading
+if exists("g:loaded_sqlutilities_auto")
+    finish
+endif
+if v:version < 700
+    echomsg "SQLUtilities: Version 2.0.0 or higher requires Vim7.  Version 1.4.1 can stil be used with Vim6."
+    finish
+endif
+let g:loaded_sqlutilities_auto = 600
+
+" Turn on support for line continuations when creating the script
+let s:cpo_save = &cpo
+set cpo&vim
+
+" SQLU_Formatter: align selected text based on alignment pattern(s)
+function! SQLUtilities#SQLU_Formatter(...) range
+    let mode = 'n'
+    if a:0 > 0
+        let mode = (a:1 == ''?'n':(a:1))
+    endif
+
+    if ! exists( ':AlignCtrl' ) 
+        call s:SQLU_WarningMsg(
+                    \ 'SQLU_Formatter - The Align plugin cannot be found'
+                    \ )
+        return -1
+    endif
+
+    call s:SQLU_WrapperStart( a:firstline, a:lastline, mode )
+    " Store pervious value of highlight search
+    let hlsearch = &hlsearch
+    let &hlsearch = 0
+
+    " Store pervious value of gdefault
+    let gdefault = &gdefault
+    let &gdefault = 0
+
+    " save previous search string
+    let saveSearch = @/ 
+
+    " save previous format options and turn off automatic formating
+    let saveFormatOptions = &formatoptions
+    silent execute 'setlocal formatoptions-=a'
+
+    " Use the mark locations instead of storing the line numbers
+    " since these values can changes based on the reformatting 
+    " of the lines
+    let ret = s:SQLU_ReformatStatement()
+    if ret > -1
+        if g:sqlutil_wrap_expressions == 1
+            let ret = s:SQLU_WrapExpressions()
+        endif
+        if ret > -1
+            let ret = s:SQLU_IndentNestedBlocks()
+            if ret > -1
+                let ret = s:SQLU_WrapLongLines()
+            endif
+        endif
+    endif
+
+    " Restore default value
+    " And restore cursor position
+    let &hlsearch = hlsearch
+    call s:SQLU_WrapperEnd(mode)
+
+    " restore previous format options 
+    let &formatoptions = saveFormatOptions 
+
+    " restore previous search string
+    let @/ = saveSearch
+    let &gdefault = gdefault
+    
+endfunction
+
+" SQLU_FormatStmts: 
+"    For a given range (default entire file), it find each SQL 
+"    statement an run SQLFormatter against it.
+"                 
+function! SQLUtilities#SQLU_FormatStmts(...) range
+    let mode = 'n'
+    if a:0 > 0
+        let mode = (a:1 == ''?'n':(a:1))
+    endif
+
+    let curline     = line(".")
+    let curcol      = virtcol(".")
+    let keepline_ms = line("'s")
+    let keepcol_ms  = virtcol("'s")
+    let keepline_me = line("'e")
+    let keepcol_me  = virtcol("'e")
+
+    silent! exec 'normal! '.a:lastline."G\<bar>0\<bar>"
+    " Add a new line to the bottom of the mark to be removed latter
+    put =''
+    silent! exec "ma e"
+    silent! exec 'normal! '.a:firstline."G\<bar>0\<bar>"
+    " Add a new line above the mark to be removed latter
+    put! = ''
+    silent! exec "ma s"
+    silent! exec "normal! 'sj"
+
+    " Store pervious value of highlight search
+    let hlsearch = &hlsearch
+    let &hlsearch = 0
+
+    " save previous search string
+    let saveSearch = @/ 
+
+    " save previous format options and turn off automatic formating
+    let saveFormatOptions = &formatoptions
+    silent execute 'setlocal formatoptions-=a'
+
+    " Must default the statements to query
+    let stmt_keywords = g:sqlutil_stmt_keywords
+
+    " Verify the string is in the correct format
+    " Strip off any trailing commas
+    let stmt_keywords =
+                \ substitute(stmt_keywords, ',$','','')
+    " Convert commas to regex ors
+    let stmt_keywords =
+                \ substitute(stmt_keywords, '\s*,\s*', '\\|', 'g')
+
+    let sql_commands = '\c\<\('.stmt_keywords.'\)\>'
+
+    " Find a line starting with SELECT|UPDATE|DELETE
+    "     .,-             - From that line backup one line due to :g
+    "     /;              - find the ending command delimiter
+    "     SQLUFormatter   - Use the SQLUtilities plugin to format it
+    let cmd = a:firstline.','.a:lastline.'g/^\s*\<\(' .
+                \ stmt_keywords . '\)\>/.,-/' .
+                \ g:sqlutil_cmd_terminator . '/SQLUFormatter'
+    exec cmd
+
+    " Restore default value
+    " And restore cursor position
+    let &hlsearch = hlsearch
+
+    " restore previous format options 
+    let &formatoptions = saveFormatOptions 
+
+    " restore previous search string
+    let @/ = saveSearch
+    
+    silent! exe 'normal! '.curline."G\<bar>".(curcol-1).
+				\ ((curcol-1)>0 ? 'l' : '' )
+
+    if (mode != 'n')
+        " Reselect the visual area, so the user can us gv
+        " to operate over the region again
+        exec 'normal! '.(line("'s")+1).'gg'.'|'.
+                    \ 'V'.(line("'e")-2-line("'s")).'j|'."\<Esc>"
+    endif
+
+    " Delete blanks lines added around the visually selected range
+    silent! exe "normal! 'sdd'edd"
+
+    silent! exe 'normal! '.curline."G\<bar>".(curcol-1).
+				\ ((curcol-1)>0 ? 'l' : '' )
+
+endfunction
+
+" This function will return a count of unmatched parenthesis
+" ie ( this ( funtion ) - will return 1 in this case
+function! s:SQLU_CountUnbalancedParan( line, paran_to_check )
+    let l = a:line
+    let lp = substitute(l, '[^(]', '', 'g')
+    let l = a:line
+    let rp = substitute(l, '[^)]', '', 'g')
+
+    if a:paran_to_check =~ ')'
+        " echom 'SQLU_CountUnbalancedParan ) returning: ' 
+        " \ . (strlen(rp) - strlen(lp))
+        return (strlen(rp) - strlen(lp))
+    elseif a:paran_to_check =~ '('
+        " echom 'SQLU_CountUnbalancedParan ( returning: ' 
+        " \ . (strlen(lp) - strlen(rp))
+        return (strlen(lp) - strlen(rp))
+    else
+        " echom 'SQLU_CountUnbalancedParan unknown paran to check: ' . 
+        " \ a:paran_to_check
+        return 0
+    endif
+endfunction
+
+" WS: wrapper start (internal)   Creates guard lines,
+"     stores marks y and z, and saves search pattern
+function! s:SQLU_WrapperStart( beginline, endline, mode )
+    let b:curline     = line(".")
+    let b:curcol      = virtcol(".")
+    let b:keepsearch  = @/
+    let b:keepline_my = line("'y")
+    let b:keepcol_my  = virtcol("'y")
+    let b:keepline_mz = line("'z")
+    let b:keepcol_mz  = virtcol("'z")
+
+    silent! exec 'normal! '.a:endline."G\<bar>0\<bar>"
+    " Add a new line to the bottom of the mark to be removed later
+    put =''
+    silent! exec "ma z"
+    silent! exec 'normal! '.a:beginline."G\<bar>0\<bar>"
+    " Add a new line above the mark to be removed later
+    put! = ''
+    silent! exec "ma y"
+    let b:cmdheight= &cmdheight
+    set cmdheight=2
+    silent! exec "normal! 'zk"
+endfunction
+
+" WE: wrapper end (internal)   Removes guard lines,
+"     restores marks y and z, and restores search pattern
+function! s:SQLU_WrapperEnd(mode)
+    if (a:mode != 'n')
+        " Reselect the visual area, so the user can us gv
+        " to operate over the region again
+        exec 'normal! '.(line("'y")+1).'gg'.'|'.
+                    \ 'V'.(line("'z")-2-line("'y")).'j|'."\<Esc>"
+    endif
+
+    " Delete blanks lines added around the visually selected range
+    silent! exe "normal! 'ydd'zdd"
+    silent! exe "set cmdheight=".b:cmdheight
+    unlet b:cmdheight
+    let @/= b:keepsearch
+
+    silent! exe 'normal! '.b:curline."G\<bar>".(b:curcol-1).
+				\ ((b:curcol-1)>0 ? 'l' : '' )
+
+    unlet b:keepline_my b:keepcol_my
+    unlet b:keepline_mz b:keepcol_mz
+    unlet b:curline     b:curcol
+endfunction
+
+" Generic Search and Replace uses syntax ID {{{
+function! s:SQLU_SearchReplace(exp_find_str, exp_rplc_str)
+
+    " Find the string index position of the first match
+    " 'c'	accept a match at the cursor position
+    " 'W'	don't wrap around the end of the file
+    let index = search(a:exp_find_str, 'cW', (line("'z")))
+    while index > 0
+        " Verify the cursor is within the range
+        if index >= line("'y") && index <= line("'z")
+
+            " Useful debug statment to see where on the line 
+            " and which keyword you are working on
+            " echo line(".") strpart(getline("."), col(".")-1)
+
+            let syn_element_list = split(g:sqlutil_syntax_elements, ',')
+            
+            if !empty(syn_element_list)
+                let found_in_str = 0
+                for syn_element_name in syn_element_list
+                    " Determine the ID for the name in the CSV list
+                    let syn_element_id = hlID(syn_element_name)
+
+                    " Grab the current syntax ID of the match
+                    let childsynid  = synID(line("."),col("."),1)
+                    let parentsynid = synIDtrans(synID(line("."),col("."),1)) 
+
+                    if childsynid == syn_element_id || parentsynid == syn_element_id
+                        let found_in_str = 1
+                        break
+                    endif
+                endfor
+                if found_in_str == 1
+                    " Advance the cursor 1 position since we use 
+                    " 'c' in the flags
+                    call cursor( line("."), (col(".") + 1) )
+                    let index = search(a:exp_find_str, 'cW', (line("'z")))
+                    continue
+                endif
+            endif
+
+            " At the current cursor position
+            exec 's/\%#/' . a:exp_rplc_str
+
+            let index = search(a:exp_find_str, 'cW', (line("'z")))
+        endif
+    endwhile
+    
+endfunction 
+" }}}
+
+
+" Reformats the statements 
+" 1. Keywords (FROM, WHERE, AND, ... ) " are on new lines
+" 2. Keywords are right justified
+" 3. CASE statements are setup for alignment.
+" 4. Operators are lined up
+" 
+function! s:SQLU_ReformatStatement()
+    " Remove any lines that have comments on them since the comments
+    " could spill onto new lines and no longer have comment markers
+    " which would result in syntax errors
+    " Comments could also contain keywords, which would be split
+    " on to new lines
+    let srch_exp = '.*\zs--.*'
+    if exists("b:current_syntax") == 0 || g:sqlutil_use_syntax_support == 0
+        let cmd = "'y+1,'z-1s/". srch_exp .
+                    \ '//ge'
+        " Decho cmd
+        silent! exec cmd
+    else
+        " This uses Vim's syntax support to determine if
+        " a match is found within a string or not.
+        " Therefore only do it if syntax support is on
+        " which can be tested checking for the existance
+        " of the buffer local variable b:current_syntax
+        call s:SQLU_SearchReplace(srch_exp,  '')
+    endif
+
+    " Join block of text into 1 line
+    silent! 'y+1,'z-1j
+    " Reformat the commas, to remove any spaces before them
+    silent! 'y+1,'z-1s/\s*,/,/ge
+    " And add a space following them, this allows the line to be
+    " split using gqq
+    silent! 'y+1,'z-1s/,\(\w\)/, \1/ge
+    " Change more than 1 space with just one except spaces at
+    " the beginning of the range
+    " silent! 'y+1,'z-1s/\s\+/ /ge
+    silent! 'y+1,'z-1s/\(\S\+\)\(\s\+\)/\1 /g
+    " Go to the start of the block
+    silent! 'y+1
+
+    " Place an UPDATE on a newline, but not if it is preceeded by
+    " the existing statement.  Example:
+    "           INSERT INTO T1 (...)
+    "           ON EXISTING UPDATE
+    "           VALUES (...);
+    "           SELECT ...
+    "           FOR UPDATE
+    let sql_update_keywords = '' . 
+                \ '\%(\%(\<\%(for\|existing\)\s\+\)\@<!update\)'
+    " WINDOW clauses can be used in both the SELECT list
+    " and after the HAVING clause.
+    let sql_window_keywords = '' . 
+                \ 'over\|partition\s\+by\|' .
+                \ '\%(rows\|range\)\s\+' .
+                \ '\%(between\|unbounded\|current\|preceding\|following\)'
+    " INTO clause can be used in a SELECT statement as well 
+    " as an INSERT statement.  We do not want to place INTO
+    " on a newline if it is preceeded by INSERT
+    let sql_into_keywords = '' . 
+                \ '\%(\%(\<\%(insert\|merge\)\s\+\)\@<!into\)'
+    " Normally you would add put an AND statement on a new
+    " line.  But in the cases where you are dealing with
+    " a BETWEEN '1963-1-1' AND '1965-3-31', we no not want
+    " to put the AND on a new line
+    " Do not put AND on a new line if preceeded by
+    "      between<space><some text not including space><space>AND
+    let sql_and_between_keywords = '' . 
+                \ '\%(\%(\<between\s\+[^ ]\+\s\+\)\@<!and\)'
+    " For SQL Remote (ASA), this is valid syntax
+    "           SUBSCRIBE BY
+    "       OLD SUBSCRIBE BY
+    "       NEW SUBSCRIBE BY
+    let sql_subscribe_keywords = '' . 
+                \ '\%(\%(\<\%(old\|new\)\s\+\)\?subscribe\)'
+    " Oracle CONNECT BY statement
+    let sql_connect_by_keywords = '' . 
+                \ 'connect\s\+by\s\+\w\+'
+    " Oracle MERGE INTO statement
+    "      MERGE INTO ...
+    "      WHEN MATCHED THEN ...
+    "      WHEN NOT MATCHED THEN ....
+    " Match on the WHEN clause (with zero width) if it is followed
+    " by [not] matched
+    let sql_merge_keywords = '' . 
+                \ '\%(merge\s\+into\)\|\%(when\(\s\+\%(not\s\+\)\?matched\)\@=\)'
+    " Some additional Oracle keywords from the SQL Reference for SELECT
+    let sql_ora_keywords = '' .
+                \ '\%(dimension\s\+by\|' .
+                \ 'measures\s*(\|' .
+                \ 'iterate\s*(\|' .
+                \ 'within\s\+group\|' .
+                \ '\%(ignore\|keep\)\s\+nav\|' .
+                \ 'return\s\+\%(updated\|all\)\|' .
+                \ 'rules\s\+\%(upsert\|update\)\)'
+    " FROM clause can be used in a DELETE statement as well 
+    " as a SELECT statement.  We do not want to place FROM
+    " on a newline if it is preceeded by DELETE
+    let sql_from_keywords = '' . 
+                \ '\%(\%(\<delete\s\+\)\@<!from\)'
+    " Only place order on a newline if followed by "by"
+    " let sql_order_keywords = '' .  \ '\%(\%(\<order\s\+\)\@<!into\)'
+
+    " join type syntax from ASA help file
+    " INNER
+    " | LEFT [ OUTER ]
+    " | RIGHT [ OUTER ]
+    " | FULL [ OUTER ]
+    " LEFT, RIGHT, FULL can optional be followed by OUTER
+    " The entire expression is optional
+    let sql_join_type_keywords = '' . 
+                \ '\%(' .
+                \ '\%(inner\|' .
+                \ '\%(\%(\%(left\|right\|full\)\%(\s\+outer\)\?\s*\)\?\)' .
+                \ '\)\?\s*\)\?'
+    " Decho 'join types: ' . sql_join_type_keywords
+    " join operator syntax
+    " [ KEY | NATURAL ] [ join_type ] JOIN
+    " | CROSS JOIN
+    let sql_join_operator = '' .
+                \ '\%(' .
+                \ '\%(\%(\%(key\|natural\)\?\s*\)\?' .
+                \ sql_join_type_keywords .
+                \ 'join\)\|' .
+                \ '\%(\%(\%(cross\)\?\s*\)\?join\)' .
+                \ '\)'
+    " Decho 'join types: ' . sql_join_type_keywords
+    " join operator syntax
+    " [ KEY | NATURAL ] [ join_type ] JOIN
+    " | CROSS JOIN
+    " force each keyword onto a newline
+    let sql_keywords =  '\<\%(create\|drop\|call\|select\|set\|values\|' .
+                \ sql_update_keywords . '\|' .
+                \ sql_into_keywords . '\|' .
+                \ sql_and_between_keywords . '\|' .
+                \ sql_from_keywords . '\|' .
+                \ sql_join_operator . '\|' .
+                \ sql_subscribe_keywords . '\|' .
+                \ sql_connect_by_keywords . '\|' .
+                \ sql_merge_keywords . '\|' .
+                \ sql_ora_keywords . '\|' .
+                \ 'on\|where\|or\|\%(order\|group\)\s\+\%(\w\+\s\+\)\?\<by\>\|'.
+                \ sql_window_keywords . '\|' .
+                \ 'having\|for\|insert\|using\|' .
+                \ 'intersect\|except\|window\|' .
+                \ '\%(union\%(\s\+all\)\?\)\|' .
+                \ 'start\s\+with\|' .
+                \ '\%(\%(\<start\s\+\)\@<!with\)\)\>'
+    " The user can specify whether to align the statements based on 
+    " the first word, or on the matching string.
+    "     let g:sqlutil_align_first_word = 0
+    "           select
+    "             from
+    "         union all
+    "     let g:sqlutil_align_first_word = 1
+    "           select
+    "             from
+    "            union all
+    let srch_exp = '\c\%(^\s*\)\@<!\zs\<\(' .
+                \ sql_keywords .
+                \ '\)\>\s*'
+
+    if exists("b:current_syntax") == 0 || g:sqlutil_use_syntax_support == 0
+        let cmd = "'y+1,'z-1s/". srch_exp .
+                    \ '/\r\1' .
+                    \ ( g:sqlutil_align_first_word==0 ? '-@-' : ' ' ) .
+                    \ '/ge'
+        " Decho cmd
+        silent! exec cmd
+    else
+        " This uses Vim's syntax support to determine if
+        " a match is found within a string or not.
+        " Therefore only do it if syntax support is on
+        " which can be tested checking for the existance
+        " of the buffer local variable b:current_syntax
+        call s:SQLU_SearchReplace(srch_exp,  '\r\1' .  (g:sqlutil_align_first_word==0 ? '-@-' : ' ') )
+    endif
+
+    " Ensure keywords at the beginning of a line have a space after them
+    " This will ensure the Align program lines them up correctly
+    " silent! 'y+1,'z-1s/^\([a-zA-Z0-9_]*\)(/\1 (/e
+    " Delete any non empty lines
+    " Do NOT delete empty lines, since that can affect the marks
+    " and change which lines get formatted
+    " 'y+1,'z-1g/^\s*$/d
+
+    " If g:sqlutil_align_first_word == 0, then we need only add the -@-
+    " on the first word, else we need to do it to the first word
+    " on each line
+    silent! exec "'y+1," .  
+                \ ( g:sqlutil_align_first_word==0 ? "'y+1" : "'z-1" ) .  
+                \ 's/^\s*\<\w\+\>\zs\s*/-@-'
+
+    " Ensure CASE statements also start on new lines
+    " CASE statements can also be nested, but we want these to align
+    " with column lists, not keywords, so the -@- is placed BEFORE
+    " the CASE keywords, not after
+    "
+    " The CASE statement and the Oracle MERGE statement are very similar.
+    " I have changed the WHEN clause to check to see if it is followed
+    " by [NOT] MATCHED, if so, do not match the WHEN
+    let sql_case_keywords = '\(\<end\s\+\)\@<!case' .
+                \ '\|\<when\>\(\%(-@-\)\?\s*\%(not\s\+\)\?matched\)\@!' .
+                \ '\|else\|end\(\s\+case\)\?' 
+
+    " echom 'case: '.sql_case_keywords
+    " The case keywords must not be proceeded by a -@-
+    " silent! exec "'y+1,'z-1".'s/'.
+    "             \ '\%(-@-\)\@<!'.
+    "             \ '\<\('.
+    "             \ sql_case_keywords.
+    "             \ '\)\>/\r-@-\1/gei'
+    let srch_exp = '\c\%(-@-\)\@<!'.
+                \ '\<\('.
+                \ sql_case_keywords.
+                \ '\)\>'
+
+    if exists("b:current_syntax") == 0 || g:sqlutil_use_syntax_support == 0
+        let cmd = "'y+1,'z-1s/". srch_exp .
+                    \ '/\r-@-\1' .
+                    \ '/ge'
+        " Decho cmd
+        silent! exec cmd
+    else
+        " This uses Vim's syntax support to determine if
+        " a match is found within a string or not.
+        " Therefore only do it if syntax support is on
+        " which can be tested checking for the existance
+        " of the buffer local variable b:current_syntax
+        call s:SQLU_SearchReplace(srch_exp,  '\r-@-\1' )
+    endif
+
+    " AlignPush
+
+    " Using the Align.vim plugin, reformat the lines
+    " so that the keywords are RIGHT justified
+    AlignCtrl default
+
+    if g:sqlutil_align_comma == 1 
+        call s:SQLU_WrapAtCommas()
+    endif
+
+    call s:SQLU_WrapFunctionCalls()
+
+    let ret = s:SQLU_SplitUnbalParan()
+    if ret < 0
+        " Undo any changes made so far since an error occurred
+        " silent! exec 'u'
+        return ret
+    endif
+
+    " Align these based on the special charater
+    " and the column names are LEFT justified
+    let align_ctrl = 'Ip0P0'.(g:sqlutil_align_keyword_right==1?'r':'l').'l:'
+    silent! exec 'AlignCtrl '.align_ctrl
+    silent! 'y+1,'z-1Align -@-
+    silent! 'y+1,'z-1s/-@-/ /ge
+
+    " Now that we have removed the special alignment marker
+    " upper or lower case all the keywords only if the user
+    " has specified an override.
+    if g:sqlutil_keyword_case != ''
+        let cmd = "'y+1,'z-1".'s/\<\(' .
+                    \ sql_keywords .
+                    \ '\|' .
+                    \ sql_case_keywords .
+                    \ '\|' .
+                    \ sql_join_type_keywords .
+                    \ '\)\>/' .
+                    \ g:sqlutil_keyword_case .
+                    \ '\1/gei'
+        silent! exec cmd
+    endif
+
+    " Now align the operators 
+    " and the operators are CENTER justified
+    if g:sqlutil_align_where == 1
+        AlignCtrl default
+        AlignCtrl g [!<>=]
+        AlignCtrl Wp1P1l
+
+        " Change this to only attempt to align the last WHERE clause
+        " and not the entire SQL statement
+        " Valid operators are: 
+        "      =, =, >, <, >=, <=, !=, !<, !>, <> 
+        " The align below was extended to allow the last character
+        " to be either =,<,>
+        silent! 'y+1,'z-1Align [!<>=]\(<\|>\|=\)\=
+    endif
+
+    " Reset back to defaults
+    AlignCtrl default
+
+    " Reset the alignment to what it was prior to 
+    " this function
+    " AlignPop
+
+    return 1
+endfunction
+
+" Check through the selected text for open ( and
+" indent if necessary
+function! s:SQLU_IndentNestedBlocks()
+
+    let org_textwidth = &textwidth
+    if &textwidth == 0 
+        " Get the width of the window
+        let &textwidth = winwidth(winnr())
+    endif
+    
+    let sql_keywords = '\<\%(select\|set\|\%(insert\s\+\)\?into\|from\|values'.
+                \ '\|order\|group\|having\|return\|call\)\>'
+
+    " Indent nested blocks surrounded by ()s.
+    let linenum = line("'y+1")
+    while linenum <= line("'z-1")
+        let line = getline(linenum)
+        if line =~ '(\s*$'
+            let begin_paran = match( line, '(\s*$' )
+            if begin_paran > -1
+                let curline     = line(".")
+                let curcol      = begin_paran + 1
+                " echom 'begin_paran: '.begin_paran.
+                "             \ ' line: '.curline.
+                "             \ ' col: '.curcol
+                silent! exe 'normal! '.linenum."G\<bar>".curcol."l"
+                " v  - visual
+                " ib - inner block
+                " k  - backup on line
+                " >  - right shift
+                " .  - shift again
+                " silent! exe 'normal! vibk>.'
+                silent! exe 'normal! vibk>'
+                
+                " If the following line begins with a keyword, 
+                " indent one additional time.  This is necessary since 
+                " keywords are right justified, so they need an extra
+                " indent
+                if getline(linenum+1) =~? '^\s*\('.sql_keywords.'\)'
+                    silent! exe 'normal! .'
+                endif
+                " echom 'SQLU_IndentNestedBlocks - from: '.line("'<").' to: ' .
+                "             \ line("'>") 
+                " echom 'SQLU_IndentNestedBlocks - no match: '.getline(linenum)
+            endif
+        endif
+
+        let linenum = linenum + 1
+    endwhile
+
+    let ret = linenum
+
+    "
+    " Indent nested CASE blocks
+    "
+    let linenum = line("'y+1")
+    " Search for the beginning of a CASE statement
+    let begin_case = '\<\(\<end\s\+\)\@<!case\>'
+
+    silent! exe 'normal! '.linenum."G\<bar>0\<bar>"
+
+    while( search( begin_case, 'W' ) > 0 )
+        " Check to see if the CASE statement is inside a string
+        if synID(line("."),col("."),1) > 0
+            continue
+        endif
+        let curline = line(".")
+        if( (curline < line("'y+1"))  || (curline > line("'z-1" )) )
+            " echom 'No case statements, leaving loop'
+            silent! exe 'normal! '.line("'y+1")."G\<bar>0\<bar>"
+            break
+        endif
+        " echom 'begin CASE found at: '.curline
+        let curline = curline + 1
+        let end_of_case = s:SQLU_IndentNestedCase( begin_case, curline, 
+                    \ line("'z-1") )
+        let end_of_case = end_of_case + 1
+        let ret = end_of_case
+        if( ret < 0 )
+            break
+        endif
+        silent! exe 'normal! '.end_of_case."G\<bar>0\<bar>"
+    endwhile
+
+    "
+    " Indent Oracle nested MERGE blocks
+    "
+    let linenum = line("'y+1")
+    " Search for the beginning of a CASE statement
+    let begin_merge = '\<merge\s\+into\>'
+
+    silent! exe 'normal! '.linenum."G\<bar>0\<bar>"
+
+    if( search( begin_merge, 'W' ) > 0 )
+        let curline = line(".")
+        if( (curline < line("'y+1"))  || (curline > line("'z-1" )) )
+            " echom 'No case statements, leaving loop'
+            silent! exe 'normal! '.line("'y+1")."G\<bar>0\<bar>"
+        else
+            " echom 'begin CASE found at: '.curline
+            let curline = curline + 1
+
+            while 1==1
+                " Find the matching when statement
+                " let match_merge = searchpair('\<merge\s\+into\>', 
+                let match_merge = searchpair('\<merge\>', '',
+                            \ '\<\%(when\s\+\%(not\s\+\)\?matched\)', 
+                            \ 'W', '' )
+                if( (match_merge < curline) || (match_merge > line("'z-1")) )
+                    silent! exec curline . "," . line("'z-1") . ">>"
+                    break
+                else
+                    if match_merge > (curline+1)
+                        let savePos = 'normal! '.line(".").'G'.col(".")."\<bar>"
+                        silent! exec curline . "," . (match_merge-1) . ">>"
+                        silent! exec savePos
+                    endif
+                    let curline = match_merge + 1
+                endif
+            endwhile
+        endif
+    endif
+
+    let &textwidth = org_textwidth
+    return ret
+endfunction
+
+" Recursively indent nested case statements
+function! s:SQLU_IndentNestedCase( begin_case, start_line, end_line )
+
+    " Indent nested CASE blocks
+    let linenum = a:start_line
+
+    " Find the matching end case statement
+    let end_of_prev_case = searchpair(a:begin_case, '', 
+                \ '\<end\( case\)\?\>', 'W', '' )
+
+    if( (end_of_prev_case < a:start_line) || (end_of_prev_case > a:end_line) )
+        call s:SQLU_WarningMsg(
+                    \ 'SQLU_IndentNestedCase - No matching end case for: ' .
+                    \ getline((linenum-1))
+                    \ )
+        return -1
+    " else
+        " echom 'Matching END found at: '.end_of_prev_case
+    endif
+
+    silent! exe 'normal! '.linenum."G\<bar>0\<bar>"
+
+    if( search( a:begin_case, 'W' ) > 0 )
+        let curline = line(".")
+        if( (curline > a:start_line) && (curline < end_of_prev_case) )
+            let curline = curline + 1
+            let end_of_case = s:SQLU_IndentNestedCase( a:begin_case, curline, 
+                        \ line("'z-1") )
+            " echom 'SQLU_IndentNestedCase from: '.linenum.' to: '.end_of_case
+            silent! exec (curline-1) . "," . end_of_case . ">>"
+        " else
+        "     echom 'SQLU_IndentNestedCase No case statements, '.
+        "                 \ 'leaving SQLU_IndentNestedCase: '.linenum
+        endif
+    endif
+
+    return end_of_prev_case
+endfunction
+
+" For certain keyword lines (SELECT, ORDER BY, GROUP BY, ...)
+" Ensure the lines fit in the textwidth (or default 80), wrap
+" the lines where necessary and left justify the column names
+function! s:SQLU_WrapFunctionCalls()
+    " Check if this is a statement that can often by longer than 80 characters
+    " (select, set and so on), if so, ensure the column list is broken over as
+    " many lines as necessary and lined up with the other columns
+    let linenum = line("'y+1")
+
+    return 
+
+    let org_textwidth = &textwidth
+    if org_textwidth == 0 
+        " Get the width of the window
+        let curr_textwidth = winwidth(winnr())
+    else
+        let curr_textwidth = org_textwidth
+    endif
+
+    let sql_keywords = '\<\%(select\|set\|\%(insert\(-@-\)\?\)into' .
+                \ '\|from\|values'.
+                \ '\|order\|group\|having\|return\|with\)\>'
+
+    " Useful in the debugger
+    " echo linenum.' '.func_call.' '.virtcol(".").' 
+    " '.','.substitute(getline("."), '^ .*\(\%'.(func_call-1).'c...\).*', 
+    " '\1', '' ).', '.getline(linenum)
+
+    " call Decho(" Before column splitter 'y+1=".line("'<").
+    " \ ":".col("'<")."  'z-1=".line("'>").":".col("'>"))
+    while linenum <= line("'z-1")
+        let line = getline(linenum)
+
+        if strlen(line) < curr_textwidth
+            let linenum = linenum + 1
+            continue
+        endif
+
+        let get_func_nm = '[a-zA-Z_.]\+\s*('
+
+        " Use a special line textwidth, since if we split function calls
+        " any text within the parantheses will be indented 2 &shiftwidths
+        " so when calculating where to split, we must take that into
+        " account
+        let keyword_str = matchstr(
+                    \ getline(linenum), '^\s*\('.sql_keywords.'\)' )
+
+        let line_textwidth = curr_textwidth - strlen(keyword_str)
+        let func_call = 0
+        while( strlen(getline(linenum)) > line_textwidth )
+
+            " Find the column # of the start of the function name
+            let func_call = match( getline(linenum), get_func_nm, func_call )
+            if func_call < 0 
+                " If no functions found, move on to next line
+                break
+            endif
+
+            let prev_func_call = func_call
+
+            " Position cursor at func_call
+            silent! exe 'normal! '.linenum."G\<bar>".func_call."l"
+
+            if search('(', 'W') > linenum
+                call s:SQLU_WarningMsg(
+                            \ 'SQLU_WrapFunctionCalls - should have found a ('
+                            \ )
+                let linenum = linenum + 1
+                break
+            endif
+
+            " Check to ensure the paran is not part of a string
+            " Otherwise ignore and move on to the next paran
+            if synID(line("."),col("."),1) == 0
+                " let end_paran = searchpair( '(', '', ')', '' )
+                " Ignore parans that are inside of strings
+                let end_paran = searchpair( '(', '', ')', '',
+                            \ 'synID(line("."),col("."),1)>0' )
+                if end_paran < linenum || end_paran > linenum
+                    " call s:SQLU_WarningMsg(
+                    "             \ 'SQLU_WrapFunctionCalls - ' . 
+                    "             \ 'should have found a matching ) for :' .
+                    "             \ getline(linenum)
+                    "             \ )
+                    let linenum = linenum + 1
+                    break
+                endif
+
+                " If the matching ) is past the textwidth
+                if virtcol(".") > line_textwidth
+                    if (virtcol(".")-func_call) > line_textwidth
+                        " Place the closing brace on a new line only if
+                        " the entire length of the function call and 
+                        " parameters is longer than a line
+                        silent! exe "normal! i\r-@-\<esc>"
+                    endif
+                    " If the SQL keyword preceeds the function name dont
+                    " bother placing it on a new line
+                    let preceeded_by_keyword = 
+                                \ '^\s*' .
+                                \ '\(' .
+                                \ sql_keywords .
+                                \ '\|,' .
+                                \ '\)' .
+                                \ '\(-@-\)\?' .
+                                \ '\s*' .
+                                \ '\%'.(func_call+1).'c'
+                    " echom 'preceeded_by_keyword: '.preceeded_by_keyword
+                    " echom 'func_call:'.func_call.' Current 
+                    " character:"'.getline(linenum)[virtcol(func_call)].'"  - 
+                    " '.getline(linenum)
+                    if getline(linenum) !~? preceeded_by_keyword
+                        " if line =~? '^\s*\('.sql_keywords.'\)'
+                        " Place the function name on a new line
+                        silent! exe linenum.'s/\%'.(func_call+1).'c/\r-@-'
+                        let linenum = linenum + 1
+                        " These lines will be indented since they are wrapped
+                        " in parantheses.  Decrease the line_textwidth by
+                        " that amount to determine where to split nested 
+                        " function calls
+                        let line_textwidth = line_textwidth - (2 * &shiftwidth)
+                        let func_call = 0
+                        " Get the new offset of this function from the start
+                        " of the newline it is on
+                        let prev_func_call = match(
+                                    \ getline(linenum),get_func_nm,func_call)
+                    endif
+                endif
+            endif
+
+            " Get the name of the previous function
+            let prev_func_call_str = matchstr(
+                        \ getline(linenum), get_func_nm, prev_func_call )
+            " Advance the column by its length to find the next function
+            let func_call = prev_func_call +
+                        \ strlen(prev_func_call_str) 
+
+        endwhile
+
+        let linenum = linenum + 1
+    endwhile
+
+    let &textwidth = org_textwidth
+    return linenum
+endfunction
+
+" For certain keyword lines (SELECT, SET, INTO, FROM, VALUES)
+" put each comma on a new line and align it with the keyword 
+"     SELECT c1
+"          , c2
+"          , c3
+function! s:SQLU_WrapAtCommas()
+    let linenum = line("'y+1")
+
+    let sql_keywords = '\<\%(select\|set\|into\|from\|values\|insert\)\>'
+
+    " call Decho(" Before column splitter 'y+1=".line("'<").
+    " \ ":".col("'<")."  'z-1=".line("'>").":".col("'>"))
+    while linenum <= line("'z-1")
+        let line = getline(linenum)
+        " if line =~? '^\s*\('.sql_keywords.'\)'
+        if line =~? '\w'
+            " if line =~? '^\s*\<\('.sql_keywords.'\)\>'
+                silent! exec linenum 
+                " Mark the start of the line
+                silent! exec "normal! mb"
+                " echom "line b - ".getline("'b")
+                " Mark the next line
+                silent! exec "normal! jmek"
+
+                let saved_linenum = linenum
+                " let index = match(getline(linenum), '[,(]')
+                " Find the first , or (
+                let index = match(getline(linenum), (g:sqlutil_align_comma==1?'[,(]':'[,]'))
+                while index > -1
+                    " Go to the , or (
+                    call cursor(linenum, (index+1))
+
+                    " Assuming syntax is on, check to ensure the , or (
+                    " is not a string
+                    if getline(linenum)[col(".")-1] == '(' &&
+                                \ synID(line("."),col("."),1) == 0
+                        " if searchpair( '(', '', ')', '' ) > 0
+                        " Ignore parans that are inside of strings
+                        if searchpair( '(', '', ')', '',
+                                    \ 'synID(line("."),col("."),1)>0' ) > 0
+                            let linenum = line(".")
+                            let index   = col(".")
+                        endif
+                    else
+                        " Only do this if the comma at this offset
+                        " is not already at the start of the line
+                        if match(getline(linenum), '\S') != index
+                            " Given the current cursor position, replace
+                            " the , and any following whitespace
+                            " with a newline and the special -@- character
+                            " for Align
+                            silent! exec linenum . ',' . linenum . 
+                                        \ 's/\%' . (index + 1) . 'c,\s*' .
+                                        \ '/\r' .
+                                        \ (g:sqlutil_align_keyword_right == 1 ? ',-@-' : '-@-, ')
+                            let linenum = linenum + 1
+
+                            let index = 0
+                            if g:sqlutil_align_keyword_right == 0
+                                " If aligning the commas with the left justified 
+                                " column names, we must skip ahead the index
+                                " to be infront of the -@-
+                                let index = 3
+                            endif
+                        endif
+                        " Find the index of the first non-white space
+                        " which should be the , we just put on the 
+                        " newline
+                        let index = match(getline(linenum), '\S', index)
+                        let index = index + 1
+                    endif
+
+                    " then continue on for the remainder of the line
+                    " looking for the next , or (
+                    "
+                    " Must figure out what index value to start from
+                    let index = match( getline(linenum), '[,(]', index )
+                endwhile
+                let linenum = saved_linenum 
+
+                " Go to the end of the new lines
+                silent! exec "'e-" 
+                let linenum = line("'e")-1
+            " endif
+        endif
+
+        let linenum = linenum + 1
+    endwhile
+
+    return linenum
+endfunction
+
+" For certain keyword lines (SELECT, ORDER BY, GROUP BY, ...)
+" Ensure the lines fit in the textwidth (or default 80), wrap
+" the lines where necessary and left justify the column names
+function! s:SQLU_WrapExpressions()
+    " Check if this is a statement that can often by longer than 80 characters
+    " (select, set and so on), if so, ensure the column list is broken over as
+    " many lines as necessary and lined up with the other columns
+    let linenum = line("'y+1")
+
+    return 
+
+    let sql_keywords = '\<\%(select\)\>'
+    let sql_expression_operator = '' .
+                \ '\<\%(' .
+                \ '\%(end\s\+\)\@<!if\|else\%(if\)\?\|endif\|case\|when\|end' .
+                \ '\)\>'
+
+    " call Decho(" Before column splitter 'y+1=".line("'<").
+    " \ ":".col("'<")."  'z-1=".line("'>").":".col("'>"))
+    while linenum <= line("'z-1")
+        let line = getline(linenum)
+        " if line =~? '^\s*\('.sql_keywords.'\)'
+        if line =~? '\w'
+            " if line =~? '^\s*\('.sql_keywords.'\)'
+                " Decho 'linenum: ' . linenum . ' strlen: ' .
+                " \ strlen(line) . ' textwidth: ' . &textwidth .
+                " \ '  line: ' . line
+                " go to the current line
+                silent! exec linenum 
+                " Mark the start of the wide line
+                silent! exec "normal! mb"
+                let markb = linenum
+                " echom "line b - ".getline("'b")
+                " Mark the next line
+                silent! exec "normal! jmek"
+                " echom "line e - ".getline("'e")
+
+
+                if line =~? '\('.sql_expression_operator.'\)'
+                    silent! exec linenum . ',' . linenum . 
+                                \ 's/^\s*\('.sql_keywords.'\)\s*'.
+                                \ '/\1-@-'
+                    " Create a special marker for Align.vim
+                    " to line up the columns with
+                    silent! exec linenum . ',' . linenum . 
+                                \ 's/'.sql_expression_operator.'/'.
+                                \ '\r-@-&'
+
+                endif
+
+                " echom "end_line_nbr - ".end_line_nbr
+                " echom "normal! end_line_nbr - ".line(end_line_nbr)
+
+                " Append the special marker to the beginning of the line
+                " for Align.vim
+                " silent! exec "'b+," .end_line_nbr. 's/\s*\(.*\)/-@-\1'
+                " silent! exec "'b+," .end_line_nbr. 's/^\s*/-@-'
+                silent! exec ''.(markb+1)."," .end_line_nbr. 's/^\s*/-@-/g'
+                " silent! exec "'b+,'e-" . 's/\s*\(.*\)/-@-\1'
+                AlignCtrl Ip0P0rl:
+                " silent! 'b,'e-Align -@-
+                " silent! exec "'b,".end_line_nbr.'Align -@-'
+                silent! exec markb.",'e".'Align -@-'
+                " silent! 'b,'e-s/-@-/ /
+                silent! exec markb.",'e".'s/-@-/ /ge'
+                AlignCtrl default
+
+                " Advance the linenum to the end of the range
+                let linenum = line("'e") 
+            " endif
+        endif
+
+        let linenum = linenum + 1
+    endwhile
+
+    return linenum
+endfunction
+
+" For certain keyword lines (SELECT, ORDER BY, GROUP BY, ...)
+" Ensure the lines fit in the textwidth (or default 80), wrap
+" the lines where necessary and left justify the column names
+function! s:SQLU_WrapLongLines()
+    " Check if this is a statement that can often by longer than 80 characters
+    " (select, set and so on), if so, ensure the column list is broken over as
+    " many lines as necessary and lined up with the other columns
+    let linenum = line("'y+1")
+
+    return
+
+    let org_textwidth = &textwidth
+    if &textwidth == 0 
+        " Get the width of the window
+        let &textwidth = winwidth(winnr())
+    endif
+
+    let sql_keywords = '\<\%(select\|set\|into\|from\|values'.
+                \ '\|order\|group\|having\|call\|with\)\>'
+
+    " call Decho(" Before column splitter 'y+1=".line("'<").
+    " \ ":".col("'<")."  'z-1=".line("'>").":".col("'>"))
+    while linenum <= line("'z-1")
+        let line = getline(linenum)
+        " if line =~? '^\s*\('.sql_keywords.'\)'
+        if line =~? '\w'
+            " Set the textwidth to current value
+            " minus an adjustment for select and set
+            " minus any indent value this may have
+            " echo 'tw: '.&textwidth.'  indent: '.indent(line)
+            " Decho 'line: '.line
+            " Decho 'tw: '.&textwidth.'  match at: '.
+            "             \ matchend(line, sql_keywords )
+            " let &textwidth = &textwidth - 10 - indent(line)
+            if line =~? '^\s*\('.sql_keywords.'\)'
+                let &textwidth = &textwidth - matchend(line, sql_keywords ) - 2
+                let line_length = strlen(line) - matchend(line, sql_keywords )
+            else
+                let line_length = strlen(line)
+            endif
+
+            if( line_length > &textwidth )
+                " Decho 'linenum: ' . linenum . ' strlen: ' .
+                " \ strlen(line) . ' textwidth: ' . &textwidth .
+                " \ '  line: ' . line
+                " go to the current line
+                silent! exec linenum 
+                " Mark the start of the wide line
+                silent! exec "normal! mb"
+                let markb = linenum
+                " echom "line b - ".getline("'b")
+                " Mark the next line
+                silent! exec "normal! jmek"
+                " echom "line e - ".getline("'e")
+                " echom "line length- ".strlen(getline(".")).
+                " \ "  tw=".&textwidth
+
+
+                if line =~? '^\s*\('.sql_keywords.'\)'
+                    " Create a special marker for Align.vim
+                    " to line up the columns with
+                    silent! exec linenum . ',' . linenum . 's/\(\w\) /\1-@-'
+
+                    " If the line begins with SET then force each
+                    " column on a newline, instead of breaking them apart
+                    " this will ensure that the col_name = ... is on the
+                    " same line
+                    if line =~? '^\s*\<set\>'
+                        silent! 'b,'e-1s/,/,\r/ge
+                    endif
+                else
+                    " Place the special marker that the first non-whitespace
+                    " characeter
+                    if g:sqlutil_align_comma == 1  && line =~ '^\s*,'
+                        " silent! exec linenum . ',' . linenum .
+                        "             \ 's/^\s*\zs,\s*/,  -@-'
+                        if g:sqlutil_align_keyword_right == 1 
+                            silent! exec linenum . ',' . linenum .
+                                        \ 's/^\s*\zs,\s*/,  -@-'
+                        else
+                            silent! exec linenum . ',' . linenum .
+                                        \ 's/^\s*\zs,\s*/-@-, '
+                        endif
+                    else
+                        silent! exec linenum . ',' . linenum . 's/\S/-@-&'
+                    endif
+                endif
+
+                silent! exec linenum
+                " Reformat the line based on the textwidth
+                silent! exec "normal! gqq"
+
+                " echom "normal! mb - ".line("'b")
+                " echom "normal! me - ".line("'e")
+                " Sometimes reformatting does not change the line
+                " so we need to double check the end range to 
+                " ensure it does go backwards
+                let begin_line_nbr = (line("'b") + 1)
+                let begin_line_nbr = (markb + 1)
+                let end_line_nbr = (line("'e") - 1)
+                " echom "b- ".begin_line_nbr."  e- ".end_line_nbr
+                if end_line_nbr < begin_line_nbr
+                    let end_line_nbr = end_line_nbr + 1
+                    " echom "end_line_nbr adding 1 "
+                endif
+                " echom "end_line_nbr - ".end_line_nbr
+                " echom "normal! end_line_nbr - ".line(end_line_nbr)
+
+                " Reformat the commas
+                " silent! 'b,'e-s/\s*,/,/ge
+                " silent! exec "'b,".end_line_nbr.'s/\s*,/,/ge'
+                " Add a space after the comma
+                " silent! 'b,'e-s/,\(\w\)/, \1/ge
+                " silent! exec "'b,".end_line_nbr.'s/,\(\w\)/, \1/ge'
+                silent! exec markb.",".end_line_nbr.'s/,\(\w\)/, \1/ge'
+
+                " Append the special marker to the beginning of the line
+                " for Align.vim
+                " silent! exec "'b+," .end_line_nbr. 's/\s*\(.*\)/-@-\1'
+                " silent! exec "'b+," .end_line_nbr. 's/^\s*/-@-'
+                silent! exec ''.(markb+1)."," .end_line_nbr. 's/^\s*/-@-'
+                " silent! exec "'b+,'e-" . 's/\s*\(.*\)/-@-\1'
+                AlignCtrl Ip0P0rl:
+                " silent! 'b,'e-Align -@-
+                " silent! exec "'b,".end_line_nbr.'Align -@-'
+                silent! exec markb.",".end_line_nbr.'Align -@-'
+                " silent! 'b,'e-s/-@-/ /
+                if line =~? '^\s*\('.sql_keywords.'\)'
+                    silent! exec markb.",".end_line_nbr.'s/-@-/ /ge'
+                else
+                    silent! exec markb.",".end_line_nbr.'s/-@-/'.(g:sqlutil_align_comma == 1 ? ' ' : '' ).'/ge'
+                endif
+                AlignCtrl default
+
+                " Dont move to the end of the reformatted text
+                " since we also want to check for CASE statemtns
+                " let linenum = line("'e") - 1
+                " let linenum = line("'e")
+            endif
+        endif
+
+        let &textwidth = org_textwidth
+        if &textwidth == 0 
+            " Get the width of the window
+            let &textwidth = winwidth(winnr())
+        endif
+        let linenum = linenum + 1
+    endwhile
+
+    let &textwidth = org_textwidth
+    return linenum
+endfunction
+
+" Finds unbalanced paranthesis and put each one on a new line
+function! s:SQLU_SplitUnbalParan()
+    let linenum = line("'y+1")
+    while linenum <= line("'z-1")
+        let line = getline(linenum)
+        " echom 'SQLU_SplitUnbalParan: l: ' . linenum . ' t: '. getline(linenum)
+        if line !~ '('
+            " echom 'SQLU_SplitUnbalParan: no (s: '.linenum.'  : '.
+            " \ getline(linenum)
+            let linenum = linenum + 1
+            continue
+        endif
+            
+        " echom 'SQLU_SplitUnbalParan: start line: '.linenum.' : '.line
+
+        let begin_paran = match( line, "(" )
+        while begin_paran > -1
+            " Check if the paran is inside a string
+            if synID(linenum,(begin_paran+1),1) > 0
+                " If it is, skip to the next paran
+                let begin_paran = match( getline(linenum), "(", (begin_paran+1) )
+                continue
+            endif
+
+            " let curcol      = begin_paran + 1
+            let curcol      = begin_paran
+            " echom 'begin_paran: '.begin_paran.
+            "             \ ' line: '.linenum.
+            "             \ ' col: '.curcol.
+            "             \ ' : '.line
+
+            " Place the cursor on the (
+             "silent! exe 'normal! '.linenum."G\<bar>".(curcol-1)."l"
+            " silent! exe 'normal! '.linenum."G\<bar>".curcol."l"
+            call cursor(linenum,(curcol+1))
+
+            " let indent_to = searchpair( '(', '', ')', '' )
+            " Find the matching closing )
+            " Ignore parans that are inside of strings
+            let indent_to = searchpair( '(', '', ')', 'W',
+                        \ 'synID(line("."),col("."),1)>0' )
+
+            " If the match is outside of the range, this is an unmatched (
+            if indent_to < 1 || indent_to > line("'z-1")
+                " Return to previous location
+                " echom 'Unmatched parentheses on line: ' . getline(linenum)
+                call s:SQLU_WarningMsg(
+                            \ 'SQLU_SplitUnbalParan: Unmatched parentheses' .
+                            \ ' at line/col: (' . (linenum-1).','.(curcol+1). 
+                            \ ') on line: ' . 
+                            \ getline(linenum)
+                            \ )
+                " echom 'Unmatched parentheses: Returning to: '.
+                "             \ linenum."G\<bar>".curcol."l"
+                "             \ " #: ".line(".")
+                "             \ " text: ".getline(".")
+                " silent! exe 'normal! '.linenum."G\<bar>".(curcol-1)."l"
+                silent! exe 'normal! '.linenum."G\<bar>".curcol."l"
+                return -1
+            endif
+             
+            let matchline     = line(".")
+            let matchcol      = virtcol(".")
+            " echom 'SQLU_SplitUnbalParan searchpair: ' . indent_to.
+            "             \ ' col: '.matchcol.
+            "             \ ' line: '.getline(indent_to)
+
+            " If the match is on a DIFFERENT line
+            if indent_to != linenum
+                " If a ) is NOT the only thing on the line
+                " I have relaxed this, so it must be the first
+                " thing on the line 
+                " if getline(indent_to) !~ '^\s*\(-@-\)\?)\s*$'
+                if getline(indent_to) !~ '^\s*\(-@-\)\?)'
+                    " Place the paranethesis on a new line
+                    silent! exec "normal! i\n\<Esc>"
+                    let indent_to = indent_to + 1
+                    " echom 'Indented closing line: '.getline(".")
+                endif
+                " Remove leading spaces
+                " echom "Removing leading spaces"
+                " exec 'normal! '.indent_to.','.indent_to.
+                "             \'s/^\s*//e'."\n"
+                silent! exec 's/^\s*//e'."\n"
+                
+                " Place a marker at the beginning of the line so
+                " it can be Aligned with its matching paranthesis
+                if getline(".") !~ '^\s*-@-'
+                    silent! exec "normal! i-@-\<Esc>"
+                endif
+                " echom 'Replacing ) with newline: '.line(".").
+                "             \ ' indent: '.curcol.' '
+                "             \ getline(indent_to)
+
+                " echom 'line:' . linenum . ' col:' . curcol
+                "echom linenum . ' ' . getline(linenum) . curcol . 
+                "\ ' ' . matchstr( getline(linenum),  
+                "\ '^.\{'.(curcol).'}\zs.*' )     
+
+
+                " Return to the original line
+                " Check if the line with the ( needs splitting
+                " as well
+                " Since the closing ) is on a different line, make sure
+                " this ( is the last character on the line, this is 
+                " necessary so that the blocks are correctly indented
+                " .\{8} - match any characters up to the 8th column
+                " \zs   - start the search in column 9
+                " \s*$  - If the line only has whitespace dont split
+
+                if getline(linenum) !~ '^.\{'.(curcol+1).'}\zs\s*$'     
+                    " Return to previous location
+                    silent! exe 'normal! '.linenum."G\<bar>".curcol."l"
+
+                    " Place the paranethesis on a new line
+                    " with the marker at the beginning so
+                    " it can be Aligned with its matching paranthesis
+                    silent! exec "normal! a\n-@-\<Esc>"
+
+                    " Add 1 to the linenum since the remainder of this 
+                    " line has been moved 
+                    let linenum = linenum + 1
+                    " Reset begin_paran since we are on a new line
+                    let begin_paran = -1
+
+                endif
+            endif
+
+            " We have potentially changed the line we are on
+            " so get a new copy of the row to perform the match
+            " Add one to the curcol to look for the next (
+            let begin_paran = match( getline(linenum), "(", (begin_paran+1) )
+
+        endwhile
+
+        let linenum = linenum + 1
+    endwhile
+
+    " Never found matching close parenthesis
+    " return end of range
+    return linenum
+endfunction
+
+" Puts a command separate list of columns given a table name
+" Will search through the file looking for the create table command
+" It assumes that each column is on a separate line
+" It places the column list in unnamed buffer
+function! SQLUtilities#SQLU_CreateColumnList(...)
+
+    " Mark the current line to return to
+    let curline     = line(".")
+    let curcol      = virtcol(".")
+    let curbuf      = bufnr(expand("<abuf>"))
+    let found       = 0
+
+    if(a:0 > 0) 
+        let table_name  = a:1
+    else
+        let table_name  = expand("<cword>")
+    endif
+
+    if(a:0 > 1) 
+        let only_primary_key = 1
+    else
+        let only_primary_key = 0
+    endif
+
+    let add_alias = ''
+    if(a:0 > 2) 
+        let add_alias = a:2
+    else
+        if 'da' =~? g:sqlutil_use_tbl_alias
+            if table_name =~ '_'
+                " Treat _ as separators since people often use these
+                " for word separators
+                let save_keyword = &iskeyword
+                setlocal iskeyword-=_
+
+                " Get the first letter of each word
+                " [[:alpha:]] is used instead of \w 
+                " to catch extended accented characters
+                "
+                let initials = substitute( 
+                            \ table_name, 
+                            \ '\<[[:alpha:]]\+\>_\?', 
+                            \ '\=strpart(submatch(0), 0, 1)', 
+                            \ 'g'
+                            \ )
+                " Restore original value
+                let &iskeyword = save_keyword
+            elseif table_name =~ '\u\U'
+                let initials = substitute(
+                            \ table_name, '\(\u\)\U*', '\1', 'g')
+            else
+                let initials = strpart(table_name, 0, 1)
+            endif
+
+            if 'a' =~? g:sqlutil_use_tbl_alias
+                let add_alias = inputdialog("Enter table alias:", initials)
+            else
+                let add_alias = initials
+            endif
+        endif
+    endif
+    " Following a word character, make sure there is a . and no spaces
+    let add_alias = substitute(add_alias, '\w\zs\.\?\s*$', '.', '')
+
+    " save previous search string
+    let saveSearch = @/
+    let saveZ      = @z
+    let columns    = ""
+    " Prevent the alternate buffer (<C-^>) from being set to this
+    " temporary file
+    let l:old_cpoptions = &cpoptions
+    setlocal cpo-=a
+    
+    " ignore case
+    if( only_primary_key == 0 )
+        let srch_table = '\c^[ \t]*create.*table.*\<'.table_name.'\>'
+    else
+        " Regular expression breakdown
+        " Ingore case and spaces
+        " line begins with either create or alter
+        " followed by table and table_name (on the same line)
+        " Could be other lines inbetween these
+        " Look for the primary key clause (must be one)
+        " Start the match after the open paran
+        " The column list could span multiple lines
+        " End the match on the closing paran
+        " Could be other lines in between these
+        " Remove any newline characters for the command
+        " terminator (ie "\ngo" )
+        " Besides a CREATE TABLE statement, this expression
+        " should find statements like:
+        "     ALTER TABLE SSD.D_CENTR_ALLOWABLE_DAYS
+        "         ADD PRIMARY KEY (CUST_NBR, CAL_NBR, GRP_NBR,
+        "              EVENT_NBR, ALLOW_REVIS_NBR, ROW_REVIS_NBR);
+        let srch_table = '\c^[ \t]*' . 
+                    \ '\(create\|alter\)' . 
+                    \ '.*table.*' . 
+                    \ table_name .                
+                    \ '\_.\{-}' .    
+                    \ '\%(primary key\)\{-1,}' . 
+                    \ '\s*(\zs' . 
+                    \ '\_.\{-}' . 
+                    \ '\ze)' . 
+                    \ '\_.\{-}' . 
+                    \ substitute( g:sqlutil_cmd_terminator,
+                            \ "[\n]", '', "g" )
+    endif
+
+    " Loop through all currenly open buffers to look for the 
+    " CREATE TABLE statement, if found build the column list
+    " or display a message saying the table wasn't found
+    " I am assuming a create table statement is of this format
+    " CREATE TABLE "cons"."sync_params" (
+    "   "id"                            integer NOT NULL,
+    "   "last_sync"                     timestamp NULL,
+    "   "sync_required"                 char(1) NOT NULL DEFAULT 'N',
+    "   "retries"                       smallint NOT NULL ,
+    "   PRIMARY KEY ("id")
+    " );
+    while( 1==1 )
+        " Mark the current line to return to
+        let buf_curline     = line(".")
+        let buf_curcol      = virtcol(".")
+        " From the top of the file
+        silent! exe "normal! 1G\<bar>0\<bar>"
+        if( search( srch_table, "W" ) ) > 0
+            if( only_primary_key == 0 )
+                " Find the create table statement
+                " let cmd = '/'.srch_create_table."\n"
+                " Find the opening ( that starts the column list
+                let cmd = 'normal! /('."\n".'Vib'."\<ESC>"
+                silent! exe cmd
+                " Decho 'end: '.getline(line("'>"))
+                let start_line = line("'<")
+                let end_line = line("'>")
+                silent! exe 'noh'
+                let found = 1
+                
+                " Visually select until the following keyword are the beginning
+                " of the line, this should be at the bottom of the column list
+                " Start visually selecting columns
+                " let cmd = 'silent! normal! V'."\n"
+                let find_end_of_cols = 
+                            \ '\(' .
+                            \ g:sqlutil_cmd_terminator .
+                            \ '\|' .
+                            \ substitute(
+                            \ g:sqlutil_col_list_terminators,
+                            \ ',', '\\|\1', 'g' ) .
+                            \ '\)' 
+                    
+                let separator = ""
+                let columns = ""
+
+                " Build comma separated list of input parameters
+                while start_line <= end_line
+                    let line = getline(start_line)
+
+                    " If the line has no words on it, skip it
+                    if line !~ '\w' || line =~ '^\s*$'
+                        let start_line = start_line + 1
+                        continue
+                    endif
+
+
+                    " if any of the find_end_of_cols is found, leave this loop.
+                    " This test is case insensitive.
+                    if line =~? '^\s*\w\+\s\+\w\+\s\+'.find_end_of_cols
+                        " Special case, the column name definition
+                        " is part of the line
+                    elseif line =~? find_end_of_cols
+                        let end_line = start_line - 1
+                        break
+                    endif
+
+                    let column_name = substitute( line, 
+                                \ '[ \t"]*\(\<\w\+\>\).*', '\1', "g" )
+                    let column_def = SQLU_GetColumnDatatype( line, 1 )
+
+                    let columns = columns . separator . add_alias . column_name
+                    let separator  = ", "
+                    let start_line = start_line + 1
+                endwhile
+
+            else
+                " Find the primary key statement
+                " Visually select all the text until the 
+                " closing paranthesis
+                silent! exe 'silent! normal! v/)/e-1'."\n".'"zy'
+                let columns = @z
+                " Strip newlines characters
+                let columns = substitute( columns, 
+                            \ "[\n]", '', "g" )
+                " Strip everything but the column list
+                let columns = substitute( columns, 
+                            \ '\s*\(.*\)\s*', '\1', "g" )
+                " Remove double quotes
+                let columns = substitute( columns, '"', '', "g" )
+                let columns = substitute( columns, ',\s*', ', ', "g" )
+                let columns = substitute( columns, '^\s*', '', "g" )
+                let columns = substitute( columns, '\s*$', '', "g" )
+                let found = 1
+                silent! exe 'noh'
+            endif
+
+        endif
+
+        " Return to previous location
+        silent! exe 'normal! '.buf_curline."G\<bar>".buf_curcol."l"
+
+        if found == 1
+            break
+        endif
+        
+        if &hidden == 0
+            call s:SQLU_WarningMsg(
+                        \ "Cannot search other buffers with set nohidden"
+                        \ )
+            break
+        endif
+
+        " Switch buffers to check to see if the create table
+        " statement exists
+        silent! exec "bnext"
+        if bufnr(expand("<abuf>")) == curbuf
+            break
+        endif
+    endwhile
+    
+    silent! exec "buffer " . curbuf
+
+    " Return to previous location
+    silent! exe 'normal! '.curline."G\<bar>".(curcol-1).(((curcol-1) > 0)?"l":'')
+    silent! exe 'noh'
+
+    " restore previous search
+    let @/ = saveSearch
+    let @z = saveZ
+
+    " Restore previous cpoptions
+    let &cpoptions = l:old_cpoptions
+
+
+    redraw
+
+    if found == 0
+        let @@ = ""
+        if( only_primary_key == 0 )
+            call s:SQLU_WarningMsg(
+                        \ "SQLU_CreateColumnList - Table: " .
+                        \ table_name . 
+                        \ " was not found"
+                        \ )
+        else
+            call s:SQLU_WarningMsg(
+                        \ "SQLU_CreateColumnList - Table: " .
+                        \ table_name . 
+                        \ " does not have a primary key"
+                        \ )
+        endif
+        return ""
+    endif 
+
+    " If clipboard is pointing to the windows clipboard
+    " copy the results there.
+    if &clipboard == 'unnamed'
+        let @* = columns 
+    else
+        let @@ = columns 
+    endif
+
+    echo "Paste register: " . columns
+
+    return columns
+
+endfunction
+
+
+" Strip the datatype from a column definition line
+function! SQLUtilities#SQLU_GetColumnDatatype( line, need_type )
+
+    let pattern = '\c^\s*'  " case insensitve, white space at start of line
+    let pattern = pattern . '\S\+\w\+[ "\t]\+' " non white space (name with 
+                                               " quotes)
+
+    if a:need_type == 1
+        let pattern = pattern . '\zs'    " Start matching the datatype
+        let pattern = pattern . '.\{-}'  " include anything
+        let pattern = pattern . '\ze\s*'    " Stop matching when ...
+        let pattern = pattern . '\(NOT\|NULL\|DEFAULT\|'
+        let pattern = pattern . '\(\s*,\s*$\)' " Line ends with a comma 
+        let pattern = pattern . '\)' 
+    else
+        let pattern = pattern . '\zs'   " Start matching the datatype
+        let pattern = pattern . '.\{-}' " include anything
+        let pattern = pattern . '\ze'   " Stop matching when ...
+        let pattern = pattern . '\s*,\s*$' " Line ends with a comma 
+    endif
+
+    let datatype = matchstr( a:line, pattern )
+
+    return datatype
+endfunction
+
+
+" Puts a comma separated list of columns given a table name
+" Will search through the file looking for the create table command
+" It assumes that each column is on a separate line
+" It places the column list in unnamed buffer
+function! SQLUtilities#SQLU_GetColumnDef( ... )
+
+    " Mark the current line to return to
+    let curline     = line(".")
+    let curcol      = virtcol(".")
+    let curbuf      = bufnr(expand("<abuf>"))
+    let found       = 0
+    
+    if(a:0 > 0) 
+        let col_name  = a:1
+    else
+        let col_name  = expand("<cword>")
+    endif
+
+    if(a:0 > 1) 
+        let need_type = a:2
+    else
+        let need_type = 0
+    endif
+
+    let srch_column_name = '^[ \t]*["]\?\<' . col_name . '\>["]\?\s\+\<\w\+\>'
+    let column_def = ""
+
+    " Loop through all currenly open buffers to look for the 
+    " CREATE TABLE statement, if found build the column list
+    " or display a message saying the table wasn't found
+    " I am assuming a create table statement is of this format
+    " CREATE TABLE "cons"."sync_params" (
+    "   "id"                            integer NOT NULL,
+    "   "last_sync"                     timestamp NULL,
+    "   "sync_required"                 char(1) NOT NULL DEFAULT 'N',
+    "   "retries"                       smallint NOT NULL ,
+    "   PRIMARY KEY ("id")
+    " );
+    while( 1==1 )
+        " Mark the current line to return to
+        let buf_curline     = line(".")
+        let buf_curcol      = virtcol(".")
+
+        " From the top of the file
+        silent! exe "normal! 1G\<bar>0\<bar>"
+
+        if( search( srch_column_name, "w" ) ) > 0
+            silent! exe 'noh'
+            let found = 1
+            let column_def = SQLU_GetColumnDatatype( getline("."), need_type )
+        endif
+
+        " Return to previous location
+        silent! exe 'normal! '.buf_curline."G\<bar>".buf_curcol."l"
+
+        if found == 1
+            break
+        endif
+        
+        if &hidden == 0
+            call s:SQLU_WarningMsg(
+                        \ "Cannot search other buffers with set nohidden"
+                        \ )
+            break
+        endif
+
+        " Switch buffers to check to see if the create table
+        " statement exists
+        silent! exec "bnext"
+        if bufnr(expand("<abuf>")) == curbuf
+            break
+        endif
+    endwhile
+    
+    silent! exec "buffer " . curbuf
+
+    " Return to previous location
+    silent! exe 'normal! '.curline."G\<bar>".curcol."l"
+
+    if found == 0
+        let @@ = ""
+        echo "Column: " . col_name . " was not found"
+        return ""
+    endif 
+
+    if &clipboard == 'unnamed'
+        let @* = column_def 
+    else
+        let @@ = column_def 
+    endif
+
+    " If a parameter has been passed, this means replace the 
+    " current word, with the column list
+    " if (a:0 > 0) && (found == 1)
+        " exec "silent! normal! viwp"
+        " if &clipboard == 'unnamed'
+            " let @* = col_name 
+        " else
+            " let @@ = col_name 
+        " endif
+        " echo "Paste register: " . col_name
+    " else
+        echo "Paste register: " . column_def
+    " endif
+
+    return column_def
+
+endfunction
+
+
+
+" Creates a procedure defintion into the unnamed buffer for the 
+" table that the cursor is currently under.
+function! SQLUtilities#SQLU_CreateProcedure(...)
+
+    " Mark the current line to return to
+    let curline     = line(".")
+    let curcol      = virtcol(".")
+    let curbuf      = bufnr(expand("<abuf>"))
+    let found       = 0
+    " save previous search string
+    let saveSearch=@/ 
+    " Prevent the alternate buffer (<C-^>) from being set to this
+    " temporary file
+    let l:old_cpoptions   = &cpoptions
+    let l:old_eventignore = &eventignore
+    setlocal cpo-=A
+    setlocal eventignore=BufRead,BufReadPre,BufEnter,BufNewFile
+
+    
+
+    if(a:0 > 0) 
+        let table_name  = a:1
+    else
+        let table_name  = expand("<cword>")
+    endif
+
+    let i = 0
+    let indent_spaces = ''
+    while( i < &shiftwidth )
+        let indent_spaces = indent_spaces . ' '
+        let i = i + 1
+    endwhile
+    
+    " ignore case
+    " let srch_create_table = '\c^[ \t]*create.*table.*\<' . table_name . '\>'
+    let srch_create_table = '\c^[ \t]*create.*table.*\<' . 
+                \ table_name . 
+                \ '\>'
+    let procedure_def = "CREATE PROCEDURE sp_" . table_name . "(\n"
+
+    " Loop through all currenly open buffers to look for the 
+    " CREATE TABLE statement, if found build the column list
+    " or display a message saying the table wasn't found
+    " I am assuming a create table statement is of this format
+    " CREATE TABLE "cons"."sync_params" (
+    "   "id"                            integer NOT NULL,
+    "   "last_sync"                     timestamp NULL,
+    "   "sync_required"                 char(1) NOT NULL DEFAULT 'N',
+    "   "retries"                       smallint NOT NULL,
+    "   PRIMARY KEY ("id")
+    " );
+    while( 1==1 )
+        " Mark the current line to return to
+        let buf_curline     = line(".")
+        let buf_curcol      = virtcol(".")
+
+        " From the top of the file
+        silent! exe "normal! 1G\<bar>0\<bar>"
+
+        if( search( srch_create_table, "w" ) ) > 0
+            " Find the create table statement
+            " let cmd = '/'.srch_create_table."\n"
+            " Find the opening ( that starts the column list
+            let cmd = 'normal! /('."\n".'Vib'."\<ESC>"
+            silent! exe cmd
+            " Decho 'end: '.getline(line("'>"))
+            let start_line = line("'<")
+            let end_line = line("'>")
+            silent! exe 'noh'
+            let found = 1
+            
+            " Visually select until the following keyword are the beginning
+            " of the line, this should be at the bottom of the column list
+            " Start visually selecting columns
+            " let cmd = 'silent! normal! V'."\n"
+            let find_end_of_cols = 
+                        \ '\(' .
+                        \ g:sqlutil_cmd_terminator .
+                        \ '\|' .
+                        \ substitute(
+                        \ g:sqlutil_col_list_terminators,
+                        \ ',', '\\|\1', 'g' ) .
+                        \ '\)' 
+                
+            let separator = " "
+            let column_list = ""
+
+            " Build comma separated list of input parameters
+            while start_line <= end_line
+                let line = getline(start_line)
+
+                " If the line has no words on it, skip it
+                if line !~ '\w' || line =~ '^\s*$'
+                    let start_line = start_line + 1
+                    continue
+                endif
+
+                " if any of the find_end_of_cols is found, leave this loop.
+                " This test is case insensitive.
+                if line =~? find_end_of_cols
+                    let end_line = start_line - 1
+                    break
+                endif
+
+                let column_name = substitute( line, 
+                            \ '[ \t"]*\(\<\w\+\>\).*', '\1', "g" )
+                let column_def = SQLU_GetColumnDatatype( line, 1 )
+
+                let column_list = column_list . separator . column_name
+                let procedure_def = procedure_def . 
+                            \ indent_spaces .
+                            \ separator .
+                            \ "IN @" . column_name .
+                            \ ' ' . column_def . "\n"
+
+                let separator  = ","
+                let start_line = start_line + 1
+            endwhile
+
+            let procedure_def = procedure_def .  ")\n"
+            let procedure_def = procedure_def . "RESULT(\n" 
+
+            let start_line = line("'<")
+            let separator  = " "
+            
+            " Build comma separated list of datatypes
+            while start_line <= end_line
+                let line = getline(start_line)
+                
+                " If the line has no words on it, skip it
+                if line !~ '\w' || line =~ '^\s*$'
+                    let start_line = start_line + 1
+                    continue
+                endif
+
+                let column_def = SQLU_GetColumnDatatype( line, 1 )
+                
+                let procedure_def = procedure_def .
+                            \ indent_spaces .
+                            \ separator . 
+                            \ column_def .
+                            \ "\n"
+
+                let separator  = ","
+                let start_line = start_line + 1
+            endwhile
+
+            let procedure_def = procedure_def .  ")\n"
+            " Strip off any spaces
+            let column_list = substitute( column_list, ' ', '', 'g' )
+            " Ensure there is one space after each ,
+            let column_list = substitute( column_list, ',', ', ', 'g' )
+            let save_tbl_alias = g:sqlutil_use_tbl_alias
+            " Disable the prompt for the table alias
+            let g:sqlutil_use_tbl_alias = 'n'
+            let pk_column_list = SQLU_CreateColumnList(
+                        \ table_name, 'primary_keys')
+            let g:sqlutil_use_tbl_alias = save_tbl_alias  
+
+            let procedure_def = procedure_def . "BEGIN\n\n" 
+            
+            " Create a sample SELECT statement
+            let procedure_def = procedure_def . 
+                        \ indent_spaces .
+                        \ "SELECT " . column_list . "\n" .
+                        \ indent_spaces .
+                        \ "  FROM " . table_name . "\n"
+            let where_clause = indent_spaces . 
+                        \ substitute( column_list, 
+                        \ '^\(\<\w\+\>\)\(.*\)', " WHERE \\1 = \@\\1\\2", "g" )
+            let where_clause = 
+                        \ substitute( where_clause, 
+                        \ ', \(\<\w\+\>\)', 
+                        \ "\n" . indent_spaces . "   AND \\1 = @\\1", "g" )
+            let procedure_def = procedure_def . where_clause . ";\n\n"
+
+            " Create a sample INSERT statement
+            let procedure_def = procedure_def . 
+                        \ indent_spaces . 
+                        \ "INSERT INTO " . table_name . "( " .
+                        \ column_list .
+                        \ " )\n"
+            let procedure_def = procedure_def . 
+                        \ indent_spaces .
+                        \ "VALUES( " .
+                        \ substitute( column_list, '\(\<\w\+\>\)', '@\1', "g" ).
+                        \ " );\n\n"
+
+            " Create a sample UPDATE statement
+            let procedure_def = procedure_def . 
+                        \ indent_spaces .
+                        \ "UPDATE " . table_name . "\n" 
+
+            " Now we must remove each of the columns in the pk_column_list
+            " from the column_list, to create the no_pk_column_list.  This is
+            " used by the UPDATE statement, since we do not SET columns in the
+            " primary key.
+            " The order of the columns in the pk_column_list is not guaranteed
+            " to be in the same order as the table list in the CREATE TABLE
+            " statement.  So we must remove each word one at a time.
+            let no_pk_column_list = SQLU_RemoveMatchingColumns(
+                        \ column_list, pk_column_list )
+
+            " Check for the special case where there is no 
+            " primary key for the table (ie ,\? \? )
+            let set_clause = 
+                        \ indent_spaces .
+                        \ substitute( no_pk_column_list, 
+                        \ ',\? \?\(\<\w\+\>\)', 
+                        \ '   SET \1 = @\1', '' )
+            let set_clause = 
+                        \ substitute( set_clause, 
+                        \ ', \(\<\w\+\>\)', 
+                        \ ",\n" . indent_spaces . '       \1 = @\1', "g" )
+
+            " Check for the special case where there is no 
+            " primary key for the table
+            if strlen(pk_column_list) > 0
+                let where_clause = 
+                            \ indent_spaces .
+                            \ substitute( pk_column_list, 
+                            \ '^\(\<\w\+\>\)', ' WHERE \1 = @\1', "" ) 
+                let where_clause = 
+                            \ substitute( where_clause, 
+                            \ ', \(\<\w\+\>\)', 
+                            \ "\n" . indent_spaces . '   AND \1 = @\1', "g" )
+            else
+                " If there is no primary key for the table place
+                " all columns in the WHERE clause
+                let where_clause = 
+                            \ indent_spaces .
+                            \ substitute( column_list, 
+                            \ '^\(\<\w\+\>\)', ' WHERE \1 = @\1', "" ) 
+                let where_clause = 
+                            \ substitute( where_clause, 
+                            \ ', \(\<\w\+\>\)', 
+                            \ "\n" . indent_spaces . '   AND \1 = @\1', "g" )
+            endif
+            let procedure_def = procedure_def . set_clause . "\n" 
+            let procedure_def = procedure_def . where_clause .  ";\n\n"
+
+            " Create a sample DELETE statement
+            let procedure_def = procedure_def . 
+                        \ indent_spaces .
+                        \ "DELETE FROM " . table_name . "\n" 
+            let procedure_def = procedure_def . where_clause . ";\n\n"
+
+            let procedure_def = procedure_def . "END;\n\n" 
+            
+        endif
+
+        " Return to previous location
+        silent! exe 'normal! '.buf_curline."G\<bar>".buf_curcol."l"
+
+        if found == 1
+            break
+        endif
+        
+        if &hidden == 0
+            call s:SQLU_WarningMsg(
+                        \ "Cannot search other buffers with set nohidden"
+                        \ )
+            break
+        endif
+
+        " Switch buffers to check to see if the create table
+        " statement exists
+        silent! exec "bnext"
+        if bufnr(expand("<abuf>")) == curbuf
+            break
+        endif
+    endwhile
+    
+    silent! exec "buffer " . curbuf
+
+    " restore previous search string
+    let @/ = saveSearch
+    " Restore previous cpoptions
+    let &cpoptions   = l:old_cpoptions
+    let &eventignore = l:old_eventignore
+
+    
+    " Return to previous location
+    silent! exe 'normal! '.curline."G\<bar>".curcol."l"
+
+    if found == 0
+        let @@ = ""
+        echo "Table: " . table_name . " was not found"
+        return ""
+    endif 
+
+    echo 'Procedure: sp_' . table_name . ' in unnamed buffer'
+    if &clipboard == 'unnamed'
+        let @* = procedure_def 
+    else
+        let @@ = procedure_def 
+    endif
+
+    return ""
+
+endfunction
+
+
+
+" Compares two strings, and will remove all names from the first 
+" parameter, if the same name exists in the second column name.
+" The 2 parameters take comma separated lists
+function! SQLUtilities#SQLU_RemoveMatchingColumns( full_col_list, dup_col_list )
+
+    let stripped_col_list = a:full_col_list
+    let pos = 0
+    " Find the string index position of the first match
+    let index = match( a:dup_col_list, '\w\+' )
+    while index > -1
+        " Get name of column
+        let dup_col_name = matchstr( a:dup_col_list, '\w\+', index )
+        let stripped_col_list = substitute( stripped_col_list,
+                    \ dup_col_name.'[, ]*', '', 'g' )
+        " Advance the search after the word we just found and look for
+        " others.  
+        let index = match( a:dup_col_list, '\w\+', 
+                    \ index + strlen(dup_col_name) )
+    endwhile
+
+    return stripped_col_list
+
+endfunction
+
+function! s:SQLU_WarningMsg(msg) "{{{
+    echohl WarningMsg
+    echomsg a:msg
+    echohl None
+endfunction "}}}
+
+let &cpo = s:cpo_save
+unlet s:cpo_save
+
+" vim:fdm=marker:nowrap:ts=4:expandtab:ff=unix:
diff --git a/vimrc/.vim/bundle/SQLUtilities/doc/SQLUtilities.txt b/vimrc/.vim/bundle/SQLUtilities/doc/SQLUtilities.txt
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/bundle/SQLUtilities/doc/SQLUtilities.txt
@@ -0,0 +1,1062 @@
+*SQLUtilities.txt*      For Vim version 7.0. 
+
+Author:	        David Fishburn                             October 10, 2012
+
+SQLUtilities:   Variety of tools for working with SQL
+Version:        6.0.0
+Homepage:       http://www.vim.org/scripts/script.php?script_id=492
+Feedback:	    David Fishburn <dfishburn dot vim at gmail dot com>
+
+For instructions on installing this file, type
+	:help add-local-help |add-local-help| inside Vim.
+
+
+==============================================================================
+1. Contents                                      *sqlutil* *sqlutil-contents*
+
+    1. Contents...............................: |sqlutil-contents|
+    2. Tutorial...............................: |sqlutil-tutorial|
+    3. Commands...............................: |sqlutil-commands|
+       3.1 SQLUFormatter......................: |sqlutil-formatter|
+           3.1.1 Formatting Examples..........: |sqlutil-examples|
+           3.1.2 Formatting Options...........: |sqlutil-format-options|
+                 3.1.2.1 Align Where Clause...: |sqlutil-align-where|
+                 3.1.2.2 Align Comma..........: |sqlutil-align-comma|
+                 3.1.2.3 Align First Word.....: |sqlutil-align-first-word|
+                 3.1.2.4 Align Keyword Right..: |sqlutil-align-keyword-right|
+                 3.1.2.5 Change Keyword Case..: |sqlutil-change_keyword-case|
+       3.2 SQLUCreateColumnList...............: |sqlutil-column-list|
+       3.3 SQLUGetColumnDef...................: |sqlutil-column-definition|
+           SQLUGetColumnDataType..............: |sqlutil-column-datatype|
+       3.4 SQLUCreateProcedure................: |sqlutil-procedure|
+    4. Suggested Mappings.....................: |sqlutil-mappings|
+    5. Global Options.........................: |sqlutil-options|
+    6. Customization..........................: |sqlutil-customization|
+        6.1 Cmd Terminator....................: |sqlutil-customization|
+        6.2 Vim Menu..........................: |sqlutil-customization|
+        6.3 Vim's Syntax Support..............: |sqlutil-customization|
+    7. History................................: |sqlutil-history|
+    8. Dependencies...........................: |sqlutil-dependencies|
+    9. Complementary Plugins..................: |sqlutil-complementary-plugins|
+    10.TODO...................................: |sqlutil-todo|
+
+
+==============================================================================
+2. Tutorial                                      *sqlutil-tutorial*
+
+My most used command is the formatting capability of SQLUtil.  Please
+ensure the Align.vim plugin has already been installed see
+|sqlutil-dependencies|.
+
+Section 3 covers each command in detail, but to use these commands you can 
+do the following.  Assume you have a SQL statement you would like to 
+be formatted. >
+    SELECT t1.c1, t1.c2, t1.c3, t2.column1, t2.column2 
+    FROM t1 JOIN t2 WHERE t1.c1 = 'hello'
+    AND t2.column2 = 'goodbye';
+
+There are several ways to format this statement.
+
+    1.  Start |visual-mode| using any of the modes (i.e. v, V or CTRL-V),
+        highlight the 2 lines and (assuming the default |<Leader>|) you can 
+        use the visual map: >
+            \sf (sql - format).
+<
+    2.  Start |visual-mode| using any of the modes (i.e. v, V or CTRL-V),
+        highlight the 2 lines and run the SQLUFormatter command: >
+            :'<,'>SQLUFormatter
+<            
+    3.  If using Vim in GUI mode, the plugin provides a menu to make accessing
+        the commands easier.  It also shows the mapping, to assist with 
+        remembering them.  After visually selecting the lines you can 
+        use the (default) menu as: >
+            Plugin->SQLUtil->Format Statement
+<            
+    4.  Specify the range of lines and run the SQLUFormatter command: >
+            :1,2SQLUFormatter
+<
+The default settings produce a formatted statement as: >
+    SELECT t1.c1, t1.c2, t1.c3, t2.column1, t2.column2
+      FROM t1
+      JOIN t2
+     WHERE t1.c1      = 'hello'
+       AND t2.column2 = 'goodbye';
+<
+Using the menu Plugin -> SQLUtil -> Toggle Align Where and reformat the
+statement: >
+    SELECT t1.c1, t1.c2, t1.c3, t2.column1, t2.column2
+      FROM t1
+      JOIN t2
+     WHERE t1.c1 = 'hello'
+       AND t2.column2 = 'goodbye';
+<
+Using the menu Plugin -> SQLUtil -> Toggle Right Align Keywords and 
+reformat the statement: >
+    SELECT t1.c1, t1.c2, t1.c3, t2.column1, t2.column2
+    FROM   t1
+    JOIN   t2
+    WHERE  t1.c1 = 'hello'
+    AND    t2.column2 = 'goodbye';
+<    
+Using the menu Plugin -> SQLUtil -> Toggle Align Comma and retoggle
+Plugin -> SQLUtil -> Toggle Right Align Keywords and reformat the
+statement: >
+    SELECT t1.c1
+         , t1.c2
+         , t1.c3
+         , t2.column1
+         , t2.column2
+      FROM t1
+      JOIN t2
+     WHERE t1.c1 = 'hello'
+       AND t2.column2 = 'goodbye';
+<    
+Using the menu Plugin -> SQLUtil -> Lowercase Keywords and reformat the
+statement: >
+    select t1.c1, t1.c2, t1.c3, t2.column1, t2.column2
+      from t1
+      join t2
+     where t1.c1 = 'hello'
+       and t2.column2 = 'goodbye';
+<
+Since there are many options to control how the statement is formatted, these 
+can be set from the command line (though it is easier using the menus): >
+    let g:sqlutil_align_where = 1
+    let g:sqlutil_<tab> to cycle through the various option names.
+<
+These features are much more easily set via the menu, which does a number of 
+things for you:
+    1.  Allows you to toggle the setting of the options.
+    2.  Does not require you to remember the option names.
+    3.  Shows the current setting of each of the options.
+
+The remaining commands all rely upon have the CREATE TABLE statements open 
+in Vim (either in the same buffer or a different one) and will work 
+over those statements: >
+    SQLUCreateColumnList
+    SQLUGetColumnDef
+    SQLUGetColumnDataType
+    SQLUCreateProcedure
+
+Each of these statements work on the current word the cursor is on.
+So if the cursor is on the "t1" word in the above SQL statement 
+the you can either use the command:
+    :SQLUCreateColumnList
+or 
+    \scl 
+
+See below for more information in the mappings.
+
+
+If you do not have the CREATE TABLE statements handy in a SQL file, the 
+dbext plugin (which I also author) can pull this information directly from 
+within the database.  So typically, I only use this plugin to format 
+SQL statements and use the dbext plugin to execute statement against a 
+database.  See |sqlutil-complementary-plugins| for more details.
+
+
+==============================================================================
+3. Commands                                      *sqlutil-commands*
+
+3.1 SQLUFormatter                                *sqlutil-formatter*
+
+  [range]SQLUFormatter(..list..)                
+
+       - Formats one statement at a time, this is not meant to be
+         an indenter for SQL files.
+       - Reformats the SQL statements over the specified range.  
+       - Statement will lined up given the existing indent of the first word.
+       - Formats SQL statements into a easily readable form.
+       - Breaks keywords onto new lines.
+       - Forces column lists to be split over as many lines as
+         necessary to fit the current textwidth of the buffer,
+         so that lines do not wrap.
+       - If parentheses are unbalanced (ie a subselect) it will
+         indent everything within the unbalanced parenthesis.
+       - Works for SELECT, INSERT, UPDATE, DELETE statements.
+
+3.1.1 Formatting Examples:                       *sqlutil-examples*
+
+    Original: >
+    SELECT m.MSG_ID, m.PRIORITY_ID, CUST.CUST_NBR, CUST.CUST_NM, 
+    CUST.CUST_LEGAL_NM, CUST.STORE_ADDR_1, CUST.STORE_ADDR_2, 
+    CUST.CROSS_STREET, XMLELEMENT( 'Alerts', XMLELEMENT( 'Alert_alert_id', 
+    alert_id ), XMLELEMENT( 'Alert_agent_id', agent_id ), XMLELEMENT( 
+    'Alert_alert_type_id', alert_type_desc), XMLELEMENT( 
+    'Alert_alert_date', alert_date), XMLELEMENT( 
+    'Alert_url_reference', url_reference), XMLELEMENT( 
+    'Alert_read_status', read_status )) CUST.STORE_CITY, 
+    CUST.STORE_ST, CUST.POST_CODE, CUST.STORE_MGR_NM, FROM MESSAGES m JOIN 
+    PRIORITY_CD P WHERE m.to_person_id = ?  AND p.NAME = 'PRI_EMERGENCY' AND 
+    p.JOB = 'Plumber' AND m.status_id < ( SELECT s.STATUS_ID FROM 
+    MSG_STATUS_CD s WHERE s.NAME = 'MSG_READ') ORDER BY m.msg_id desc
+<    
+
+  Formatted: >
+    SELECT m.MSG_ID, m.PRIORITY_ID, CUST.CUST_NBR, CUST.CUST_NM,
+           CUST.CUST_LEGAL_NM, CUST.STORE_ADDR_1, CUST.STORE_ADDR_2,
+           CUST.CROSS_STREET,
+           XMLELEMENT(
+               'Alerts', XMLELEMENT( 'Alert_alert_id', alert_id ),
+               XMLELEMENT( 'Alert_agent_id', agent_id ),
+               XMLELEMENT( 'Alert_alert_type_id', alert_type_desc),
+               XMLELEMENT( 'Alert_alert_date', alert_date),
+               XMLELEMENT(
+                   'Alert_url_reference', url_reference
+                ), XMLELEMENT( 'Alert_read_status', read_status )
+           ) CUST.STORE_CITY, CUST.STORE_ST, CUST.POST_CODE, 
+           CUST.STORE_MGR_NM
+      FROM MESSAGES m
+      JOIN PRIORITY_CD P
+     WHERE m.to_person_id = ?
+       AND p.NAME = 'PRI_EMERGENCY'
+       AND p.JOB = 'Plumber'
+       AND m.status_id < (
+            SELECT s.STATUS_ID
+              FROM MSG_STATUS_CD s
+             WHERE s.NAME = 'MSG_READ'
+           )
+     ORDER BY m.msg_id desc
+<    
+    
+
+  Original: >
+    UPDATE "SERVICE_REQUEST" SET "BUILDING_ID" = ?, "UNIT_ID" = ?, 
+    "REASON_ID" = ?, "PERSON_ID" = ?, "PRIORITY_ID" = ?, "STATUS_ID" = ?, 
+    "CREATED" = ?, "REQUESTED" = ?, "ARRIVED" = ?  WHERE "REQUEST_ID" = ?
+<
+
+  Formatted: >
+    UPDATE "SERVICE_REQUEST"
+       SET "BUILDING_ID" = ?,
+           "UNIT_ID" = ?,
+           "REASON_ID" = ?,
+           "PERSON_ID" = ?,
+           "PRIORITY_ID" = ?,
+           "STATUS_ID" = ?,
+           "CREATED" = ?,
+           "REQUESTED" = ?,
+           "ARRIVED" = ?,
+     WHERE "REQUEST_ID"  = ?
+<
+
+
+  Original: >
+    INSERT INTO "MESSAGES" ( "MSG_ID", "TO_PERSON_ID", 
+    "FROM_PERSON_ID", "REQUEST_ID", "CREATED", "PRIORITY_ID", 
+    "MSG_TYPE_ID", "STATUS_ID", "READ_WHEN", "TIMEOUT", 
+    "MSG_TXT", "RESEND_COUNT" ) VALUES ( ?, ?, ?, 
+    ?, ?, ?, ?, ?, ?, ?, ?, ? )
+<
+
+  Formatted: >
+    INSERT INTO "MESSAGES" ( "MSG_ID", "TO_PERSON_ID",
+           "FROM_PERSON_ID", "REQUEST_ID", "CREATED",
+           "PRIORITY_ID", "MSG_TYPE_ID", "STATUS_ID",
+           "READ_WHEN", "TIMEOUT", "MSG_TXT", "RESEND_COUNT" )
+    VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )
+<
+
+
+3.1.2 Formatting Options                         *sqlutil-format-options*
+
+  There are several options which can control how the SQL statements are
+  formatted.
+  
+3.1.2.1 Align Where Clause                       *sqlutil-align-where*
+
+  sqlutil_align_where is used to align operators. Valid operators are: 
+       =, =, >, <, >=, <=, !=, !<, !>, <> 
+  This option is "ON" by default.  When formatting SQL statements with many 
+  nested statements, the results can shifted too much.  You can disable it,
+  format the statement and enable it again afterwards: >
+       let g:sqlutil_align_where = 1
+
+       SELECT CategoryID, CategoryName, CategorySystemName, (
+               SELECT B.CATEGORYID CATID
+                 FROM CATEGORY
+                WHERE B.CATEGORYID      =  intCategoryID
+                  AND B.REVIDDFD        =  intRevID
+                  AND B.REVID           >  intRevID
+                  AND B.REVIDDFDSDSF    <  intRevID
+                  AND B.REVIDDFD        >= intRevID
+                  AND B.REVIDD          <= intRevID
+                  AND B.REVIDLLKKKK     != intRevID
+                  AND B.REVIDK          !< intRevID
+                  AND B.REVIDDD         !> intRevID
+                  AND B.REV             <> intRevID
+                  AND B.DEL             =  0
+                UNION ALL
+               SELECT B.CATEGORYID
+                 FROM CATEGORYHDR B
+                WHERE intCategoryID IS NULL
+              ) tmp
+        WHERE TMP.CATID         =  PCat.CategoryID
+          AND PCat.RevID        =  intRevID
+          AND P.RevID           =  PCat.RevID
+          AND CATHDR.CATEGORYID =  PCAT.CATEGORYID
+<
+
+  To disable: >
+       let g:sqlutil_align_where = 0
+
+       SELECT CategoryID, CategoryName, CategorySystemName, (
+               SELECT B.CATEGORYID CATID
+                 FROM CATEGORY
+                WHERE B.CATEGORYID = intCategoryID
+                  AND B.REVIDDFD = intRevID
+                  AND B.REVID > intRevID
+                  AND B.REVIDDFDSDSF < intRevID
+                  AND B.REVIDDFD >= intRevID
+                  AND B.REVIDD <= intRevID
+                  AND B.REVIDLLKKKK != intRevID
+                  AND B.REVIDK !< intRevID
+                  AND B.REVIDDD !> intRevID
+                  AND B.REV <> intRevID
+                  AND B.DEL = 0
+                UNION ALL
+               SELECT B.CATEGORYID
+                 FROM CATEGORYHDR B
+                WHERE intCategoryID IS NULL
+              ) tmp
+        WHERE TMP.CATID = PCat.CategoryID
+          AND PCat.RevID = intRevID
+          AND P.RevID = PCat.RevID
+          AND CATHDR.CATEGORYID = PCAT.CATEGORYID
+<
+
+3.1.2.2 Align Comma                              *sqlutil-align-comma*
+
+  sqlutil_align_comma is used to force each column in a column list to be
+  placed on a new line.  The SET statement in a UPDATE clause already 
+  does this by default.
+  This option is "OFF" by default. >
+       let g:sqlutil_align_comma = 0
+
+       SELECT PK_BranchID, PK_ItemID, FK_VaultID, FK_ItemType,
+              ItemBarCode, FK_CommodityType, FK_CommodityTypeCode,
+              ItemQuantity, ItemSealNumber, FK_ItemDenominationType,
+              ItemSaidToContain, ItemNotes, FK_PackageDeliveryLocationID,
+              FK_PackagePickupLocationID, FK_ItemParentID
+         FROM some_table
+<
+
+  To enable: >
+       let g:sqlutil_align_comma = 1
+
+       SELECT PK_BranchID
+            , PK_ItemID
+            , FK_VaultID
+            , FK_ItemType
+            , ItemBarCode
+            , FK_CommodityType
+            , FK_CommodityTypeCode
+            , ItemQuantity
+            , ItemSealNumber
+            , FK_ItemDenominationType
+            , ItemSaidToContain
+            , ItemNotes
+            , FK_PackageDeliveryLocationID
+            , FK_PackagePickupLocationID
+            , FK_ItemParentID
+         FROM some_table
+<
+
+3.1.2.3 Align First Word                         *sqlutil-align-first-word*
+
+  sqlutil_align_first_word is used to control how the keywords are 
+  aligned when formatting.  The default behaviour is the keywords
+  are RIGHT justified on the first word of the phrase.  So for an
+  ORDER BY statement the keywords are aligned between the ORDER and the 
+  BY words.  
+  This option is "ON" by default. >
+       let g:sqlutil_align_first_word = 1
+
+       SELECT CategoryID
+            , CategoryName
+            , CategorySystemName
+            , (
+               SELECT B.CATEGORYID CATID
+                 FROM CATEGORY B
+                START WITH B.CATEGORYID     = intCategoryID
+                  AND B.REVID               = intRevID
+                  AND B.DEL                 = 0
+              CONNECT BY PRIOR B.CATEGORYID = B.PARENTCATEGORYID
+                  AND B.REVID               = intRevID
+                  AND B.DEL                 = 0
+                UNION ALL
+               SELECT B.CATEGORYID
+                 FROM CATEGORYHDR B
+                WHERE intCategoryID IS NULL
+              ) tmp
+        WHERE TMP.CATID             = PCat.CategoryID
+          AND PCat.RevID            = intRevID
+          AND P.RevID               = PCat.RevID
+          AND CATHDR.CATEGORYID     = PCAT.CATEGORYID
+        ORDER BY CategoryID
+<
+
+  To disable: >
+       let g:sqlutil_align_first_word = 0
+
+          SELECT CategoryID
+               , CategoryName
+               , CategorySystemName
+               , (
+                  SELECT B.CATEGORYID CATID
+                    FROM CATEGORY B
+              START WITH B.CATEGORYID      = intCategoryID
+                     AND B.REVID           = intRevID
+                     AND B.DEL             = 0
+        CONNECT BY PRIOR B.CATEGORYID      = B.PARENTCATEGORYID
+                     AND B.REVID           = intRevID
+                     AND B.DEL             = 0
+               UNION ALL 
+                  SELECT B.CATEGORYID
+                    FROM CATEGORYHDR B
+                   WHERE intCategoryID IS NULL
+                 ) tmp
+           WHERE TMP.CATID         = PCat.CategoryID
+             AND PCat.RevID        = intRevID
+             AND P.RevID           = PCat.RevID
+             AND CATHDR.CATEGORYID = PCAT.CATEGORYID
+        ORDER BY CategoryID
+<
+
+3.1.2.4 Align Keyword Right                     *sqlutil-align-keyword-right*
+
+  sqlutil_align_keyword_right is used to control how the keywords are 
+  aligned when formatting.  The default behaviour is the keywords
+  are RIGHT justified on the first keyword.  This option allows you to
+  choose whether the keywords are left or right justified.
+  This option is "1" by default. >
+       let g:sqlutil_align_keyword_right = 1
+
+           SELECT B.CATEGORYID CATID
+             FROM CATEGORY B
+            WHERE B.CATEGORYID     = intCategoryID
+              AND B.REVID          = intRevID
+              AND B.DEL            = 0
+<
+
+  To toggle: >
+       let g:sqlutil_align_keyword_right = 0
+
+           SELECT B.CATEGORYID CATID
+           FROM   CATEGORY B
+           WHERE  B.CATEGORYID     = intCategoryID
+           AND    B.REVID          = intRevID
+           AND    B.DEL            = 0
+<
+
+3.1.2.5 Change Keyword Case                      *sqlutil-change_keyword-case*
+
+  sqlutil_keyword_case is used to control if the case of the keywords
+  should be changed when formatting.  This option uses Vim's standard 
+  regular expression syntax |/\l| to control its' behaviour.  
+  The default is to leave the cAsE aS Is.  Assume the first query
+  below is our original statement: >
+       let g:sqlutil_keyword_case = ''
+
+       select CategoryID, CategoryName, CategorySystemName
+        WHERE TMP.CATID         = PCat.CategoryID
+          and PCat.RevID        = intRevID
+          aND P.RevID           = PCat.RevID
+          and CATHDR.CATEGORYID = PCAT.CATEGORYID
+          
+
+       let g:sqlutil_keyword_case = '\U'
+
+       SELECT CategoryID, CategoryName, CategorySystemName
+        WHERE TMP.CATID         =  PCat.CategoryID
+          AND PCat.RevID        =  intRevID
+          AND P.RevID           =  PCat.RevID
+          AND CATHDR.CATEGORYID =  PCAT.CATEGORYID
+
+          
+       let g:sqlutil_keyword_case = '\L'
+
+       select CategoryID, CategoryName, CategorySystemName
+        where TMP.CATID = PCat.CategoryID
+          and PCat.RevID = intRevID
+          and P.RevID = PCat.RevID
+          and CATHDR.CATEGORYID = PCAT.CATEGORYID
+
+          
+       let g:sqlutil_keyword_case = '\u'
+
+       Select CategoryID, CategoryName, CategorySystemName
+        WHERE TMP.CATID = PCat.CategoryID
+          And PCat.RevID = intRevID
+          AND P.RevID = PCat.RevID
+          And CATHDR.CATEGORYID = PCAT.CATEGORYID
+
+          
+       let g:sqlutil_keyword_case = '\l'
+
+       select CategoryID, CategoryName, CategorySystemName
+        wHERE TMP.CATID = PCat.CategoryID
+          and PCat.RevID = intRevID
+          aND P.RevID = PCat.RevID
+          and CATHDR.CATEGORYID = PCAT.CATEGORYID
+
+
+3.2 SQLUCreateColumnList                         *sqlutil-column-list*
+
+  SQLUCreateColumnList( optional parameter(s) )
+
+  Creates a comma separated list of column names for the table name under the
+  cursor, assuming the table definition exists in any open buffer.  The column
+  list is placed in the unnamed buffer.  Be default, an alias is added to 
+  the column list (new to version 1.3.7).
+
+  To determine where a statement ends the g:sqlutil_cmd_terminator is used.
+  This is true for the CREATE TABLE statement, and the ALTER TABLE 
+  statements.
+
+  Normally this command is run by placing your cursor anywhere on the 
+  table name and using the mapping <Leader>scl (or \scl).  The paste
+  buffer contains the column list, and a message is displayed.
+
+  You can also call this from the Vim command line, this function optionally
+  takes 3 parameters: >
+       SQLUCreateColumnList T1 
+<            Creates a column list for T1
+>
+       SQLUCreateColumnList T1 1
+<            Creates a column list for T1 but only for the primary keys for
+             that table.
+>
+       SQLUCreateColumnList T1 0 alias_name
+<            Creates a column list for T1 add appends the supplied 
+             alias_name to each column.
+
+   Assumes either the current file, or any other open buffer, has a CREATE
+   TABLE statement in a format similar to this: >
+       CREATE TABLE customer_list (
+            id	           INT DEFAULT AUTOINCREMENT,
+            last_modified  TIMESTAMP NULL,
+            first_name     VARCHAR(30) NOT NULL,
+            last_name	   VARCHAR(60) NOT NULL,
+            balance	        NUMERIC(10,2),
+            PRIMARY KEY( id )
+       );
+<       
+  If you place the cursor on the word customer, then the unnamed buffer (also
+  displayed by an echo statement) will contain: >
+       cl.id, cl.last_modified, cl.first_name, cl.last_name, cl.balance
+<
+  The table alias has several options / features and is controlled by: >
+       let g:sqlutil_use_tbl_alias = 'd|a|n'
+<
+  Here are the meaning of each setting: >
+       d - Use the default
+       a - Calculate an alias, and prompt the user to override
+       n - Do not use table aliases
+<
+  An alias is determined following a few rules:
+       1.  If the table name has an '_', then use it as a separator: >
+           MY_TABLE_NAME --> MTN
+           my_table_name --> mtn
+           My_table_NAME --> MtN
+<      2.  If the table name does NOT contain a '_', but DOES use 
+           mixed case then the case is used as a separator: >
+           MyTableName --> MTN
+<      3.  If the table name does NOT contain a '_', and does NOT use 
+           mixed case then the first letter of the table is used: >
+           mytablename --> m
+           MYTABLENAME --> M
+<
+  This also uses the g:sqlutil_cmd_terminator to determine when the create
+  table statement ends if none of the following terms (these are the defaults)
+  are found before the final ");". >
+       primary key,reference,unique,check,constraint, [not null] foreign
+< sqlutil_cmd_terminator defaults to ";"
+
+  When building a column list from a script file (ie CREATE TABLE statements),
+  you can customize the script to detect when the column list finishes by
+  creating the following in your |vimrc|: >
+       let g:sqlutil_col_list_terminators = 
+                         \ 'primary,reference,unique,check,foreign'
+<
+  This is necessary to determine where the list of columns finishes and 
+  when the list of table keywords begin in the following examples: >
+       CREATE TABLE customer (
+          id           INT DEFAULT AUTOINCREMENT,
+          first_name   VARCHAR(30) NOT NULL,
+          last_name    VARCHAR(60) NOT NULL,
+          PRIMARY KEY( id )
+       ); 
+
+       CREATE TABLE contact (
+          id           INT DEFAULT AUTOINCREMENT,
+          cust_        INT NOT NULL,
+          first_name   VARCHAR(30) NOT NULL,
+          last_name    VARCHAR(60) NOT NULL,
+          CHECK( id > 0 )
+          FOREIGN KEY fk_customer ( cust_id ) 
+          REFERENCES customer(id)
+          PRIMARY KEY( id )
+       ); 
+<
+
+3.3 SQLUGetColumnDef                             *sqlutil-column-definition*
+    SQLUGetColumnDataType                        *sqlutil-column-datatype*
+
+  SQLUGetColumnDef( optional parameter )           
+  SQLUGetColumnDataType( expand("<cword>"), 1 )
+
+  Assumes either the current file, or any other open buffer, has a CREATE TABLE
+  statement in a format similar to this: >
+
+       CREATE TABLE customer (
+           id	           INT DEFAULT AUTOINCREMENT,
+           last_modified   TIMESTAMP NULL,
+           first_name      VARCHAR(30) NOT NULL,
+           last_name	   VARCHAR(60) NOT NULL,
+           balance	       NUMERIC(10,2),
+           PRIMARY KEY( id )
+       );
+<
+  |hidden| must be enabled for this plugin to cycle through other open 
+  buffers.  If you place the cursor on the word first_name, then the column
+  definition will be placed in the unnamed buffer (and also displayed by an
+  echo statement). >
+       VARCHAR(30) NOT NULL        
+<
+  If the command is called as SQLUGetColumnDef( expand("<cword>"), 1 ) or using
+  the default mapping <Leader>scdt, just the datatype (instead of the column
+  definition) will be returned.  A separate command SQLUGetColumnDataType has
+  been created for this. >
+       VARCHAR(30) 
+<
+
+
+3.4 SQLUCreateProcedure()                        *sqlutil-procedure*
+
+  SQLUCreateProcedure()
+
+  Creates a stored procedure that performs standard operations (SELECT, 
+  INSERT, UPDATE, DELETE) against the table that the cursor is currently under.
+  Once the procedure has been pasted into the buffer, the unwanted statements
+  can be removed.
+
+  Assumes either the current file, or any other open buffer, has a CREATE TABLE
+  statement in a format similar to this: >
+
+       CREATE TABLE customer (
+           id	           INT DEFAULT AUTOINCREMENT,
+           last_modified   TIMESTAMP NULL,
+           first_name      VARCHAR(30) NOT NULL,
+           last_name	   VARCHAR(60) NOT NULL,
+           balance	       NUMERIC(10,2),
+           PRIMARY KEY( id )
+       );
+<       
+  |hidden| must be enabled for this plugin to cycle through other open 
+  buffers.  
+
+
+==============================================================================
+4. Suggested Mappings:                           *sqlutil-mappings*
+
+  vmap <leader>sf        <Plug>SQLU_Formatter<CR>
+  nmap <leader>scl       <Plug>SQLU_CreateColumnList<CR>
+  nmap <leader>scd       <Plug>SQLU_GetColumnDef<CR>
+  nmap <leader>scdt      <Plug>SQLU_GetColumnDataType<CR>
+  nmap <leader>scp       <Plug>SQLU_CreateProcedure<CR>
+
+  mnemonic explanation
+     s - sql
+         f   - format
+         cl  - column list
+         cd  - column definition
+         cdt - column datatype
+         cp  - create procedure
+
+  To prevent the default mappings from being created, place the following in
+  your |vimrc|:
+          let g:sqlutil_load_default_maps = 0
+
+
+==============================================================================
+5. Global Options                                *sqlutil-options*
+
+  Many defaults for the SQLUtilities plugin can be enabled or disabled or 
+  customized via entries in your .vimrc.  Here is a list of all options used 
+  by the plugin and a brief description of what it does.  A more complete
+  example of how to use this option can be found through the doc (if worthy) 
+  so just search for it.
+
+  Many of these options can be controlled via the SQLUtil menu, which is often 
+  far more convienent that tweaking these variables.
+
+  Global variables: >
+    sqlutil_align_where
+<       - See |sqlutil-align-where|
+        - Default: 1 >
+        let g:sqlutil_align_where = 1
+    sqlutil_align_comma
+<       - See |sqlutil-align-comma|
+        - Default: 0 >
+        let g:sqlutil_align_comma = 0
+    sqlutil_align_first_word
+<       - See |sqlutil-align-first-word|
+        - Default: 0 >
+        let g:sqlutil_align_first_word = 0
+    sqlutil_align_keyword_right
+<       - See |sqlutil-align-keyword-right|
+        - Default: 1 >
+        let g:sqlutil_align_keyword_right = 1
+    sqlutil_wrap_expressions
+<       - By default, when formatting a statement if a column is an expression 
+          or function call which is very long, break it apart and indent 
+          portions of it to make it clear.
+        - Default: 0 >
+        let g:sqlutil_wrap_expressions = 0
+    sqlutil_cmd_terminator
+<       - Certain SQL statements require cmd terminators.  Different databases
+          have different defaults.  This is important when parsing SQL files.
+        - Default: ';' >
+        let g:sqlutil_cmd_terminator = ';'
+        let g:sqlutil_cmd_terminator = "\ngo\n"
+    sqlutil_stmt_keywords
+<       - Used by the SQLUFormatter command to determine which SQL statements 
+          to format.
+        - Default: 'select,insert,update,delete,with,merge' >
+        let g:sqlutil_stmt_keywords = 'select,insert,update,delete,with,merge'
+    sqlutil_keyword_case
+<       - See |sqlutil-change_keyword-case|
+        - Default: '' >
+        let g:sqlutil_keyword_case = ''
+    sqlutil_use_tbl_alias
+<       - See |sqlutil-column-list|
+        - Default: 'a' >
+        let g:sqlutil_use_tbl_alias = 'a'
+    g:sqlutil_use_syntax_support
+<       - See |sqlutil-customization||
+        - Default: 1 >
+        let g:g:sqlutil_use_syntax_support = 1
+    sqlutil_syntax_elements
+<       - See |sqlutil-column-list|
+        - Default: 'Constant,sqlString' >
+        let g:sqlutil_syntax_elements = 'Constant,sqlString'
+    sqlutil_col_list_terminators
+<       - See |sqlutil-change_keyword-case| >
+        let g:sqlutil_col_list_terminators = 
+                    \ 'primary\s\+key.*(' .
+                    \ ',references' .
+                    \ ',match' .
+                    \ ',unique' .
+                    \ ',check' .
+                    \ ',constraint' .
+                    \ ',\%(not\s\+null\s\+\)\?foreign'
+    sqlutil_load_default_maps
+<       - See |sqlutil-mappings|
+        - Default: 1 >
+        let g:sqlutil_load_default_maps = 1
+    sqlutil_default_menu_mode
+<       - See |sqlutil-customization|
+        - Default: 3 >
+        let g:sqlutil_default_menu_mode = 3
+
+==============================================================================
+6. Customization                                 *sqlutil-customization*
+
+6.1 Cmd Terminator
+
+  By default this script assumes a command is terminated by a ; If you are
+  using Microsoft SQL Server a command terminator would be "go", or perhaps
+  "\ngo".
+
+  To permanently override the terminator in your |vimrc| file you can add
+  (note: using double quotes is necessary when using \n): >
+            let g:sqlutil_cmd_terminator = "\ngo"
+<
+6.2 Vim Menu
+
+  By default a menu is created under the Plugin menu.  Menus are useful for a
+  number of reasons:
+        - See a list of available commands
+        - Remember what the shortcut maps are
+        - Have a floating menu when using the plugin a lot
+        - Allow you to quickly and easily toggle various formatting
+          options on a per statement basis.  Especially useful when
+          used with the floating menu.
+        - Quick reference guide
+  
+  You have several choices on where to place the menu.  There are four
+  settings that will control the placement of the menu: 
+        "0": Turns the menu off.
+        "1": Turns the 'SQLUtil' menu on with no menu shortcut.
+        "2": Turns the 'SQLUtil 'menu on with <alt>-d as the shortcut.
+        "3": Turns the 'Plugin -> SQLUtil' menu on with <alt>-s as 
+             the shortcut.
+  The option, g:sqlutil_default_menu_mode defaults to a value of 3 and can be
+  changed by adding the following to your vimrc: >
+            let  g:sqlutil_default_menu_mode = 3
+<
+ You can also control where (and the name of) the SQLUtil menu is created
+ using the g:sqlutil_menu_root option.  It can be used in conjuction with
+ g:sqlutil_default_menu_mode = 3.  To create the menu: 'MyPlugins -> SQLUtil'
+ you can create the following variable: >
+            let  g:sqlutil_menu_root = 'MyPlugin.&SQLUtil'
+<            
+ Menus are created in a documented order by Vim (|menu-priority|).  You can
+ override this setting using sqlutil_menu_priority.  This option allows you to
+ override the setting and shift the SQLUtil menu item to the left between the
+ Edit and Tools menu. >
+            let  g:sqlutil_menu_priority = 30
+
+6.3 Vim's Syntax Support
+
+  New to 5.0 of SQLUtilities, when reformatting a SQL statement Vim's syntax
+  rules are used to determine if the keyword found (i.e. SELECT, FROM, WHERE, 
+  ...) is within a string.  Consider the following statement: >
+    SELECT 1, 'text with keywords IN FROM CASE WHERE AND OR ' FROM T1 WHERE c1 = 1
+<
+  Formatting this statement with g:sqlutil_use_syntax_support = 0 results in: >
+    SELECT 'text
+      with keywords IN
+      FROM CASE
+     WHERE 
+       AND 
+        OR '
+      FROM T1
+     WHERE c1 = 1
+<
+  As you can see the keywords found within the string were aligned like all
+  other keywords.  To address this, when the keyword is found and Vim is
+  highlighting the text (i.e. syntax on is enabled) then determine the 
+  syntax group.  If the group is within the comma separated list of 
+  groups listed in g:sqlutil_syntax_elements, then it will be bypassed.
+  The resulting query with g:sqlutil_use_syntax_support = 1 will be 
+  formatted as: >
+    SELECT 1, 'some text with sql keywords IN FROM CASE WHERE AND OR '
+      FROM T1
+     WHERE c1 = 1
+<
+  To help you determine what the correct groups are, you can install: >
+    SyntaxAttr.vim
+    http://vim.sourceforge.net/script.php?script_id=383
+<
+  Then create a mapping: >
+    nnoremap -a :call SyntaxAttr()<CR>
+<
+  Place your cursor on the word which is hightlighted in the colour you 
+  are interested in and hit -a.  The output displayed looks something like 
+  this: >
+    group: sqlString->Constant guifg=White(#ffffff)
+<
+  With this information, you can override the default for SQLUtilities 
+  using the following line in my .vimrc: >
+    let g:sqlutil_syntax_elements = 'Constant,sqlString'
+
+==============================================================================
+7. History                                       *sqlutil-history*
+
+  6.0.0: October 10, 2012: 
+         NF: When formatting INSERT statements, the sqlutil_align_comma
+             is also respected to place each column on a newline.
+         NF: When formatting UPDATE statements and sqlutil_align_comma is set
+             comments at the end of the line were removed (Rodrigo Laporte).
+
+  5.0.0: February 10, 2012: 
+         NF: Now an extra check is made for the Align plugin.  If not 
+             found when attempting to format a SQL statement a friendly 
+             message is shown (Enrico Teotti).
+         NF: Updated documentation added the Global Options section plus
+             updated the Customization section.
+         NF: Problem: Keywords within strings were being formatted 
+             (Olivier Laurent).
+             Solution: Added an option, g:sqlutil_use_syntax_support, to 
+             determine whether or not to use Vim's syntax support 
+             to decide if the keyword is highlighted as a "string".
+             If so, leave it and move on to the next keyword.
+             Default value is 1 (enabled).
+             See |sqlutil-customization| for details on usage.
+         NF: Added an option, g:sqlutil_syntax_elements, to 
+             allow the user to decide which syntax elements 
+             should be considered a string.
+             Default value is 'Constant,sqlString'.
+
+  4.1.0: August 18, 2010: 
+         NF: Store and reset the value of the |gdefault| option before
+             formatting SQL statements (Sebastian Kusnier).
+         BF: When g:sqlutil_align_keyword_right = 0 and 
+             g:sqlutil_align_comma = 1 commas where left aligned
+             with the keywords instead of left aligned with the 
+             column list (Per Winkvist).
+
+  4.0.0: August 13, 2010: 
+         NF: Added a tutorial to take users through the common features 
+             of the plugin.
+         NF: Added an option, g:sqlutil_align_keyword_right, to left or 
+             right (default) align the keywords (Per Winkvist).
+         NF: Documented and added new global variables (g:sqlutil_menu_root,
+             g:sqlutil_menu_priority) to customize the location of the 
+             SQLUtil menu.
+         BF: SQLite used slightly different syntax specifying UNIQUE
+             values and would not correctly generate a column list
+             from the CREATE TABLE statement (Oliver Peters).
+         BF: Ensured all normal commands used ! to ensure no mappings
+             interfered with the commands (Benoit Mortgat).
+
+  3.0.0: January 15, 2009: 
+         NF: Added new menu links so that commonly used options can be
+             quickly and easily toggled without having to remember the 
+             global variable names or values.  For example, if you cut the 
+             menu so that it floats beside your buffer you can easily
+             hit "Toggle Align Where" or "Uppercase Keywords".  
+         NF: Using the menu_mode option you can control if and where the
+             SQLUtil menu is created.  See the menu_mode option for more
+             details.
+         NF: Added the default maps to the menus.  If you use a floating 
+             menu, or simply view the menu you can more easily memorize
+             your most commonly used maps.
+         BF: UPPER and lower case of keywords did not work for multi-word
+             keywords (ORDER BY, LEFT OUTER JOIN, ...).
+
+  2.0.0: September 09, 2007: 
+         NF: Added support for Vim 7's autoload functionality
+
+  1.4.1: October 07, 2005: 
+         NF: Added additional statements to g:sqlutil_col_list_terminators
+         BF: Forgot to increment g:loaded_sqlutilities
+
+  1.4.0: March 10, 2005: 
+         BF: If a statement has parenthesis inside of strings, the formatter
+             was not ignoring them.  This could result in the formatter
+             reporting there were mismatched parenthesis.
+             Example: select 'string' + '(' from dummy
+         BF: If a keyword was not followed by a space, it was not placed on
+             a newline.  
+             Example:  SELECT * FROM(T1)
+         BF: Nested function calls could potentially lead to an endless loop.  
+
+  1.3.9: February 10, 2005: 
+         BF: When g:sqlutil_align_comma=1 and a select list spanned more than 1
+             line (via functions calls and so on), it was possible the
+             remaining comma separated list was not aligned properly.
+
+  1.3.8: December 2, 2004: 
+         NF: Enhanced the feature to change the case of keywords, to include
+             the optional join words, left, right, full, inner, outer.  These
+             words were missed prior to this change and only the JOIN word was
+             capitalized.
+         C: Changed the default for g:sqlutil_use_tbl_alias = 'a' (ask) from
+             being on at all times.  This can be overridden in your vimrc.
+
+  1.3.7: July 21, 2004: 
+         NF: Added new option g:sqlutil_use_tbl_alias, which is on by default.
+             When creating a column list for a table, it will add a table
+             alias to each column.  The table alias is calculated based on 
+             rules.  This feature has 3 settings:
+                n - no alias
+                d - default calculated alias
+                a - ask the user using default alias
+         NF: Updated g:sqlutil_col_list_terminators to handle some additional
+             cases.
+         BF: In some cases -@- could be left in the query.  This seems to be
+             a bug in Vim, where the marks could move.  Unsure why, but put
+             a workaround in.
+         BF: When g:sqlutil_align_comma=1, and the lines did not begin with
+             commas, the formatting was incorrect.
+         BF: When searching through buffers (SQLU_CreateColumnList), the 
+             alternate buffer could be changed.
+
+  1.3.6: June 21, 2004: 
+         NF: Added support for window functions (OVER, PARTITION BY, ROWS,
+             RANGE), and additional Oracle SELECT keywords (DIMENSION,
+             MEASURES, ITERATE, WITHIN GROUP, IGNORE, KEEP, RETURN, RULES)
+
+  1.3.5: Mar 05, 2004: 
+         NF: Added global variable sqlutil_align_where, sqlutil_align_comma,
+             sqlutil_align_first_word for customization of alignment rules.
+
+  1.3.3: Sep 05, 2003: 
+         NF: Added global variable sqlutil_col_list_terminators for
+             customization.
+
+  1.3.2: Aug 24, 2003: 
+         NF: Changed all functions to be prefixed by SQLU_ for consistency.
+         BF: Fixed SQLU_GetColumnDataType and SQLU_GetColumnDef to handle tabs.
+         
+  1.3.1: Aug 21, 2003: 
+         BF: -@- could be left after incorrect formatting.
+
+  1.3.0: Mar 30, 2003: 
+         NF: Support the formatting of FUNCTIONS or stored procedures used as
+             derived tables.  This will nest the function calls on new lines
+             and correctly split the parenthesis on new lines if the function
+             call is longer than one line.  You would notice this mainly in the
+             SELECT column list.
+         NF: Support the formatting of nested CASE statements.
+         NF: Added the SQLU_GetColumnDataType command. 
+         NF: Improved primary key determination, it no longer requires the
+             PRIMARY KEY statement to be part of the CREATE TABLE statement, it
+             can be part of an ALTER TABLE statement.
+         NF: Improved formatting of SQL keywords.  INSERT INTO statement, the
+             INTO will no longer be split onto a new line.
+         NF: Now correctly format the various JOIN keywords: NATURAL RIGHT
+             OUTER JOIN will be placed one online instead of just the JOIN
+             keyword as before.
+         BF: Did not properly handle the formatting of nested open parenthesis
+             in all cases.
+         BF: Using new technique to determine how to change the textwidth to
+             utilize more screen space when wrapping long lines.
+                           
+  1.2.0: Nov 30, 2002: 
+         NF: Create procedure uses shiftwidth for indent.
+         BF: Save/restore previous search.
+         
+  1.0.0: Nov 13, 2002: 
+         NF: Initial version.
+    
+
+==============================================================================
+8. Dependencies                                  *sqlutil-dependencies*
+
+       Align.vim - Version 15 (as a minimum)
+                 - Author: Charles E. Campbell, Jr.
+                 - http://www.vim.org/script.php?script_id=294
+                 - SQLUtilities uses this to extensively
+
+
+==============================================================================
+9. Complementary Plugins                       *sqlutil-complementary-plugins*
+
+       dbext.vim  - Author: Peter Bagyinszki and David Fishburn
+                  - http://www.vim.org/script.php?script_id=356
+                  - Works with almost all databases
+                  - Allows you to execute commands, browse through objects
+                    and many more items.
+
+       SrchRplcHiGrp.vim  
+                  - Author: David Fishburn
+                  - http://www.vim.org/script.php?script_id=848
+                  - Search and Replace based on a syntax highlight
+                    group name.  For example, you can visually select
+                    a block of code and tell it to change all the
+                    "yellow" words to UPPER case.
+                    
+       Intellisense.vim  
+                  - Author: Ravi Shankar
+                  - SQL plugin Author: David Fishburn
+                  - http://www.vim.org/scripts/script.php?script_id=747
+                  - Performs popup method completion for SQL development
+                    this includes, keywords, functions, tables, columns,
+                    procedures and more.
+
+
+==============================================================================
+10. TODO                                          *sqlutil-todo*
+
+  TODO:
+    1. Suggestions welcome please email <dfishburn dot vim at gmail dot com>
+
+
+==============================================================================
+
+
+vim: ts=4 ft=help
diff --git a/vimrc/.vim/bundle/SQLUtilities/doc/tags b/vimrc/.vim/bundle/SQLUtilities/doc/tags
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/bundle/SQLUtilities/doc/tags
@@ -0,0 +1,24 @@
+SQLUtilities.txt	SQLUtilities.txt	/*SQLUtilities.txt*
+sqlutil	SQLUtilities.txt	/*sqlutil*
+sqlutil-align-comma	SQLUtilities.txt	/*sqlutil-align-comma*
+sqlutil-align-first-word	SQLUtilities.txt	/*sqlutil-align-first-word*
+sqlutil-align-keyword-right	SQLUtilities.txt	/*sqlutil-align-keyword-right*
+sqlutil-align-where	SQLUtilities.txt	/*sqlutil-align-where*
+sqlutil-change_keyword-case	SQLUtilities.txt	/*sqlutil-change_keyword-case*
+sqlutil-column-datatype	SQLUtilities.txt	/*sqlutil-column-datatype*
+sqlutil-column-definition	SQLUtilities.txt	/*sqlutil-column-definition*
+sqlutil-column-list	SQLUtilities.txt	/*sqlutil-column-list*
+sqlutil-commands	SQLUtilities.txt	/*sqlutil-commands*
+sqlutil-complementary-plugins	SQLUtilities.txt	/*sqlutil-complementary-plugins*
+sqlutil-contents	SQLUtilities.txt	/*sqlutil-contents*
+sqlutil-customization	SQLUtilities.txt	/*sqlutil-customization*
+sqlutil-dependencies	SQLUtilities.txt	/*sqlutil-dependencies*
+sqlutil-examples	SQLUtilities.txt	/*sqlutil-examples*
+sqlutil-format-options	SQLUtilities.txt	/*sqlutil-format-options*
+sqlutil-formatter	SQLUtilities.txt	/*sqlutil-formatter*
+sqlutil-history	SQLUtilities.txt	/*sqlutil-history*
+sqlutil-mappings	SQLUtilities.txt	/*sqlutil-mappings*
+sqlutil-options	SQLUtilities.txt	/*sqlutil-options*
+sqlutil-procedure	SQLUtilities.txt	/*sqlutil-procedure*
+sqlutil-todo	SQLUtilities.txt	/*sqlutil-todo*
+sqlutil-tutorial	SQLUtilities.txt	/*sqlutil-tutorial*
diff --git a/vimrc/.vim/bundle/SQLUtilities/includefile.conf b/vimrc/.vim/bundle/SQLUtilities/includefile.conf
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/bundle/SQLUtilities/includefile.conf
@@ -0,0 +1 @@
+*/keys/keymap
diff --git a/vimrc/.vim/bundle/SQLUtilities/plugin/SQLUtilities.vim b/vimrc/.vim/bundle/SQLUtilities/plugin/SQLUtilities.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/bundle/SQLUtilities/plugin/SQLUtilities.vim
@@ -0,0 +1,364 @@
+" SQLUtilities:   Variety of tools for writing SQL
+"   Author:	      David Fishburn <dfishburn dot vim at gmail dot com>
+"   Date:	      Nov 23, 2002
+"   Last Changed: 2012 Oct 09
+"   Version:	  6.0.0
+"   Script:	      http://www.vim.org/script.php?script_id=492
+"   License:      GPL (http://www.gnu.org/licenses/gpl.html)
+"
+"   Dependencies:
+"        Align.vim - Version 15 (as a minimum)
+"                  - Author: Charles E. Campbell, Jr.
+"                  - http://www.vim.org/script.php?script_id=294
+"   Documentation:
+"        :h SQLUtilities.txt 
+"
+
+" Prevent duplicate loading
+if exists("g:loaded_sqlutilities")
+    finish
+endif
+let g:loaded_sqlutilities = 600
+
+" Turn on support for line continuations when creating the script
+let s:cpo_save = &cpo
+set cpo&vim
+
+if !exists('g:sqlutil_align_where')
+    let g:sqlutil_align_where = 1
+endif
+
+if !exists('g:sqlutil_align_comma')
+    let g:sqlutil_align_comma = 0
+endif
+
+if !exists('g:sqlutil_wrap_expressions')
+    let g:sqlutil_wrap_expressions = 0
+endif
+
+if !exists('g:sqlutil_align_first_word')
+    let g:sqlutil_align_first_word = 1
+endif
+
+if !exists('g:sqlutil_align_keyword_right')
+    let g:sqlutil_align_keyword_right = 1
+endif
+
+if !exists('g:sqlutil_cmd_terminator')
+    let g:sqlutil_cmd_terminator = ';'
+endif
+
+if !exists('g:sqlutil_stmt_keywords')
+    let g:sqlutil_stmt_keywords = 'select,insert,update,delete,with,merge'
+endif
+
+if !exists('g:sqlutil_keyword_case')
+    " This controls whether keywords should be made
+    " upper or lower case.
+    " The default is to leave them in current case.
+    let g:sqlutil_keyword_case = ''
+endif
+
+if !exists('g:sqlutil_use_tbl_alias')
+    " If this is set to 1, when you run SQLU_CreateColumnList
+    " and you do not specify a 3rd parameter, you will be
+    " prompted for the alias name to append to the column list.
+    "
+    " The default for the alias are the initials for the table:
+    "     some_thing_with_under_bars -> stwub
+    "     somethingwithout           -> s
+    "
+    " The default is no asking
+    "   d - use by default
+    "   a - ask (prompt)
+    "   n - no
+    let g:sqlutil_use_tbl_alias = 'a'
+endif
+
+if !exists('g:sqlutil_col_list_terminators')
+    " You can override which keywords will determine
+    " when a column list finishes:
+    "        CREATE TABLE customer (
+    "        	id	INT DEFAULT AUTOINCREMENT,
+    "        	last_modified TIMESTAMP NULL,
+    "        	first_name     	VARCHAR(30) NOT NULL,
+    "        	last_name	VARCHAR(60) NOT NULL,
+    "        	balance	        NUMERIC(10,2),
+    "        	PRIMARY KEY( id )
+    "        );
+    " So in the above example, when "primary" is reached, we
+    " know the column list is complete.
+    "     PRIMARY KEY
+    "     foreign keys
+    "     indicies
+    "     check contraints
+    "     table contraints
+    "     foreign keys
+    " 
+    let g:sqlutil_col_list_terminators = 
+                \ 'primary\s\+key.*(' .
+                \ ',references' .
+                \ ',match' .
+                \ ',unique' .
+                \ ',check' .
+                \ ',constraint' .
+                \ ',\%(not\s\+null\s\+\)\?foreign'
+endif
+
+if !exists('g:sqlutil_use_syntax_support')
+    " This controls whether search and replace
+    " of various keywords as part of the formatting 
+    " of sql statements should use Vim's built in
+    " syntax support.
+    " The default to use the syntax id to help
+    " determine if keywords are within strings
+    " and therefore not aligning them.
+    let g:sqlutil_use_syntax_support = 1
+endif
+
+if !exists('g:sqlutil_syntax_elements')
+    " This controls how SQLUtilities determines if
+    " the keyword found is within a string or not.
+    " This is a comma separated list of values.
+    " The default is Constant,sqlString.
+    let g:sqlutil_syntax_elements = 'Constant,sqlString'
+endif
+
+" Determines which menu items will be recreated
+let s:sqlutil_menus_created = 0
+
+" Public Interface:
+command! -range=% -nargs=* SQLUFormatStmts <line1>,<line2> 
+            \ call SQLUtilities#SQLU_FormatStmts(<q-args>)
+command! -range -nargs=* SQLUFormatter <line1>,<line2> 
+            \ call SQLUtilities#SQLU_Formatter(<q-args>)
+command!        -nargs=* SQLUCreateColumnList  
+            \ call SQLU_CreateColumnList(<f-args>)
+command!        -nargs=* SQLUGetColumnDef 
+            \ call SQLU_GetColumnDef(<f-args>)
+command!        -nargs=* SQLUGetColumnDataType 
+            \ call SQLU_GetColumnDef(expand("<cword>"), 1)
+command!        -nargs=* SQLUCreateProcedure 
+            \ call SQLU_CreateProcedure(<f-args>)
+command!        -nargs=* SQLUToggleValue 
+            \ call SQLU_ToggleValue(<f-args>)
+
+if !exists("g:sqlutil_load_default_maps")
+    let g:sqlutil_load_default_maps = 1
+endif 
+
+if(g:sqlutil_load_default_maps == 1)
+    if !hasmapto('<Plug>SQLUFormatStmts')
+        nmap <unique> <Leader>sfr <Plug>SQLUFormatStmts
+        vmap <unique> <Leader>sfr <Plug>SQLUFormatStmts
+    endif 
+    if !hasmapto('<Plug>SQLUFormatter')
+        nmap <unique> <Leader>sfs <Plug>SQLUFormatter
+        vmap <unique> <Leader>sfs <Plug>SQLUFormatter
+        nmap <unique> <Leader>sf <Plug>SQLUFormatter
+        vmap <unique> <Leader>sf <Plug>SQLUFormatter
+    endif 
+    if !hasmapto('<Plug>SQLUCreateColumnList')
+        nmap <unique> <Leader>scl <Plug>SQLUCreateColumnList
+    endif 
+    if !hasmapto('<Plug>SQLUGetColumnDef')
+        nmap <unique> <Leader>scd <Plug>SQLUGetColumnDef
+    endif 
+    if !hasmapto('<Plug>SQLUGetColumnDataType')
+        nmap <unique> <Leader>scdt <Plug>SQLUGetColumnDataType
+    endif 
+    if !hasmapto('<Plug>SQLUCreateProcedure')
+        nmap <unique> <Leader>scp <Plug>SQLUCreateProcedure
+    endif 
+endif 
+
+if exists("g:loaded_sqlutilities_global_maps")
+    vunmap <unique> <script> <Plug>SQLUFormatStmts
+    nunmap <unique> <script> <Plug>SQLUFormatStmts
+    vunmap <unique> <script> <Plug>SQLUFormatter
+    nunmap <unique> <script> <Plug>SQLUFormatter
+    nunmap <unique> <script> <Plug>SQLUCreateColumnList
+    nunmap <unique> <script> <Plug>SQLUGetColumnDef
+    nunmap <unique> <script> <Plug>SQLUGetColumnDataType
+    nunmap <unique> <script> <Plug>SQLUCreateProcedure
+endif
+
+" Global Maps:
+vmap <unique> <script> <Plug>SQLUFormatStmts       :SQLUFormatStmts v<CR>
+nmap <unique> <script> <Plug>SQLUFormatStmts       :SQLUFormatStmts n<CR>
+vmap <unique> <script> <Plug>SQLUFormatter         :SQLUFormatter v<CR>
+nmap <unique> <script> <Plug>SQLUFormatter         :SQLUFormatter n<CR>
+nmap <unique> <script> <Plug>SQLUCreateColumnList  :SQLUCreateColumnList<CR>
+nmap <unique> <script> <Plug>SQLUGetColumnDef      :SQLUGetColumnDef<CR>
+nmap <unique> <script> <Plug>SQLUGetColumnDataType :SQLUGetColumnDataType<CR>
+nmap <unique> <script> <Plug>SQLUCreateProcedure   :SQLUCreateProcedure<CR>
+let g:loaded_sqlutilities_global_maps = 1
+
+if !exists('g:sqlutil_default_menu_mode')
+    let g:sqlutil_default_menu_mode = 3
+endif
+
+function! SQLU_Menu()
+    if has("menu") && g:sqlutil_default_menu_mode != 0
+        if g:sqlutil_default_menu_mode == 1
+            let menuRoot     = 'SQLUtil'
+            let menuPriority = exists("g:sqlutil_menu_priority") ? g:sqlutil_menu_priority : ''
+        elseif g:sqlutil_default_menu_mode == 2
+            let menuRoot     = '&SQLUtil'
+            let menuPriority = exists("g:sqlutil_menu_priority") ? g:sqlutil_menu_priority : ''
+        elseif g:sqlutil_default_menu_mode == 3
+            let menuRoot     = exists("g:sqlutil_menu_root") ? g:sqlutil_menu_root : '&Plugin.&SQLUtil'
+            let menuPriority = exists("g:sqlutil_menu_priority") ? g:sqlutil_menu_priority : ''
+        else
+            let menuRoot     = '&Plugin.&SQLUtil'
+            let menuPriority = exists("g:sqlutil_menu_priority") ? g:sqlutil_menu_priority : ''
+        endif
+
+        let leader = '\'
+        if exists('g:mapleader')
+            let leader = g:mapleader
+        endif
+        let leader = escape(leader, '\')
+
+        if s:sqlutil_menus_created == 0 
+            exec 'vnoremenu <script> '.menuPriority.' '.menuRoot.'.Format\ Range\ Stmts<TAB>'.leader.'sfr :SQLUFormatStmts<CR>'
+            exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Format\ Range\ Stmts<TAB>'.leader.'sfr :SQLUFormatStmts<CR>'
+            exec 'vnoremenu <script> '.menuPriority.' '.menuRoot.'.Format\ Statement<TAB>'.leader.'sfs :SQLUFormatter<CR>'
+            exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Format\ Statement<TAB>'.leader.'sfs :SQLUFormatter<CR>'
+            exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Create\ Procedure<TAB>'.leader.'scp :SQLUCreateProcedure<CR>'
+            exec 'inoremenu <script> '.menuPriority.' '.menuRoot.'.Create\ Procedure<TAB>'.leader.'scp  
+                        \ <C-O>:SQLUCreateProcedure<CR>'
+            exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Create\ Column\ List<TAB>'.leader.'sl   
+                        \ :SQLUCreateColumnList<CR>'
+            exec 'inoremenu <script> '.menuPriority.' '.menuRoot.'.Create\ Column\ List<TAB>'.leader.'sl 
+                        \ <C-O>:SQLUCreateColumnList<CR>'
+            exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Column\ Definition<TAB>'.leader.'scd 
+                        \ :SQLUGetColumnDef<CR>'
+            exec 'inoremenu <script> '.menuPriority.' '.menuRoot.'.Column\ Definition<TAB>'.leader.'scd 
+                        \ <C-O>:SQLUGetColumnDef<CR>'
+            exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Column\ Datatype<TAB>'.leader.'scdt
+                        \ :SQLUGetColumnDataType<CR>'
+            exec 'inoremenu <script> '.menuPriority.' '.menuRoot.'.Column\ Datatype<TAB>'.leader.'scdt
+                        \ <C-O>:SQLUGetColumnDataType<CR>'
+
+            let s:sqlutil_menus_created = 1
+        endif
+        silent! exec 'aunmenu  <script> '.menuPriority.' '.menuRoot.'.Toggle\ Align\ Where'
+        exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Toggle\ Align\ Where'.
+                    \ (g:sqlutil_align_where==1?'<TAB>(on) ':'<TAB>(off) ').
+                    \ ':SQLUToggleValue g:sqlutil_align_where<CR>'
+        silent! exec 'aunmenu '.menuPriority.' '.menuRoot.'.Toggle\ Align\ Comma'
+        exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Toggle\ Align\ Comma'.
+                    \ (g:sqlutil_align_comma==1?'<TAB>(on) ':'<TAB>(off) ').
+                    \ ':SQLUToggleValue g:sqlutil_align_comma<CR>'
+        silent! exec 'aunmenu '.menuPriority.' '.menuRoot.'.Toggle\ Align\ First\ Word'
+        exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Toggle\ Align\ First\ Word'.
+                    \ (g:sqlutil_align_first_word==1?'<TAB>(on) ':'<TAB>(off) ').
+                    \ ':SQLUToggleValue g:sqlutil_align_first_word<CR>'
+        silent! exec 'aunmenu '.menuPriority.' '.menuRoot.'.Toggle\ Right\ Align\ Keywords'
+        exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Toggle\ Right\ Align\ Keywords'.
+                    \ (g:sqlutil_align_keyword_right=='1'?'<TAB>(on) ':'<TAB>(off) ').
+                    \ ':SQLUToggleValue g:sqlutil_align_keyword_right<CR>'
+        silent! exec 'aunmenu '.menuPriority.' '.menuRoot.'.Uppercase\ Keywords'
+        exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Uppercase\ Keywords'.
+                    \ (g:sqlutil_keyword_case=='\U'?'<TAB>(on) ':' ').
+                    \ ':SQLUToggleValue g:sqlutil_keyword_case \U<CR>'
+        silent! exec 'aunmenu '.menuPriority.' '.menuRoot.'.Lowercase\ Keywords'
+        exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Lowercase\ Keywords'.
+                    \ (g:sqlutil_keyword_case=='\L'?'<TAB>(on) ':' ').
+                    \ ':SQLUToggleValue g:sqlutil_keyword_case \L<CR>'
+        silent! exec 'aunmenu '.menuPriority.' '.menuRoot.'.Default\ Case\ Keywords'
+        exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Default\ Case\ Keywords'.
+                    \ (g:sqlutil_keyword_case==''?'<TAB>(on) ':' ').
+                    \ ':SQLUToggleValue g:sqlutil_keyword_case default<CR>'
+    endif
+endfunction
+
+" Puts a command separate list of columns given a table name
+" Will search through the file looking for the create table command
+" It assumes that each column is on a separate line
+" It places the column list in unnamed buffer
+function! SQLU_CreateColumnList(...)
+    if(a:0 > 1) 
+        call SQLUtilities#SQLU_CreateColumnList(a:1, a:2)
+    elseif(a:0 > 0) 
+        call SQLUtilities#SQLU_CreateColumnList(a:1)
+    else
+        call SQLUtilities#SQLU_CreateColumnList()
+    endif
+endfunction
+
+
+" Strip the datatype from a column definition line
+function! SQLU_GetColumnDatatype( line, need_type )
+    return SQLUtilities#SQLU_GetColumnDatatype(a:line, a:need_type)
+endfunction
+
+
+" Puts a comma separated list of columns given a table name
+" Will search through the file looking for the create table command
+" It assumes that each column is on a separate line
+" It places the column list in unnamed buffer
+function! SQLU_GetColumnDef( ... )
+    if(a:0 > 1) 
+        return SQLUtilities#SQLU_GetColumnDef(a:1, a:2)
+    elseif(a:0 > 0) 
+        return SQLUtilities#SQLU_GetColumnDef(a:1)
+    else
+        return SQLUtilities#SQLU_GetColumnDef()
+    endif
+endfunction
+
+
+
+" Creates a procedure defintion into the unnamed buffer for the 
+" table that the cursor is currently under.
+function! SQLU_CreateProcedure(...)
+    if(a:0 > 0) 
+        return SQLUtilities#SQLU_CreateProcedure(a:1)
+    else
+        return SQLUtilities#SQLU_CreateProcedure()
+    endif
+endfunction
+
+
+
+" Compares two strings, and will remove all names from the first 
+" parameter, if the same name exists in the second column name.
+" The 2 parameters take comma separated lists
+function! SQLU_RemoveMatchingColumns( full_col_list, dup_col_list )
+    return SQLUtilities#SQLU_RemoveMatchingColumns( a:full_col_list, a:dup_col_list )
+endfunction
+
+
+
+" Toggles the value of some configuration parameters.
+" Mainly used by the menu.
+function! SQLU_ToggleValue( ... )
+    if (a:0 == 0)
+        echohl WarningMsg
+        echomsg "SQLUToggle value requires at least 1 parameter"
+        echohl None
+    elseif (a:0 == 1)
+        if exists('{a:1}') 
+            let {a:1} = (({a:1} == 0)?1:0)
+        endif
+    else
+        if exists('{a:1}') 
+            " Use defaults as the default for this function
+            if a:2 == 'default'
+                let {a:1} = ''
+            else
+                let {a:1} = a:2
+            endif
+        endif
+    endif
+    call SQLU_Menu()
+endfunction
+
+call SQLU_Menu()
+
+let &cpo = s:cpo_save
+unlet s:cpo_save
+
+" vim:fdm=marker:nowrap:ts=4:expandtab:ff=unix:
diff --git a/vimrc/.vim/bundle/SQLUtilities/prunefix.conf b/vimrc/.vim/bundle/SQLUtilities/prunefix.conf
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/bundle/SQLUtilities/prunefix.conf
@@ -0,0 +1,21 @@
+bak
+class
+cvs
+findresult
+gif
+git
+hg
+jpg
+metadata
+orig
+out
+png
+pyc
+svn
+swj
+swl
+swm
+swn
+swo
+swp
+tmp
diff --git a/vimrc/.vim/bundle/asyncrun.vim b/vimrc/.vim/bundle/asyncrun.vim
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/asyncrun.vim
@@ -0,0 +1 @@
+Subproject commit 45216942c2580fbe6e9def0b3921ec0ac3259c52
diff --git a/vimrc/.vim/bundle/bash-support.vim b/vimrc/.vim/bundle/bash-support.vim
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/bash-support.vim
@@ -0,0 +1 @@
+Subproject commit 537b2a38560042dfcb134ed8cdfdb77e3c649e6e-dirty
diff --git a/vimrc/.vim/bundle/bclose.vim b/vimrc/.vim/bundle/bclose.vim
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/bclose.vim
@@ -0,0 +1 @@
+Subproject commit 99018b4a2dd18aea1cbd3aa23565b01a0f8c5b73
diff --git a/vimrc/.vim/bundle/cql-vim b/vimrc/.vim/bundle/cql-vim
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/cql-vim
@@ -0,0 +1 @@
+Subproject commit 6f61df5a633c3a91edea7bcb5d5772648df19d1a
diff --git a/vimrc/.vim/bundle/delimitMate b/vimrc/.vim/bundle/delimitMate
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/delimitMate
@@ -0,0 +1 @@
+Subproject commit 537a1da0fa5eeb88640425c37e545af933c56e1b
diff --git a/vimrc/.vim/bundle/firenvim b/vimrc/.vim/bundle/firenvim
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/firenvim
@@ -0,0 +1 @@
+Subproject commit b6be2e074b8f62815a45e31eb0966b4dd5e57810
diff --git a/vimrc/.vim/bundle/indentLine b/vimrc/.vim/bundle/indentLine
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/indentLine
@@ -0,0 +1 @@
+Subproject commit d15d63bf9c4a74a02470d4bc8ecce53df13e3a75
diff --git a/vimrc/.vim/bundle/ncm2 b/vimrc/.vim/bundle/ncm2
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/ncm2
@@ -0,0 +1 @@
+Subproject commit 24d77cd5206438a6670ff1cf8d1628532910e14e
diff --git a/vimrc/.vim/bundle/ncm2-bufword b/vimrc/.vim/bundle/ncm2-bufword
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/ncm2-bufword
@@ -0,0 +1 @@
+Subproject commit 1d42750114e47a31286268880affcd66c6ae48d5
diff --git a/vimrc/.vim/bundle/ncm2-cssomni b/vimrc/.vim/bundle/ncm2-cssomni
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/ncm2-cssomni
@@ -0,0 +1 @@
+Subproject commit adaf78b921ee4320fd9d7adaa5bff7f3794f373a
diff --git a/vimrc/.vim/bundle/ncm2-github b/vimrc/.vim/bundle/ncm2-github
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/ncm2-github
@@ -0,0 +1 @@
+Subproject commit 2d7ed04a8fe5b8c27cfef5781a944d9865eed61f
diff --git a/vimrc/.vim/bundle/ncm2-go b/vimrc/.vim/bundle/ncm2-go
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/ncm2-go
@@ -0,0 +1 @@
+Subproject commit ca525bda6cb93248059422129dec717daa263e89
diff --git a/vimrc/.vim/bundle/ncm2-highprio-pop b/vimrc/.vim/bundle/ncm2-highprio-pop
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/ncm2-highprio-pop
@@ -0,0 +1 @@
+Subproject commit 0cf9b1a6e128fc8490cfadccc41bd4d9904d1df9
diff --git a/vimrc/.vim/bundle/ncm2-html-subscope b/vimrc/.vim/bundle/ncm2-html-subscope
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/ncm2-html-subscope
@@ -0,0 +1 @@
+Subproject commit 8294cf1bb55fb805454a9230aeb91dbb0f733a14
diff --git a/vimrc/.vim/bundle/ncm2-jedi b/vimrc/.vim/bundle/ncm2-jedi
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/ncm2-jedi
@@ -0,0 +1 @@
+Subproject commit f2e9007783b1f543b00d336a94210b4bc76b67e0
diff --git a/vimrc/.vim/bundle/ncm2-look.vim b/vimrc/.vim/bundle/ncm2-look.vim
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/ncm2-look.vim
@@ -0,0 +1 @@
+Subproject commit 6c2f878cf6092f678dc85e9b53034d5478ae7a75
diff --git a/vimrc/.vim/bundle/ncm2-markdown-subscope b/vimrc/.vim/bundle/ncm2-markdown-subscope
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/ncm2-markdown-subscope
@@ -0,0 +1 @@
+Subproject commit beeef1e88df29d2718f0fb73cdd4702eaf449f13
diff --git a/vimrc/.vim/bundle/ncm2-match-highlight b/vimrc/.vim/bundle/ncm2-match-highlight
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/ncm2-match-highlight
@@ -0,0 +1 @@
+Subproject commit 94c70b4a5606679ff6f1b695145ee300ca67e968
diff --git a/vimrc/.vim/bundle/ncm2-neoinclude b/vimrc/.vim/bundle/ncm2-neoinclude
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/ncm2-neoinclude
@@ -0,0 +1 @@
+Subproject commit 081f48c735c5f51849ec14e6a266b5400bf94b62
diff --git a/vimrc/.vim/bundle/ncm2-otherbuf b/vimrc/.vim/bundle/ncm2-otherbuf
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/ncm2-otherbuf
@@ -0,0 +1 @@
+Subproject commit 3b41baf22e8671c7b42faaf865dc5a7880f721f7
diff --git a/vimrc/.vim/bundle/ncm2-path b/vimrc/.vim/bundle/ncm2-path
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/ncm2-path
@@ -0,0 +1 @@
+Subproject commit 84b1e6b5f28ced2245ff08e6694101f029fdfca8
diff --git a/vimrc/.vim/bundle/ncm2-racer b/vimrc/.vim/bundle/ncm2-racer
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/ncm2-racer
@@ -0,0 +1 @@
+Subproject commit e3aec0836ea1ff1b820e937f9c6463eb015fa784
diff --git a/vimrc/.vim/bundle/ncm2-rst-subscope b/vimrc/.vim/bundle/ncm2-rst-subscope
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/ncm2-rst-subscope
@@ -0,0 +1 @@
+Subproject commit a3bbf4a09191990d97da2387c2d19b8529223b3e
diff --git a/vimrc/.vim/bundle/ncm2-snipmate b/vimrc/.vim/bundle/ncm2-snipmate
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/ncm2-snipmate
@@ -0,0 +1 @@
+Subproject commit 298871ade3656afa1aec717728aae457b6346e3b
diff --git a/vimrc/.vim/bundle/ncm2-syntax b/vimrc/.vim/bundle/ncm2-syntax
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/ncm2-syntax
@@ -0,0 +1 @@
+Subproject commit d41d60b22175822c14f497378a05398e3eca2517
diff --git a/vimrc/.vim/bundle/ncm2-tagprefix b/vimrc/.vim/bundle/ncm2-tagprefix
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/ncm2-tagprefix
@@ -0,0 +1 @@
+Subproject commit 6bff80cbd3edb02a0c91a26820606d0dcbfeb3bd
diff --git a/vimrc/.vim/bundle/ncm2-tmux b/vimrc/.vim/bundle/ncm2-tmux
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/ncm2-tmux
@@ -0,0 +1 @@
+Subproject commit 17fa16ac1211af3d8e671f1591939d6f37bdd3bd
diff --git a/vimrc/.vim/bundle/ncm2-vim b/vimrc/.vim/bundle/ncm2-vim
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/ncm2-vim
@@ -0,0 +1 @@
+Subproject commit 876ad5f30d1e296a4ab425a0e22a8162876ac48b
diff --git a/vimrc/.vim/bundle/neco-syntax b/vimrc/.vim/bundle/neco-syntax
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/neco-syntax
@@ -0,0 +1 @@
+Subproject commit f8d7b748b022aac8ce73458574da5616f1c5fb65
diff --git a/vimrc/.vim/bundle/neco-vim b/vimrc/.vim/bundle/neco-vim
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/neco-vim
@@ -0,0 +1 @@
+Subproject commit 6c581808ac3179ea0c640e43c77de48bbbec4fbc
diff --git a/vimrc/.vim/bundle/neoinclude.vim b/vimrc/.vim/bundle/neoinclude.vim
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/neoinclude.vim
@@ -0,0 +1 @@
+Subproject commit 954cfc9dfdb303f2c2fa867b9cf949dd74512628
diff --git a/vimrc/.vim/bundle/nvim-yarp b/vimrc/.vim/bundle/nvim-yarp
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/nvim-yarp
@@ -0,0 +1 @@
+Subproject commit bb5f5e038bfe119d3b777845a76b0b919b35ebc8
diff --git a/vimrc/.vim/bundle/open-browser.vim b/vimrc/.vim/bundle/open-browser.vim
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/open-browser.vim
@@ -0,0 +1 @@
+Subproject commit 7d4c1d8198e889d513a030b5a83faa07606bac27
diff --git a/vimrc/.vim/bundle/plantuml-previewer.vim b/vimrc/.vim/bundle/plantuml-previewer.vim
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/plantuml-previewer.vim
@@ -0,0 +1 @@
+Subproject commit e5514bf2e8f0c9a524496d1012e5ba260c7175a6
diff --git a/vimrc/.vim/bundle/plantuml-syntax b/vimrc/.vim/bundle/plantuml-syntax
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/plantuml-syntax
@@ -0,0 +1 @@
+Subproject commit 845abb56dcd3f12afa6eb47684ef5ba3055802b8
diff --git a/vimrc/.vim/bundle/python-mode b/vimrc/.vim/bundle/python-mode
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/python-mode
@@ -0,0 +1 @@
+Subproject commit bd5422d9e40c732b010dcd4da3eafda81b3b1d54-dirty
diff --git a/vimrc/.vim/bundle/swift.vim b/vimrc/.vim/bundle/swift.vim
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/swift.vim
@@ -0,0 +1 @@
+Subproject commit ba6f6cef58d08ac741aaf1626d3799d476cd43b6
diff --git a/vimrc/.vim/bundle/taglist-plus/README.md b/vimrc/.vim/bundle/taglist-plus/README.md
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/bundle/taglist-plus/README.md
@@ -0,0 +1,42 @@
+taglist-plus.vim
+================
+
+This is a fork of the popular taglist.vim plugin.
+
+Taglist-plus provides excellent Javascript support via jsctags. See [here][1]
+for examples.
+
+This plugin can also be obtained through [vim.org][2].
+
+Installation
+------------
+
+Unzip the plugin files to your `.vim` directory.
+
+For great Javascript support, jsctags is required as well.
+
+jsctags can be obtained via [github][4]. It requires a recent version of
+node.js -- the default one provided in Maverick Meerkat won't cut it. You can
+[build it from source][6] or get it via [this PPA][5].
+
+If you're going the PPA route, you'll need to map `nodejs` to `node`. Here are
+the commands:
+<pre>
+sudo add-apt-repository ppa:richarvey/nodester
+sudo apt-get update
+sudo apt-get install nodejs
+sudo ln -s /usr/bin/nodejs /usr/local/bin/node
+</pre>
+
+Usage
+-----
+
+`:TlistToggle` brings up the taglist window.  More commands can be found via
+`:help taglist-commands`.
+
+[1]:http://discontinuously.com/2011/03/vim-support-javascript-taglist-plus/
+[2]:https://github.com/int3/vim-taglist-plus
+[3]:http://www.vim.org/scripts/script.php?script_id=3504
+[4]:https://github.com/mozilla/doctorjs
+[5]:https://launchpad.net/~richarvey/+archive/nodester
+[6]:http://nodejs.org/#download
diff --git a/vimrc/.vim/bundle/taglist-plus/doc/taglist-plus.txt b/vimrc/.vim/bundle/taglist-plus/doc/taglist-plus.txt
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/bundle/taglist-plus/doc/taglist-plus.txt
@@ -0,0 +1,1499 @@
+*taglist-plus.txt*	Plugin for browsing source code
+
+Author: Yegappan Lakshmanan  (yegappan AT yahoo DOT com)
+Modified By: Jezreel Ng (jezreel AT gmail DOT com)
+For Vim version 6.0 and above
+
+1. Overview 					|taglist-intro|
+2. Requirements					|taglist-requirements|
+3. Installation 				|taglist-install|
+4. Usage 					|taglist-using|
+5. Options 					|taglist-options|
+6. Commands 					|taglist-commands|
+7. Global functions 				|taglist-functions|
+8. Extending 					|taglist-extend|
+9. FAQ  					|taglist-faq|
+10. License 					|taglist-license|
+11. Todo					|taglist-todo|
+
+==============================================================================
+						*taglist-intro*
+1. Overview~
+
+The "Tag List" plugin is a source code browser plugin for Vim. This plugin
+allows you to efficiently browse through source code files for different
+programming languages. The "Tag List" plugin provides the following features:
+
+    * Displays the tags (functions, classes, structures, variables, etc.) 
+      defined in a file in a vertically or horizontally split Vim window.
+    * In GUI Vim, optionally displays the tags in the Tags drop-down menu and
+      in the popup menu.
+    * Automatically updates the taglist window as you switch between
+      files/buffers. As you open new files, the tags defined in the new files
+      are added to the existing file list and the tags defined in all the
+      files are displayed grouped by the filename.
+    * When a tag name is selected from the taglist window, positions the
+      cursor at the definition of the tag in the source file.
+    * Automatically highlights the current tag name.
+    * Groups the tags by their type and displays them in a foldable tree.
+    * Can display the prototype and scope of a tag.
+    * Can optionally display the tag prototype instead of the tag name in the
+      taglist window.
+    * The tag list can be sorted either by name or by chronological order.
+    * Supports the following language files: Assembly, ASP, Awk, Beta, C,
+      C++, C#, Cobol, Eiffel, Erlang, Fortran, HTML, Java, Javascript, Lisp,
+      Lua, Make, Pascal, Perl, PHP, Python, Rexx, Ruby, Scheme, Shell, Slang,
+      SML, Sql, TCL, Verilog, Vim and Yacc.
+    * Can be easily extended to support new languages. Support for
+      existing languages can be modified easily.
+    * Provides functions to display the current tag name in the Vim status
+      line or the window title bar.
+    * The list of tags and files in the taglist can be saved and
+      restored across Vim sessions.
+    * Provides commands to get the name and prototype of the current tag.
+    * Runs in both console/terminal and GUI versions of Vim.
+    * Works with the winmanager plugin. Using the winmanager plugin, you
+      can use Vim plugins like the file explorer, buffer explorer and the
+      taglist plugin at the same time like an IDE.
+    * Can be used in both Unix and MS-Windows systems.
+
+==============================================================================
+						*taglist-requirements*
+2. Requirements~
+
+The taglist plugin requires the following:
+
+    * Vim version 6.0 and above
+    * Exuberant ctags 5.0 and above
+
+The taglist plugin will work on all the platforms where the exuberant ctags
+utility and Vim are supported (this includes MS-Windows and Unix based
+systems).
+
+The taglist plugin relies on the exuberant ctags utility to dynamically
+generate the tag listing.  The exuberant ctags utility must be installed in
+your system to use this plugin.  The exuberant ctags utility is shipped with
+most of the Linux distributions.  You can download the exuberant ctags utility
+from
+>
+	http://ctags.sourceforge.net
+<
+The taglist plugin doesn't use or create a tags file and there is no need to
+create a tags file to use this plugin. The taglist plugin will not work with
+the GNU ctags or the Unix ctags utility.
+
+This plugin relies on the Vim "filetype" detection mechanism to determine the
+type of the current file. You have to turn on the Vim filetype detection by
+adding the following line to your .vimrc file:
+>
+	filetype on
+<
+The taglist plugin will not work if you run Vim in the restricted mode (using
+the -Z command-line argument).
+
+The taglist plugin uses the Vim system() function to invoke the exuberant
+ctags utility. If Vim is compiled without the system() function then you
+cannot use the taglist plugin. Some of the Linux distributions (Suse) compile
+Vim without the system() function for security reasons.
+
+==============================================================================
+						*taglist-install*
+3. Installation~
+
+1. Download the taglist.zip file and unzip the files to the $HOME/.vim or the
+   $HOME/vimfiles or the $VIM/vimfiles directory. After this step, you should
+   have the following two files (the directory structure should be preserved):
+
+	plugin/taglist.vim - main taglist plugin file
+	doc/taglist.txt    - documentation (help) file
+
+   Refer to the |add-plugin|and |'runtimepath'| Vim help pages for more
+   details about installing Vim plugins.
+2. Change to the $HOME/.vim/doc or $HOME/vimfiles/doc or $VIM/vimfiles/doc
+   directory, start Vim and run the ":helptags ." command to process the
+   taglist help file. Without this step, you cannot jump to the taglist help
+   topics.
+3. If the exuberant ctags utility is not present in one of the directories in
+   the PATH environment variable, then set the 'Tlist_Ctags_Cmd' variable to
+   point to the location of the exuberant ctags utility (not to the directory)
+   in the .vimrc file.
+4. If you are running a terminal/console version of Vim and the terminal
+   doesn't support changing the window width then set the
+   'Tlist_Inc_Winwidth' variable to 0 in the .vimrc file.
+5. Restart Vim.
+6. You can now use the ":TlistToggle" command to open/close the taglist
+   window. You can use the ":help taglist" command to get more information
+   about using the taglist plugin.
+
+To uninstall the taglist plugin, remove the plugin/taglist.vim and
+doc/taglist.txt files from the $HOME/.vim or $HOME/vimfiles directory.
+
+==============================================================================
+						*taglist-using*
+4. Usage~
+
+The taglist plugin can be used in several different ways.
+
+1. You can keep the taglist window open during the entire editing session. On
+   opening the taglist window, the tags defined in all the files in the Vim
+   buffer list will be displayed in the taglist window. As you edit files, the
+   tags defined in them will be added to the taglist window. You can select a
+   tag from the taglist window and jump to it. The current tag will be
+   highlighted in the taglist window. You can close the taglist window when
+   you no longer need the window.
+2. You can configure the taglist plugin to process the tags defined in all the
+   edited files always. In this configuration, even if the taglist window is
+   closed and the taglist menu is not displayed, the taglist plugin will
+   processes the tags defined in newly edited files. You can then open the
+   taglist window only when you need to select a tag and then automatically
+   close the taglist window after selecting the tag.
+3. You can configure the taglist plugin to display only the tags defined in
+   the current file in the taglist window. By default, the taglist plugin
+   displays the tags defined in all the files in the Vim buffer list. As you
+   switch between files, the taglist window will be refreshed to display only
+   the tags defined in the current file.
+4. In GUI Vim, you can use the Tags pull-down and popup menu created by the
+   taglist plugin to display the tags defined in the current file and select a
+   tag to jump to it. You can use the menu without opening the taglist window.
+   By default, the Tags menu is disabled.
+5. You can configure the taglist plugin to display the name of the current tag
+   in the Vim window status line or in the Vim window title bar. For this to
+   work without the taglist window or menu, you need to configure the taglist
+   plugin to process the tags defined in a file always.
+6. You can save the tags defined in multiple files to a taglist session file
+   and load it when needed. You can also configure the taglist plugin to not
+   update the taglist window when editing new files. You can then manually add
+   files to the taglist window.
+
+Opening the taglist window~
+You can open the taglist window using the ":TlistOpen" or the ":TlistToggle"
+commands. The ":TlistOpen" command opens the taglist window and jumps to it.
+The ":TlistToggle" command opens or closes (toggle) the taglist window and the
+cursor remains in the current window. If the 'Tlist_GainFocus_On_ToggleOpen'
+variable is set to 1, then the ":TlistToggle" command opens the taglist window
+and moves the cursor to the taglist window.
+
+You can map a key to invoke these commands. For example, the following command
+creates a normal mode mapping for the <F8> key to toggle the taglist window.
+>
+	nnoremap <silent> <F8> :TlistToggle<CR>
+<
+Add the above mapping to your ~/.vimrc or $HOME/_vimrc file.
+
+To automatically open the taglist window on Vim startup, set the
+'Tlist_Auto_Open' variable to 1.
+
+You can also open the taglist window on startup using the following command
+line:
+>
+	$ vim +TlistOpen
+<
+Closing the taglist window~
+You can close the taglist window from the taglist window by pressing 'q' or
+using the Vim ":q" command. You can also use any of the Vim window commands to
+close the taglist window. Invoking the ":TlistToggle" command when the taglist
+window is opened, closes the taglist window. You can also use the
+":TlistClose" command to close the taglist window.
+
+To automatically close the taglist window when a tag or file is selected, you
+can set the 'Tlist_Close_On_Select' variable to 1.  To exit Vim when only the
+taglist window is present, set the 'Tlist_Exit_OnlyWindow' variable to 1.
+
+Jumping to a tag or a file~
+You can select a tag in the taglist window either by pressing the <Enter> key
+or by double clicking the tag name using the mouse. To jump to a tag on a
+single mouse click set the 'Tlist_Use_SingleClick' variable to 1.
+
+If the selected file is already opened in a window, then the cursor is moved
+to that window. If the file is not currently opened in a window then the file
+is opened in the window used by the taglist plugin to show the previously
+selected file. If there are no usable windows, then the file is opened in a
+new window.  The file is not opened in special windows like the quickfix
+window, preview window and windows containing buffer with the 'buftype' option
+set.
+
+To jump to the tag in a new window, press the 'o' key. To open the file in the
+previous window (Ctrl-W_p) use the 'P' key. You can press the 'p' key to jump
+to the tag but still keep the cursor in the taglist window (preview).
+
+To open the selected file in a tab, use the 't' key.  If the file is already
+present in a tab then the cursor is moved to that tab otherwise the file is
+opened in a new tab. To jump to a tag in a new tab press Ctrl-t.  The taglist
+window is automatically opened in the newly created tab.
+
+Instead of jumping to a tag, you can open a file by pressing the <Enter> key
+or by double clicking the file name using the mouse.
+
+In the taglist window, you can use the [[ or <Backspace> key to jump to the
+beginning of the previous file. You can use the ]] or <Tab> key to jump to the
+beginning of the next file. When you reach the first or last file, the search
+wraps around and the jumps to the next/previous file.
+
+Highlighting the current tag~
+The taglist plugin automatically highlights the name of the current tag in the
+taglist window. The Vim |CursorHold| autocmd event is used for this. If the
+current tag name is not visible in the taglist window, then the taglist window
+contents are scrolled to make that tag name visible. You can also use the
+":TlistHighlightTag" command to force the highlighting of the current tag.
+
+The tag name is highlighted if no activity is performed for |'updatetime'|
+milliseconds. The default value for this Vim option is 4 seconds. To avoid
+unexpected problems, you should not set the |'updatetime'| option to a very
+low value.
+
+To disable the automatic highlighting of the current tag name in the taglist
+window, set the 'Tlist_Auto_Highlight_Tag' variable to zero.
+
+When entering a Vim buffer/window, the taglist plugin automatically highlights
+the current tag in that buffer/window.  If you like to disable the automatic
+highlighting of the current tag when entering a buffer, set the
+'Tlist_Highlight_Tag_On_BufEnter' variable to zero.
+
+Adding files to the taglist~
+When the taglist window is opened, all the files in the Vim buffer list are
+processed and the supported files are added to the taglist.  When you edit a
+file in Vim, the taglist plugin automatically processes this file and adds it
+to the taglist. If you close the taglist window, the tag information in the
+taglist is retained.
+
+To process files even when the taglist window is not open, set the
+'Tlist_Process_File_Always' variable to 1.
+
+You can manually add multiple files to the taglist without opening them using
+the ":TlistAddFiles" and the ":TlistAddFilesRecursive" commands.
+
+For example, to add all the C files in the /my/project/dir directory to the
+taglist, you can use the following command:
+>
+	:TlistAddFiles /my/project/dir/*.c
+<
+Note that when adding several files with a large number of tags or a large
+number of files, it will take several seconds to several minutes for the
+taglist plugin to process all the files. You should not interrupt the taglist
+plugin by pressing <CTRL-C>.
+
+You can recursively add multiple files from a directory tree using the
+":TlistAddFilesRecursive" command:
+>
+	:TlistAddFilesRecursive /my/project/dir *.c
+<
+This command takes two arguments. The first argument specifies the directory
+from which to recursively add the files. The second optional argument
+specifies the wildcard matching pattern for selecting the files to add. The
+default pattern is * and all the files are added.
+
+Displaying tags for only one file~
+The taglist window displays the tags for all the files in the Vim buffer list
+and all the manually added files. To display the tags for only the current
+active buffer, set the 'Tlist_Show_One_File' variable to 1.
+
+Removing files from the taglist~
+You can remove a file from the taglist window, by pressing the 'd' key when the
+cursor is on one of the tags listed for the file in the taglist window. The
+removed file will no longer be displayed in the taglist window in the current
+Vim session. To again display the tags for the file, open the file in a Vim
+window and then use the ":TlistUpdate" command or use ":TlistAddFiles" command
+to add the file to the taglist.
+
+When a buffer is removed from the Vim buffer list using the ":bdelete" or the
+":bwipeout" command, the taglist is updated to remove the stored information
+for this buffer.
+
+Updating the tags displayed for a file~
+The taglist plugin keeps track of the modification time of a file. When the
+modification time changes (the file is modified), the taglist plugin
+automatically updates the tags listed for that file. The modification time of
+a file is checked when you enter a window containing that file or when you
+load that file.
+
+You can also update or refresh the tags displayed for a file by pressing the
+"u" key in the taglist window. If an existing file is modified, after the file
+is saved, the taglist plugin automatically updates the tags displayed for the
+file.
+
+You can also use the ":TlistUpdate" command to update the tags for the current
+buffer after you made some changes to it. You should save the modified buffer
+before you update the taglist window. Otherwise the listed tags will not
+include the new tags created in the buffer. 
+
+If you have deleted the tags displayed for a file in the taglist window using
+the 'd' key, you can again display the tags for that file using the
+":TlistUpdate" command.
+
+Controlling the taglist updates~
+To disable the automatic processing of new files or modified files, you can
+set the 'Tlist_Auto_Update' variable to zero. When this variable is set to
+zero, the taglist is updated only when you use the ":TlistUpdate" command or
+the ":TlistAddFiles" or the ":TlistAddFilesRecursive" commands. You can use
+this option to control which files are added to the taglist.
+
+You can use the ":TlistLock" command to lock the taglist contents. After this
+command is executed, new files are not automatically added to the taglist.
+When the taglist is locked, you can use the ":TlistUpdate" command to add the
+current file or the ":TlistAddFiles" or ":TlistAddFilesRecursive" commands to
+add new files to the taglist.  To unlock the taglist, use the ":TlistUnlock"
+command.
+
+Displaying the tag prototype~
+To display the prototype of the tag under the cursor in the taglist window,
+press the space bar. If you place the cursor on a tag name in the taglist
+window, then the tag prototype is displayed at the Vim status line after
+|'updatetime'| milliseconds. The default value for the |'updatetime'| Vim
+option is 4 seconds.
+
+You can get the name and prototype of a tag without opening the taglist window
+and the taglist menu using the ":TlistShowTag" and the ":TlistShowPrototype"
+commands. These commands will work only if the current file is already present
+in the taglist. To use these commands without opening the taglist window, set
+the 'Tlist_Process_File_Always' variable to 1.
+
+You can use the ":TlistShowTag" command to display the name of the tag at or
+before the specified line number in the specified file.  If the file name and
+line number are not supplied, then this command will display the name of the
+current tag. For example,
+>
+	:TlistShowTag
+	:TlistShowTag myfile.java 100
+<
+You can use the ":TlistShowPrototype" command to display the prototype of the
+tag at or before the specified line number in the specified file.  If the file
+name and the line number are not supplied, then this command will display the
+prototype of the current tag.  For example,
+>
+	:TlistShowPrototype
+	:TlistShowPrototype myfile.c 50
+<
+In the taglist window, when the mouse is moved over a tag name, the tag
+prototype is displayed in a balloon. This works only in GUI versions where
+balloon evaluation is supported.
+
+Taglist window contents~
+The taglist window contains the tags defined in various files in the taglist
+grouped by the filename and by the tag type (variable, function, class, etc.).
+For tags with scope information (like class members, structures inside
+structures, etc.), the scope information is displayed in square brackets "[]"
+after the tag name.
+
+The contents of the taglist buffer/window are managed by the taglist plugin.
+The |'filetype'| for the taglist buffer is set to 'taglist'.  The Vim
+|'modifiable'| option is turned off for the taglist buffer. You should not
+manually edit the taglist buffer, by setting the |'modifiable'| flag. If you
+manually edit the taglist buffer contents, then the taglist plugin will be out
+of sync with the taglist buffer contents and the plugin will no longer work
+correctly. To redisplay the taglist buffer contents again, close the taglist
+window and reopen it.
+
+Opening and closing the tag and file tree~
+In the taglist window, the tag names are displayed as a foldable tree using
+the Vim folding support. You can collapse the tree using the '-' key or using
+the Vim |zc| fold command. You can open the tree using the '+' key or using
+the Vim |zo| fold command. You can open all the folds using the '*' key or
+using the Vim |zR| fold command. You can also use the mouse to open/close the
+folds. You can close all the folds using the '=' key. You should not manually
+create or delete the folds in the taglist window.
+
+To automatically close the fold for the inactive files/buffers and open only
+the fold for the current buffer in the taglist window, set the
+'Tlist_File_Fold_Auto_Close' variable to 1.
+
+Sorting the tags for a file~
+The tags displayed in the taglist window can be sorted either by their name or
+by their chronological order. The default sorting method is by the order in
+which the tags appear in a file. You can change the default sort method by
+setting the 'Tlist_Sort_Type' variable to either "name" or "order". You can
+sort the tags by their name by pressing the "s" key in the taglist window. You
+can again sort the tags by their chronological order using the "s" key. Each
+file in the taglist window can be sorted using different order.
+
+Zooming in and out of the taglist window~
+You can press the 'x' key in the taglist window to maximize the taglist
+window width/height. The window will be maximized to the maximum possible
+width/height without closing the other existing windows. You can again press
+'x' to restore the taglist window to the default width/height.
+
+						*taglist-session*
+Taglist Session~
+A taglist session refers to the group of files and their tags stored in the
+taglist in a Vim session.
+
+You can save and restore a taglist session (and all the displayed tags) using
+the ":TlistSessionSave" and ":TlistSessionLoad" commands.
+
+To save the information about the tags and files in the taglist to a file, use
+the ":TlistSessionSave" command and specify the filename:
+>
+	:TlistSessionSave <file name>
+<
+To load a saved taglist session, use the ":TlistSessionLoad" command: >
+
+	:TlistSessionLoad <file name>
+<
+When you load a taglist session file, the tags stored in the file will be
+added to the tags already stored in the taglist.
+
+The taglist session feature can be used to save the tags for large files or a
+group of frequently used files (like a project). By using the taglist session
+file, you can minimize the amount to time it takes to load/refresh the taglist
+for multiple files.
+
+You can create more than one taglist session file for multiple groups of
+files.
+
+Displaying the tag name in the Vim status line or the window title bar~
+You can use the Tlist_Get_Tagname_By_Line() function provided by the taglist
+plugin to display the current tag name in the Vim status line or the window
+title bar. Similarly, you can use the Tlist_Get_Tag_Prototype_By_Line()
+function to display the current tag prototype in the Vim status line or the
+window title bar.
+
+For example, the following command can be used to display the current tag name
+in the status line:
+>
+	:set statusline=%<%f%=%([%{Tlist_Get_Tagname_By_Line()}]%)
+<
+The following command can be used to display the current tag name in the
+window title bar:
+>
+	:set title titlestring=%<%f\ %([%{Tlist_Get_Tagname_By_Line()}]%)
+<
+Note that the current tag name can be displayed only after the file is
+processed by the taglist plugin. For this, you have to either set the
+'Tlist_Process_File_Always' variable to 1 or open the taglist window or use
+the taglist menu. For more information about configuring the Vim status line,
+refer to the documentation for the Vim |'statusline'| option.
+
+Changing the taglist window highlighting~
+The following Vim highlight groups are defined and used to highlight the
+various entities in the taglist window:
+
+    TagListTagName  - Used for tag names
+    TagListTagScope - Used for tag scope
+    TagListTitle    - Used for tag titles
+    TagListComment  - Used for comments
+    TagListFileName - Used for filenames
+
+By default, these highlight groups are linked to the standard Vim highlight
+groups. If you want to change the colors used for these highlight groups,
+prefix the highlight group name with 'My' and define it in your .vimrc or
+.gvimrc file: MyTagListTagName, MyTagListTagScope, MyTagListTitle,
+MyTagListComment and MyTagListFileName.  For example, to change the colors
+used for tag names, you can use the following command:
+>
+    :highlight MyTagListTagName guifg=blue ctermfg=blue
+<
+Controlling the taglist window~
+To use a horizontally split taglist window, instead of a vertically split
+window, set the 'Tlist_Use_Horiz_Window' variable to 1.
+
+To use a vertically split taglist window on the rightmost side of the Vim
+window, set the 'Tlist_Use_Right_Window' variable to 1.
+
+You can specify the width of the vertically split taglist window, by setting
+the 'Tlist_WinWidth' variable.  You can specify the height of the horizontally
+split taglist window, by setting the 'Tlist_WinHeight' variable.
+
+When opening a vertically split taglist window, the Vim window width is
+increased to accommodate the new taglist window. When the taglist window is
+closed, the Vim window is reduced. To disable this, set the
+'Tlist_Inc_Winwidth' variable to zero.
+
+To reduce the number of empty lines in the taglist window, set the
+'Tlist_Compact_Format' variable to 1.
+
+To not display the Vim fold column in the taglist window, set the
+'Tlist_Enable_Fold_Column' variable to zero.
+
+To display the tag prototypes instead of the tag names in the taglist window,
+set the 'Tlist_Display_Prototype' variable to 1.
+
+To not display the scope of the tags next to the tag names, set the
+'Tlist_Display_Tag_Scope' variable to zero.
+
+						*taglist-keys*
+Taglist window key list~
+The following table lists the description of the keys that can be used
+in the taglist window.
+
+  Key           Description~
+
+  <CR>          Jump to the location where the tag under cursor is
+                defined.
+  o             Jump to the location where the tag under cursor is
+                defined in a new window.
+  P             Jump to the tag in the previous (Ctrl-W_p) window.
+  p             Display the tag definition in the file window and
+                keep the cursor in the taglist window itself.
+  t             Jump to the tag in a new tab. If the file is already
+                opened in a tab, move to that tab.
+  Ctrl-t	Jump to the tag in a new tab.
+  <Space>       Display the prototype of the tag under the cursor.
+  		For file names, display the full path to the file,
+		file type and the number of tags. For tag types, display the
+		tag type and the number of tags.
+  u             Update the tags listed in the taglist window
+  s             Change the sort order of the tags (by name or by order)
+  d             Remove the tags for the file under the cursor
+  x             Zoom-in or Zoom-out the taglist window
+  +             Open a fold
+  -             Close a fold
+  *             Open all folds
+  =             Close all folds
+  [[		Jump to the beginning of the previous file
+  <Backspace>	Jump to the beginning of the previous file
+  ]]		Jump to the beginning of the next file
+  <Tab>		Jump to the beginning of the next file
+  q             Close the taglist window
+  <F1>          Display help
+
+The above keys will work in both the normal mode and the insert mode.
+
+						*taglist-menu*
+Taglist menu~
+When using GUI Vim, the taglist plugin can display the tags defined in the
+current file in the drop-down menu and the popup menu. By default, this
+feature is turned off. To turn on this feature, set the 'Tlist_Show_Menu'
+variable to 1.
+
+You can jump to a tag by selecting the tag name from the menu. You can use the
+taglist menu independent of the taglist window i.e. you don't need to open the
+taglist window to get the taglist menu.
+
+When you switch between files/buffers, the taglist menu is automatically
+updated to display the tags defined in the current file/buffer.
+
+The tags are grouped by their type (variables, functions, classes, methods,
+etc.) and displayed as a separate sub-menu for each type. If all the tags
+defined in a file are of the same type (e.g. functions), then the sub-menu is
+not used.
+
+If the number of items in a tag type submenu exceeds the value specified by
+the 'Tlist_Max_Submenu_Items' variable, then the submenu will be split into
+multiple submenus. The default setting for 'Tlist_Max_Submenu_Items' is 25.
+The first and last tag names in the submenu are used to form the submenu name.
+The menu items are prefixed by alpha-numeric characters for easy selection by
+keyboard.
+
+If the popup menu support is enabled (the |'mousemodel'| option contains
+"popup"), then the tags menu is added to the popup menu. You can access
+the popup menu by right clicking on the GUI window.
+
+You can regenerate the tags menu by selecting the 'Tags->Refresh menu' entry.
+You can sort the tags listed in the menu either by name or by order by
+selecting the 'Tags->Sort menu by->Name/Order' menu entry.
+
+You can tear-off the Tags menu and keep it on the side of the Vim window
+for quickly locating the tags.
+
+Using the taglist plugin with the winmanager plugin~
+You can use the taglist plugin with the winmanager plugin. This will allow you
+to use the file explorer, buffer explorer and the taglist plugin at the same
+time in different windows. To use the taglist plugin with the winmanager
+plugin, set 'TagList' in the 'winManagerWindowLayout' variable. For example,
+to use the file explorer plugin and the taglist plugin at the same time, use
+the following setting: >
+
+	let winManagerWindowLayout = 'FileExplorer|TagList'
+<
+Getting help~
+If you have installed the taglist help file (this file), then you can use the
+Vim ":help taglist-<keyword>" command to get help on the various taglist
+topics.
+
+You can press the <F1> key in the taglist window to display the help
+information about using the taglist window. If you again press the <F1> key,
+the help information is removed from the taglist window.
+
+						*taglist-debug*
+Debugging the taglist plugin~
+You can use the ":TlistDebug" command to enable logging of the debug messages
+from the taglist plugin. To display the logged debug messages, you can use the
+":TlistMessages" command. To disable the logging of the debug messages, use
+the ":TlistUndebug" command.
+
+You can specify a file name to the ":TlistDebug" command to log the debug
+messages to a file. Otherwise, the debug messages are stored in a script-local
+variable. In the later case, to minimize memory usage, only the last 3000
+characters from the debug messages are stored.
+
+==============================================================================
+						*taglist-options*
+5. Options~
+
+A number of Vim variables control the behavior of the taglist plugin. These
+variables are initialized to a default value. By changing these variables you
+can change the behavior of the taglist plugin. You need to change these
+settings only if you want to change the behavior of the taglist plugin. You
+should use the |:let| command in your .vimrc file to change the setting of any
+of these variables. 
+
+The configurable taglist variables are listed below. For a detailed
+description of these variables refer to the text below this table.
+
+|'Tlist_Auto_Highlight_Tag'|	Automatically highlight the current tag in the
+				taglist.
+|'Tlist_Auto_Open'|		Open the taglist window when Vim starts.
+|'Tlist_Auto_Update'|		Automatically update the taglist to include
+				newly edited files.
+|'Tlist_Close_On_Select'|	Close the taglist window when a file or tag is
+				selected.
+|'Tlist_Compact_Format'|	Remove extra information and blank lines from
+       				the taglist window.
+|'Tlist_Ctags_Cmd'|		Specifies the path to the ctags utility.
+|'Tlist_Display_Prototype'|	Show prototypes and not tags in the taglist
+				window.
+|'Tlist_Display_Tag_Scope'|	Show tag scope next to the tag name.
+|'Tlist_Enable_Fold_Column'|	Show the fold indicator column in the taglist
+				window.
+|'Tlist_Exit_OnlyWindow'|	Close Vim if the taglist is the only window.
+|'Tlist_File_Fold_Auto_Close'|	Close tag folds for inactive buffers.
+|'Tlist_GainFocus_On_ToggleOpen'|
+				Jump to taglist window on open.
+|'Tlist_Highlight_Tag_On_BufEnter'|
+				On entering a buffer, automatically highlight
+				the current tag.
+|'Tlist_Inc_Winwidth'|		Increase the Vim window width to accommodate
+				the taglist window.
+|'Tlist_Max_Submenu_Items'|	Maximum number of items in a tags sub-menu.
+|'Tlist_Max_Tag_Length'|	Maximum tag length used in a tag menu entry.
+|'Tlist_Process_File_Always'|	Process files even when the taglist window is
+				closed.
+|'Tlist_Show_Menu'|		Display the tags menu.
+|'Tlist_Show_One_File'|		Show tags for the current buffer only.
+|'Tlist_Sort_Type'|		Sort method used for arranging the tags.
+|'Tlist_Use_Horiz_Window'|	Use a horizontally split window for the
+				taglist window.
+|'Tlist_Use_Right_Window'|	Place the taglist window on the right side.
+|'Tlist_Use_SingleClick'|	Single click on a tag jumps to it.
+|'Tlist_WinHeight'|		Horizontally split taglist window height.
+|'Tlist_WinWidth'|		Vertically split taglist window width.
+|'Tlist_javascript_Hide_Extras'| Hide extra tag data produced by jsctags.
+
+						*'Tlist_Auto_Highlight_Tag'*
+Tlist_Auto_Highlight_Tag~
+The taglist plugin will automatically highlight the current tag in the taglist
+window. If you want to disable this, then you can set the
+'Tlist_Auto_Highlight_Tag' variable to zero. Note that even though the current
+tag highlighting is disabled, the tags for a new file will still be added to
+the taglist window.
+>
+	let Tlist_Auto_Highlight_Tag = 0
+<
+With the above variable set to 1, you can use the ":TlistHighlightTag" command
+to highlight the current tag.
+
+						*'Tlist_Auto_Open'*
+Tlist_Auto_Open~
+To automatically open the taglist window, when you start Vim, you can set the
+'Tlist_Auto_Open' variable to 1. By default, this variable is set to zero and
+the taglist window will not be opened automatically on Vim startup.
+>
+	let Tlist_Auto_Open = 1
+<
+The taglist window is opened only when a supported type of file is opened on
+Vim startup. For example, if you open text files, then the taglist window will
+not be opened.
+
+						*'Tlist_Auto_Update'*
+Tlist_Auto_Update~
+When a new file is edited, the tags defined in the file are automatically
+processed and added to the taglist. To stop adding new files to the taglist,
+set the 'Tlist_Auto_Update' variable to zero. By default, this variable is set
+to 1.
+>
+	let Tlist_Auto_Update = 0
+<
+With the above variable set to 1, you can use the ":TlistUpdate" command to
+add the tags defined in the current file to the taglist.
+
+						*'Tlist_Close_On_Select'*
+Tlist_Close_On_Select~
+If you want to close the taglist window when a file or tag is selected, then
+set the 'Tlist_Close_On_Select' variable to 1. By default, this variable is
+set zero and when you select a tag or file from the taglist window, the window
+is not closed.
+>
+	let Tlist_Close_On_Select = 1
+<
+						*'Tlist_Compact_Format'*
+Tlist_Compact_Format~
+By default, empty lines are used to separate different tag types displayed for
+a file and the tags displayed for different files in the taglist window. If
+you want to display as many tags as possible in the taglist window, you can
+set the 'Tlist_Compact_Format' variable to 1 to get a compact display.
+>
+	let Tlist_Compact_Format = 1
+<
+						*'Tlist_Ctags_Cmd'*
+Tlist_Ctags_Cmd~
+The 'Tlist_Ctags_Cmd' variable specifies the location (path) of the exuberant
+ctags utility. If exuberant ctags is present in any one of the directories in
+the PATH environment variable, then there is no need to set this variable.
+
+The exuberant ctags tool can be installed under different names.  When the
+taglist plugin starts up, if the 'Tlist_Ctags_Cmd' variable is not set, it
+checks for the names exuberant-ctags, exctags, ctags, ctags.exe and tags in
+the PATH environment variable.  If any one of the named executable is found,
+then the Tlist_Ctags_Cmd variable is set to that name.
+
+If exuberant ctags is not present in one of the directories specified in the
+PATH environment variable, then set this variable to point to the location of
+the ctags utility in your system. Note that this variable should point to the
+fully qualified exuberant ctags location and NOT to the directory in which
+exuberant ctags is installed. If the exuberant ctags tool is not found in
+either PATH or in the specified location, then the taglist plugin will not be
+loaded. Examples:
+>
+	let Tlist_Ctags_Cmd = 'd:\tools\ctags.exe'
+	let Tlist_Ctags_Cmd = '/usr/local/bin/ctags'
+<
+						*'Tlist_Display_Prototype'*
+Tlist_Display_Prototype~
+By default, only the tag name will be displayed in the taglist window. If you
+like to see tag prototypes instead of names, set the 'Tlist_Display_Prototype'
+variable to 1. By default, this variable is set to zero and only tag names
+will be displayed.
+>
+	let Tlist_Display_Prototype = 1
+<
+						*'Tlist_Display_Tag_Scope'*
+Tlist_Display_Tag_Scope~
+By default, the scope of a tag (like a C++ class) will be displayed in
+square brackets next to the tag name. If you don't want the tag scopes
+to be displayed, then set the 'Tlist_Display_Tag_Scope' to zero. By default,
+this variable is set to 1 and the tag scopes will be displayed.
+>
+	let Tlist_Display_Tag_Scope = 0
+<
+						*'Tlist_Enable_Fold_Column'*
+Tlist_Enable_Fold_Column~
+By default, the Vim fold column is enabled and displayed in the taglist
+window. If you wish to disable this (for example, when you are working with a
+narrow Vim window or terminal), you can set the 'Tlist_Enable_Fold_Column'
+variable to zero.
+>
+	let Tlist_Enable_Fold_Column = 1
+<
+						*'Tlist_Exit_OnlyWindow'*
+Tlist_Exit_OnlyWindow~
+If you want to exit Vim if only the taglist window is currently opened, then
+set the 'Tlist_Exit_OnlyWindow' variable to 1. By default, this variable is
+set to zero and the Vim instance will not be closed if only the taglist window
+is present.
+>
+	let Tlist_Exit_OnlyWindow = 1
+<
+						*'Tlist_File_Fold_Auto_Close'*
+Tlist_File_Fold_Auto_Close~
+By default, the tags tree displayed in the taglist window for all the files is
+opened. You can close/fold the tags tree for the files manually. To
+automatically close the tags tree for inactive files, you can set the
+'Tlist_File_Fold_Auto_Close' variable to 1. When this variable is set to 1,
+the tags tree for the current buffer is automatically opened and for all the
+other buffers is closed.
+>
+	let Tlist_File_Fold_Auto_Close = 1
+<
+					    *'Tlist_GainFocus_On_ToggleOpen'*
+Tlist_GainFocus_On_ToggleOpen~
+When the taglist window is opened using the ':TlistToggle' command, this
+option controls whether the cursor is moved to the taglist window or remains
+in the current window. By default, this option is set to 0 and the cursor
+remains in the current window. When this variable is set to 1, the cursor
+moves to the taglist window after opening the taglist window.
+>
+	let Tlist_GainFocus_On_ToggleOpen = 1
+<
+					    *'Tlist_Highlight_Tag_On_BufEnter'*
+Tlist_Highlight_Tag_On_BufEnter~
+When you enter a Vim buffer/window, the current tag in that buffer/window is
+automatically highlighted in the taglist window. If the current tag name is
+not visible in the taglist window, then the taglist window contents are
+scrolled to make that tag name visible. If you like to disable the automatic
+highlighting of the current tag when entering a buffer, you can set the
+'Tlist_Highlight_Tag_On_BufEnter' variable to zero. The default setting for
+this variable is 1.
+>
+	let Tlist_Highlight_Tag_On_BufEnter = 0
+<
+						*'Tlist_Inc_Winwidth'*
+Tlist_Inc_Winwidth~
+By default, when the width of the window is less than 100 and a new taglist
+window is opened vertically, then the window width is increased by the value
+set in the 'Tlist_WinWidth' variable to accommodate the new window. The value
+of this variable is used only if you are using a vertically split taglist
+window.
+
+If your terminal doesn't support changing the window width from Vim (older
+version of xterm running in a Unix system) or if you see any weird problems in
+the screen due to the change in the window width or if you prefer not to
+adjust the window width then set the 'Tlist_Inc_Winwidth' variable to zero.
+CAUTION: If you are using the MS-Windows version of Vim in a MS-DOS command
+window then you must set this variable to zero, otherwise the system may hang
+due to a Vim limitation (explained in :help win32-problems)
+>
+	let Tlist_Inc_Winwidth = 0
+<
+						*'Tlist_Max_Submenu_Items'*
+Tlist_Max_Submenu_Items~
+If a file contains too many tags of a particular type (function, variable,
+class, etc.), greater than that specified by the 'Tlist_Max_Submenu_Items'
+variable, then the menu for that tag type will be split into multiple
+sub-menus. The default setting for the 'Tlist_Max_Submenu_Items' variable is
+25.  This can be changed by setting the 'Tlist_Max_Submenu_Items' variable:
+>
+	let Tlist_Max_Submenu_Items = 20
+<
+The name of the submenu is formed using the names of the first and the last
+tag entries in that submenu.
+
+						*'Tlist_Max_Tag_Length'*
+Tlist_Max_Tag_Length~
+Only the first 'Tlist_Max_Tag_Length' characters from the tag names will be
+used to form the tag type submenu name. The default value for this variable is
+10.  Change the 'Tlist_Max_Tag_Length' setting if you want to include more or
+less characters:
+>
+	let Tlist_Max_Tag_Length = 10
+<
+						*'Tlist_Process_File_Always'*
+Tlist_Process_File_Always~
+By default, the taglist plugin will generate and process the tags defined in
+the newly opened files only when the taglist window is opened or when the
+taglist menu is enabled. When the taglist window is closed, the taglist plugin
+will stop processing the tags for newly opened files.
+
+You can set the 'Tlist_Process_File_Always' variable to 1 to generate the list
+of tags for new files even when the taglist window is closed and the taglist
+menu is disabled.
+>
+	let Tlist_Process_File_Always = 1
+<
+To use the ":TlistShowTag" and the ":TlistShowPrototype" commands without the
+taglist window and the taglist menu, you should set this variable to 1.
+
+						*'Tlist_Show_Menu'*
+Tlist_Show_Menu~
+When using GUI Vim, you can display the tags defined in the current file in a
+menu named "Tags". By default, this feature is turned off. To turn on this
+feature, set the 'Tlist_Show_Menu' variable to 1:
+>
+	let Tlist_Show_Menu = 1
+<
+						*'Tlist_Show_One_File'*
+Tlist_Show_One_File~
+By default, the taglist plugin will display the tags defined in all the loaded
+buffers in the taglist window. If you prefer to display the tags defined only
+in the current buffer, then you can set the 'Tlist_Show_One_File' to 1. When
+this variable is set to 1, as you switch between buffers, the taglist window
+will be refreshed to display the tags for the current buffer and the tags for
+the previous buffer will be removed.
+>
+	let Tlist_Show_One_File = 1
+<
+						*'Tlist_Sort_Type'*
+Tlist_Sort_Type~
+The 'Tlist_Sort_Type' variable specifies the sort order for the tags in the
+taglist window. The tags can be sorted either alphabetically by their name or
+by the order of their appearance in the file (chronological order). By
+default, the tag names will be listed by the order in which they are defined
+in the file. You can change the sort type (from name to order or from order to
+name) by pressing the "s" key in the taglist window. You can also change the
+default sort order by setting 'Tlist_Sort_Type' to "name" or "order":
+>
+	let Tlist_Sort_Type = "name"
+<
+						*'Tlist_Use_Horiz_Window'*
+Tlist_Use_Horiz_Window~
+Be default, the tag names are displayed in a vertically split window. If you
+prefer a horizontally split window, then set the 'Tlist_Use_Horiz_Window'
+variable to 1. If you are running MS-Windows version of Vim in a MS-DOS
+command window, then you should use a horizontally split window instead of a
+vertically split window. Also, if you are using an older version of xterm in a
+Unix system that doesn't support changing the xterm window width, you should
+use a horizontally split window.
+>
+	let Tlist_Use_Horiz_Window = 1
+<
+						*'Tlist_Use_Right_Window'*
+Tlist_Use_Right_Window~
+By default, the vertically split taglist window will appear on the left hand
+side. If you prefer to open the window on the right hand side, you can set the
+'Tlist_Use_Right_Window' variable to 1:
+>
+	let Tlist_Use_Right_Window = 1
+<
+						*'Tlist_Use_SingleClick'*
+Tlist_Use_SingleClick~
+By default, when you double click on the tag name using the left mouse 
+button, the cursor will be positioned at the definition of the tag. You 
+can set the 'Tlist_Use_SingleClick' variable to 1 to jump to a tag when
+you single click on the tag name using the mouse. By default this variable
+is set to zero.
+>
+	let Tlist_Use_SingleClick = 1
+<
+Due to a bug in Vim, if you set 'Tlist_Use_SingleClick' to 1 and try to resize
+the taglist window using the mouse, then Vim will crash. This problem is fixed
+in Vim 6.3 and above. In the meantime, instead of resizing the taglist window
+using the mouse, you can use normal Vim window resizing commands to resize the
+taglist window.
+
+						*'Tlist_WinHeight'*
+Tlist_WinHeight~
+The default height of the horizontally split taglist window is 10. This can be
+changed by modifying the 'Tlist_WinHeight' variable:
+>
+	let Tlist_WinHeight = 20
+<
+The |'winfixheight'| option is set for the taglist window, to maintain the
+height of the taglist window, when new Vim windows are opened and existing
+windows are closed.
+
+						*'Tlist_WinWidth'*
+Tlist_WinWidth~
+The default width of the vertically split taglist window is 30. This can be
+changed by modifying the 'Tlist_WinWidth' variable:
+>
+	let Tlist_WinWidth = 20
+<
+Setting Tlist_WinWidth to 'auto' causes the taglist window to resize
+automatically to fit the contents.
+
+Note that the value of the |'winwidth'| option setting determines the minimum
+width of the current window. If you set the 'Tlist_WinWidth' variable to a
+value less than that of the |'winwidth'| option setting, then Vim will use the
+value of the |'winwidth'| option.
+
+When new Vim windows are opened and existing windows are closed, the taglist
+plugin will try to maintain the width of the taglist window to the size
+specified by the 'Tlist_WinWidth' variable.
+
+						*'Tlist_javascript_Hide_Extras'*
+Tlist_javascript_Hide_Extras~
+
+To hide the type inference data generated by jsctags, modify this variable:
+
+    let Tlist_javascript_Hide_Extras = ['type']
+
+Note that 'javascript' here is not capitalized!
+
+==============================================================================
+						*taglist-commands*
+6. Commands~
+
+The taglist plugin provides the following ex-mode commands:
+
+|:TlistAddFiles|	Add multiple files to the taglist.
+|:TlistAddFilesRecursive|
+			Add files recursively to the taglist.
+|:TlistClose|		Close the taglist window.
+|:TlistDebug|		Start logging of taglist debug messages.
+|:TlistLock|		Stop adding new files to the taglist.
+|:TlistMessages|	Display the logged taglist plugin debug messages.
+|:TlistOpen|		Open and jump to the taglist window.
+|:TlistSessionSave|	Save the information about files and tags in the
+			taglist to a session file.
+|:TlistSessionLoad|	Load the information about files and tags stored
+			in a session file to taglist.
+|:TlistShowPrototype|	Display the prototype of the tag at or before the
+		    	specified line number.
+|:TlistShowTag|		Display the name of the tag defined at or before the
+			specified line number.
+|:TlistHighlightTag|	Highlight the current tag in the taglist window.
+|:TlistToggle|		Open or close (toggle) the taglist window.
+|:TlistUndebug|		Stop logging of taglist debug messages.
+|:TlistUnlock|		Start adding new files to the taglist.
+|:TlistUpdate|		Update the tags for the current buffer.
+
+						*:TlistAddFiles*
+:TlistAddFiles {file(s)} [file(s) ...]
+		Add one or more specified files to the taglist. You can
+		specify multiple filenames using wildcards. To specify a
+		file name with space character, you should escape the space
+		character with a backslash.
+		Examples:
+>
+		    :TlistAddFiles *.c *.cpp
+		    :TlistAddFiles file1.html file2.html
+<
+		If you specify a large number of files, then it will take some
+		time for the taglist plugin to process all of them. The
+		specified files will not be edited in a Vim window and will
+		not be added to the Vim buffer list.
+
+						*:TlistAddFilesRecursive*
+:TlistAddFilesRecursive {directory} [ {pattern} ]
+		Add files matching {pattern} recursively from the specified
+		{directory} to the taglist. If {pattern} is not specified,
+		then '*' is assumed. To specify the current directory, use "."
+		for {directory}. To specify a directory name with space
+		character, you should escape the space character with a
+		backslash.
+		Examples:
+>
+		    :TlistAddFilesRecursive myproject *.java
+		    :TlistAddFilesRecursive smallproject
+<
+		If large number of files are present in the specified
+		directory tree, then it will take some time for the taglist
+		plugin to process all of them.
+
+						*:TlistClose*
+:TlistClose	Close the taglist window. This command can be used from any
+		one of the Vim windows.
+
+						*:TlistDebug*
+:TlistDebug [filename]
+		Start logging of debug messages from the taglist plugin.
+		If {filename} is specified, then the debug messages are stored
+		in the specified file. Otherwise, the debug messages are
+		stored in a script local variable. If the file {filename} is
+		already present, then it is overwritten.
+
+						*:TlistLock*
+:TlistLock
+		Lock the taglist and don't process new files. After this
+		command is executed, newly edited files will not be added to
+		the taglist.
+
+						*:TlistMessages*
+:TlistMessages
+		Display the logged debug messages from the taglist plugin
+		in a window.  This command works only when logging to a
+		script-local variable.
+
+						*:TlistOpen*
+:TlistOpen	Open and jump to the taglist window. Creates the taglist
+		window, if the window is not opened currently. After executing
+		this command, the cursor is moved to the taglist window.  When
+		the taglist window is opened for the first time, all the files
+		in the buffer list are processed and the tags defined in them
+		are displayed in the taglist window.
+
+						*:TlistSessionSave*
+:TlistSessionSave {filename}
+		Saves the information about files and tags in the taglist to
+		the specified file. This command can be used to save and
+		restore the taglist contents across Vim sessions.
+
+						*:TlistSessionLoad*
+:TlistSessionLoad {filename}
+		Load the information about files and tags stored in the
+		specified session file to the taglist.
+
+						*:TlistShowPrototype*
+:TlistShowPrototype [filename] [linenumber]
+		Display the prototype of the tag at or before the specified
+		line number. If the file name and the line number are not
+		specified, then the current file name and line number are
+		used. A tag spans multiple lines starting from the line where
+		it is defined to the line before the next tag. This command
+		displays the prototype for the tag for any line number in this
+		range. 
+
+						*:TlistShowTag*
+:TlistShowTag [filename] [linenumber]
+		Display the name of the tag defined at or before the specified
+		line number. If the file name and the line number are not
+		specified, then the current file name and line number are
+		used. A tag spans multiple lines starting from the line where
+		it is defined to the line before the next tag. This command
+		displays the tag name for any line number in this range. 
+
+						*:TlistHighlightTag*
+:TlistHighlightTag
+		Highlight the current tag in the taglist window. By default,
+		the taglist plugin periodically updates the taglist window to
+		highlight the current tag. This command can be used to force
+		the taglist plugin to highlight the current tag.
+
+						*:TlistToggle*
+:TlistToggle	Open or close (toggle) the taglist window. Opens the taglist
+		window, if the window is not opened currently. Closes the
+		taglist window, if the taglist window is already opened. When
+		the taglist window is opened for the first time, all the files
+		in the buffer list are processed and the tags are displayed in
+		the taglist window. After executing this command, the cursor
+		is not moved from the current window to the taglist window.
+
+						*:TlistUndebug*
+:TlistUndebug
+		Stop logging of debug messages from the taglist plugin.
+
+						*:TlistUnlock*
+:TlistUnlock
+		Unlock the taglist and start processing newly edited files.
+
+						*:TlistUpdate*
+:TlistUpdate	Update the tags information for the current buffer. This
+		command can be used to re-process the current file/buffer and
+		get the tags information. As the taglist plugin uses the file
+		saved in the disk (instead of the file displayed in a Vim
+		buffer), you should save a modified buffer before you update
+		the taglist. Otherwise the listed tags will not include the
+		new tags created in the buffer. You can use this command even
+		when the taglist window is not opened.
+
+==============================================================================
+						*taglist-functions*
+7. Global functions~
+
+The taglist plugin provides several global functions that can be used from
+other Vim plugins to interact with the taglist plugin. These functions are
+described below.
+
+|Tlist_Update_File_Tags()|		Update the tags for the specified file
+|Tlist_Get_Tag_Prototype_By_Line()|	Return the prototype of the tag at or
+				    	before the specified line number in the
+				    	specified file.
+|Tlist_Get_Tagname_By_Line()|		Return the name of the tag at or
+					before the specified line number in
+					the specified file.
+|Tlist_Set_App()|			Set the name of the application
+					controlling the taglist window.
+
+					    *Tlist_Update_File_Tags()*
+Tlist_Update_File_Tags({filename}, {filetype})
+		Update the tags for the file {filename}. The second argument
+		specifies the Vim filetype for the file. If the taglist plugin
+		has not processed the file previously, then the exuberant
+		ctags tool is invoked to generate the tags for the file.
+
+					    *Tlist_Get_Tag_Prototype_By_Line()*
+Tlist_Get_Tag_Prototype_By_Line([{filename}, {linenumber}])
+		Return the prototype of the tag at or before the specified
+		line number in the specified file. If the filename and line
+		number are not specified, then the current buffer name and the
+		current line number are used.
+
+					    *Tlist_Get_Tagname_By_Line()*
+Tlist_Get_Tagname_By_Line([{filename}, {linenumber}])
+		Return the name of the tag at or before the specified line
+		number in the specified file. If the filename and line number
+		are not specified, then the current buffer name and the
+		current line number are used.
+
+					    *Tlist_Set_App()*
+Tlist_Set_App({appname})
+		Set the name of the plugin that controls the taglist plugin
+		window and buffer. This can be used to integrate the taglist
+		plugin with other Vim plugins.
+		
+		For example, the winmanager plugin and the Cream package use
+		this function and specify the appname as "winmanager" and
+		"cream" respectively.
+		
+		By default, the taglist plugin is a stand-alone plugin and
+		controls the taglist window and buffer. If the taglist window
+		is controlled by an external plugin, then the appname should
+		be set appropriately.
+
+==============================================================================
+						*taglist-extend*
+8. Extending~
+
+The taglist plugin supports all the languages supported by the exuberant ctags
+tool, which includes the following languages: Assembly, ASP, Awk, Beta, C,
+C++, C#, Cobol, Eiffel, Erlang, Fortran, HTML, Java, Javascript, Lisp, Lua,
+Make, Pascal, Perl, PHP, Python, Rexx, Ruby, Scheme, Shell, Slang, SML, Sql,
+TCL, Verilog, Vim and Yacc.
+
+You can extend the taglist plugin to add support for new languages and also
+modify the support for the above listed languages.
+
+You should NOT make modifications to the taglist plugin script file to add
+support for new languages. You will lose these changes when you upgrade to the
+next version of the taglist plugin. Instead you should follow the below
+described instructions to extend the taglist plugin.
+
+You can extend the taglist plugin by setting variables in the .vimrc or _vimrc
+file. The name of these variables depends on the language name and is
+described below.
+
+Modifying support for an existing language~
+To modify the support for an already supported language, you have to set the
+tlist_xxx_settings variable in the ~/.vimrc or $HOME/_vimrc file. Replace xxx
+with the Vim filetype name for the language file.  For example, to modify the
+support for the perl language files, you have to set the tlist_perl_settings
+variable. To modify the support for java files, you have to set the
+tlist_java_settings variable.
+
+To determine the filetype name used by Vim for a file, use the following
+command in the buffer containing the file:
+
+	:set filetype
+
+The above command will display the Vim filetype for the current buffer.
+
+The format of the value set in the tlist_xxx_settings variable is
+
+    <language_name>;flag1:name1;flag2:name2;flag3:name3
+
+The different fields in the value are separated by the ';' character.
+
+The first field 'language_name' is the name used by exuberant ctags to refer
+to this language file. This name can be different from the file type name used
+by Vim. For example, for C++, the language name used by ctags is 'c++' but the
+filetype name used by Vim is 'cpp'. To get the list of language names
+supported by exuberant ctags, use the following command:
+
+	$ ctags --list-maps=all
+
+The remaining fields follow the format "flag:name". The sub-field 'flag' is
+the language specific flag used by exuberant ctags to generate the
+corresponding tags. For example, for the C language, to list only the
+functions, the 'f' flag is used. To get the list of flags supported by
+exuberant ctags for the various languages use the following command:
+
+	$ ctags --list-kinds=all
+
+The sub-field 'name' specifies the title text to use for displaying the tags
+of a particular type. For example, 'name' can be set to 'functions'. This
+field can be set to any text string name.
+
+For example, to list only the classes and functions defined in a C++ language
+file, add the following line to your .vimrc file:
+
+	let tlist_cpp_settings = 'c++;c:class;f:function'
+
+In the above setting, 'cpp' is the Vim filetype name and 'c++' is the name
+used by the exuberant ctags tool. 'c' and 'f' are the flags passed to
+exuberant ctags to list C++ classes and functions and 'class' is the title
+used for the class tags and 'function' is the title used for the function tags
+in the taglist window.
+
+For example, to display only functions defined in a C file and to use "My
+Functions" as the title for the function tags, use
+
+	let tlist_c_settings = 'c;f:My Functions'
+
+When you set the tlist_xxx_settings variable, you will override the default
+setting used by the taglist plugin for the 'xxx' language. You cannot add to
+the default options used by the taglist plugin for a particular file type. To
+add to the options used by the taglist plugin for a language, copy the option
+values from the taglist plugin file to your .vimrc file and modify it.
+
+Adding support for a new language~
+If you want to add support for a new language to the taglist plugin, you need
+to first extend the exuberant ctags tool. For more information about extending
+exuberant ctags, visit the following page:
+
+    http://ctags.sourceforge.net/EXTENDING.html
+
+To add support for a new language, set the tlist_xxx_settings variable in the
+~/.vimrc file appropriately as described above. Replace 'xxx' in the variable
+name with the Vim filetype name for the new language.
+
+For example, to extend the taglist plugin to support the latex language, you
+can use the following line (assuming, you have already extended exuberant
+ctags to support the latex language):
+
+	let tlist_tex_settings='latex;b:bibitem;c:command;l:label'
+
+With the above line, when you edit files of filetype "tex" in Vim, the taglist
+plugin will invoke the exuberant ctags tool passing the "latex" filetype and
+the flags b, c and l to generate the tags. The text heading 'bibitem',
+'command' and 'label' will be used in the taglist window for the tags which
+are generated for the flags b, c and l respectively.
+
+==============================================================================
+						*taglist-faq*
+9. Frequently Asked Questions~
+
+Q. The taglist plugin doesn't work. The taglist window is empty and the tags
+   defined in a file are not displayed. 
+A. Are you using Vim version 6.0 and above? The taglist plugin relies on the
+   features supported by Vim version 6.0 and above. You can use the following
+   command to get the Vim version:
+>
+	$ vim --version
+<
+   Are you using exuberant ctags version 5.0 and above? The taglist plugin
+   relies on the features supported by exuberant ctags and will not work with
+   GNU ctags or the Unix ctags utility. You can use the following command to
+   determine whether the ctags installed in your system is exuberant ctags:
+>
+	$ ctags --version
+<
+   Is exuberant ctags present in one of the directories in your PATH? If not,
+   you need to set the Tlist_Ctags_Cmd variable to point to the location of
+   exuberant ctags. Use the following Vim command to verify that this is setup
+   correctly:
+>
+	:echo system(Tlist_Ctags_Cmd . ' --version')
+<
+   The above command should display the version information for exuberant
+   ctags.
+
+   Did you turn on the Vim filetype detection? The taglist plugin relies on
+   the filetype detected by Vim and passes the filetype to the exuberant ctags
+   utility to parse the tags. Check the output of the following Vim command:
+>
+	:filetype
+<
+   The output of the above command should contain "filetype detection:ON".
+   To turn on the filetype detection, add the following line to the .vimrc or
+   _vimrc file:
+>
+	filetype on
+<
+   Is your version of Vim compiled with the support for the system() function?
+   The following Vim command should display 1:
+>
+	:echo exists('*system')
+<
+   In some Linux distributions (particularly Suse Linux), the default Vim
+   installation is built without the support for the system() function. The
+   taglist plugin uses the system() function to invoke the exuberant ctags
+   utility. You need to rebuild Vim after enabling the support for the
+   system() function. If you use the default build options, the system()
+   function will be supported. 
+
+   Do you have the |'shellslash'| option set? You can try disabling the
+   |'shellslash'| option. When the taglist plugin invokes the exuberant ctags
+   utility with the path to the file, if the incorrect slashes are used, then
+   you will see errors.
+   
+   Check the shell related Vim options values using the following command:
+>
+	:set shell? shellcmdflag? shellpipe?
+	:set shellquote? shellredir? shellxquote?
+<
+   If these options are set in your .vimrc or _vimrc file, try removing those
+   lines.
+
+   Are you using a Unix shell in a MS-Windows environment? For example,
+   the Unix shell from the MKS-toolkit. Do you have the SHELL environment
+   set to point to this shell? You can try resetting the SHELL environment
+   variable.
+
+   If you are using a Unix shell on MS-Windows, you should try to use
+   exuberant ctags that is compiled for Unix-like environments so that
+   exuberant ctags will understand path names with forward slash characters.
+
+   Is your filetype supported by the exuberant ctags utility? The file types
+   supported by the exuberant ctags utility are listed in the ctags help. If a
+   file type is not supported, you have to extend exuberant ctags. You can use
+   the following command to list the filetypes supported by exuberant ctags:
+>
+	ctags --list-languages
+<
+   Run the following command from the shell prompt and check whether the tags
+   defined in your file are listed in the output from exuberant ctags:
+>
+	ctags -f - --format=2 --excmd=pattern --fields=nks <filename>
+<
+   If you see your tags in the output from the above command, then the
+   exuberant ctags utility is properly parsing your file.
+
+   Do you have the .ctags or _ctags or the ctags.cnf file in your home
+   directory for specifying default options or for extending exuberant ctags?
+   If you do have this file, check the options in this file and make sure
+   these options are not interfering with the operation of the taglist plugin.
+
+   If you are using MS-Windows, check the value of the TEMP and TMP
+   environment variables. If these environment variables are set to a path
+   with space characters in the name, then try using the DOS 8.3 short name
+   for the path or set them to a path without the space characters in the
+   name. For example, if the temporary directory name is "C:\Documents and
+   Settings\xyz\Local Settings\Temp", then try setting the TEMP variable to
+   the following:
+>
+	set TEMP=C:\DOCUMEN~1\xyz\LOCALS~1\Temp
+<
+   If exuberant ctags is installed in a directory with space characters in the
+   name, then try adding the directory to the PATH environment variable or try
+   setting the 'Tlist_Ctags_Cmd' variable to the shortest path name to ctags
+   or try copying the exuberant ctags to a path without space characters in
+   the name. For example, if exuberant ctags is installed in the directory
+   "C:\Program Files\Ctags", then try setting the 'Tlist_Ctags_Cmd' variable
+   as below:
+>
+	let Tlist_Ctags_Cmd='C:\Progra~1\Ctags\ctags.exe'
+<
+   If you are using a cygwin compiled version of exuberant ctags on MS-Windows,
+   make sure that either you have the cygwin compiled sort utility installed
+   and available in your PATH or compile exuberant ctags with internal sort
+   support. Otherwise, when exuberant ctags sorts the tags output by invoking
+   the sort utility, it may end up invoking the MS-Windows version of
+   sort.exe, thereby resulting in failure.
+
+Q. When I try to open the taglist window, I am seeing the following error
+   message. How do I fix this problem?
+
+   Taglist: Failed to generate tags for /my/path/to/file
+   ctags: illegal option -- -^@usage: ctags [-BFadtuwvx] [-f tagsfile] file ...
+
+A. The taglist plugin will work only with the exuberant ctags tool. You
+   cannot use the GNU ctags or the Unix ctags program with the taglist plugin.
+   You will see an error message similar to the one shown above, if you try
+   use a non-exuberant ctags program with Vim. To fix this problem, either add
+   the exuberant ctags tool location to the PATH environment variable or set
+   the 'Tlist_Ctags_Cmd' variable.
+
+Q. A file has more than one tag with the same name. When I select a tag name
+   from the taglist window, the cursor is positioned at the incorrect tag
+   location. 
+A. The taglist plugin uses the search pattern generated by the exuberant ctags
+   utility to position the cursor at the location of a tag definition. If a
+   file has more than one tag with the same name and same prototype, then the
+   search pattern will be the same. In this case, when searching for the tag
+   pattern, the cursor may be positioned at the incorrect location. 
+
+Q. I have made some modifications to my file and introduced new
+   functions/classes/variables. I have not yet saved my file. The taglist
+   plugin is not displaying the new tags when I update the taglist window.
+A. The exuberant ctags utility will process only files that are present in the
+   disk. To list the tags defined in a file, you have to save the file and
+   then update the taglist window. 
+
+Q. I have created a ctags file using the exuberant ctags utility for my source
+   tree. How do I configure the taglist plugin to use this tags file? 
+A. The taglist plugin doesn't use a tags file stored in disk. For every opened
+   file, the taglist plugin invokes the exuberant ctags utility to get the
+   list of tags dynamically. The Vim system() function is used to invoke
+   exuberant ctags and get the ctags output. This function internally uses a
+   temporary file to store the output. This file is deleted after the output
+   from the command is read. So you will never see the file that contains the
+   output of exuberant ctags.
+
+Q. When I set the |'updatetime'| option to a low value (less than 1000) and if
+   I keep pressing a key with the taglist window open, the current buffer
+   contents are changed. Why is this?
+A. The taglist plugin uses the |CursorHold| autocmd to highlight the current
+   tag. The CursorHold autocmd triggers for every |'updatetime'| milliseconds.
+   If the |'updatetime'| option is set to a low value, then the CursorHold
+   autocmd will be triggered frequently. As the taglist plugin changes
+   the focus to the taglist window to highlight the current tag, this could
+   interfere with the key movement resulting in changing the contents of
+   the current buffer. The workaround for this problem is to not set the
+   |'updatetime'| option to a low value.
+
+==============================================================================
+						*taglist-license*
+10. License~
+Permission is hereby granted to use and distribute the taglist plugin, with or
+without modifications, provided that this copyright notice is copied with it.
+Like anything else that's free, taglist.vim is provided *as is* and comes with
+no warranty of any kind, either expressed or implied. In no event will the
+copyright holder be liable for any damamges resulting from the use of this
+software.
+
+==============================================================================
+						*taglist-todo*
+11. Todo~
+
+1. Group tags according to the scope and display them. For example,
+   group all the tags belonging to a C++/Java class 
+2. Support for displaying tags in a modified (not-yet-saved) file. 
+3. Automatically open the taglist window only for selected filetypes.
+   For other filetypes, close the taglist window. 
+4. When using the shell from the MKS toolkit, the taglist plugin 
+   doesn't work.
+5. The taglist plugin doesn't work with files edited remotely using the
+   netrw plugin. The exuberant ctags utility cannot process files over
+   scp/rcp/ftp, etc.
+
+==============================================================================
+
+vim:tw=78:ts=8:noet:ft=help:
diff --git a/vimrc/.vim/bundle/taglist-plus/doc/tags b/vimrc/.vim/bundle/taglist-plus/doc/tags
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/bundle/taglist-plus/doc/tags
@@ -0,0 +1,62 @@
+'Tlist_Auto_Highlight_Tag'	taglist-plus.txt	/*'Tlist_Auto_Highlight_Tag'*
+'Tlist_Auto_Open'	taglist-plus.txt	/*'Tlist_Auto_Open'*
+'Tlist_Auto_Update'	taglist-plus.txt	/*'Tlist_Auto_Update'*
+'Tlist_Close_On_Select'	taglist-plus.txt	/*'Tlist_Close_On_Select'*
+'Tlist_Compact_Format'	taglist-plus.txt	/*'Tlist_Compact_Format'*
+'Tlist_Ctags_Cmd'	taglist-plus.txt	/*'Tlist_Ctags_Cmd'*
+'Tlist_Display_Prototype'	taglist-plus.txt	/*'Tlist_Display_Prototype'*
+'Tlist_Display_Tag_Scope'	taglist-plus.txt	/*'Tlist_Display_Tag_Scope'*
+'Tlist_Enable_Fold_Column'	taglist-plus.txt	/*'Tlist_Enable_Fold_Column'*
+'Tlist_Exit_OnlyWindow'	taglist-plus.txt	/*'Tlist_Exit_OnlyWindow'*
+'Tlist_File_Fold_Auto_Close'	taglist-plus.txt	/*'Tlist_File_Fold_Auto_Close'*
+'Tlist_GainFocus_On_ToggleOpen'	taglist-plus.txt	/*'Tlist_GainFocus_On_ToggleOpen'*
+'Tlist_Highlight_Tag_On_BufEnter'	taglist-plus.txt	/*'Tlist_Highlight_Tag_On_BufEnter'*
+'Tlist_Inc_Winwidth'	taglist-plus.txt	/*'Tlist_Inc_Winwidth'*
+'Tlist_Max_Submenu_Items'	taglist-plus.txt	/*'Tlist_Max_Submenu_Items'*
+'Tlist_Max_Tag_Length'	taglist-plus.txt	/*'Tlist_Max_Tag_Length'*
+'Tlist_Process_File_Always'	taglist-plus.txt	/*'Tlist_Process_File_Always'*
+'Tlist_Show_Menu'	taglist-plus.txt	/*'Tlist_Show_Menu'*
+'Tlist_Show_One_File'	taglist-plus.txt	/*'Tlist_Show_One_File'*
+'Tlist_Sort_Type'	taglist-plus.txt	/*'Tlist_Sort_Type'*
+'Tlist_Use_Horiz_Window'	taglist-plus.txt	/*'Tlist_Use_Horiz_Window'*
+'Tlist_Use_Right_Window'	taglist-plus.txt	/*'Tlist_Use_Right_Window'*
+'Tlist_Use_SingleClick'	taglist-plus.txt	/*'Tlist_Use_SingleClick'*
+'Tlist_WinHeight'	taglist-plus.txt	/*'Tlist_WinHeight'*
+'Tlist_WinWidth'	taglist-plus.txt	/*'Tlist_WinWidth'*
+'Tlist_javascript_Hide_Extras'	taglist-plus.txt	/*'Tlist_javascript_Hide_Extras'*
+:TlistAddFiles	taglist-plus.txt	/*:TlistAddFiles*
+:TlistAddFilesRecursive	taglist-plus.txt	/*:TlistAddFilesRecursive*
+:TlistClose	taglist-plus.txt	/*:TlistClose*
+:TlistDebug	taglist-plus.txt	/*:TlistDebug*
+:TlistHighlightTag	taglist-plus.txt	/*:TlistHighlightTag*
+:TlistLock	taglist-plus.txt	/*:TlistLock*
+:TlistMessages	taglist-plus.txt	/*:TlistMessages*
+:TlistOpen	taglist-plus.txt	/*:TlistOpen*
+:TlistSessionLoad	taglist-plus.txt	/*:TlistSessionLoad*
+:TlistSessionSave	taglist-plus.txt	/*:TlistSessionSave*
+:TlistShowPrototype	taglist-plus.txt	/*:TlistShowPrototype*
+:TlistShowTag	taglist-plus.txt	/*:TlistShowTag*
+:TlistToggle	taglist-plus.txt	/*:TlistToggle*
+:TlistUndebug	taglist-plus.txt	/*:TlistUndebug*
+:TlistUnlock	taglist-plus.txt	/*:TlistUnlock*
+:TlistUpdate	taglist-plus.txt	/*:TlistUpdate*
+Tlist_Get_Tag_Prototype_By_Line()	taglist-plus.txt	/*Tlist_Get_Tag_Prototype_By_Line()*
+Tlist_Get_Tagname_By_Line()	taglist-plus.txt	/*Tlist_Get_Tagname_By_Line()*
+Tlist_Set_App()	taglist-plus.txt	/*Tlist_Set_App()*
+Tlist_Update_File_Tags()	taglist-plus.txt	/*Tlist_Update_File_Tags()*
+taglist-commands	taglist-plus.txt	/*taglist-commands*
+taglist-debug	taglist-plus.txt	/*taglist-debug*
+taglist-extend	taglist-plus.txt	/*taglist-extend*
+taglist-faq	taglist-plus.txt	/*taglist-faq*
+taglist-functions	taglist-plus.txt	/*taglist-functions*
+taglist-install	taglist-plus.txt	/*taglist-install*
+taglist-intro	taglist-plus.txt	/*taglist-intro*
+taglist-keys	taglist-plus.txt	/*taglist-keys*
+taglist-license	taglist-plus.txt	/*taglist-license*
+taglist-menu	taglist-plus.txt	/*taglist-menu*
+taglist-options	taglist-plus.txt	/*taglist-options*
+taglist-plus.txt	taglist-plus.txt	/*taglist-plus.txt*
+taglist-requirements	taglist-plus.txt	/*taglist-requirements*
+taglist-session	taglist-plus.txt	/*taglist-session*
+taglist-todo	taglist-plus.txt	/*taglist-todo*
+taglist-using	taglist-plus.txt	/*taglist-using*
diff --git a/vimrc/.vim/bundle/taglist-plus/plugin/taglist-plus.vim b/vimrc/.vim/bundle/taglist-plus/plugin/taglist-plus.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/bundle/taglist-plus/plugin/taglist-plus.vim
@@ -0,0 +1,4620 @@
+" File: taglist-plus.vim
+" Authors: Jezreel Ng (jezreel AT gmail DOT com)
+"          Yegappan Lakshmanan (yegappan AT yahoo DOT com)
+" Version: 1.0
+ "Last Modified: March 16, 2011
+ "Copyright: Copyright (C) 2011 Jezeel Ng
+"            Copyright (C) 2002-2007 Yegappan Lakshmanan
+"            Permission is hereby granted to use and distribute this code,
+"            with or without modifications, provided that this copyright
+"            notice is copied with it. Like anything else that's free,
+"            taglist.vim is provided *as is* and comes with no warranty of any
+"            kind, either expressed or implied. In no event will the copyright
+"            holder be liable for any damamges resulting from the use of this
+"            software.
+"
+" For more information about using this plugin, after installing the
+" taglist plugin, use the ":help taglist" command.
+"
+" Installation
+" ------------
+" 1. Download the taglist.zip file and unzip the files to the $HOME/.vim
+"    or the $HOME/vimfiles or the $VIM/vimfiles directory. This should
+"    unzip the following two files (the directory structure should be
+"    preserved):
+"
+"       plugin/taglist-plus.vim - main taglist plugin file
+"       doc/taglist-plus.txt    - documentation (help) file
+"
+"    Refer to the 'add-plugin', 'add-global-plugin' and 'runtimepath'
+"    Vim help pages for more details about installing Vim plugins.
+" 2. Change to the $HOME/.vim/doc or $HOME/vimfiles/doc or
+"    $VIM/vimfiles/doc directory, start Vim and run the ":helptags ."
+"    command to process the taglist help file.
+" 3. If the exuberant ctags utility is not present in your PATH, then set the
+"    Tlist_Ctags_Cmd variable to point to the location of the exuberant ctags
+"    utility (not to the directory) in the .vimrc file.
+" 4. If you are running a terminal/console version of Vim and the
+"    terminal doesn't support changing the window width then set the
+"    'Tlist_Inc_Winwidth' variable to 0 in the .vimrc file.
+" 5. Restart Vim.
+" 6. You can now use the ":TlistToggle" command to open/close the taglist
+"    window. You can use the ":help taglist" command to get more
+"    information about using the taglist plugin.
+"
+" ****************** Do not modify after this line ************************
+
+" Line continuation used here
+let s:cpo_save = &cpo
+set cpo&vim
+
+if !exists('loaded_taglist')
+    " First time loading the taglist plugin
+    "
+    " To speed up the loading of Vim, the taglist plugin uses autoload
+    " mechanism to load the taglist functions.
+    " Only define the configuration variables, user commands and some
+    " auto-commands and finish sourcing the file
+
+    " The taglist plugin requires the built-in Vim system() function. If this
+    " function is not available, then don't load the plugin.
+    if !exists('*system')
+        echomsg 'Taglist: Vim system() built-in function is not available. ' .
+                    \ 'Plugin is not loaded.'
+        let loaded_taglist = 'no'
+        let &cpo = s:cpo_save
+        finish
+    endif
+
+    " Location of the exuberant ctags tool
+    if !exists('Tlist_Ctags_Cmd')
+        if executable('exuberant-ctags')
+            " On Debian Linux, exuberant ctags is installed
+            " as exuberant-ctags
+            let Tlist_Ctags_Cmd = 'exuberant-ctags'
+        elseif executable('exctags')
+            " On Free-BSD, exuberant ctags is installed as exctags
+            let Tlist_Ctags_Cmd = 'exctags'
+        elseif executable('ctags')
+            let Tlist_Ctags_Cmd = 'ctags'
+        elseif executable('ctags.exe')
+            let Tlist_Ctags_Cmd = 'ctags.exe'
+        elseif executable('tags')
+            let Tlist_Ctags_Cmd = 'tags'
+        else
+            echomsg 'Taglist: Exuberant ctags (http://ctags.sf.net) ' .
+                        \ 'not found in PATH. Plugin is not loaded.'
+            " Skip loading the plugin
+            let loaded_taglist = 'no'
+            let &cpo = s:cpo_save
+            finish
+        endif
+    endif
+
+
+    " Automatically open the taglist window on Vim startup
+    if !exists('Tlist_Auto_Open')
+        let Tlist_Auto_Open = 0
+    endif
+
+    " When the taglist window is toggle opened, move the cursor to the
+    " taglist window
+    if !exists('Tlist_GainFocus_On_ToggleOpen')
+        let Tlist_GainFocus_On_ToggleOpen = 0
+    endif
+
+    " Process files even when the taglist window is not open
+    if !exists('Tlist_Process_File_Always')
+        let Tlist_Process_File_Always = 0
+    endif
+
+    if !exists('Tlist_Show_Menu')
+        let Tlist_Show_Menu = 0
+    endif
+
+    " Tag listing sort type - 'name' or 'order'
+    if !exists('Tlist_Sort_Type')
+        let Tlist_Sort_Type = 'order'
+    endif
+
+    " Tag listing window split (horizontal/vertical) control
+    if !exists('Tlist_Use_Horiz_Window')
+        let Tlist_Use_Horiz_Window = 0
+    endif
+
+    " Open the vertically split taglist window on the left or on the right
+    " side.  This setting is relevant only if Tlist_Use_Horiz_Window is set to
+    " zero (i.e.  only for vertically split windows)
+    if !exists('Tlist_Use_Right_Window')
+        let Tlist_Use_Right_Window = 0
+    endif
+
+    " Increase Vim window width to display vertically split taglist window.
+    " For MS-Windows version of Vim running in a MS-DOS window, this must be
+    " set to 0 otherwise the system may hang due to a Vim limitation.
+    if !exists('Tlist_Inc_Winwidth')
+        if (has('win16') || has('win95')) && !has('gui_running')
+            let Tlist_Inc_Winwidth = 0
+        else
+            let Tlist_Inc_Winwidth = 1
+        endif
+    endif
+
+    " Vertically split taglist window width setting
+    if !exists('Tlist_WinWidth')
+        let Tlist_WinWidth = 30
+        let s:auto_width = 0
+    elseif Tlist_WinWidth == 'auto'
+        let Tlist_WinWidth = 30
+        let s:auto_width = 1
+    endif
+
+    " Horizontally split taglist window height setting
+    if !exists('Tlist_WinHeight')
+        let Tlist_WinHeight = 10
+    endif
+
+    " Display tag prototypes or tag names in the taglist window
+    if !exists('Tlist_Display_Prototype')
+        let Tlist_Display_Prototype = 0
+    endif
+
+    " Display tag scopes in the taglist window
+    if !exists('Tlist_Display_Tag_Scope')
+        let Tlist_Display_Tag_Scope = 1
+    endif
+
+    " Use single left mouse click to jump to a tag. By default this is disabled.
+    " Only double click using the mouse will be processed.
+    if !exists('Tlist_Use_SingleClick')
+        let Tlist_Use_SingleClick = 0
+    endif
+
+    " Control whether additional help is displayed as part of the taglist or
+    " not.  Also, controls whether empty lines are used to separate the tag
+    " tree.
+    if !exists('Tlist_Compact_Format')
+        let Tlist_Compact_Format = 0
+    endif
+
+    " Exit Vim if only the taglist window is currently open. By default, this is
+    " set to zero.
+    if !exists('Tlist_Exit_OnlyWindow')
+        let Tlist_Exit_OnlyWindow = 0
+    endif
+
+    " Automatically close the folds for the non-active files in the taglist
+    " window
+    if !exists('Tlist_File_Fold_Auto_Close')
+        let Tlist_File_Fold_Auto_Close = 0
+    endif
+
+    " Close the taglist window when a tag is selected
+    if !exists('Tlist_Close_On_Select')
+        let Tlist_Close_On_Select = 0
+    endif
+
+    " Automatically update the taglist window to display tags for newly
+    " edited files
+    if !exists('Tlist_Auto_Update')
+        let Tlist_Auto_Update = 1
+    endif
+
+    " Automatically highlight the current tag
+    if !exists('Tlist_Auto_Highlight_Tag')
+        let Tlist_Auto_Highlight_Tag = 1
+    endif
+    
+    " Automatically highlight the current tag on entering a buffer
+    if !exists('Tlist_Highlight_Tag_On_BufEnter')
+        let Tlist_Highlight_Tag_On_BufEnter = 1
+    endif
+
+    " Enable fold column to display the folding for the tag tree
+    if !exists('Tlist_Enable_Fold_Column')
+        let Tlist_Enable_Fold_Column = 1
+    endif
+
+    " Display the tags for only one file in the taglist window
+    if !exists('Tlist_Show_One_File')
+        let Tlist_Show_One_File = 0
+    endif
+
+    if !exists('Tlist_Max_Submenu_Items')
+        let Tlist_Max_Submenu_Items = 20
+    endif
+
+    if !exists('Tlist_Max_Tag_Length')
+        let Tlist_Max_Tag_Length = 10
+    endif
+
+    " Do not change the name of the taglist title variable. The winmanager
+    " plugin relies on this name to determine the title for the taglist
+    " plugin.
+    let TagList_title = "__Tag_List__"
+
+    " Taglist debug messages
+    let s:tlist_msg = ''
+
+    " Define the taglist autocommand to automatically open the taglist window
+    " on Vim startup
+    if g:Tlist_Auto_Open
+        autocmd VimEnter * nested call s:Tlist_Window_Check_Auto_Open()
+    endif
+
+    " Refresh the taglist
+    if g:Tlist_Process_File_Always
+        autocmd BufEnter * call s:Tlist_Refresh()
+    endif
+
+    if g:Tlist_Show_Menu
+        autocmd GUIEnter * call s:Tlist_Menu_Init()
+    endif
+
+    " When the taglist buffer is created when loading a Vim session file,
+    " the taglist buffer needs to be initialized. The BufFilePost event
+    " is used to handle this case.
+    autocmd BufFilePost __Tag_List__ call s:Tlist_Vim_Session_Load()
+
+    " Define the user commands to manage the taglist window
+    command! -nargs=0 -bar TlistToggle call s:Tlist_Window_Toggle()
+    command! -nargs=0 -bar TlistOpen call s:Tlist_Window_Open()
+    " For backwards compatiblity define the Tlist command
+    command! -nargs=0 -bar Tlist TlistToggle
+    command! -nargs=+ -complete=file TlistAddFiles
+                \  call s:Tlist_Add_Files(<f-args>)
+    command! -nargs=+ -complete=dir TlistAddFilesRecursive
+                \ call s:Tlist_Add_Files_Recursive(<f-args>)
+    command! -nargs=0 -bar TlistClose call s:Tlist_Window_Close()
+    command! -nargs=0 -bar TlistUpdate call s:Tlist_Update_Current_File()
+    command! -nargs=0 -bar TlistHighlightTag call s:Tlist_Window_Highlight_Tag(
+                        \ fnamemodify(bufname('%'), ':p'), line('.'), 2, 1)
+    " For backwards compatiblity define the TlistSync command
+    command! -nargs=0 -bar TlistSync TlistHighlightTag
+    command! -nargs=* -complete=buffer TlistShowPrototype
+                \ echo Tlist_Get_Tag_Prototype_By_Line(<f-args>)
+    command! -nargs=* -complete=buffer TlistShowTag
+                \ echo Tlist_Get_Tagname_By_Line(<f-args>)
+    command! -nargs=* -complete=file TlistSessionLoad
+                \ call s:Tlist_Session_Load(<q-args>)
+    command! -nargs=* -complete=file TlistSessionSave
+                \ call s:Tlist_Session_Save(<q-args>)
+    command! -bar TlistLock let Tlist_Auto_Update=0
+    command! -bar TlistUnlock let Tlist_Auto_Update=1
+
+    " Commands for enabling/disabling debug and to display debug messages
+    command! -nargs=? -complete=file -bar TlistDebug
+                \ call s:Tlist_Debug_Enable(<q-args>)
+    command! -nargs=0 -bar TlistUndebug  call s:Tlist_Debug_Disable()
+    command! -nargs=0 -bar TlistMessages call s:Tlist_Debug_Show()
+
+    " Define autocommands to autoload the taglist plugin when needed.
+
+    " Trick to get the current script ID
+    map <SID>xx <SID>xx
+    let s:tlist_sid = substitute(maparg('<SID>xx'), '<SNR>\(\d\+_\)xx$',
+                                \ '\1', '')
+    unmap <SID>xx
+
+    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_Window_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_Menu_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+    exe 'autocmd FuncUndefined Tlist_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+    exe 'autocmd FuncUndefined TagList_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+
+    let loaded_taglist = 'fast_load_done'
+
+    if g:Tlist_Show_Menu && has('gui_running')
+        call s:Tlist_Menu_Init()
+    endif
+
+    " restore 'cpo'
+    let &cpo = s:cpo_save
+    finish
+endif
+
+if !exists('s:tlist_sid')
+    " Two or more versions of taglist plugin are installed. Don't
+    " load this version of the plugin.
+    finish
+endif
+
+unlet! s:tlist_sid
+
+if loaded_taglist != 'fast_load_done'
+    " restore 'cpo'
+    let &cpo = s:cpo_save
+    finish
+endif
+
+" Taglist plugin functionality is available
+let loaded_taglist = 'available'
+
+"------------------- end of user configurable options --------------------
+
+" Default language specific settings for supported file types and tag types
+"
+" Variable name format:
+"
+"       s:tlist_def_{vim_ftype}_settings
+" 
+" vim_ftype - Filetype detected by Vim
+"
+" Value format:
+"
+"       <ctags_ftype>;<flag>:<name>;<flag>:<name>;...
+"
+" ctags_ftype - File type supported by exuberant ctags
+" flag        - Flag supported by exuberant ctags to generate a tag type
+" name        - Name of the tag type used in the taglist window to display the
+"               tags of this type
+"
+
+" assembly language
+let s:tlist_def_asm_settings = 'asm;d:define;l:label;m:macro;t:type'
+
+" aspperl language
+let s:tlist_def_aspperl_settings = 'asp;f:function;s:sub;v:variable'
+
+" aspvbs language
+let s:tlist_def_aspvbs_settings = 'asp;f:function;s:sub;v:variable'
+
+" awk language
+let s:tlist_def_awk_settings = 'awk;f:function'
+
+" beta language
+let s:tlist_def_beta_settings = 'beta;f:fragment;s:slot;v:pattern'
+
+" c language
+let s:tlist_def_c_settings = 'c;d:macro;g:enum;s:struct;u:union;t:typedef;' .
+                           \ 'v:variable;f:function'
+
+" c++ language
+let s:tlist_def_cpp_settings = 'c++;n:namespace;v:variable;d:macro;t:typedef;' .
+                             \ 'c:class;g:enum;s:struct;u:union;f:function'
+
+" c# language
+let s:tlist_def_cs_settings = 'c#;d:macro;t:typedef;n:namespace;c:class;' .
+                             \ 'E:event;g:enum;s:struct;i:interface;' .
+                             \ 'p:properties;m:method'
+
+" cobol language
+let s:tlist_def_cobol_settings = 'cobol;d:data;f:file;g:group;p:paragraph;' .
+                               \ 'P:program;s:section'
+
+" eiffel language
+let s:tlist_def_eiffel_settings = 'eiffel;c:class;f:feature'
+
+" erlang language
+let s:tlist_def_erlang_settings = 'erlang;d:macro;r:record;m:module;f:function'
+
+" expect (same as tcl) language
+let s:tlist_def_expect_settings = 'tcl;c:class;f:method;p:procedure'
+
+" fortran language
+let s:tlist_def_fortran_settings = 'fortran;p:program;b:block data;' .
+                    \ 'c:common;e:entry;i:interface;k:type;l:label;m:module;' .
+                    \ 'n:namelist;t:derived;v:variable;f:function;s:subroutine'
+
+" HTML language
+let s:tlist_def_html_settings = 'html;a:anchor;f:javascript function'
+
+" java language
+let s:tlist_def_java_settings = 'java;p:package;c:class;i:interface;' .
+                              \ 'f:field;m:method'
+
+" javascript language
+let s:tlist_def_javascript_settings = 'javascript;f:function;v:variable'
+if !exists('Tlist_javascript_Ctags_Cmd') && executable('jsctags')
+    let Tlist_javascript_Ctags_Cmd = 'jsctags'
+endif
+let Tlist_javascript_Ctags_Allowed_Flags = ['-f', '--sort']
+
+" lisp language
+let s:tlist_def_lisp_settings = 'lisp;f:function'
+
+" lua language
+let s:tlist_def_lua_settings = 'lua;f:function'
+
+" makefiles
+let s:tlist_def_make_settings = 'make;m:macro'
+
+" pascal language
+let s:tlist_def_pascal_settings = 'pascal;f:function;p:procedure'
+
+" perl language
+let s:tlist_def_perl_settings = 'perl;c:constant;l:label;p:package;s:subroutine'
+
+" php language
+let s:tlist_def_php_settings = 'php;c:class;d:constant;v:variable;f:function'
+
+" python language
+let s:tlist_def_python_settings = 'python;c:class;m:member;f:function'
+
+" rexx language
+let s:tlist_def_rexx_settings = 'rexx;s:subroutine'
+
+" ruby language
+let s:tlist_def_ruby_settings = 'ruby;c:class;f:method;F:function;' .
+                              \ 'm:singleton method'
+
+" scheme language
+let s:tlist_def_scheme_settings = 'scheme;s:set;f:function'
+
+" shell language
+let s:tlist_def_sh_settings = 'sh;f:function'
+
+" C shell language
+let s:tlist_def_csh_settings = 'sh;f:function'
+
+" Z shell language
+let s:tlist_def_zsh_settings = 'sh;f:function'
+
+" slang language
+let s:tlist_def_slang_settings = 'slang;n:namespace;f:function'
+
+" sml language
+let s:tlist_def_sml_settings = 'sml;e:exception;c:functor;s:signature;' .
+                             \ 'r:structure;t:type;v:value;f:function'
+
+" sql language
+let s:tlist_def_sql_settings = 'sql;c:cursor;F:field;P:package;r:record;' .
+            \ 's:subtype;t:table;T:trigger;v:variable;f:function;p:procedure'
+
+" tcl language
+let s:tlist_def_tcl_settings = 'tcl;c:class;f:method;m:method;p:procedure'
+
+" vera language
+let s:tlist_def_vera_settings = 'vera;c:class;d:macro;e:enumerator;' .
+                                \ 'f:function;g:enum;m:member;p:program;' .
+                                \ 'P:prototype;t:task;T:typedef;v:variable;' .
+                                \ 'x:externvar'
+
+"verilog language
+let s:tlist_def_verilog_settings = 'verilog;m:module;c:constant;P:parameter;' .
+            \ 'e:event;r:register;t:task;w:write;p:port;v:variable;f:function'
+
+" vim language
+let s:tlist_def_vim_settings = 'vim;a:autocmds;v:variable;f:function'
+
+" yacc language
+let s:tlist_def_yacc_settings = 'yacc;l:label'
+
+"------------------- end of language specific options --------------------
+
+" Vim window size is changed by the taglist plugin or not
+let s:tlist_winsize_chgd = -1
+" Taglist window is maximized or not
+let s:tlist_win_maximized = 0
+" Name of files in the taglist
+let s:tlist_file_names=''
+" Number of files in the taglist
+let s:tlist_file_count = 0
+" Number of filetypes supported by taglist
+let s:tlist_ftype_count = 0
+" Is taglist part of other plugins like winmanager or cream?
+let s:tlist_app_name = "none"
+" Are we displaying brief help text
+let s:tlist_brief_help = 1
+" List of files removed on user request
+let s:tlist_removed_flist = ""
+" Index of current file displayed in the taglist window
+let s:tlist_cur_file_idx = -1
+" Taglist menu is empty or not
+let s:tlist_menu_empty = 1
+
+" An autocommand is used to refresh the taglist window when entering any
+" buffer. We don't want to refresh the taglist window if we are entering the
+" file window from one of the taglist functions. The 'Tlist_Skip_Refresh'
+" variable is used to skip the refresh of the taglist window and is set
+" and cleared appropriately.
+let s:Tlist_Skip_Refresh = 0
+
+" Tlist_Window_Display_Help()
+function! s:Tlist_Window_Display_Help()
+    if s:tlist_app_name == "winmanager"
+        " To handle a bug in the winmanager plugin, add a space at the
+        " last line
+        call setline('$', ' ')
+    endif
+
+    if s:tlist_brief_help
+        " Add the brief help
+        call append(0, '" Press <F1> to display help text')
+    else
+        " Add the extensive help
+        call append(0, '" <enter> : Jump to tag definition')
+        call append(1, '" o : Jump to tag definition in new window')
+        call append(2, '" p : Preview the tag definition')
+        call append(3, '" <space> : Display tag prototype')
+        call append(4, '" u : Update tag list')
+        call append(5, '" s : Select sort field')
+        call append(6, '" d : Remove file from taglist')
+        call append(7, '" x : Zoom-out/Zoom-in taglist window')
+        call append(8, '" m : Toggle display of more tag info')
+        call append(9, '" + : Open a fold')
+        call append(10, '" - : Close a fold')
+        call append(11, '" * : Open all folds')
+        call append(12, '" = : Close all folds')
+        call append(13, '" [[ : Move to the start of previous file')
+        call append(14, '" ]] : Move to the start of next file')
+        call append(15, '" q : Close the taglist window')
+        call append(16, '" <F1> : Remove help text')
+    endif
+endfunction
+
+" Tlist_Window_Toggle_Help_Text()
+" Toggle taglist plugin help text between the full version and the brief
+" version
+function! s:Tlist_Window_Toggle_Help_Text()
+    if g:Tlist_Compact_Format
+        " In compact display mode, do not display help
+        return
+    endif
+
+    " Include the empty line displayed after the help text
+    let brief_help_size = 1
+    let full_help_size = 16
+
+    setlocal modifiable
+
+    " Set report option to a huge value to prevent informational messages
+    " while deleting the lines
+    let old_report = &report
+    set report=99999
+
+    " Remove the currently highlighted tag. Otherwise, the help text
+    " might be highlighted by mistake
+    match none
+
+    " Toggle between brief and full help text
+    if s:tlist_brief_help
+        let s:tlist_brief_help = 0
+
+        " Remove the previous help
+        exe '1,' . brief_help_size . ' delete _'
+
+        " Adjust the start/end line numbers for the files
+        call s:Tlist_Window_Update_Line_Offsets(0, 1, full_help_size - brief_help_size)
+    else
+        let s:tlist_brief_help = 1
+
+        " Remove the previous help
+        exe '1,' . full_help_size . ' delete _'
+
+        " Adjust the start/end line numbers for the files
+        call s:Tlist_Window_Update_Line_Offsets(0, 0, full_help_size - brief_help_size)
+    endif
+
+    call s:Tlist_Window_Display_Help()
+
+    " Restore the report option
+    let &report = old_report
+
+    setlocal nomodifiable
+endfunction
+
+" Taglist debug support
+let s:tlist_debug = 0
+
+" File for storing the debug messages
+let s:tlist_debug_file = ''
+
+" Tlist_Debug_Enable
+" Enable logging of taglist debug messages.
+function! s:Tlist_Debug_Enable(...)
+    let s:tlist_debug = 1
+
+    " Check whether a valid file name is supplied.
+    if a:1 != ''
+        let s:tlist_debug_file = fnamemodify(a:1, ':p')
+
+        " Empty the log file
+        exe 'redir! > ' . s:tlist_debug_file
+        redir END
+
+        " Check whether the log file is present/created
+        if !filewritable(s:tlist_debug_file)
+            call s:Tlist_Warning_Msg('Taglist: Unable to create log file '
+                        \ . s:tlist_debug_file)
+            let s:tlist_debug_file = ''
+        endif
+    endif
+endfunction
+
+" Tlist_Debug_Disable
+" Disable logging of taglist debug messages.
+function! s:Tlist_Debug_Disable(...)
+    let s:tlist_debug = 0
+    let s:tlist_debug_file = ''
+endfunction
+
+" Tlist_Debug_Show
+" Display the taglist debug messages in a new window
+function! s:Tlist_Debug_Show()
+    if s:tlist_msg == ''
+        call s:Tlist_Warning_Msg('Taglist: No debug messages')
+        return
+    endif
+
+    " Open a new window to display the taglist debug messages
+    new taglist_debug.txt
+    " Delete all the lines (if the buffer already exists)
+    silent! %delete _
+    " Add the messages
+    silent! put =s:tlist_msg
+    " Move the cursor to the first line
+    normal! gg
+endfunction
+
+" Tlist_Log_Msg
+" Log the supplied debug message along with the time
+function! s:Tlist_Log_Msg(msg)
+    if s:tlist_debug
+        if s:tlist_debug_file != ''
+            exe 'redir >> ' . s:tlist_debug_file
+            silent echon strftime('%H:%M:%S') . ': ' . a:msg . "\n"
+            redir END
+        else
+            " Log the message into a variable
+            " Retain only the last 3000 characters
+            let len = strlen(s:tlist_msg)
+            if len > 3000
+                let s:tlist_msg = strpart(s:tlist_msg, len - 3000)
+            endif
+            let s:tlist_msg = s:tlist_msg . strftime('%H:%M:%S') . ': ' . 
+                        \ a:msg . "\n"
+        endif
+    endif
+endfunction
+
+" Tlist_Warning_Msg()
+" Display a message using WarningMsg highlight group
+function! s:Tlist_Warning_Msg(msg)
+    echohl WarningMsg
+    echomsg a:msg
+    echohl None
+endfunction
+
+" Last returned file index for file name lookup.
+" Used to speed up file lookup
+let s:tlist_file_name_idx_cache = -1
+
+" Tlist_Get_File_Index()
+" Return the index of the specified filename
+function! s:Tlist_Get_File_Index(fname)
+    if s:tlist_file_count == 0 || a:fname == ''
+        return -1
+    endif
+
+    " If the new filename is same as the last accessed filename, then
+    " return that index
+    if s:tlist_file_name_idx_cache != -1 &&
+                \ s:tlist_file_name_idx_cache < s:tlist_file_count
+        if s:tlist_{s:tlist_file_name_idx_cache}_filename == a:fname
+            " Same as the last accessed file
+            return s:tlist_file_name_idx_cache
+        endif
+    endif
+
+    " First, check whether the filename is present
+    let s_fname = a:fname . "\n"
+    let i = stridx(s:tlist_file_names, s_fname)
+    if i == -1
+        let s:tlist_file_name_idx_cache = -1
+        return -1
+    endif
+
+    " Second, compute the file name index
+    let nl_txt = substitute(strpart(s:tlist_file_names, 0, i), "[^\n]", '', 'g')
+    let s:tlist_file_name_idx_cache = strlen(nl_txt)
+    return s:tlist_file_name_idx_cache
+endfunction
+
+" Last returned file index for line number lookup.
+" Used to speed up file lookup
+let s:tlist_file_lnum_idx_cache = -1
+
+" Tlist_Window_Get_File_Index_By_Linenum()
+" Return the index of the filename present in the specified line number
+" Line number refers to the line number in the taglist window
+function! s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
+    call s:Tlist_Log_Msg('Tlist_Window_Get_File_Index_By_Linenum (' . a:lnum . ')')
+
+    " First try to see whether the new line number is within the range
+    " of the last returned file
+    if s:tlist_file_lnum_idx_cache != -1 &&
+                \ s:tlist_file_lnum_idx_cache < s:tlist_file_count
+        if a:lnum >= s:tlist_{s:tlist_file_lnum_idx_cache}_start &&
+                    \ a:lnum <= s:tlist_{s:tlist_file_lnum_idx_cache}_end
+            return s:tlist_file_lnum_idx_cache
+        endif
+    endif
+
+    let fidx = -1
+
+    if g:Tlist_Show_One_File
+        " Displaying only one file in the taglist window. Check whether
+        " the line is within the tags displayed for that file
+        if s:tlist_cur_file_idx != -1
+            if a:lnum >= s:tlist_{s:tlist_cur_file_idx}_start
+                        \ && a:lnum <= s:tlist_{s:tlist_cur_file_idx}_end
+                let fidx = s:tlist_cur_file_idx
+            endif
+
+        endif
+    else
+        " Do a binary search in the taglist
+        let left = 0
+        let right = s:tlist_file_count - 1
+
+        while left < right
+            let mid = (left + right) / 2
+
+            if a:lnum >= s:tlist_{mid}_start && a:lnum <= s:tlist_{mid}_end
+                let s:tlist_file_lnum_idx_cache = mid
+                return mid
+            endif
+
+            if a:lnum < s:tlist_{mid}_start
+                let right = mid - 1
+            else
+                let left = mid + 1
+            endif
+        endwhile
+
+        if left >= 0 && left < s:tlist_file_count
+                    \ && a:lnum >= s:tlist_{left}_start
+                    \ && a:lnum <= s:tlist_{left}_end
+            let fidx = left
+        endif
+    endif
+
+    let s:tlist_file_lnum_idx_cache = fidx
+
+    return fidx
+endfunction
+
+" Tlist_Exe_Cmd_No_Acmds
+" Execute the specified Ex command after disabling autocommands
+function! s:Tlist_Exe_Cmd_No_Acmds(cmd)
+    let old_eventignore = &eventignore
+    set eventignore=all
+    exe a:cmd
+    let &eventignore = old_eventignore
+endfunction
+
+" Tlist_Skip_File()
+" Check whether tag listing is supported for the specified file
+function! s:Tlist_Skip_File(filename, ftype)
+    " Skip buffers with no names and buffers with filetype not set
+    if a:filename == '' || a:ftype == ''
+        return 1
+    endif
+
+    " Skip files which are not supported by exuberant ctags
+    " First check whether default settings for this filetype are available.
+    " If it is not available, then check whether user specified settings are
+    " available. If both are not available, then don't list the tags for this
+    " filetype
+    let var = 's:tlist_def_' . a:ftype . '_settings'
+    if !exists(var)
+        let var = 'g:tlist_' . a:ftype . '_settings'
+        if !exists(var)
+            return 1
+        endif
+    endif
+
+    " Skip files which are not readable or files which are not yet stored
+    " to the disk
+    if !filereadable(a:filename)
+        return 1
+    endif
+
+    return 0
+endfunction
+
+" Tlist_User_Removed_File
+" Returns 1 if a file is removed by a user from the taglist
+function! s:Tlist_User_Removed_File(filename)
+    return stridx(s:tlist_removed_flist, a:filename . "\n") != -1
+endfunction
+
+" Tlist_Update_Remove_List
+" Update the list of user removed files from the taglist
+" add == 1, add the file to the removed list
+" add == 0, delete the file from the removed list
+function! s:Tlist_Update_Remove_List(filename, add)
+    if a:add
+        let s:tlist_removed_flist = s:tlist_removed_flist . a:filename . "\n"
+    else
+        let idx = stridx(s:tlist_removed_flist, a:filename . "\n")
+        let text_before = strpart(s:tlist_removed_flist, 0, idx)
+        let rem_text = strpart(s:tlist_removed_flist, idx)
+        let next_idx = stridx(rem_text, "\n")
+        let text_after = strpart(rem_text, next_idx + 1)
+
+        let s:tlist_removed_flist = text_before . text_after
+    endif
+endfunction
+
+" Tlist_FileType_Init
+" Initialize the ctags arguments and tag variable for the specified
+" file type
+function! s:Tlist_FileType_Init(ftype)
+    call s:Tlist_Log_Msg('Tlist_FileType_Init (' . a:ftype . ')')
+    " If the user didn't specify any settings, then use the default
+    " ctags args. Otherwise, use the settings specified by the user
+    let var = 'g:tlist_' . a:ftype . '_settings'
+    if exists(var)
+        " User specified ctags arguments
+        let settings = {var} . ';'
+    else
+        " Default ctags arguments
+        let var = 's:tlist_def_' . a:ftype . '_settings'
+        if !exists(var)
+            " No default settings for this file type. This filetype is
+            " not supported
+            return 0
+        endif
+        let settings = s:tlist_def_{a:ftype}_settings . ';'
+    endif
+
+    let msg = 'Taglist: Invalid ctags option setting - ' . settings
+
+    " Format of the option that specifies the filetype and ctags arugments:
+    "
+    "       <language_name>;flag1:name1;flag2:name2;flag3:name3
+    "
+
+    " Extract the file type to pass to ctags. This may be different from the
+    " file type detected by Vim
+    let pos = stridx(settings, ';')
+    if pos == -1
+        call s:Tlist_Warning_Msg(msg)
+        return 0
+    endif
+    let ctags_ftype = strpart(settings, 0, pos)
+    if ctags_ftype == ''
+        call s:Tlist_Warning_Msg(msg)
+        return 0
+    endif
+    " Make sure a valid filetype is supplied. If the user didn't specify a
+    " valid filetype, then the ctags option settings may be treated as the
+    " filetype
+    if ctags_ftype =~ ':'
+        call s:Tlist_Warning_Msg(msg)
+        return 0
+    endif
+
+    " Remove the file type from settings
+    let settings = strpart(settings, pos + 1)
+    if settings == ''
+        call s:Tlist_Warning_Msg(msg)
+        return 0
+    endif
+
+    " Process all the specified ctags flags. The format is
+    " flag1:name1;flag2:name2;flag3:name3
+    let ctags_flags = ''
+    let cnt = 0
+    while settings != ''
+        " Extract the flag
+        let pos = stridx(settings, ':')
+        if pos == -1
+            call s:Tlist_Warning_Msg(msg)
+            return 0
+        endif
+        let flag = strpart(settings, 0, pos)
+        if flag == ''
+            call s:Tlist_Warning_Msg(msg)
+            return 0
+        endif
+        " Remove the flag from settings
+        let settings = strpart(settings, pos + 1)
+
+        " Extract the tag type name
+        let pos = stridx(settings, ';')
+        if pos == -1
+            call s:Tlist_Warning_Msg(msg)
+            return 0
+        endif
+        let name = strpart(settings, 0, pos)
+        if name == ''
+            call s:Tlist_Warning_Msg(msg)
+            return 0
+        endif
+        let settings = strpart(settings, pos + 1)
+
+        let cnt = cnt + 1
+
+        let s:tlist_{a:ftype}_{cnt}_name = flag
+        let s:tlist_{a:ftype}_{cnt}_fullname = name
+        let ctags_flags = ctags_flags . flag
+    endwhile
+
+    let s:tlist_{a:ftype}_ctags_args = { '--language-force=': ctags_ftype,
+                            \ '--'.ctags_ftype.'-types=': ctags_flags }
+    let s:tlist_{a:ftype}_count = cnt
+    let s:tlist_{a:ftype}_ctags_flags = ctags_flags
+
+    " Save the filetype name
+    let s:tlist_ftype_{s:tlist_ftype_count}_name = a:ftype
+    let s:tlist_ftype_count = s:tlist_ftype_count + 1
+
+    return 1
+endfunction
+
+" Tlist_Detect_Filetype
+" Determine the filetype for the specified file using the filetypedetect
+" autocmd.
+function! s:Tlist_Detect_Filetype(fname)
+    " Ignore the filetype autocommands
+    let old_eventignore = &eventignore
+    set eventignore=FileType
+
+    " Save the 'filetype', as this will be changed temporarily
+    let old_filetype = &filetype
+
+    " Run the filetypedetect group of autocommands to determine
+    " the filetype
+    exe 'doautocmd filetypedetect BufRead ' . a:fname
+
+    " Save the detected filetype
+    let ftype = &filetype
+
+    " Restore the previous state
+    let &filetype = old_filetype
+    let &eventignore = old_eventignore
+
+    return ftype
+endfunction
+
+" Tlist_Get_Buffer_Filetype
+" Get the filetype for the specified buffer
+function! s:Tlist_Get_Buffer_Filetype(bnum)
+    let buf_ft = getbufvar(a:bnum, '&filetype')
+
+    if bufloaded(a:bnum)
+        " For loaded buffers, the 'filetype' is already determined
+        return buf_ft
+    endif
+
+    " For unloaded buffers, if the 'filetype' option is set, return it
+    if buf_ft != ''
+        return buf_ft
+    endif
+
+    " Skip non-existent buffers
+    if !bufexists(a:bnum)
+        return ''
+    endif
+
+    " For buffers whose filetype is not yet determined, try to determine
+    " the filetype
+    let bname = bufname(a:bnum)
+
+    return s:Tlist_Detect_Filetype(bname)
+endfunction
+
+" Tlist_Discard_TagInfo
+" Discard the stored tag information for a file
+function! s:Tlist_Discard_TagInfo(fidx)
+    call s:Tlist_Log_Msg('Tlist_Discard_TagInfo (' .
+                \ s:tlist_{a:fidx}_filename . ')')
+    let ftype = s:tlist_{a:fidx}_filetype
+
+    " Discard information about the tags defined in the file
+    let i = 1
+    while i <= s:tlist_{a:fidx}_tag_count
+        let fidx_i = 's:tlist_' . a:fidx . '_' . i
+        unlet! {fidx_i}_tag
+        unlet! {fidx_i}_tag_name
+        unlet! {fidx_i}_tag_type
+        unlet! {fidx_i}_ttype_idx
+        unlet! {fidx_i}_tag_proto
+        unlet! {fidx_i}_tag_searchpat
+        unlet! {fidx_i}_tag_linenum
+        let i = i + 1
+    endwhile
+
+    let s:tlist_{a:fidx}_tag_count = 0
+
+    " Discard information about tag type groups
+    let i = 1
+    while i <= s:tlist_{ftype}_count
+        let ttype = s:tlist_{ftype}_{i}_name
+        if s:tlist_{a:fidx}_{ttype} != ''
+            let fidx_ttype = 's:tlist_' . a:fidx . '_' . ttype
+            let {fidx_ttype} = ''
+            let {fidx_ttype}_offset = 0
+            let cnt = {fidx_ttype}_count
+            let {fidx_ttype}_count = 0
+            let j = 1
+            while j <= cnt
+                unlet! {fidx_ttype}_{j}
+                let j = j + 1
+            endwhile
+        endif
+        let i = i + 1
+    endwhile
+
+    " Discard the stored menu command also
+    let s:tlist_{a:fidx}_menu_cmd = ''
+endfunction
+
+" Tlist_Window_Update_Line_Offsets
+" Update the line offsets for tags for files starting from start_idx
+" and displayed in the taglist window by the specified offset
+function! s:Tlist_Window_Update_Line_Offsets(start_idx, increment, offset)
+    let i = a:start_idx
+
+    while i < s:tlist_file_count
+        if s:tlist_{i}_visible
+            " Update the start/end line number only if the file is visible
+            if a:increment
+                let s:tlist_{i}_start = s:tlist_{i}_start + a:offset
+                let s:tlist_{i}_end = s:tlist_{i}_end + a:offset
+            else
+                let s:tlist_{i}_start = s:tlist_{i}_start - a:offset
+                let s:tlist_{i}_end = s:tlist_{i}_end - a:offset
+            endif
+        endif
+        let i = i + 1
+    endwhile
+endfunction
+
+" Tlist_Discard_FileInfo
+" Discard the stored information for a file
+function! s:Tlist_Discard_FileInfo(fidx)
+    call s:Tlist_Log_Msg('Tlist_Discard_FileInfo (' .
+                \ s:tlist_{a:fidx}_filename . ')')
+    call s:Tlist_Discard_TagInfo(a:fidx)
+
+    let ftype = s:tlist_{a:fidx}_filetype
+
+    let i = 1
+    while i <= s:tlist_{ftype}_count
+        let ttype = s:tlist_{ftype}_{i}_name
+        unlet! s:tlist_{a:fidx}_{ttype}
+        unlet! s:tlist_{a:fidx}_{ttype}_offset
+        unlet! s:tlist_{a:fidx}_{ttype}_count
+        let i = i + 1
+    endwhile
+
+    unlet! s:tlist_{a:fidx}_filename
+    unlet! s:tlist_{a:fidx}_sort_type
+    unlet! s:tlist_{a:fidx}_filetype
+    unlet! s:tlist_{a:fidx}_mtime
+    unlet! s:tlist_{a:fidx}_start
+    unlet! s:tlist_{a:fidx}_end
+    unlet! s:tlist_{a:fidx}_valid
+    unlet! s:tlist_{a:fidx}_visible
+    unlet! s:tlist_{a:fidx}_tag_count
+    unlet! s:tlist_{a:fidx}_menu_cmd
+endfunction
+
+" Tlist_Window_Remove_File_From_Display
+" Remove the specified file from display
+function! s:Tlist_Window_Remove_File_From_Display(fidx)
+    call s:Tlist_Log_Msg('Tlist_Window_Remove_File_From_Display (' .
+                \ s:tlist_{a:fidx}_filename . ')')
+    " If the file is not visible then no need to remove it
+    if !s:tlist_{a:fidx}_visible
+        return
+    endif
+
+    " Remove the tags displayed for the specified file from the window
+    let start = s:tlist_{a:fidx}_start
+    " Include the empty line after the last line also
+    if g:Tlist_Compact_Format
+        let end = s:tlist_{a:fidx}_end
+    else
+        let end = s:tlist_{a:fidx}_end + 1
+    endif
+
+    setlocal modifiable
+    exe 'silent! ' . start . ',' . end . 'delete _'
+    setlocal nomodifiable
+
+    " Correct the start and end line offsets for all the files following
+    " this file, as the tags for this file are removed
+    call s:Tlist_Window_Update_Line_Offsets(a:fidx + 1, 0, end - start + 1)
+endfunction
+
+" Tlist_Remove_File
+" Remove the file under the cursor or the specified file index
+" user_request - User requested to remove the file from taglist
+function! s:Tlist_Remove_File(file_idx, user_request)
+    let fidx = a:file_idx
+
+    if fidx == -1
+        let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
+        if fidx == -1
+            return
+        endif
+    endif
+    call s:Tlist_Log_Msg('Tlist_Remove_File (' .
+                \ s:tlist_{fidx}_filename . ', ' . a:user_request . ')')
+
+    let save_winnr = winnr()
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        " Taglist window is open, remove the file from display
+
+        if save_winnr != winnum
+            let old_eventignore = &eventignore
+            set eventignore=all
+            exe winnum . 'wincmd w'
+        endif
+
+        call s:Tlist_Window_Remove_File_From_Display(fidx)
+
+        if save_winnr != winnum
+            exe save_winnr . 'wincmd w'
+            let &eventignore = old_eventignore
+        endif
+    endif
+
+    let fname = s:tlist_{fidx}_filename
+
+    if a:user_request
+        " As the user requested to remove the file from taglist,
+        " add it to the removed list
+        call s:Tlist_Update_Remove_List(fname, 1)
+    endif
+
+    " Remove the file name from the taglist list of filenames
+    let idx = stridx(s:tlist_file_names, fname . "\n")
+    let text_before = strpart(s:tlist_file_names, 0, idx)
+    let rem_text = strpart(s:tlist_file_names, idx)
+    let next_idx = stridx(rem_text, "\n")
+    let text_after = strpart(rem_text, next_idx + 1)
+    let s:tlist_file_names = text_before . text_after
+
+    call s:Tlist_Discard_FileInfo(fidx)
+
+    " Shift all the file variables by one index
+    let i = fidx + 1
+
+    while i < s:tlist_file_count
+        let j = i - 1
+
+        let s:tlist_{j}_filename = s:tlist_{i}_filename
+        let s:tlist_{j}_sort_type = s:tlist_{i}_sort_type
+        let s:tlist_{j}_filetype = s:tlist_{i}_filetype
+        let s:tlist_{j}_mtime = s:tlist_{i}_mtime
+        let s:tlist_{j}_start = s:tlist_{i}_start
+        let s:tlist_{j}_end = s:tlist_{i}_end
+        let s:tlist_{j}_valid = s:tlist_{i}_valid
+        let s:tlist_{j}_visible = s:tlist_{i}_visible
+        let s:tlist_{j}_tag_count = s:tlist_{i}_tag_count
+        let s:tlist_{j}_menu_cmd = s:tlist_{i}_menu_cmd
+
+        let k = 1
+        while k <= s:tlist_{j}_tag_count
+            let s:tlist_{j}_{k}_tag = s:tlist_{i}_{k}_tag
+            let s:tlist_{j}_{k}_tag_name = s:tlist_{i}_{k}_tag_name
+            let s:tlist_{j}_{k}_tag_type = s:Tlist_Get_Tag_Type_By_Tag(i, k)
+            let s:tlist_{j}_{k}_ttype_idx = s:tlist_{i}_{k}_ttype_idx
+            let s:tlist_{j}_{k}_tag_proto = s:Tlist_Get_Tag_Prototype(i, k)
+            let s:tlist_{j}_{k}_tag_searchpat = s:Tlist_Get_Tag_SearchPat(i, k)
+            let s:tlist_{j}_{k}_tag_linenum = s:Tlist_Get_Tag_Linenum(i, k)
+            let k = k + 1
+        endwhile
+
+        let ftype = s:tlist_{i}_filetype
+
+        let k = 1
+        while k <= s:tlist_{ftype}_count
+            let ttype = s:tlist_{ftype}_{k}_name
+            let s:tlist_{j}_{ttype} = s:tlist_{i}_{ttype}
+            let s:tlist_{j}_{ttype}_offset = s:tlist_{i}_{ttype}_offset
+            let s:tlist_{j}_{ttype}_count = s:tlist_{i}_{ttype}_count
+            if s:tlist_{j}_{ttype} != ''
+                let l = 1
+                while l <= s:tlist_{j}_{ttype}_count
+                    let s:tlist_{j}_{ttype}_{l} = s:tlist_{i}_{ttype}_{l}
+                    let l = l + 1
+                endwhile
+            endif
+            let k = k + 1
+        endwhile
+
+        " As the file and tag information is copied to the new index,
+        " discard the previous information
+        call s:Tlist_Discard_FileInfo(i)
+
+        let i = i + 1
+    endwhile
+
+    " Reduce the number of files displayed
+    let s:tlist_file_count = s:tlist_file_count - 1
+
+    if g:Tlist_Show_One_File
+        " If the tags for only one file is displayed and if we just
+        " now removed that file, then invalidate the current file idx
+        if s:tlist_cur_file_idx == fidx
+            let s:tlist_cur_file_idx = -1
+        endif
+    endif
+endfunction
+
+" Tlist_Window_Goto_Window
+" Goto the taglist window
+function! s:Tlist_Window_Goto_Window()
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        if winnr() != winnum
+            call s:Tlist_Exe_Cmd_No_Acmds(winnum . 'wincmd w')
+        endif
+    endif
+endfunction
+
+" Tlist_Window_Create
+" Create a new taglist window. If it is already open, jump to it
+function! s:Tlist_Window_Create()
+    call s:Tlist_Log_Msg('Tlist_Window_Create()')
+    " If the window is open, jump to it
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        " Jump to the existing window
+        if winnr() != winnum
+            exe winnum . 'wincmd w'
+        endif
+        return
+    endif
+
+    " If used with winmanager don't open windows. Winmanager will handle
+    " the window/buffer management
+    if s:tlist_app_name == "winmanager"
+        return
+    endif
+
+    " Create a new window. If user prefers a horizontal window, then open
+    " a horizontally split window. Otherwise open a vertically split
+    " window
+    if g:Tlist_Use_Horiz_Window
+        " Open a horizontally split window
+        let win_dir = 'botright'
+        " Horizontal window height
+        let win_size = g:Tlist_WinHeight
+    else
+        if s:tlist_winsize_chgd == -1
+            " Open a vertically split window. Increase the window size, if
+            " needed, to accomodate the new window
+            if g:Tlist_Inc_Winwidth &&
+                        \ &columns < (80 + g:Tlist_WinWidth)
+                " Save the original window position
+                let s:tlist_pre_winx = getwinposx()
+                let s:tlist_pre_winy = getwinposy()
+
+                " one extra column is needed to include the vertical split
+                let &columns= &columns + g:Tlist_WinWidth + 1
+
+                let s:tlist_winsize_chgd = 1
+            else
+                let s:tlist_winsize_chgd = 0
+            endif
+        endif
+
+        if g:Tlist_Use_Right_Window
+            " Open the window at the rightmost place
+            let win_dir = 'botright vertical'
+        else
+            " Open the window at the leftmost place
+            let win_dir = 'topleft vertical'
+        endif
+        let win_size = g:Tlist_WinWidth
+    endif
+
+    " If the tag listing temporary buffer already exists, then reuse it.
+    " Otherwise create a new buffer
+    let bufnum = bufnr(g:TagList_title)
+    if bufnum == -1
+        " Create a new buffer
+        let wcmd = g:TagList_title
+    else
+        " Edit the existing buffer
+        let wcmd = '+buffer' . bufnum
+    endif
+
+    " Create the taglist window
+    exe 'silent! ' . win_dir . ' ' . win_size . 'split ' . wcmd
+
+    " Save the new window position
+    let s:tlist_winx = getwinposx()
+    let s:tlist_winy = getwinposy()
+
+    " Initialize the taglist window
+    call s:Tlist_Window_Init()
+endfunction
+
+" Tlist_Window_Zoom
+" Zoom (maximize/minimize) the taglist window
+function! s:Tlist_Window_Zoom()
+    if s:tlist_win_maximized
+        " Restore the window back to the previous size
+        if g:Tlist_Use_Horiz_Window
+            exe 'resize ' . g:Tlist_WinHeight
+        else
+            exe 'vert resize ' . g:Tlist_WinWidth
+        endif
+        let s:tlist_win_maximized = 0
+    else
+        " Set the window size to the maximum possible without closing other
+        " windows
+        if g:Tlist_Use_Horiz_Window
+            resize
+        else
+            vert resize
+        endif
+        let s:tlist_win_maximized = 1
+    endif
+endfunction
+
+" Tlist_Ballon_Expr
+" When the mouse cursor is over a tag in the taglist window, display the
+" tag prototype (balloon)
+function! Tlist_Ballon_Expr()
+    " Get the file index
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(v:beval_lnum)
+    if fidx == -1
+        return ''
+    endif
+
+    " Get the tag output line for the current tag
+    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, v:beval_lnum)
+    if tidx == 0
+        return ''
+    endif
+
+    " Get the tag search pattern and display it
+    return s:Tlist_Get_Tag_Prototype(fidx, tidx)
+endfunction
+
+" Tlist_Window_Check_Width
+" Check the width of the taglist window. For horizontally split windows, the
+" 'winfixheight' option is used to fix the height of the window. For
+" vertically split windows, Vim doesn't support the 'winfixwidth' option. So
+" need to handle window width changes from this function.
+function! s:Tlist_Window_Check_Width()
+    let tlist_winnr = bufwinnr(g:TagList_title)
+    if tlist_winnr == -1
+        return
+    endif
+
+    let width = winwidth(tlist_winnr)
+    if width != g:Tlist_WinWidth
+        call s:Tlist_Log_Msg("Tlist_Window_Check_Width: Changing window " .
+                    \ "width from " . width . " to " . g:Tlist_WinWidth)
+        let save_winnr = winnr()
+        if save_winnr != tlist_winnr
+            call s:Tlist_Exe_Cmd_No_Acmds(tlist_winnr . 'wincmd w')
+        endif
+        exe 'vert resize ' . g:Tlist_WinWidth
+        if save_winnr != tlist_winnr
+            call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
+        endif
+    endif
+endfunction
+
+" Tlist_Window_Exit_Only_Window
+" If the 'Tlist_Exit_OnlyWindow' option is set, then exit Vim if only the
+" taglist window is present.
+function! s:Tlist_Window_Exit_Only_Window()
+    " Before quitting Vim, delete the taglist buffer so that
+    " the '0 mark is correctly set to the previous buffer.
+    if v:version < 700
+	if winbufnr(2) == -1
+	    bdelete
+	    quit
+	endif
+    else
+	if winbufnr(2) == -1
+	    if tabpagenr('$') == 1
+		" Only one tag page is present
+		bdelete
+		quit
+	    else
+		" More than one tab page is present. Close only the current
+		" tab page
+		close
+	    endif
+	endif
+    endif
+endfunction
+
+" Tlist_Window_Init
+" Set the default options for the taglist window
+function! s:Tlist_Window_Init()
+    call s:Tlist_Log_Msg('Tlist_Window_Init()')
+
+    " The 'readonly' option should not be set for the taglist buffer.
+    " If Vim is started as "view/gview" or if the ":view" command is
+    " used, then the 'readonly' option is set for all the buffers.
+    " Unset it for the taglist buffer
+    setlocal noreadonly
+
+    " Set the taglist buffer filetype to taglist
+    setlocal filetype=taglist
+
+    " Define taglist window element highlighting
+    syntax match TagListComment '^" .*'
+    syntax match TagListFileName '^[^" ].*$'
+    syntax match TagListTitle '^  \S.*$'
+    syntax region TagListTagScope1  start='\[' end='\]' contains=TagListTagScope1 nextgroup=TagListTagScope2 skipwhite
+    syntax region TagListTagScope2 start='\[' end='\]' contained contains=TaglistTagScope2
+
+    " Define the highlighting only if colors are supported
+    if has('gui_running') || &t_Co > 2
+        " Colors to highlight various taglist window elements
+        " If user defined highlighting group exists, then use them.
+        " Otherwise, use default highlight groups.
+        if hlexists('MyTagListTagName')
+            highlight link TagListTagName MyTagListTagName
+        else
+            highlight default link TagListTagName Search
+        endif
+        " Colors to highlight comments and titles
+        if hlexists('MyTagListComment')
+            highlight link TagListComment MyTagListComment
+        else
+            highlight clear TagListComment
+            highlight default link TagListComment Comment
+        endif
+        if hlexists('MyTagListTitle')
+            highlight link TagListTitle MyTagListTitle
+        else
+            highlight clear TagListTitle
+            highlight default link TagListTitle Title
+        endif
+        if hlexists('MyTagListFileName')
+            highlight link TagListFileName MyTagListFileName
+        else
+            highlight clear TagListFileName
+            highlight default TagListFileName guibg=Grey ctermbg=darkgray
+                        \ guifg=white ctermfg=white
+        endif
+        if hlexists('MyTagListTagScope')
+            highlight link TagListTagScope1 MyTagListTagScope
+        else
+            highlight clear TagListTagScope1
+            highlight clear TagListTagScope2
+            highlight default link TagListTagScope1 Identifier
+            highlight default link TagListTagScope2 Keyword
+        endif
+    else
+        highlight default TagListTagName term=reverse cterm=reverse
+    endif
+
+    " Folding related settings
+    setlocal foldenable
+    setlocal foldminlines=0
+    setlocal foldmethod=manual
+    setlocal foldlevel=9999
+    if g:Tlist_Enable_Fold_Column
+        setlocal foldcolumn=3
+    else
+        setlocal foldcolumn=0
+    endif
+    setlocal foldtext=v:folddashes.getline(v:foldstart)
+
+    if s:tlist_app_name != "winmanager"
+        " Mark buffer as scratch
+        silent! setlocal buftype=nofile
+        if s:tlist_app_name == "none"
+            silent! setlocal bufhidden=delete
+        endif
+        silent! setlocal noswapfile
+        " Due to a bug in Vim 6.0, the winbufnr() function fails for unlisted
+        " buffers. So if the taglist buffer is unlisted, multiple taglist
+        " windows will be opened. This bug is fixed in Vim 6.1 and above
+        if v:version >= 601
+            silent! setlocal nobuflisted
+        endif
+    endif
+
+    silent! setlocal nowrap
+
+    " If the 'number' option is set in the source window, it will affect the
+    " taglist window. So forcefully disable 'number' option for the taglist
+    " window
+    silent! setlocal nonumber
+
+    " Use fixed height when horizontally split window is used
+    if g:Tlist_Use_Horiz_Window
+        if v:version >= 602
+            set winfixheight
+        endif
+    endif
+    if !g:Tlist_Use_Horiz_Window && v:version >= 700
+        set winfixwidth
+    endif
+
+    " Setup balloon evaluation to display tag prototype
+    if v:version >= 700 && has('balloon_eval')
+        setlocal balloonexpr=Tlist_Ballon_Expr()
+        set ballooneval
+    endif
+
+    " Setup the cpoptions properly for the maps to work
+    let old_cpoptions = &cpoptions
+    set cpoptions&vim
+
+    " Create buffer local mappings for jumping to the tags and sorting the list
+    nnoremap <buffer> <silent> <CR>
+                \ :call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    " If more languages are required, generate this from a list of options
+    nnoremap <buffer> <silent> m
+                \ :call <SID>Tlist_Window_Toggle_Extra('javascript', 'type')<CR>
+    nnoremap <buffer> <silent> o
+                \ :call <SID>Tlist_Window_Jump_To_Tag('newwin')<CR>
+    nnoremap <buffer> <silent> p
+                \ :call <SID>Tlist_Window_Jump_To_Tag('preview')<CR>
+    nnoremap <buffer> <silent> P
+                \ :call <SID>Tlist_Window_Jump_To_Tag('prevwin')<CR>
+    if v:version >= 700
+    nnoremap <buffer> <silent> t
+                \ :call <SID>Tlist_Window_Jump_To_Tag('checktab')<CR>
+    nnoremap <buffer> <silent> <C-t>
+                \ :call <SID>Tlist_Window_Jump_To_Tag('newtab')<CR>
+    endif
+    nnoremap <buffer> <silent> <2-LeftMouse>
+                \ :call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    nnoremap <buffer> <silent> s
+                \ :call <SID>Tlist_Change_Sort('cmd', 'toggle', '')<CR>
+    nnoremap <buffer> <silent> + :silent! foldopen<CR>
+    nnoremap <buffer> <silent> - :silent! foldclose<CR>
+    nnoremap <buffer> <silent> * :silent! %foldopen!<CR>
+    nnoremap <buffer> <silent> = :silent! %foldclose<CR>
+    nnoremap <buffer> <silent> <kPlus> :silent! foldopen<CR>
+    nnoremap <buffer> <silent> <kMinus> :silent! foldclose<CR>
+    nnoremap <buffer> <silent> <kMultiply> :silent! %foldopen!<CR>
+    nnoremap <buffer> <silent> <Space> :call <SID>Tlist_Window_Show_Info()<CR>
+    nnoremap <buffer> <silent> u :call <SID>Tlist_Window_Update_File()<CR>
+    nnoremap <buffer> <silent> d :call <SID>Tlist_Remove_File(-1, 1)<CR>
+    nnoremap <buffer> <silent> x :call <SID>Tlist_Window_Zoom()<CR>
+    nnoremap <buffer> <silent> [[ :call <SID>Tlist_Window_Move_To_File(-1)<CR>
+    nnoremap <buffer> <silent> <BS> :call <SID>Tlist_Window_Move_To_File(-1)<CR>
+    nnoremap <buffer> <silent> ]] :call <SID>Tlist_Window_Move_To_File(1)<CR>
+    nnoremap <buffer> <silent> <Tab> :call <SID>Tlist_Window_Move_To_File(1)<CR>
+    nnoremap <buffer> <silent> <F1> :call <SID>Tlist_Window_Toggle_Help_Text()<CR>
+    nnoremap <buffer> <silent> q :close<CR>
+
+    " Insert mode mappings
+    inoremap <buffer> <silent> <CR>
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    " Windows needs return
+    inoremap <buffer> <silent> <Return>
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    inoremap <buffer> <silent> o
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('newwin')<CR>
+    inoremap <buffer> <silent> p
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('preview')<CR>
+    inoremap <buffer> <silent> P
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('prevwin')<CR>
+    if v:version >= 700
+    inoremap <buffer> <silent> t
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('checktab')<CR>
+    inoremap <buffer> <silent> <C-t>
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('newtab')<CR>
+    endif
+    inoremap <buffer> <silent> <2-LeftMouse>
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    inoremap <buffer> <silent> s
+                \ <C-o>:call <SID>Tlist_Change_Sort('cmd', 'toggle', '')<CR>
+    inoremap <buffer> <silent> +             <C-o>:silent! foldopen<CR>
+    inoremap <buffer> <silent> -             <C-o>:silent! foldclose<CR>
+    inoremap <buffer> <silent> *             <C-o>:silent! %foldopen!<CR>
+    inoremap <buffer> <silent> =             <C-o>:silent! %foldclose<CR>
+    inoremap <buffer> <silent> <kPlus>       <C-o>:silent! foldopen<CR>
+    inoremap <buffer> <silent> <kMinus>      <C-o>:silent! foldclose<CR>
+    inoremap <buffer> <silent> <kMultiply>   <C-o>:silent! %foldopen!<CR>
+    inoremap <buffer> <silent> <Space>       <C-o>:call
+                                    \ <SID>Tlist_Window_Show_Info()<CR>
+    inoremap <buffer> <silent> u
+                            \ <C-o>:call <SID>Tlist_Window_Update_File()<CR>
+    inoremap <buffer> <silent> d    <C-o>:call <SID>Tlist_Remove_File(-1, 1)<CR>
+    inoremap <buffer> <silent> x    <C-o>:call <SID>Tlist_Window_Zoom()<CR>
+    inoremap <buffer> <silent> [[   <C-o>:call <SID>Tlist_Window_Move_To_File(-1)<CR>
+    inoremap <buffer> <silent> <BS> <C-o>:call <SID>Tlist_Window_Move_To_File(-1)<CR>
+    inoremap <buffer> <silent> ]]   <C-o>:call <SID>Tlist_Window_Move_To_File(1)<CR>
+    inoremap <buffer> <silent> <Tab> <C-o>:call <SID>Tlist_Window_Move_To_File(1)<CR>
+    inoremap <buffer> <silent> <F1>  <C-o>:call <SID>Tlist_Window_Toggle_Help_Text()<CR>
+    inoremap <buffer> <silent> q    <C-o>:close<CR>
+
+    " Map single left mouse click if the user wants this functionality
+    if g:Tlist_Use_SingleClick == 1
+        " Contributed by Bindu Wavell
+        " attempt to perform single click mapping, it would be much
+        " nicer if we could nnoremap <buffer> ... however vim does
+        " not fire the <buffer> <leftmouse> when you use the mouse
+        " to enter a buffer.
+        let clickmap = ':if bufname("%") =~ "__Tag_List__" <bar> ' .
+                    \ 'call <SID>Tlist_Window_Jump_To_Tag("useopen") ' .
+                    \ '<bar> endif <CR>'
+        if maparg('<leftmouse>', 'n') == ''
+            " no mapping for leftmouse
+            exe ':nnoremap <silent> <leftmouse> <leftmouse>' . clickmap
+        else
+            " we have a mapping
+            let mapcmd = ':nnoremap <silent> <leftmouse> <leftmouse>'
+            let mapcmd = mapcmd . substitute(substitute(
+                        \ maparg('<leftmouse>', 'n'), '|', '<bar>', 'g'),
+                        \ '\c^<leftmouse>', '', '')
+            let mapcmd = mapcmd . clickmap
+            exe mapcmd
+        endif
+    endif
+
+    " Define the taglist autocommands
+    augroup TagListAutoCmds
+        autocmd!
+        " Display the tag prototype for the tag under the cursor.
+        autocmd CursorHold __Tag_List__ call s:Tlist_Window_Show_Info()
+        " Highlight the current tag periodically
+        autocmd CursorHold * silent call s:Tlist_Window_Highlight_Tag(
+                            \ fnamemodify(bufname('%'), ':p'), line('.'), 1, 0)
+
+        " Adjust the Vim window width when taglist window is closed
+        autocmd BufUnload __Tag_List__ call s:Tlist_Post_Close_Cleanup()
+        " Close the fold for this buffer when leaving the buffer
+        if g:Tlist_File_Fold_Auto_Close
+            autocmd BufEnter * silent
+                \ call s:Tlist_Window_Open_File_Fold(expand('<abuf>'))
+        endif
+        " Exit Vim itself if only the taglist window is present (optional)
+        if g:Tlist_Exit_OnlyWindow
+	    autocmd BufEnter __Tag_List__ nested
+			\ call s:Tlist_Window_Exit_Only_Window()
+        endif
+        if s:tlist_app_name != "winmanager" &&
+                    \ !g:Tlist_Process_File_Always &&
+                    \ (!has('gui_running') || !g:Tlist_Show_Menu)
+            " Auto refresh the taglist window
+            autocmd BufEnter * call s:Tlist_Refresh()
+        endif
+
+        if !g:Tlist_Use_Horiz_Window
+            if v:version < 700
+                autocmd WinEnter * call s:Tlist_Window_Check_Width()
+            endif
+        endif
+        if v:version >= 700
+            autocmd TabEnter * silent call s:Tlist_Refresh_Folds()
+        endif
+    augroup end
+
+    " Restore the previous cpoptions settings
+    let &cpoptions = old_cpoptions
+endfunction
+
+" Tlist_Window_Refresh
+" Display the tags for all the files in the taglist window
+function! s:Tlist_Window_Refresh()
+    call s:Tlist_Log_Msg('Tlist_Window_Refresh()')
+    " Set report option to a huge value to prevent informational messages
+    " while deleting the lines
+    let old_report = &report
+    set report=99999
+
+    " Mark the buffer as modifiable
+    setlocal modifiable
+
+    " Delete the contents of the buffer to the black-hole register
+    silent! %delete _
+
+    " As we have cleared the taglist window, mark all the files
+    " as not visible
+    let i = 0
+    while i < s:tlist_file_count
+        let s:tlist_{i}_visible = 0
+        let i = i + 1
+    endwhile
+
+    if g:Tlist_Compact_Format == 0
+        " Display help in non-compact mode
+        call s:Tlist_Window_Display_Help()
+    endif
+
+    " Mark the buffer as not modifiable
+    setlocal nomodifiable
+
+    " Restore the report option
+    let &report = old_report
+
+    " If the tags for only one file should be displayed in the taglist
+    " window, then no need to add the tags here. The bufenter autocommand
+    " will add the tags for that file.
+    if g:Tlist_Show_One_File
+        return
+    endif
+
+    " List all the tags for the previously processed files
+    " Do this only if taglist is configured to display tags for more than
+    " one file. Otherwise, when Tlist_Show_One_File is configured,
+    " tags for the wrong file will be displayed.
+    let i = 0
+    while i < s:tlist_file_count
+        call s:Tlist_Window_Refresh_File(s:tlist_{i}_filename,
+                    \ s:tlist_{i}_filetype)
+        let i = i + 1
+    endwhile
+
+    if g:Tlist_Auto_Update
+        " Add and list the tags for all buffers in the Vim buffer list
+        let i = 1
+        let last_bufnum = bufnr('$')
+        while i <= last_bufnum
+            if buflisted(i)
+                let fname = fnamemodify(bufname(i), ':p')
+                let ftype = s:Tlist_Get_Buffer_Filetype(i)
+                " If the file doesn't support tag listing, skip it
+                if !s:Tlist_Skip_File(fname, ftype)
+                    call s:Tlist_Window_Refresh_File(fname, ftype)
+                endif
+            endif
+            let i = i + 1
+        endwhile
+    endif
+
+    " If Tlist_File_Fold_Auto_Close option is set, then close all the folds
+    if g:Tlist_File_Fold_Auto_Close
+        " Close all the folds
+        silent! %foldclose
+    endif
+
+    if !g:Tlist_Use_Horiz_Window && s:auto_width
+        exe 'vertical resize '.g:Tlist_WinWidth
+    endif
+
+    " Move the cursor to the top of the taglist window
+    normal! gg
+endfunction
+
+" Tlist_Post_Close_Cleanup()
+" Close the taglist window and adjust the Vim window width
+function! s:Tlist_Post_Close_Cleanup()
+    call s:Tlist_Log_Msg('Tlist_Post_Close_Cleanup()')
+    " Mark all the files as not visible
+    let i = 0
+    while i < s:tlist_file_count
+        let s:tlist_{i}_visible = 0
+        let i = i + 1
+    endwhile
+
+    " Remove the taglist autocommands
+    silent! autocmd! TagListAutoCmds
+
+    " Clear all the highlights
+    match none
+
+    silent! syntax clear TagListTitle
+    silent! syntax clear TagListComment
+    silent! syntax clear TagListTagScope
+
+    " Remove the left mouse click mapping if it was setup initially
+    if g:Tlist_Use_SingleClick
+        if hasmapto('<LeftMouse>')
+            nunmap <LeftMouse>
+        endif
+    endif
+
+    if s:tlist_app_name != "winmanager"
+    if g:Tlist_Use_Horiz_Window || g:Tlist_Inc_Winwidth == 0 ||
+                \ s:tlist_winsize_chgd != 1 ||
+                \ &columns < (80 + g:Tlist_WinWidth)
+        " No need to adjust window width if using horizontally split taglist
+        " window or if columns is less than 101 or if the user chose not to
+        " adjust the window width
+    else
+        " If the user didn't manually move the window, then restore the window
+        " position to the pre-taglist position
+        if s:tlist_pre_winx != -1 && s:tlist_pre_winy != -1 &&
+                    \ getwinposx() == s:tlist_winx &&
+                    \ getwinposy() == s:tlist_winy
+            exe 'winpos ' . s:tlist_pre_winx . ' ' . s:tlist_pre_winy
+        endif
+
+        " Adjust the Vim window width
+        let &columns= &columns - (g:Tlist_WinWidth + 1)
+    endif
+    endif
+
+    let s:tlist_winsize_chgd = -1
+
+    " Reset taglist state variables
+    if s:tlist_app_name == "winmanager"
+        let s:tlist_app_name = "none"
+    endif
+    let s:tlist_window_initialized = 0
+endfunction
+
+" Tlist_Window_Refresh_File()
+" List the tags defined in the specified file in a Vim window
+function! s:Tlist_Window_Refresh_File(filename, ftype)
+    call s:Tlist_Log_Msg('Tlist_Window_Refresh_File (' . a:filename . ')')
+    " First check whether the file already exists
+    let fidx = s:Tlist_Get_File_Index(a:filename)
+    if fidx != -1
+        let file_listed = 1
+    else
+        let file_listed = 0
+    endif
+
+    if !file_listed
+        " Check whether this file is removed based on user request
+        " If it is, then don't display the tags for this file
+        if s:Tlist_User_Removed_File(a:filename)
+            return
+        endif
+    endif
+
+    if file_listed && s:tlist_{fidx}_visible
+        " Check whether the file tags are currently valid
+        if s:tlist_{fidx}_valid
+            " Goto the first line in the file
+            exe s:tlist_{fidx}_start
+
+            " If the line is inside a fold, open the fold
+            if foldclosed('.') != -1
+                exe "silent! " . s:tlist_{fidx}_start . "," .
+                            \ s:tlist_{fidx}_end . "foldopen!"
+            endif
+            return
+        endif
+
+        " Discard and remove the tags for this file from display
+        call s:Tlist_Discard_TagInfo(fidx)
+        call s:Tlist_Window_Remove_File_From_Display(fidx)
+    endif
+
+    " Process and generate a list of tags defined in the file
+    if !file_listed || !s:tlist_{fidx}_valid
+        let ret_fidx = s:Tlist_Process_File(a:filename, a:ftype)
+        if ret_fidx == -1
+            return
+        endif
+        let fidx = ret_fidx
+    endif
+
+    " Set report option to a huge value to prevent informational messages
+    " while adding lines to the taglist window
+    let old_report = &report
+    set report=99999
+
+    if g:Tlist_Show_One_File
+        " Remove the previous file
+        if s:tlist_cur_file_idx != -1
+            call s:Tlist_Window_Remove_File_From_Display(s:tlist_cur_file_idx)
+            let s:tlist_{s:tlist_cur_file_idx}_visible = 0
+            let s:tlist_{s:tlist_cur_file_idx}_start = 0
+            let s:tlist_{s:tlist_cur_file_idx}_end = 0
+        endif
+        let s:tlist_cur_file_idx = fidx
+    endif
+
+    " Mark the buffer as modifiable
+    setlocal modifiable
+
+    " Add new files to the end of the window. For existing files, add them at
+    " the same line where they were previously present. If the file is not
+    " visible, then add it at the end
+    if s:tlist_{fidx}_start == 0 || !s:tlist_{fidx}_visible
+        if g:Tlist_Compact_Format
+            let s:tlist_{fidx}_start = line('$')
+        else
+            let s:tlist_{fidx}_start = line('$') + 1
+        endif
+    endif
+
+    let s:tlist_{fidx}_visible = 1
+
+    " Goto the line where this file should be placed
+    if g:Tlist_Compact_Format
+        exe s:tlist_{fidx}_start
+    else
+        exe s:tlist_{fidx}_start - 1
+    endif
+
+    let txt = fnamemodify(s:tlist_{fidx}_filename, ':t') . ' (' .
+                \ fnamemodify(s:tlist_{fidx}_filename, ':p:h') . ')'
+    if g:Tlist_Compact_Format == 0
+        silent! put =txt
+    else
+        silent! put! =txt
+        " Move to the next line
+        exe line('.') + 1
+    endif
+    let file_start = s:tlist_{fidx}_start
+
+    " Add the tag names grouped by tag type to the buffer with a title
+    let i = 1
+    let ttype_cnt = s:tlist_{a:ftype}_count
+    while i <= ttype_cnt
+        let ttype = s:tlist_{a:ftype}_{i}_name
+        " Add the tag type only if there are tags for that type
+        let fidx_ttype = 's:tlist_' . fidx . '_' . ttype
+        let ttype_txt = {fidx_ttype}
+        if ttype_txt != ''
+            let txt = '  ' . s:tlist_{a:ftype}_{i}_fullname
+            if g:Tlist_Compact_Format == 0
+                let ttype_start_lnum = line('.') + 1
+                silent! put =txt
+            else
+                let ttype_start_lnum = line('.')
+                silent! put! =txt
+            endif
+            silent! put =ttype_txt
+
+            let {fidx_ttype}_offset = ttype_start_lnum - file_start
+
+            " create a fold for this tag type
+            let fold_start = ttype_start_lnum
+            let fold_end = fold_start + {fidx_ttype}_count
+            exe fold_start . ',' . fold_end  . 'fold'
+
+            " Adjust the cursor position
+            if g:Tlist_Compact_Format == 0
+                exe ttype_start_lnum + {fidx_ttype}_count
+            else
+                exe ttype_start_lnum + {fidx_ttype}_count + 1
+            endif
+
+            if g:Tlist_Compact_Format == 0
+                " Separate the tag types by a empty line
+                silent! put =''
+            endif
+        endif
+        let i = i + 1
+    endwhile
+
+    if s:tlist_{fidx}_tag_count == 0
+        if g:Tlist_Compact_Format == 0
+            silent! put =''
+        endif
+    endif
+
+    let s:tlist_{fidx}_end = line('.') - 1
+
+    " Create a fold for the entire file
+    exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'fold'
+    exe 'silent! ' . s:tlist_{fidx}_start . ',' .
+                \ s:tlist_{fidx}_end . 'foldopen!'
+
+    " Goto the starting line for this file,
+    exe s:tlist_{fidx}_start
+
+    if s:tlist_app_name == "winmanager"
+        " To handle a bug in the winmanager plugin, add a space at the
+        " last line
+        call setline('$', ' ')
+    endif
+
+    " Mark the buffer as not modifiable
+    setlocal nomodifiable
+
+    " Restore the report option
+    let &report = old_report
+
+    " Update the start and end line numbers for all the files following this
+    " file
+    let start = s:tlist_{fidx}_start
+    " include the empty line after the last line
+    if g:Tlist_Compact_Format
+        let end = s:tlist_{fidx}_end
+    else
+        let end = s:tlist_{fidx}_end + 1
+    endif
+    call s:Tlist_Window_Update_Line_Offsets(fidx + 1, 1, end - start + 1)
+
+    if !g:Tlist_Use_Horiz_Window && s:auto_width
+        exe 'vertical resize '.g:Tlist_WinWidth
+    endif
+
+    " Now that we have updated the taglist window, update the tags
+    " menu (if present)
+    if g:Tlist_Show_Menu
+        call s:Tlist_Menu_Update_File(1)
+    endif
+endfunction
+
+" Tlist_Init_File
+" Initialize the variables for a new file
+function! s:Tlist_Init_File(filename, ftype)
+    call s:Tlist_Log_Msg('Tlist_Init_File (' . a:filename . ')')
+    " Add new files at the end of the list
+    let fidx = s:tlist_file_count
+    let s:tlist_file_count = s:tlist_file_count + 1
+    " Add the new file name to the taglist list of file names
+    let s:tlist_file_names = s:tlist_file_names . a:filename . "\n"
+
+    " Initialize the file variables
+    let s:tlist_{fidx}_filename = a:filename
+    let s:tlist_{fidx}_sort_type = g:Tlist_Sort_Type
+    let s:tlist_{fidx}_filetype = a:ftype
+    let s:tlist_{fidx}_mtime = -1
+    let s:tlist_{fidx}_start = 0
+    let s:tlist_{fidx}_end = 0
+    let s:tlist_{fidx}_valid = 0
+    let s:tlist_{fidx}_visible = 0
+    let s:tlist_{fidx}_tag_count = 0
+    let s:tlist_{fidx}_menu_cmd = ''
+
+    " Initialize the tag type variables
+    let i = 1
+    while i <= s:tlist_{a:ftype}_count
+        let ttype = s:tlist_{a:ftype}_{i}_name
+        let s:tlist_{fidx}_{ttype} = ''
+        let s:tlist_{fidx}_{ttype}_offset = 0
+        let s:tlist_{fidx}_{ttype}_count = 0
+        let i = i + 1
+    endwhile
+
+    return fidx
+endfunction
+
+" Tlist_Get_Tag_Type_By_Tag
+" Return the tag type for the specified tag index
+function! s:Tlist_Get_Tag_Type_By_Tag(fidx, tidx)
+    let ttype_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_type'
+
+    " Already parsed and have the tag name
+    if exists(ttype_var)
+        return {ttype_var}
+    endif
+
+    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
+    let {ttype_var} = s:Tlist_Extract_Tagtype(tag_line)
+
+    return {ttype_var}
+endfunction
+
+" Tlist_Get_Tag_Prototype
+function! s:Tlist_Get_Tag_Prototype(fidx, tidx)
+    let tproto_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_proto'
+
+    " Already parsed and have the tag prototype
+    if exists(tproto_var)
+        return {tproto_var}
+    endif
+
+    " Parse and extract the tag prototype
+    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
+    let start = stridx(tag_line, '/^') + 2
+    let end = stridx(tag_line, '/;"' . "\t")
+    if tag_line[end - 1] == '$'
+        let end = end -1
+    endif
+    let tag_proto = strpart(tag_line, start, end - start)
+    let {tproto_var} = substitute(tag_proto, '\s*', '', '')
+
+    return {tproto_var}
+endfunction
+
+" Tlist_Get_Tag_SearchPat
+function! s:Tlist_Get_Tag_SearchPat(fidx, tidx)
+    let tpat_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_searchpat'
+
+    " Already parsed and have the tag search pattern
+    if exists(tpat_var)
+        return {tpat_var}
+    endif
+
+    " Parse and extract the tag search pattern
+    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
+    let start = stridx(tag_line, '/^') + 2
+    let end = stridx(tag_line, '/;"' . "\t")
+    if tag_line[end - 1] == '$'
+        let end = end -1
+    endif
+    let {tpat_var} = '\V\^' . strpart(tag_line, start, end - start) .
+                        \ (tag_line[end] == '$' ? '\$' : '')
+
+    return {tpat_var}
+endfunction
+
+" Tlist_Get_Tag_Linenum
+" Return the tag line number, given the tag index
+function! s:Tlist_Get_Tag_Linenum(fidx, tidx)
+    let tline_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_linenum'
+
+    " Already parsed and have the tag line number
+    if exists(tline_var)
+        return {tline_var}
+    endif
+
+    " Parse and extract the tag line number
+    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
+    let start = match(tag_line, 'line\(no\)\?:')
+    let start = stridx(tag_line, ':', start) + 1
+    let end = stridx(tag_line, "\t", start)
+
+    if end < start
+        let {tline_var} = strpart(tag_line, start) + 0
+    else
+        let {tline_var} = strpart(tag_line, start, end - start) + 0
+    endif
+
+    return {tline_var}
+endfunction
+
+" Tlist_Parse_Tagline
+" Parse a tag line from the ctags output. Separate the tag output based on the
+" tag type and store it in the tag type variable.
+" The format of each line in the ctags output is:
+"
+"     tag_name<TAB>file_name<TAB>ex_cmd;"<TAB>extension_fields
+"
+function! s:Tlist_Parse_Tagline(tag_line,ftype)
+    if a:tag_line == ''
+        " Skip empty lines
+        return
+    endif
+
+    " Extract the tag type
+    let ttype = s:Tlist_Extract_Tagtype(a:tag_line)
+
+    " Make sure the tag type is a valid and supported one
+    if ttype == '' || stridx(s:ctags_flags, ttype) == -1
+        " Line is not in proper tags format or Tag type is not supported
+        return
+    endif
+
+    " Update the total tag count
+    let s:tidx = s:tidx + 1
+
+    " The following variables are used to optimize this code.  Vim is slow in
+    " using curly brace names. To reduce the amount of processing needed, the
+    " curly brace variables are pre-processed here
+    let fidx_tidx = 's:tlist_' . s:fidx . '_' . s:tidx
+    let fidx_ttype = 's:tlist_' . s:fidx . '_' . ttype
+
+    " Update the count of this tag type
+    let ttype_idx = {fidx_ttype}_count + 1
+    let {fidx_ttype}_count = ttype_idx
+
+    " Store the ctags output for this tag
+    let {fidx_tidx}_tag = a:tag_line
+
+    " Store the tag index and the tag type index (back pointers)
+    let {fidx_ttype}_{ttype_idx} = s:tidx
+    let {fidx_tidx}_ttype_idx = ttype_idx
+
+    " Extract the tag name
+    let tag_name = strpart(a:tag_line, 0, stridx(a:tag_line, "\t"))
+
+    " Extract the tag scope/prototype
+    if g:Tlist_Display_Prototype
+        let ttxt = '    ' . s:Tlist_Get_Tag_Prototype(s:fidx, s:tidx)
+    else
+        let ttxt = '    ' . tag_name
+
+        " Add the tag scope, if it is available and is configured. Tag
+        " scope is the last field after the 'line:<num>\t' field
+        if g:Tlist_Display_Tag_Scope
+            let ttxt .= s:Tlist_Get_Scope_String(a:tag_line, a:ftype)
+        endif
+    endif
+
+    if !g:Tlist_Use_Horiz_Window && s:auto_width
+        " Add 3 for the fold columns
+        let g:Tlist_WinWidth = max([g:Tlist_WinWidth, strlen(ttxt)+3])
+    endif
+
+    " Add this tag to the tag type variable
+    let {fidx_ttype} = {fidx_ttype} . ttxt . "\n"
+
+    " Save the tag name
+    let {fidx_tidx}_tag_name = tag_name
+endfunction
+
+function! s:Tlist_Get_Scope_String(tag_line, ftype)
+    let ttxt = ''
+    let tag_scopes = s:Tlist_Extract_Tag_Scope(a:tag_line)
+    for [extradata_name, extradata_content] in items(tag_scopes)
+        if !exists('g:Tlist_{a:ftype}_Hide_Extras') || match(g:Tlist_{a:ftype}_Hide_Extras, extradata_name) == -1
+            let ttxt = ttxt . ' [' . extradata_content . ']'
+        endif
+    endfor
+    return ttxt
+endfunction
+
+" Tlist_Process_File
+" Get the list of tags defined in the specified file and store them
+" in Vim variables. Returns the file index where the tags are stored.
+function! s:Tlist_Process_File(filename, ftype)
+    call s:Tlist_Log_Msg('Tlist_Process_File (' . a:filename . ', ' .
+                \ a:ftype . ')')
+    " Check whether this file is supported
+    if s:Tlist_Skip_File(a:filename, a:ftype)
+        return -1
+    endif
+
+    " If the tag types for this filetype are not yet created, then create
+    " them now
+    let var = 's:tlist_' . a:ftype . '_count'
+    if !exists(var)
+        if s:Tlist_FileType_Init(a:ftype) == 0
+            return -1
+        endif
+    endif
+
+    " If this file is already processed, then use the cached values
+    let fidx = s:Tlist_Get_File_Index(a:filename)
+    if fidx == -1
+        " First time, this file is loaded
+        let fidx = s:Tlist_Init_File(a:filename, a:ftype)
+    else
+        " File was previously processed. Discard the tag information
+        call s:Tlist_Discard_TagInfo(fidx)
+    endif
+
+    let s:tlist_{fidx}_valid = 1
+
+    " Exuberant ctags arguments to generate a tag list
+    let ctags_args = { '-f': ' -', '--format=': '2', '--excmd=': 'pattern', '--fields=': 'nks' }
+
+    " Form the ctags argument depending on the sort type
+    if s:tlist_{fidx}_sort_type == 'name'
+        let ctags_args['--sort'] = '=yes'
+    else
+        let ctags_args['--sort'] = '=no'
+    endif
+
+    " Add the filetype specific arguments
+    call extend(ctags_args, s:tlist_{a:ftype}_ctags_args)
+
+    " Ctags command to produce output with regexp for locating the tags
+    if exists('g:Tlist_{a:ftype}_Ctags_Cmd')
+        let ctags_cmd = g:Tlist_{a:ftype}_Ctags_Cmd
+        let ctags_args = filter(ctags_args, 'match(g:Tlist_javascript_Ctags_Allowed_Flags, "^".v:key."$") != -1')
+    else
+        let ctags_cmd = g:Tlist_Ctags_Cmd
+    endif
+    let ctags_cmd = ctags_cmd . ' ' . join(values(map(ctags_args, 'v:key . v:val')))
+    let ctags_cmd = ctags_cmd . ' "' . a:filename . '"'
+
+    if &shellxquote == '"'
+        " Double-quotes within double-quotes will not work in the
+        " command-line.If the 'shellxquote' option is set to double-quotes,
+        " then escape the double-quotes in the ctags command-line.
+        let ctags_cmd = escape(ctags_cmd, '"')
+    endif
+
+    " In Windows 95, if not using cygwin, disable the 'shellslash'
+    " option. Otherwise, this will cause problems when running the
+    " ctags command.
+    if has('win95') && !has('win32unix')
+        let old_shellslash = &shellslash
+        set noshellslash
+    endif
+
+    if has('win32') && !has('win32unix') && !has('win95')
+                \ && (&shell =~ 'cmd.exe')
+        " Windows does not correctly deal with commands that have more than 1
+        " set of double quotes.  It will strip them all resulting in:
+        " 'C:\Program' is not recognized as an internal or external command
+        " operable program or batch file.  To work around this, place the
+        " command inside a batch file and call the batch file.
+        " Do this only on Win2K, WinXP and above.
+        " Contributed by: David Fishburn.
+        let s:taglist_tempfile = fnamemodify(tempname(), ':h') .
+                    \ '\taglist.cmd'
+        exe 'redir! > ' . s:taglist_tempfile
+        silent echo ctags_cmd
+        redir END
+
+        call s:Tlist_Log_Msg('Cmd inside batch file: ' . ctags_cmd)
+        let ctags_cmd = '"' . s:taglist_tempfile . '"'
+    endif
+
+    call s:Tlist_Log_Msg('Cmd: ' . ctags_cmd)
+
+    " Run ctags and get the tag list
+    let cmd_output = system(ctags_cmd)
+
+    " Restore the value of the 'shellslash' option.
+    if has('win95') && !has('win32unix')
+        let &shellslash = old_shellslash
+    endif
+
+    if exists('s:taglist_tempfile')
+        " Delete the temporary cmd file created on MS-Windows
+        call delete(s:taglist_tempfile)
+    endif
+
+    " Handle errors
+    if v:shell_error
+        let msg = "Taglist: Failed to generate tags for " . a:filename
+        call s:Tlist_Warning_Msg(msg)
+        if cmd_output != ''
+            call s:Tlist_Warning_Msg(cmd_output)
+        endif
+        return fidx
+    endif
+
+    " Store the modification time for the file
+    let s:tlist_{fidx}_mtime = getftime(a:filename)
+
+    " No tags for current file
+    if cmd_output == ''
+        call s:Tlist_Log_Msg('No tags defined in ' . a:filename)
+        return fidx
+    endif
+
+    call s:Tlist_Log_Msg('Generated tags information for ' . a:filename)
+
+    if v:version > 601
+        " The following script local variables are used by the
+        " Tlist_Parse_Tagline() function.
+        let s:ctags_flags = s:tlist_{a:ftype}_ctags_flags
+        let s:fidx = fidx
+        let s:tidx = 0
+
+        " Tlist_Parse_Tagline will adjust this accordingly
+        if !g:Tlist_Use_Horiz_Window && s:auto_width
+            let g:Tlist_WinWidth = 0
+        endif
+
+        " Process the ctags output one line at a time.  The substitute()
+        " command is used to parse the tag lines instead of using the
+        " matchstr()/stridx()/strpart() functions for performance reason
+        call substitute(cmd_output, "\\([^\n]\\+\\)\n",
+                    \ '\=s:Tlist_Parse_Tagline(submatch(1),a:ftype)', 'g')
+
+        " Save the number of tags for this file
+        let s:tlist_{fidx}_tag_count = s:tidx
+
+        " The following script local variables are no longer needed
+        unlet! s:ctags_flags
+        unlet! s:tidx
+        unlet! s:fidx
+    else
+        " Due to a bug in Vim earlier than version 6.1,
+        " we cannot use substitute() to parse the ctags output.
+        " Instead the slow str*() functions are used
+        let ctags_flags = s:tlist_{a:ftype}_ctags_flags
+        let tidx = 0
+
+        while cmd_output != ''
+            " Extract one line at a time
+            let idx = stridx(cmd_output, "\n")
+            let one_line = strpart(cmd_output, 0, idx)
+            " Remove the line from the tags output
+            let cmd_output = strpart(cmd_output, idx + 1)
+
+            if one_line == ''
+                " Line is not in proper tags format
+                continue
+            endif
+
+            " Extract the tag type
+            let ttype = s:Tlist_Extract_Tagtype(one_line)
+
+            " Make sure the tag type is a valid and supported one
+            if ttype == '' || stridx(ctags_flags, ttype) == -1
+                " Line is not in proper tags format or Tag type is not
+                " supported
+                continue
+            endif
+
+            " Update the total tag count
+            let tidx = tidx + 1
+
+            " The following variables are used to optimize this code.  Vim is
+            " slow in using curly brace names. To reduce the amount of
+            " processing needed, the curly brace variables are pre-processed
+            " here
+            let fidx_tidx = 's:tlist_' . fidx . '_' . tidx
+            let fidx_ttype = 's:tlist_' . fidx . '_' . ttype
+
+            " Update the count of this tag type
+            let ttype_idx = {fidx_ttype}_count + 1
+            let {fidx_ttype}_count = ttype_idx
+
+            " Store the ctags output for this tag
+            let {fidx_tidx}_tag = one_line
+
+            " Store the tag index and the tag type index (back pointers)
+            let {fidx_ttype}_{ttype_idx} = tidx
+            let {fidx_tidx}_ttype_idx = ttype_idx
+
+            " Extract the tag name
+            let tag_name = strpart(one_line, 0, stridx(one_line, "\t"))
+
+            " Extract the tag scope/prototype
+            if g:Tlist_Display_Prototype
+                let ttxt = '    ' . s:Tlist_Get_Tag_Prototype(fidx, tidx)
+            else
+                let ttxt = '    ' . tag_name
+
+                " Add the tag scope, if it is available and is configured. Tag
+                " scope is the last field after the 'line:<num>\t' field
+                if g:Tlist_Display_Tag_Scope
+                    let ttxt .= s:Tlist_Get_Scope_String(a:tag_line, a:ftype)
+                endif
+            endif
+
+            " Add this tag to the tag type variable
+            let {fidx_ttype} = {fidx_ttype} . ttxt . "\n"
+
+            " Save the tag name
+            let {fidx_tidx}_tag_name = tag_name
+        endwhile
+
+        " Save the number of tags for this file
+        let s:tlist_{fidx}_tag_count = tidx
+    endif
+
+    call s:Tlist_Log_Msg('Processed ' . s:tlist_{fidx}_tag_count . 
+                \ ' tags in ' . a:filename)
+
+    return fidx
+endfunction
+
+" Tlist_Update_File
+" Update the tags for a file (if needed)
+function! Tlist_Update_File(filename, ftype)
+    call s:Tlist_Log_Msg('Tlist_Update_File (' . a:filename . ')')
+    " If the file doesn't support tag listing, skip it
+    if s:Tlist_Skip_File(a:filename, a:ftype)
+        return
+    endif
+
+    " Convert the file name to a full path
+    let fname = fnamemodify(a:filename, ':p')
+
+    " First check whether the file already exists
+    let fidx = s:Tlist_Get_File_Index(fname)
+
+    if fidx != -1 && s:tlist_{fidx}_valid
+        " File exists and the tags are valid
+        " Check whether the file was modified after the last tags update
+        " If it is modified, then update the tags
+        if s:tlist_{fidx}_mtime == getftime(fname)
+            return
+        endif
+    else
+        " If the tags were removed previously based on a user request,
+        " as we are going to update the tags (based on the user request),
+        " remove the filename from the deleted list
+        call s:Tlist_Update_Remove_List(fname, 0)
+    endif
+
+    " If the taglist window is opened, update it
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum == -1
+        " Taglist window is not present. Just update the taglist
+        " and return
+        call s:Tlist_Process_File(fname, a:ftype)
+    else
+        if g:Tlist_Show_One_File && s:tlist_cur_file_idx != -1
+            " If tags for only one file are displayed and we are not
+            " updating the tags for that file, then no need to
+            " refresh the taglist window. Otherwise, the taglist
+            " window should be updated.
+            if s:tlist_{s:tlist_cur_file_idx}_filename != fname
+                call s:Tlist_Process_File(fname, a:ftype)
+                return
+            endif
+        endif
+
+        " Save the current window number
+        let save_winnr = winnr()
+
+        " Goto the taglist window
+        call s:Tlist_Window_Goto_Window()
+
+        " Save the cursor position
+        let save_line = line('.')
+        let save_col = col('.')
+
+        " Update the taglist window
+        call s:Tlist_Window_Refresh_File(fname, a:ftype)
+
+        " Restore the cursor position
+        if v:version >= 601
+            call cursor(save_line, save_col)
+        else
+            exe save_line
+            exe 'normal! ' . save_col . '|'
+        endif
+
+        if winnr() != save_winnr
+            " Go back to the original window
+            call s:Tlist_Exe_Cmd_No_Acmds(save_winnr . 'wincmd w')
+        endif
+    endif
+
+    " Update the taglist menu
+    if g:Tlist_Show_Menu
+        call s:Tlist_Menu_Update_File(1)
+    endif
+endfunction
+
+" Tlist_Window_Close
+" Close the taglist window
+function! s:Tlist_Window_Close()
+    call s:Tlist_Log_Msg('Tlist_Window_Close()')
+    " Make sure the taglist window exists
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum == -1
+        call s:Tlist_Warning_Msg('Error: Taglist window is not open')
+        return
+    endif
+
+    if winnr() == winnum
+        " Already in the taglist window. Close it and return.
+        " Store the buffer that was selected prior to the taglist buffer
+        let prev_buf = bufnr('#')
+        if winbufnr(2) != -1
+            " If a window other than the taglist window is open,
+            " then only close the taglist window.
+            close
+            call s:Tlist_Exe_Cmd_No_Acmds(bufwinnr(prev_buf) . 'wincmd w')
+        endif
+    else
+        " Goto the taglist window, close it and then come back to the
+        " original window
+        let curbufnr = bufnr('%')
+        exe winnum . 'wincmd w'
+        close
+        " Need to jump back to the original window only if we are not
+        " already in that window
+        let winnum = bufwinnr(curbufnr)
+        if winnr() != winnum
+            exe winnum . 'wincmd w'
+        endif
+    endif
+endfunction
+
+" Tlist_Window_Mark_File_Window
+" Mark the current window as the file window to use when jumping to a tag.
+" Only if the current window is a non-plugin, non-preview and non-taglist
+" window
+function! s:Tlist_Window_Mark_File_Window()
+    if getbufvar('%', '&buftype') == '' && !&previewwindow
+        let w:tlist_file_window = "yes"
+    endif
+endfunction
+
+" Tlist_Window_Open
+" Open and refresh the taglist window
+function! s:Tlist_Window_Open()
+    call s:Tlist_Log_Msg('Tlist_Window_Open()')
+    " If the window is open, jump to it
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        " Jump to the existing window
+        if winnr() != winnum
+            exe winnum . 'wincmd w'
+        endif
+        return
+    endif
+
+    if s:tlist_app_name == "winmanager"
+        " Taglist plugin is no longer part of the winmanager app
+        let s:tlist_app_name = "none"
+    endif
+
+    " Get the filename and filetype for the specified buffer
+    let curbuf_name = fnamemodify(bufname('%'), ':p')
+    let curbuf_ftype = s:Tlist_Get_Buffer_Filetype('%')
+    let cur_lnum = line('.')
+
+    " Mark the current window as the desired window to open a file when a tag
+    " is selected.
+    call s:Tlist_Window_Mark_File_Window()
+
+    " Open the taglist window
+    call s:Tlist_Window_Create()
+
+    call s:Tlist_Window_Refresh()
+
+    if g:Tlist_Show_One_File
+        " Add only the current buffer and file
+        "
+        " If the file doesn't support tag listing, skip it
+        if !s:Tlist_Skip_File(curbuf_name, curbuf_ftype)
+            call s:Tlist_Window_Refresh_File(curbuf_name, curbuf_ftype)
+        endif
+    endif
+
+    if g:Tlist_File_Fold_Auto_Close
+        " Open the fold for the current file, as all the folds in
+        " the taglist window are closed
+        let fidx = s:Tlist_Get_File_Index(curbuf_name)
+        if fidx != -1
+            exe "silent! " . s:tlist_{fidx}_start . "," .
+                        \ s:tlist_{fidx}_end . "foldopen!"
+        endif
+    endif
+
+    " Highlight the current tag
+    call s:Tlist_Window_Highlight_Tag(curbuf_name, cur_lnum, 1, 1)
+endfunction
+
+" Tlist_Window_Toggle()
+" Open or close a taglist window
+function! s:Tlist_Window_Toggle()
+    call s:Tlist_Log_Msg('Tlist_Window_Toggle()')
+    " If taglist window is open then close it.
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        call s:Tlist_Window_Close()
+        return
+    endif
+
+    " Store the current buffer
+    let current_buf = winbufnr(0)
+    call s:Tlist_Window_Open()
+
+    " Go back to the original window, if Tlist_GainFocus_On_ToggleOpen is not
+    " set
+    if !g:Tlist_GainFocus_On_ToggleOpen
+        let prev_win = bufwinnr(current_buf)
+        call s:Tlist_Exe_Cmd_No_Acmds(prev_win . 'wincmd w')
+    endif
+
+    " Update the taglist menu
+    if g:Tlist_Show_Menu
+        call s:Tlist_Menu_Update_File(0)
+    endif
+endfunction
+
+" Tlist_Process_Filelist
+" Process multiple files. Each filename is separated by "\n"
+" Returns the number of processed files
+function! s:Tlist_Process_Filelist(file_names)
+    let flist = a:file_names
+
+    " Enable lazy screen updates
+    let old_lazyredraw = &lazyredraw
+    set lazyredraw
+
+    " Keep track of the number of processed files
+    let fcnt = 0
+
+    " Process one file at a time
+    while flist != ''
+        let nl_idx = stridx(flist, "\n")
+        let one_file = strpart(flist, 0, nl_idx)
+
+        " Remove the filename from the list
+        let flist = strpart(flist, nl_idx + 1)
+
+        if one_file == ''
+            continue
+        endif
+
+        " Skip directories
+        if isdirectory(one_file)
+            continue
+        endif
+
+        let ftype = s:Tlist_Detect_Filetype(one_file)
+
+        echon "\r                                                              "
+        echon "\rProcessing tags for " . fnamemodify(one_file, ':p:t')
+
+        let fcnt = fcnt + 1
+
+        call Tlist_Update_File(one_file, ftype)
+    endwhile
+
+    " Clear the displayed informational messages
+    echon "\r                                                            "
+
+    " Restore the previous state
+    let &lazyredraw = old_lazyredraw
+
+    return fcnt
+endfunction
+
+" Tlist_Process_Dir
+" Process the files in a directory matching the specified pattern
+function! s:Tlist_Process_Dir(dir_name, pat)
+    let flist = glob(a:dir_name . '/' . a:pat) . "\n"
+
+    let fcnt = s:Tlist_Process_Filelist(flist)
+
+    let len = strlen(a:dir_name)
+    if a:dir_name[len - 1] == '\' || a:dir_name[len - 1] == '/'
+        let glob_expr = a:dir_name . '*'
+    else
+        let glob_expr = a:dir_name . '/*'
+    endif
+    let all_files = glob(glob_expr) . "\n"
+
+    while all_files != ''
+        let nl_idx = stridx(all_files, "\n")
+        let one_file = strpart(all_files, 0, nl_idx)
+
+        let all_files = strpart(all_files, nl_idx + 1)
+        if one_file == ''
+            continue
+        endif
+
+        " Skip non-directory names
+        if !isdirectory(one_file)
+            continue
+        endif
+
+        echon "\r                                                              "
+        echon "\rProcessing files in directory " . fnamemodify(one_file, ':t')
+        let fcnt = fcnt + s:Tlist_Process_Dir(one_file, a:pat)
+    endwhile
+
+    return fcnt
+endfunction
+
+" Tlist_Add_Files_Recursive
+" Add files recursively from a directory
+function! s:Tlist_Add_Files_Recursive(dir, ...)
+    let dir_name = fnamemodify(a:dir, ':p')
+    if !isdirectory(dir_name)
+        call s:Tlist_Warning_Msg('Error: ' . dir_name . ' is not a directory')
+        return
+    endif
+
+    if a:0 == 1
+        " User specified file pattern
+        let pat = a:1
+    else
+        " Default file pattern
+        let pat = '*'
+    endif
+
+    echon "\r                                                              "
+    echon "\rProcessing files in directory " . fnamemodify(dir_name, ':t')
+    let fcnt = s:Tlist_Process_Dir(dir_name, pat)
+
+    echon "\rAdded " . fcnt . " files to the taglist"
+endfunction
+
+" Tlist_Add_Files
+" Add the specified list of files to the taglist
+function! s:Tlist_Add_Files(...)
+    let flist = ''
+    let i = 1
+
+    " Get all the files matching the file patterns supplied as argument
+    while i <= a:0
+        let flist = flist . glob(a:{i}) . "\n"
+        let i = i + 1
+    endwhile
+
+    if flist == ''
+        call s:Tlist_Warning_Msg('Error: No matching files are found')
+        return
+    endif
+
+    let fcnt = s:Tlist_Process_Filelist(flist)
+    echon "\rAdded " . fcnt . " files to the taglist"
+endfunction
+
+" Tlist_Extract_Tagtype
+" Extract the tag type from the tag text
+function! s:Tlist_Extract_Tagtype(tag_line)
+    " The tag type is after the tag prototype field. The prototype field
+    " ends with the /;"\t string. We add 4 at the end to skip the characters
+    " in this special string..
+    let start = strridx(a:tag_line, '/;"' . "\t") + 4
+    let end = match(a:tag_line,  'line\(no\)\?:') - 1
+    let ttype = strpart(a:tag_line, start, end - start)
+
+    return ttype
+endfunction
+
+" Tlist_Extract_Tag_Scope
+" Extract the tag scope from the tag text
+function! s:Tlist_Extract_Tag_Scope(tag_line)
+    let start = match(a:tag_line, 'line\(no\)\?:')
+    let end = stridx(a:tag_line, "\t", start)
+    if end <= start
+        return {}
+    endif
+
+    let tag_extras = {}
+
+    let tag_extra = strpart(a:tag_line, end + 1)
+    while tag_extra != ''
+        let tag_extra_separator_start = stridx(tag_extra, ':')
+        let tag_extra_content_start = tag_extra_separator_start + 1
+        let tag_extra_content_end = stridx(tag_extra, "\t")
+        if tag_extra_content_end == -1
+            let tag_extra_content_end = strlen(tag_extra)
+        endif
+        let tag_extra_name = strpart(tag_extra, 0, tag_extra_separator_start)
+        let tag_extra_content = strpart(tag_extra, tag_extra_content_start, tag_extra_content_end - tag_extra_content_start)
+        let tag_extras[tag_extra_name] = tag_extra_content
+        let tag_extra = strpart(tag_extra, tag_extra_content_end + 1)
+    endwhile
+
+    return tag_extras
+endfunction
+
+function! s:Tlist_Window_Toggle_Extra(ftype, extra_name)
+    if !exists('g:Tlist_{a:ftype}_Hide_Extras')
+        return
+    endif
+    let index = index(g:Tlist_{a:ftype}_Hide_Extras, a:extra_name)
+    if index == -1
+        call add(g:Tlist_{a:ftype}_Hide_Extras, a:extra_name)
+    else
+        unlet g:Tlist_{a:ftype}_Hide_Extras[index]
+    endif
+    if s:auto_width
+        let g:Tlist_WinWidth = 30
+    endif
+
+    let cur_lnum = line('.')
+    let cur_col = col('.')
+    call s:Tlist_Window_Update_File()
+    call s:Tlist_Window_Check_Width()
+    call cursor(cur_lnum, cur_col)
+endfunction
+
+" Tlist_Refresh()
+" Refresh the taglist
+function! s:Tlist_Refresh()
+    call s:Tlist_Log_Msg('Tlist_Refresh (Skip_Refresh = ' .
+                \ s:Tlist_Skip_Refresh . ', ' . bufname('%') . ')')
+    " If we are entering the buffer from one of the taglist functions, then
+    " no need to refresh the taglist window again.
+    if s:Tlist_Skip_Refresh
+        " We still need to update the taglist menu
+        if g:Tlist_Show_Menu
+            call s:Tlist_Menu_Update_File(0)
+        endif
+        return
+    endif
+
+    " If part of the winmanager plugin and not configured to process
+    " tags always and not configured to display the tags menu, then return
+    if (s:tlist_app_name == 'winmanager') && !g:Tlist_Process_File_Always
+                \ && !g:Tlist_Show_Menu
+        return
+    endif
+
+    " Skip buffers with 'buftype' set to nofile, nowrite, quickfix or help
+    if &buftype != ''
+        return
+    endif
+
+    let filename = fnamemodify(bufname('%'), ':p')
+    let ftype = s:Tlist_Get_Buffer_Filetype('%')
+
+    " If the file doesn't support tag listing, skip it
+    if s:Tlist_Skip_File(filename, ftype)
+        return
+    endif
+
+    let tlist_win = bufwinnr(g:TagList_title)
+
+    " If the taglist window is not opened and not configured to process
+    " tags always and not displaying the tags menu, then return
+    if tlist_win == -1 && !g:Tlist_Process_File_Always && !g:Tlist_Show_Menu
+        return
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(filename)
+    if fidx == -1
+        " Check whether this file is removed based on user request
+        " If it is, then don't display the tags for this file
+        if s:Tlist_User_Removed_File(filename)
+            return
+        endif
+
+        " If the taglist should not be auto updated, then return
+        if !g:Tlist_Auto_Update
+            return
+        endif
+    endif
+
+    let cur_lnum = line('.')
+
+    if fidx == -1
+        " Update the tags for the file
+        let fidx = s:Tlist_Process_File(filename, ftype)
+    else
+        let mtime = getftime(filename)
+        if s:tlist_{fidx}_mtime != mtime
+            " Invalidate the tags listed for this file
+            let s:tlist_{fidx}_valid = 0
+
+            " Update the taglist and the window
+            call Tlist_Update_File(filename, ftype)
+
+            " Store the new file modification time
+            let s:tlist_{fidx}_mtime = mtime
+        endif
+    endif
+
+    " Update the taglist window
+    if tlist_win != -1
+        " Disable screen updates
+        let old_lazyredraw = &lazyredraw
+        set nolazyredraw
+
+        " Save the current window number
+        let save_winnr = winnr()
+
+        " Goto the taglist window
+        call s:Tlist_Window_Goto_Window()
+
+        if !g:Tlist_Auto_Highlight_Tag || !g:Tlist_Highlight_Tag_On_BufEnter
+            " Save the cursor position
+            let save_line = line('.')
+            let save_col = col('.')
+        endif
+
+        " Update the taglist window
+        call s:Tlist_Window_Refresh_File(filename, ftype)
+
+        " Open the fold for the file
+        exe "silent! " . s:tlist_{fidx}_start . "," .
+                    \ s:tlist_{fidx}_end . "foldopen!"
+
+        if g:Tlist_Highlight_Tag_On_BufEnter && g:Tlist_Auto_Highlight_Tag
+            if g:Tlist_Show_One_File && s:tlist_cur_file_idx != fidx
+                " If displaying tags for only one file in the taglist
+                " window and about to display the tags for a new file,
+                " then center the current tag line for the new file
+                let center_tag_line = 1
+            else
+                let center_tag_line = 0
+            endif
+
+            " Highlight the current tag
+            call s:Tlist_Window_Highlight_Tag(filename, cur_lnum, 1, center_tag_line)
+        else
+            " Restore the cursor position
+            if v:version >= 601
+                call cursor(save_line, save_col)
+            else
+                exe save_line
+                exe 'normal! ' . save_col . '|'
+            endif
+        endif
+
+        " Jump back to the original window
+        if save_winnr != winnr()
+            call s:Tlist_Exe_Cmd_No_Acmds(save_winnr . 'wincmd w')
+        endif
+
+        " Restore screen updates
+        let &lazyredraw = old_lazyredraw
+    endif
+
+    " Update the taglist menu
+    if g:Tlist_Show_Menu
+        call s:Tlist_Menu_Update_File(0)
+    endif
+endfunction
+
+" Tlist_Change_Sort()
+" Change the sort order of the tag listing
+" caller == 'cmd', command used in the taglist window
+" caller == 'menu', taglist menu
+" action == 'toggle', toggle sort from name to order and vice versa
+" action == 'set', set the sort order to sort_type
+function! s:Tlist_Change_Sort(caller, action, sort_type)
+    call s:Tlist_Log_Msg('Tlist_Change_Sort (caller = ' . a:caller .
+            \ ', action = ' . a:action . ', sort_type = ' . a:sort_type . ')')
+    if a:caller == 'cmd'
+        let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
+        if fidx == -1
+            return
+        endif
+
+        " Remove the previous highlighting
+        match none
+    elseif a:caller == 'menu'
+        let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
+        if fidx == -1
+            return
+        endif
+    endif
+
+    if a:action == 'toggle'
+        let sort_type = s:tlist_{fidx}_sort_type
+
+        " Toggle the sort order from 'name' to 'order' and vice versa
+        if sort_type == 'name'
+            let s:tlist_{fidx}_sort_type = 'order'
+        else
+            let s:tlist_{fidx}_sort_type = 'name'
+        endif
+    else
+        let s:tlist_{fidx}_sort_type = a:sort_type
+    endif
+
+    " Invalidate the tags listed for this file
+    let s:tlist_{fidx}_valid = 0
+
+    if a:caller  == 'cmd'
+        " Save the current line for later restoration
+        let curline = '\V\^' . getline('.') . '\$'
+
+        call s:Tlist_Window_Refresh_File(s:tlist_{fidx}_filename,
+                    \   s:tlist_{fidx}_filetype)
+
+        exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'foldopen!'
+
+        " Go back to the cursor line before the tag list is sorted
+        call search(curline, 'w')
+
+        call s:Tlist_Menu_Update_File(1)
+    else
+        call s:Tlist_Menu_Remove_File()
+
+        call s:Tlist_Refresh()
+    endif
+endfunction
+
+" Tlist_Update_Current_File()
+" Update taglist for the current buffer by regenerating the tag list
+" Contributed by WEN Guopeng.
+function! s:Tlist_Update_Current_File()
+    call s:Tlist_Log_Msg('Tlist_Update_Current_File()')
+    if winnr() == bufwinnr(g:TagList_title)
+        " In the taglist window. Update the current file
+        call s:Tlist_Window_Update_File()
+    else
+        " Not in the taglist window. Update the current buffer
+        let filename = fnamemodify(bufname('%'), ':p')
+        let fidx = s:Tlist_Get_File_Index(filename)
+        if fidx != -1
+            let s:tlist_{fidx}_valid = 0
+        endif
+        let ft = s:Tlist_Get_Buffer_Filetype('%')
+        call Tlist_Update_File(filename, ft)
+    endif
+endfunction
+
+" Tlist_Window_Update_File()
+" Update the tags displayed in the taglist window
+function! s:Tlist_Window_Update_File()
+    call s:Tlist_Log_Msg('Tlist_Window_Update_File()')
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
+    if fidx == -1
+        return
+    endif
+
+    " Remove the previous highlighting
+    match none
+
+    " Save the current line for later restoration
+    let curline = '\V\^' . getline('.') . '\$'
+
+    let s:tlist_{fidx}_valid = 0
+
+    " Update the taglist window
+    call s:Tlist_Window_Refresh_File(s:tlist_{fidx}_filename,
+                \ s:tlist_{fidx}_filetype)
+
+    exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'foldopen!'
+
+    " Go back to the tag line before the list is updated
+    call search(curline, 'w')
+endfunction
+
+" Tlist_Window_Get_Tag_Type_By_Linenum()
+" Return the tag type index for the specified line in the taglist window
+function! s:Tlist_Window_Get_Tag_Type_By_Linenum(fidx, lnum)
+    let ftype = s:tlist_{a:fidx}_filetype
+
+    " Determine to which tag type the current line number belongs to using the
+    " tag type start line number and the number of tags in a tag type
+    let i = 1
+    while i <= s:tlist_{ftype}_count
+        let ttype = s:tlist_{ftype}_{i}_name
+        let start_lnum =
+                    \ s:tlist_{a:fidx}_start + s:tlist_{a:fidx}_{ttype}_offset
+        let end =  start_lnum + s:tlist_{a:fidx}_{ttype}_count
+        if a:lnum >= start_lnum && a:lnum <= end
+            break
+        endif
+        let i = i + 1
+    endwhile
+
+    " Current line doesn't belong to any of the displayed tag types
+    if i > s:tlist_{ftype}_count
+        return ''
+    endif
+
+    return ttype
+endfunction
+
+" Tlist_Window_Get_Tag_Index()
+" Return the tag index for the specified line in the taglist window
+function! s:Tlist_Window_Get_Tag_Index(fidx, lnum)
+    let ttype = s:Tlist_Window_Get_Tag_Type_By_Linenum(a:fidx, a:lnum)
+
+    " Current line doesn't belong to any of the displayed tag types
+    if ttype == ''
+        return 0
+    endif
+
+    " Compute the index into the displayed tags for the tag type
+    let ttype_lnum = s:tlist_{a:fidx}_start + s:tlist_{a:fidx}_{ttype}_offset
+    let tidx = a:lnum - ttype_lnum
+    if tidx == 0
+        return 0
+    endif
+
+    " Get the corresponding tag line and return it
+    return s:tlist_{a:fidx}_{ttype}_{tidx}
+endfunction
+
+" Tlist_Window_Highlight_Line
+" Highlight the current line
+function! s:Tlist_Window_Highlight_Line()
+    " Clear previously selected name
+    match none
+
+    " Highlight the current line
+    if g:Tlist_Display_Prototype == 0
+        let pat = '/\%' . line('.') . 'l\s\+\zs.*/'
+    else
+        let pat = '/\%' . line('.') . 'l.*/'
+    endif
+
+    exe 'match TagListTagName ' . pat
+endfunction
+
+" Tlist_Window_Open_File
+" Open the specified file in either a new window or an existing window
+" and place the cursor at the specified tag pattern
+function! s:Tlist_Window_Open_File(win_ctrl, filename, tagpat)
+    call s:Tlist_Log_Msg('Tlist_Window_Open_File (' . a:filename . ',' .
+                \ a:win_ctrl . ')')
+    let prev_Tlist_Skip_Refresh = s:Tlist_Skip_Refresh
+    let s:Tlist_Skip_Refresh = 1
+
+    if s:tlist_app_name == "winmanager"
+        " Let the winmanager edit the file
+        call WinManagerFileEdit(a:filename, a:win_ctrl == 'newwin')
+    else
+
+    if a:win_ctrl == 'newtab'
+        " Create a new tab
+        exe 'tabnew ' . escape(a:filename, ' ')
+        " Open the taglist window in the new tab
+        call s:Tlist_Window_Open()
+    endif
+
+    if a:win_ctrl == 'checktab'
+        " Check whether the file is present in any of the tabs.
+        " If the file is present in the current tab, then use the
+        " current tab.
+        if bufwinnr(a:filename) != -1
+            let file_present_in_tab = 1
+            let i = tabpagenr()
+        else
+            let i = 1
+            let bnum = bufnr(a:filename)
+            let file_present_in_tab = 0
+            while i <= tabpagenr('$')
+                if index(tabpagebuflist(i), bnum) != -1
+                    let file_present_in_tab = 1
+                    break
+                endif
+                let i += 1
+            endwhile
+        endif
+
+        if file_present_in_tab
+            " Goto the tab containing the file
+            exe 'tabnext ' . i
+        else
+            " Open a new tab
+            exe 'tabnew ' . escape(a:filename, ' ')
+
+            " Open the taglist window
+            call s:Tlist_Window_Open()
+        endif
+    endif
+
+    let winnum = -1
+    if a:win_ctrl == 'prevwin'
+        " Open the file in the previous window, if it is usable
+        let cur_win = winnr()
+        wincmd p
+        if &buftype == '' && !&previewwindow
+            exe "edit " . escape(a:filename, ' ')
+            let winnum = winnr()
+        else
+            " Previous window is not usable
+            exe cur_win . 'wincmd w'
+        endif
+    endif
+
+    " Goto the window containing the file.  If the window is not there, open a
+    " new window
+    if winnum == -1
+        let winnum = bufwinnr(a:filename)
+    endif
+
+    if winnum == -1
+        " Locate the previously used window for opening a file
+        let fwin_num = 0
+        let first_usable_win = 0
+
+        let i = 1
+        let bnum = winbufnr(i)
+        while bnum != -1
+            if getwinvar(i, 'tlist_file_window') == 'yes'
+                let fwin_num = i
+                break
+            endif
+            if first_usable_win == 0 &&
+                        \ getbufvar(bnum, '&buftype') == '' &&
+                        \ !getwinvar(i, '&previewwindow')
+                " First non-taglist, non-plugin and non-preview window
+                let first_usable_win = i
+            endif
+            let i = i + 1
+            let bnum = winbufnr(i)
+        endwhile
+
+        " If a previously used window is not found, then use the first
+        " non-taglist window
+        if fwin_num == 0
+            let fwin_num = first_usable_win
+        endif
+
+        if fwin_num != 0
+            " Jump to the file window
+            exe fwin_num . "wincmd w"
+
+            " If the user asked to jump to the tag in a new window, then split
+            " the existing window into two.
+            if a:win_ctrl == 'newwin'
+                split
+            endif
+            exe "edit " . escape(a:filename, ' ')
+        else
+            " Open a new window
+            if g:Tlist_Use_Horiz_Window
+                exe 'leftabove split ' . escape(a:filename, ' ')
+            else
+                if winbufnr(2) == -1
+                    " Only the taglist window is present
+                    if g:Tlist_Use_Right_Window
+                        exe 'leftabove vertical split ' .
+                                    \ escape(a:filename, ' ')
+                    else
+                        exe 'rightbelow vertical split ' .
+                                    \ escape(a:filename, ' ')
+                    endif
+
+                    " Go to the taglist window to change the window size to
+                    " the user configured value
+                    call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
+                    if g:Tlist_Use_Horiz_Window
+                        exe 'resize ' . g:Tlist_WinHeight
+                    else
+                        exe 'vertical resize ' . g:Tlist_WinWidth
+                    endif
+                    " Go back to the file window
+                    call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
+                else
+                    " A plugin or help window is also present
+                    wincmd w
+                    exe 'leftabove split ' . escape(a:filename, ' ')
+                endif
+            endif
+        endif
+        " Mark the window, so that it can be reused.
+        call s:Tlist_Window_Mark_File_Window()
+    else
+        if v:version >= 700
+            " If the file is opened in more than one window, then check
+            " whether the last accessed window has the selected file.
+            " If it does, then use that window.
+            let lastwin_bufnum = winbufnr(winnr('#'))
+            if bufnr(a:filename) == lastwin_bufnum
+                let winnum = winnr('#')
+            endif
+        endif
+        exe winnum . 'wincmd w'
+
+        " If the user asked to jump to the tag in a new window, then split the
+        " existing window into two.
+        if a:win_ctrl == 'newwin'
+            split
+        endif
+    endif
+    endif
+
+    " Jump to the tag
+    if a:tagpat != ''
+        " Add the current cursor position to the jump list, so that user can
+        " jump back using the ' and ` marks.
+        mark '
+        silent call search(a:tagpat, 'w')
+
+        " Bring the line to the middle of the window
+        normal! z.
+
+        " If the line is inside a fold, open the fold
+        if foldclosed('.') != -1
+            .foldopen
+        endif
+    endif
+
+    " If the user selects to preview the tag then jump back to the
+    " taglist window
+    if a:win_ctrl == 'preview'
+        " Go back to the taglist window
+        let winnum = bufwinnr(g:TagList_title)
+        exe winnum . 'wincmd w'
+    else
+        " If the user has selected to close the taglist window, when a
+        " tag is selected, close the taglist  window
+        if g:Tlist_Close_On_Select
+            call s:Tlist_Window_Goto_Window()
+            close
+
+            " Go back to the window displaying the selected file
+            let wnum = bufwinnr(a:filename)
+            if wnum != -1 && wnum != winnr()
+                call s:Tlist_Exe_Cmd_No_Acmds(wnum . 'wincmd w')
+            endif
+        endif
+    endif
+
+    let s:Tlist_Skip_Refresh = prev_Tlist_Skip_Refresh
+endfunction
+
+" Tlist_Window_Jump_To_Tag()
+" Jump to the location of the current tag
+" win_ctrl == useopen - Reuse the existing file window
+" win_ctrl == newwin - Open a new window
+" win_ctrl == preview - Preview the tag
+" win_ctrl == prevwin - Open in previous window
+" win_ctrl == newtab - Open in new tab
+function! s:Tlist_Window_Jump_To_Tag(win_ctrl)
+    call s:Tlist_Log_Msg('Tlist_Window_Jump_To_Tag(' . a:win_ctrl . ')')
+    " Do not process comment lines and empty lines
+    let curline = getline('.')
+    if curline =~ '^\s*$' || curline[0] == '"'
+        return
+    endif
+
+    " If inside a closed fold, then use the first line of the fold
+    " and jump to the file.
+    let lnum = foldclosed('.')
+    if lnum == -1
+        " Jump to the selected tag or file
+        let lnum = line('.')
+    else
+        " Open the closed fold
+        .foldopen!
+    endif
+
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
+    if fidx == -1
+        return
+    endif
+
+    " Get the tag output for the current tag
+    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, lnum)
+    if tidx != 0
+        let tagpat = s:Tlist_Get_Tag_SearchPat(fidx, tidx)
+
+        " Highlight the tagline
+        call s:Tlist_Window_Highlight_Line()
+    else
+        " Selected a line which is not a tag name. Just edit the file
+        let tagpat = ''
+    endif
+
+    call s:Tlist_Window_Open_File(a:win_ctrl, s:tlist_{fidx}_filename, tagpat)
+endfunction
+
+" Tlist_Window_Show_Info()
+" Display information about the entry under the cursor
+function! s:Tlist_Window_Show_Info()
+    call s:Tlist_Log_Msg('Tlist_Window_Show_Info()')
+
+    " Clear the previously displayed line
+    echo
+
+    " Do not process comment lines and empty lines
+    let curline = getline('.')
+    if curline =~ '^\s*$' || curline[0] == '"'
+        return
+    endif
+
+    " If inside a fold, then don't display the prototype
+    if foldclosed('.') != -1
+        return
+    endif
+
+    let lnum = line('.')
+
+    " Get the file index
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
+    if fidx == -1
+        return
+    endif
+
+    if lnum == s:tlist_{fidx}_start
+        " Cursor is on a file name
+        let fname = s:tlist_{fidx}_filename
+        if strlen(fname) > 50
+            let fname = fnamemodify(fname, ':t')
+        endif
+        echo fname . ', Filetype=' . s:tlist_{fidx}_filetype .
+                    \  ', Tag count=' . s:tlist_{fidx}_tag_count
+        return
+    endif
+
+    " Get the tag output line for the current tag
+    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, lnum)
+    if tidx == 0
+        " Cursor is on a tag type
+        let ttype = s:Tlist_Window_Get_Tag_Type_By_Linenum(fidx, lnum)
+        if ttype == ''
+            return
+        endif
+
+        let ttype_name = ''
+
+        let ftype = s:tlist_{fidx}_filetype
+        let i = 1
+        while i <= s:tlist_{ftype}_count
+            if ttype == s:tlist_{ftype}_{i}_name
+                let ttype_name = s:tlist_{ftype}_{i}_fullname
+                break
+            endif
+            let i = i + 1
+        endwhile
+
+        echo 'Tag type=' . ttype_name .
+                    \ ', Tag count=' . s:tlist_{fidx}_{ttype}_count
+        return
+    endif
+
+    " Get the tag search pattern and display it
+    echo s:Tlist_Get_Tag_Prototype(fidx, tidx)
+endfunction
+
+" Tlist_Find_Nearest_Tag_Idx
+" Find the tag idx nearest to the supplied line number
+" Returns -1, if a tag couldn't be found for the specified line number
+function! s:Tlist_Find_Nearest_Tag_Idx(fidx, linenum)
+    let sort_type = s:tlist_{a:fidx}_sort_type
+
+    let left = 1
+    let right = s:tlist_{a:fidx}_tag_count
+
+    if sort_type == 'order'
+        " Tags sorted by order, use a binary search.
+        " The idea behind this function is taken from the ctags.vim script (by
+        " Alexey Marinichev) available at the Vim online website.
+
+        " If the current line is the less than the first tag, then no need to
+        " search
+        let first_lnum = s:Tlist_Get_Tag_Linenum(a:fidx, 1)
+
+        if a:linenum < first_lnum
+            return -1
+        endif
+
+        while left < right
+            let middle = (right + left + 1) / 2
+            let middle_lnum = s:Tlist_Get_Tag_Linenum(a:fidx, middle)
+
+            if middle_lnum == a:linenum
+                let left = middle
+                break
+            endif
+
+            if middle_lnum > a:linenum
+                let right = middle - 1
+            else
+                let left = middle
+            endif
+        endwhile
+    else
+        " Tags sorted by name, use a linear search. (contributed by Dave
+        " Eggum).
+        " Look for a tag with a line number less than or equal to the supplied
+        " line number. If multiple tags are found, then use the tag with the
+        " line number closest to the supplied line number. IOW, use the tag
+        " with the highest line number.
+        let closest_lnum = 0
+        let final_left = 0
+        while left <= right
+            let lnum = s:Tlist_Get_Tag_Linenum(a:fidx, left)
+
+            if lnum < a:linenum && lnum > closest_lnum
+                let closest_lnum = lnum
+                let final_left = left
+            elseif lnum == a:linenum
+                let closest_lnum = lnum
+                let final_left = left
+                break
+            else
+                let left = left + 1
+            endif
+        endwhile
+        if closest_lnum == 0
+            return -1
+        endif
+        if left >= right
+            let left = final_left
+        endif
+    endif
+
+    return left
+endfunction
+
+" Tlist_Window_Highlight_Tag()
+" Highlight the current tag
+" cntx == 1, Called by the taglist plugin itself
+" cntx == 2, Forced by the user through the TlistHighlightTag command
+" center = 1, move the tag line to the center of the taglist window
+function! s:Tlist_Window_Highlight_Tag(filename, cur_lnum, cntx, center)
+    " Highlight the current tag only if the user configured the
+    " taglist plugin to do so or if the user explictly invoked the
+    " command to highlight the current tag.
+    if !g:Tlist_Auto_Highlight_Tag && a:cntx == 1
+        return
+    endif
+
+    if a:filename == ''
+        return
+    endif
+
+    " Make sure the taglist window is present
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum == -1
+        call s:Tlist_Warning_Msg('Error: Taglist window is not open')
+        return
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(a:filename)
+    if fidx == -1
+        return
+    endif
+
+    " If the file is currently not displayed in the taglist window, then retrn
+    if !s:tlist_{fidx}_visible
+        return
+    endif
+
+    " If there are no tags for this file, then no need to proceed further
+    if s:tlist_{fidx}_tag_count == 0
+        return
+    endif
+
+    " Ignore all autocommands
+    let old_ei = &eventignore
+    set eventignore=all
+
+    " Save the original window number
+    let org_winnr = winnr()
+
+    if org_winnr == winnum
+        let in_taglist_window = 1
+    else
+        let in_taglist_window = 0
+    endif
+
+    " Go to the taglist window
+    if !in_taglist_window
+        exe winnum . 'wincmd w'
+    endif
+
+    " Clear previously selected name
+    match none
+
+    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, a:cur_lnum)
+    if tidx == -1
+        " Make sure the current tag line is visible in the taglist window.
+        " Calling the winline() function makes the line visible.  Don't know
+        " of a better way to achieve this.
+        let lnum = line('.')
+
+        if lnum < s:tlist_{fidx}_start || lnum > s:tlist_{fidx}_end
+            " Move the cursor to the beginning of the file
+            exe s:tlist_{fidx}_start
+        endif
+
+        if foldclosed('.') != -1
+            .foldopen
+        endif
+
+        call winline()
+
+        if !in_taglist_window
+            exe org_winnr . 'wincmd w'
+        endif
+
+        " Restore the autocommands
+        let &eventignore = old_ei
+        return
+    endif
+
+    " Extract the tag type
+    let ttype = s:Tlist_Get_Tag_Type_By_Tag(fidx, tidx)
+
+    " Compute the line number
+    " Start of file + Start of tag type + offset
+    let lnum = s:tlist_{fidx}_start + s:tlist_{fidx}_{ttype}_offset +
+                \ s:tlist_{fidx}_{tidx}_ttype_idx
+
+    " Goto the line containing the tag
+    exe lnum
+
+    " Open the fold
+    if foldclosed('.') != -1
+        .foldopen
+    endif
+
+    if a:center
+        " Move the tag line to the center of the taglist window
+        normal! z.
+    else
+        " Make sure the current tag line is visible in the taglist window.
+        " Calling the winline() function makes the line visible.  Don't know
+        " of a better way to achieve this.
+        call winline()
+    endif
+
+    " Highlight the tag name
+    call s:Tlist_Window_Highlight_Line()
+
+    " Go back to the original window
+    if !in_taglist_window
+        exe org_winnr . 'wincmd w'
+    endif
+
+    " Restore the autocommands
+    let &eventignore = old_ei
+    return
+endfunction
+
+" Tlist_Get_Tag_Prototype_By_Line
+" Get the prototype for the tag on or before the specified line number in the
+" current buffer
+function! Tlist_Get_Tag_Prototype_By_Line(...)
+    if a:0 == 0
+        " Arguments are not supplied. Use the current buffer name
+        " and line number
+        let filename = bufname('%')
+        let linenr = line('.')
+    elseif a:0 == 2
+        " Filename and line number are specified
+        let filename = a:1
+        let linenr = a:2
+        if linenr !~ '\d\+'
+            " Invalid line number
+            return ""
+        endif
+    else
+        " Sufficient arguments are not supplied
+        let msg =  'Usage: Tlist_Get_Tag_Prototype_By_Line <filename> ' .
+                                \ '<line_number>'
+        call s:Tlist_Warning_Msg(msg)
+        return ""
+    endif
+
+    " Expand the file to a fully qualified name
+    let filename = fnamemodify(filename, ':p')
+    if filename == ''
+        return ""
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(filename)
+    if fidx == -1
+        return ""
+    endif
+
+    " If there are no tags for this file, then no need to proceed further
+    if s:tlist_{fidx}_tag_count == 0
+        return ""
+    endif
+
+    " Get the tag text using the line number
+    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, linenr)
+    if tidx == -1
+        return ""
+    endif
+
+    return s:Tlist_Get_Tag_Prototype(fidx, tidx)
+endfunction
+
+" Tlist_Get_Tagname_By_Line
+" Get the tag name on or before the specified line number in the
+" current buffer
+function! Tlist_Get_Tagname_By_Line(...)
+    if a:0 == 0
+        " Arguments are not supplied. Use the current buffer name
+        " and line number
+        let filename = bufname('%')
+        let linenr = line('.')
+    elseif a:0 == 2
+        " Filename and line number are specified
+        let filename = a:1
+        let linenr = a:2
+        if linenr !~ '\d\+'
+            " Invalid line number
+            return ""
+        endif
+    else
+        " Sufficient arguments are not supplied
+        let msg =  'Usage: Tlist_Get_Tagname_By_Line <filename> <line_number>'
+        call s:Tlist_Warning_Msg(msg)
+        return ""
+    endif
+
+    " Make sure the current file has a name
+    let filename = fnamemodify(filename, ':p')
+    if filename == ''
+        return ""
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(filename)
+    if fidx == -1
+        return ""
+    endif
+
+    " If there are no tags for this file, then no need to proceed further
+    if s:tlist_{fidx}_tag_count == 0
+        return ""
+    endif
+
+    " Get the tag name using the line number
+    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, linenr)
+    if tidx == -1
+        return ""
+    endif
+
+    return s:tlist_{fidx}_{tidx}_tag_name
+endfunction
+
+" Tlist_Window_Move_To_File
+" Move the cursor to the beginning of the current file or the next file
+" or the previous file in the taglist window
+" dir == -1, move to start of current or previous function
+" dir == 1, move to start of next function
+function! s:Tlist_Window_Move_To_File(dir)
+    if foldlevel('.') == 0
+        " Cursor is on a non-folded line (it is not in any of the files)
+        " Move it to a folded line
+        if a:dir == -1
+            normal! zk
+        else
+            " While moving down to the start of the next fold,
+            " no need to do go to the start of the next file.
+            normal! zj
+            return
+        endif
+    endif
+
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
+    if fidx == -1
+        return
+    endif
+
+    let cur_lnum = line('.')
+
+    if a:dir == -1
+        if cur_lnum > s:tlist_{fidx}_start
+            " Move to the beginning of the current file
+            exe s:tlist_{fidx}_start
+            return
+        endif
+
+        if fidx != 0
+            " Move to the beginning of the previous file
+            let fidx = fidx - 1
+        else
+            " Cursor is at the first file, wrap around to the last file
+            let fidx = s:tlist_file_count - 1
+        endif
+
+        exe s:tlist_{fidx}_start
+        return
+    else
+        " Move to the beginning of the next file
+        let fidx = fidx + 1
+
+        if fidx >= s:tlist_file_count
+            " Cursor is at the last file, wrap around to the first file
+            let fidx = 0
+        endif
+
+        if s:tlist_{fidx}_start != 0
+            exe s:tlist_{fidx}_start
+        endif
+        return
+    endif
+endfunction
+
+" Tlist_Session_Load
+" Load a taglist session (information about all the displayed files
+" and the tags) from the specified file
+function! s:Tlist_Session_Load(...)
+    if a:0 == 0 || a:1 == ''
+        call s:Tlist_Warning_Msg('Usage: TlistSessionLoad <filename>')
+        return
+    endif
+
+    let sessionfile = a:1
+
+    if !filereadable(sessionfile)
+        let msg = 'Taglist: Error - Unable to open file ' . sessionfile
+        call s:Tlist_Warning_Msg(msg)
+        return
+    endif
+
+    " Mark the current window as the file window
+    call s:Tlist_Window_Mark_File_Window()
+
+    " Source the session file
+    exe 'source ' . sessionfile
+
+    let new_file_count = g:tlist_file_count
+    unlet! g:tlist_file_count
+
+    let i = 0
+    while i < new_file_count
+        let ftype = g:tlist_{i}_filetype
+        unlet! g:tlist_{i}_filetype
+
+        if !exists('s:tlist_' . ftype . '_count')
+            if s:Tlist_FileType_Init(ftype) == 0
+                let i = i + 1
+                continue
+            endif
+        endif
+
+        let fname = g:tlist_{i}_filename
+        unlet! g:tlist_{i}_filename
+
+        let fidx = s:Tlist_Get_File_Index(fname)
+        if fidx != -1
+            let s:tlist_{fidx}_visible = 0
+            let i = i + 1
+            continue
+        else
+            " As we are loading the tags from the session file, if this
+            " file was previously deleted by the user, now we need to
+            " add it back. So remove the file from the deleted list.
+            call s:Tlist_Update_Remove_List(fname, 0)
+        endif
+
+        let fidx = s:Tlist_Init_File(fname, ftype)
+
+        let s:tlist_{fidx}_filename = fname
+
+        let s:tlist_{fidx}_sort_type = g:tlist_{i}_sort_type
+        unlet! g:tlist_{i}_sort_type
+
+        let s:tlist_{fidx}_filetype = ftype
+        let s:tlist_{fidx}_mtime = getftime(fname)
+
+        let s:tlist_{fidx}_start = 0
+        let s:tlist_{fidx}_end = 0
+
+        let s:tlist_{fidx}_valid = 1
+
+        let s:tlist_{fidx}_tag_count = g:tlist_{i}_tag_count
+        unlet! g:tlist_{i}_tag_count
+
+        let j = 1
+        while j <= s:tlist_{fidx}_tag_count
+            let s:tlist_{fidx}_{j}_tag = g:tlist_{i}_{j}_tag
+            let s:tlist_{fidx}_{j}_tag_name = g:tlist_{i}_{j}_tag_name
+            let s:tlist_{fidx}_{j}_ttype_idx = g:tlist_{i}_{j}_ttype_idx
+            unlet! g:tlist_{i}_{j}_tag
+            unlet! g:tlist_{i}_{j}_tag_name
+            unlet! g:tlist_{i}_{j}_ttype_idx
+            let j = j + 1
+        endwhile
+
+        let j = 1
+        while j <= s:tlist_{ftype}_count
+            let ttype = s:tlist_{ftype}_{j}_name
+
+            if exists('g:tlist_' . i . '_' . ttype)
+                let s:tlist_{fidx}_{ttype} = g:tlist_{i}_{ttype}
+                unlet! g:tlist_{i}_{ttype}
+                let s:tlist_{fidx}_{ttype}_offset = 0
+                let s:tlist_{fidx}_{ttype}_count = g:tlist_{i}_{ttype}_count
+                unlet! g:tlist_{i}_{ttype}_count
+
+                let k = 1
+                while k <= s:tlist_{fidx}_{ttype}_count
+                    let s:tlist_{fidx}_{ttype}_{k} = g:tlist_{i}_{ttype}_{k}
+                    unlet! g:tlist_{i}_{ttype}_{k}
+                    let k = k + 1
+                endwhile
+            else
+                let s:tlist_{fidx}_{ttype} = ''
+                let s:tlist_{fidx}_{ttype}_offset = 0
+                let s:tlist_{fidx}_{ttype}_count = 0
+            endif
+
+            let j = j + 1
+        endwhile
+
+        let i = i + 1
+    endwhile
+
+    " If the taglist window is open, then update it
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        let save_winnr = winnr()
+
+        " Goto the taglist window
+        call s:Tlist_Window_Goto_Window()
+
+        " Refresh the taglist window
+        call s:Tlist_Window_Refresh()
+
+        " Go back to the original window
+        if save_winnr != winnr()
+            call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
+        endif
+    endif
+endfunction
+
+" Tlist_Session_Save
+" Save a taglist session (information about all the displayed files
+" and the tags) into the specified file
+function! s:Tlist_Session_Save(...)
+    if a:0 == 0 || a:1 == ''
+        call s:Tlist_Warning_Msg('Usage: TlistSessionSave <filename>')
+        return
+    endif
+
+    let sessionfile = a:1
+
+    if s:tlist_file_count == 0
+        " There is nothing to save
+        call s:Tlist_Warning_Msg('Warning: Taglist is empty. Nothing to save.')
+        return
+    endif
+
+    if filereadable(sessionfile)
+        let ans = input('Do you want to overwrite ' . sessionfile . ' (Y/N)?')
+        if ans !=? 'y'
+            return
+        endif
+
+        echo "\n"
+    endif
+
+    let old_verbose = &verbose
+    set verbose&vim
+
+    exe 'redir! > ' . sessionfile
+
+    silent! echo '" Taglist session file. This file is auto-generated.'
+    silent! echo '" File information'
+    silent! echo 'let tlist_file_count = ' . s:tlist_file_count
+
+    let i = 0
+
+    while i < s:tlist_file_count
+        " Store information about the file
+        silent! echo 'let tlist_' . i . "_filename = '" .
+                                            \ s:tlist_{i}_filename . "'"
+        silent! echo 'let tlist_' . i . '_sort_type = "' .
+                                                \ s:tlist_{i}_sort_type . '"'
+        silent! echo 'let tlist_' . i . '_filetype = "' .
+                                            \ s:tlist_{i}_filetype . '"'
+        silent! echo 'let tlist_' . i . '_tag_count = ' .
+                                                        \ s:tlist_{i}_tag_count
+        " Store information about all the tags
+        let j = 1
+        while j <= s:tlist_{i}_tag_count
+            let txt = escape(s:tlist_{i}_{j}_tag, '"\\')
+            silent! echo 'let tlist_' . i . '_' . j . '_tag = "' . txt . '"'
+            silent! echo 'let tlist_' . i . '_' . j . '_tag_name = "' .
+                        \ s:tlist_{i}_{j}_tag_name . '"'
+            silent! echo 'let tlist_' . i . '_' . j . '_ttype_idx' . ' = ' .
+                        \ s:tlist_{i}_{j}_ttype_idx
+            let j = j + 1
+        endwhile
+
+        " Store information about all the tags grouped by their type
+        let ftype = s:tlist_{i}_filetype
+        let j = 1
+        while j <= s:tlist_{ftype}_count
+            let ttype = s:tlist_{ftype}_{j}_name
+            if s:tlist_{i}_{ttype}_count != 0
+                let txt = escape(s:tlist_{i}_{ttype}, '"\')
+                let txt = substitute(txt, "\n", "\\\\n", 'g')
+                silent! echo 'let tlist_' . i . '_' . ttype . ' = "' .
+                                                \ txt . '"'
+                silent! echo 'let tlist_' . i . '_' . ttype . '_count = ' .
+                                                     \ s:tlist_{i}_{ttype}_count
+                let k = 1
+                while k <= s:tlist_{i}_{ttype}_count
+                    silent! echo 'let tlist_' . i . '_' . ttype . '_' . k .
+                                \ ' = ' . s:tlist_{i}_{ttype}_{k}
+                    let k = k + 1
+                endwhile
+            endif
+            let j = j + 1
+        endwhile
+
+        silent! echo
+
+        let i = i + 1
+    endwhile
+
+    redir END
+
+    let &verbose = old_verbose
+endfunction
+
+" Tlist_Buffer_Removed
+" A buffer is removed from the Vim buffer list. Remove the tags defined
+" for that file
+function! s:Tlist_Buffer_Removed(filename)
+    call s:Tlist_Log_Msg('Tlist_Buffer_Removed (' . a:filename .  ')')
+
+    " Make sure a valid filename is supplied
+    if a:filename == ''
+        return
+    endif
+
+    " Get tag list index of the specified file
+    let fidx = s:Tlist_Get_File_Index(a:filename)
+    if fidx == -1
+        " File not present in the taglist
+        return
+    endif
+
+    " Remove the file from the list
+    call s:Tlist_Remove_File(fidx, 0)
+endfunction
+
+" When a buffer is deleted, remove the file from the taglist
+autocmd BufDelete * silent call s:Tlist_Buffer_Removed(expand('<afile>:p'))
+
+" Tlist_Window_Open_File_Fold
+" Open the fold for the specified file and close the fold for all the
+" other files
+function! s:Tlist_Window_Open_File_Fold(acmd_bufnr)
+    call s:Tlist_Log_Msg('Tlist_Window_Open_File_Fold (' . a:acmd_bufnr . ')')
+
+    " Make sure the taglist window is present
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum == -1
+        call s:Tlist_Warning_Msg('Taglist: Error - Taglist window is not open')
+        return
+    endif
+
+    " Save the original window number
+    let org_winnr = winnr()
+    if org_winnr == winnum
+        let in_taglist_window = 1
+    else
+        let in_taglist_window = 0
+    endif
+
+    if in_taglist_window
+        " When entering the taglist window, no need to update the folds
+        return
+    endif
+
+    " Go to the taglist window
+    if !in_taglist_window
+        call s:Tlist_Exe_Cmd_No_Acmds(winnum . 'wincmd w')
+    endif
+
+    " Close all the folds
+    silent! %foldclose
+
+    " Get tag list index of the specified file
+    let fname = fnamemodify(bufname(a:acmd_bufnr + 0), ':p')
+    if filereadable(fname)
+        let fidx = s:Tlist_Get_File_Index(fname)
+        if fidx != -1
+            " Open the fold for the file
+            exe "silent! " . s:tlist_{fidx}_start . "," .
+                        \ s:tlist_{fidx}_end . "foldopen"
+        endif
+    endif
+
+    " Go back to the original window
+    if !in_taglist_window
+        call s:Tlist_Exe_Cmd_No_Acmds(org_winnr . 'wincmd w')
+    endif
+endfunction
+
+" Tlist_Window_Check_Auto_Open
+" Open the taglist window automatically on Vim startup.
+" Open the window only when files present in any of the Vim windows support
+" tags.
+function! s:Tlist_Window_Check_Auto_Open()
+    let open_window = 0
+
+    let i = 1
+    let buf_num = winbufnr(i)
+    while buf_num != -1
+        let filename = fnamemodify(bufname(buf_num), ':p')
+        let ft = s:Tlist_Get_Buffer_Filetype(buf_num)
+        if !s:Tlist_Skip_File(filename, ft)
+            let open_window = 1
+            break
+        endif
+        let i = i + 1
+        let buf_num = winbufnr(i)
+    endwhile
+
+    if open_window
+        call s:Tlist_Window_Toggle()
+    endif
+endfunction
+
+" Tlist_Refresh_Folds
+" Remove and create the folds for all the files displayed in the taglist
+" window. Used after entering a tab. If this is not done, then the folds
+" are not properly created for taglist windows displayed in multiple tabs.
+function! s:Tlist_Refresh_Folds()
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum == -1
+        return
+    endif
+
+    let save_wnum = winnr()
+    exe winnum . 'wincmd w'
+
+    " First remove all the existing folds
+    normal! zE
+
+    " Create the folds for each in the tag list
+    let fidx = 0
+    while fidx < s:tlist_file_count
+        let ftype = s:tlist_{fidx}_filetype
+
+        " Create the folds for each tag type in a file
+        let j = 1
+        while j <= s:tlist_{ftype}_count
+            let ttype = s:tlist_{ftype}_{j}_name
+            if s:tlist_{fidx}_{ttype}_count
+                let s = s:tlist_{fidx}_start + s:tlist_{fidx}_{ttype}_offset
+                let e = s + s:tlist_{fidx}_{ttype}_count
+                exe s . ',' . e . 'fold'
+            endif
+            let j = j + 1
+        endwhile
+
+        exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'fold'
+        exe 'silent! ' . s:tlist_{fidx}_start . ',' .
+                    \ s:tlist_{fidx}_end . 'foldopen!'
+        let fidx = fidx + 1
+    endwhile
+
+    exe save_wnum . 'wincmd w'
+endfunction
+
+function! s:Tlist_Menu_Add_Base_Menu()
+    call s:Tlist_Log_Msg('Adding the base menu')
+
+    " Add the menu
+    anoremenu <silent> T&ags.Refresh\ menu :call <SID>Tlist_Menu_Refresh()<CR>
+    anoremenu <silent> T&ags.Sort\ menu\ by.Name
+                    \ :call <SID>Tlist_Change_Sort('menu', 'set', 'name')<CR>
+    anoremenu <silent> T&ags.Sort\ menu\ by.Order
+                    \ :call <SID>Tlist_Change_Sort('menu', 'set', 'order')<CR>
+    anoremenu T&ags.-SEP1-           :
+
+    if &mousemodel =~ 'popup'
+        anoremenu <silent> PopUp.T&ags.Refresh\ menu
+                    \ :call <SID>Tlist_Menu_Refresh()<CR>
+        anoremenu <silent> PopUp.T&ags.Sort\ menu\ by.Name
+                  \ :call <SID>Tlist_Change_Sort('menu', 'set', 'name')<CR>
+        anoremenu <silent> PopUp.T&ags.Sort\ menu\ by.Order
+                  \ :call <SID>Tlist_Change_Sort('menu', 'set', 'order')<CR>
+        anoremenu PopUp.T&ags.-SEP1-           :
+    endif
+endfunction
+
+let s:menu_char_prefix =
+            \ '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
+
+" Tlist_Menu_Get_Tag_Type_Cmd
+" Get the menu command for the specified tag type
+" fidx - File type index
+" ftype - File Type
+" add_ttype_name - To add or not to add the tag type name to the menu entries
+" ttype_idx - Tag type index
+function! s:Tlist_Menu_Get_Tag_Type_Cmd(fidx, ftype, add_ttype_name, ttype_idx)
+    " Curly brace variable name optimization
+    let ftype_ttype_idx = a:ftype . '_' . a:ttype_idx
+
+    let ttype = s:tlist_{ftype_ttype_idx}_name
+    if a:add_ttype_name
+        " If the tag type name contains space characters, escape it. This
+        " will be used to create the menu entries.
+        let ttype_fullname = escape(s:tlist_{ftype_ttype_idx}_fullname, ' ')
+    endif
+
+    " Curly brace variable name optimization
+    let fidx_ttype = a:fidx . '_' . ttype
+
+    " Number of tag entries for this tag type
+    let tcnt = s:tlist_{fidx_ttype}_count
+    if tcnt == 0 " No entries for this tag type
+        return ''
+    endif
+
+    let mcmd = ''
+
+    " Create the menu items for the tags.
+    " Depending on the number of tags of this type, split the menu into
+    " multiple sub-menus, if needed.
+    if tcnt > g:Tlist_Max_Submenu_Items
+        let j = 1
+        while j <= tcnt
+            let final_index = j + g:Tlist_Max_Submenu_Items - 1
+            if final_index > tcnt
+                let final_index = tcnt
+            endif
+
+            " Extract the first and last tag name and form the
+            " sub-menu name
+            let tidx = s:tlist_{fidx_ttype}_{j}
+            let first_tag = s:tlist_{a:fidx}_{tidx}_tag_name
+
+            let tidx = s:tlist_{fidx_ttype}_{final_index}
+            let last_tag = s:tlist_{a:fidx}_{tidx}_tag_name
+
+            " Truncate the names, if they are greater than the
+            " max length
+            let first_tag = strpart(first_tag, 0, g:Tlist_Max_Tag_Length)
+            let last_tag = strpart(last_tag, 0, g:Tlist_Max_Tag_Length)
+
+            " Form the menu command prefix
+            let m_prefix = 'anoremenu <silent> T\&ags.'
+            if a:add_ttype_name
+                let m_prefix = m_prefix . ttype_fullname . '.'
+            endif
+            let m_prefix = m_prefix . first_tag . '\.\.\.' . last_tag . '.'
+
+            " Character prefix used to number the menu items (hotkey)
+            let m_prefix_idx = 0
+
+            while j <= final_index
+                let tidx = s:tlist_{fidx_ttype}_{j}
+
+                let tname = s:tlist_{a:fidx}_{tidx}_tag_name
+
+                let mcmd = mcmd . m_prefix . '\&' .
+                            \ s:menu_char_prefix[m_prefix_idx] . '\.' .
+                            \ tname . ' :call <SID>Tlist_Menu_Jump_To_Tag(' .
+                            \ tidx . ')<CR>|'
+
+                let m_prefix_idx = m_prefix_idx + 1
+                let j = j + 1
+            endwhile
+        endwhile
+    else
+        " Character prefix used to number the menu items (hotkey)
+        let m_prefix_idx = 0
+
+        let m_prefix = 'anoremenu <silent> T\&ags.'
+        if a:add_ttype_name
+            let m_prefix = m_prefix . ttype_fullname . '.'
+        endif
+        let j = 1
+        while j <= tcnt
+            let tidx = s:tlist_{fidx_ttype}_{j}
+
+            let tname = s:tlist_{a:fidx}_{tidx}_tag_name
+
+            let mcmd = mcmd . m_prefix . '\&' .
+                        \ s:menu_char_prefix[m_prefix_idx] . '\.' .
+                        \ tname . ' :call <SID>Tlist_Menu_Jump_To_Tag(' . tidx
+                        \ . ')<CR>|'
+
+            let m_prefix_idx = m_prefix_idx + 1
+            let j = j + 1
+        endwhile
+    endif
+
+    return mcmd
+endfunction
+
+" Update the taglist menu with the tags for the specified file
+function! s:Tlist_Menu_File_Refresh(fidx)
+    call s:Tlist_Log_Msg('Refreshing the tag menu for ' . s:tlist_{a:fidx}_filename)
+    " The 'B' flag is needed in the 'cpoptions' option
+    let old_cpoptions = &cpoptions
+    set cpoptions&vim
+
+    exe s:tlist_{a:fidx}_menu_cmd
+
+    " Update the popup menu (if enabled)
+    if &mousemodel =~ 'popup'
+        let cmd = substitute(s:tlist_{a:fidx}_menu_cmd, ' T\\&ags\.',
+                                        \ ' PopUp.T\\\&ags.', "g")
+        exe cmd
+    endif
+
+    " The taglist menu is not empty now
+    let s:tlist_menu_empty = 0
+
+    " Restore the 'cpoptions' settings
+    let &cpoptions = old_cpoptions
+endfunction
+
+" Tlist_Menu_Update_File
+" Add the taglist menu
+function! s:Tlist_Menu_Update_File(clear_menu)
+    if !has('gui_running')
+        " Not running in GUI mode
+        return
+    endif
+
+    call s:Tlist_Log_Msg('Updating the tag menu, clear_menu = ' . a:clear_menu)
+
+    " Remove the tags menu
+    if a:clear_menu
+        call s:Tlist_Menu_Remove_File()
+
+    endif
+
+    " Skip buffers with 'buftype' set to nofile, nowrite, quickfix or help
+    if &buftype != ''
+        return
+    endif
+
+    let filename = fnamemodify(bufname('%'), ':p')
+    let ftype = s:Tlist_Get_Buffer_Filetype('%')
+
+    " If the file doesn't support tag listing, skip it
+    if s:Tlist_Skip_File(filename, ftype)
+        return
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(filename)
+    if fidx == -1 || !s:tlist_{fidx}_valid
+        " Check whether this file is removed based on user request
+        " If it is, then don't display the tags for this file
+        if s:Tlist_User_Removed_File(filename)
+            return
+        endif
+
+        " Process the tags for the file
+        let fidx = s:Tlist_Process_File(filename, ftype)
+        if fidx == -1
+            return
+        endif
+    endif
+
+    let fname = escape(fnamemodify(bufname('%'), ':t'), '.')
+    if fname != ''
+        exe 'anoremenu T&ags.' .  fname . ' <Nop>'
+        anoremenu T&ags.-SEP2-           :
+    endif
+
+    if !s:tlist_{fidx}_tag_count
+        return
+    endif
+
+    if s:tlist_{fidx}_menu_cmd != ''
+        " Update the menu with the cached command
+        call s:Tlist_Menu_File_Refresh(fidx)
+
+        return
+    endif
+
+    " We are going to add entries to the tags menu, so the menu won't be
+    " empty
+    let s:tlist_menu_empty = 0
+
+    let cmd = ''
+
+    " Determine whether the tag type name needs to be added to the menu
+    " If more than one tag type is present in the taglisting for a file,
+    " then the tag type name needs to be present
+    let add_ttype_name = -1
+    let i = 1
+    while i <= s:tlist_{ftype}_count && add_ttype_name < 1
+        let ttype = s:tlist_{ftype}_{i}_name
+        if s:tlist_{fidx}_{ttype}_count
+            let add_ttype_name = add_ttype_name + 1
+        endif
+        let i = i + 1
+    endwhile
+
+    " Process the tags by the tag type and get the menu command
+    let i = 1
+    while i <= s:tlist_{ftype}_count
+        let mcmd = s:Tlist_Menu_Get_Tag_Type_Cmd(fidx, ftype, add_ttype_name, i)
+        if mcmd != ''
+            let cmd = cmd . mcmd
+        endif
+
+        let i = i + 1
+    endwhile
+
+    " Cache the menu command for reuse
+    let s:tlist_{fidx}_menu_cmd = cmd
+
+    " Update the menu
+    call s:Tlist_Menu_File_Refresh(fidx)
+endfunction
+
+" Tlist_Menu_Remove_File
+" Remove the tags displayed in the tags menu
+function! s:Tlist_Menu_Remove_File()
+    if !has('gui_running') || s:tlist_menu_empty
+        return
+    endif
+
+    call s:Tlist_Log_Msg('Removing the tags menu for a file')
+
+    " Cleanup the Tags menu
+    silent! unmenu T&ags
+    if &mousemodel =~ 'popup'
+        silent! unmenu PopUp.T&ags
+    endif
+
+    " Add a dummy menu item to retain teared off menu
+    noremenu T&ags.Dummy l
+
+    silent! unmenu! T&ags
+    if &mousemodel =~ 'popup'
+        silent! unmenu! PopUp.T&ags
+    endif
+
+    call s:Tlist_Menu_Add_Base_Menu()
+
+    " Remove the dummy menu item
+    unmenu T&ags.Dummy
+
+    let s:tlist_menu_empty = 1
+endfunction
+
+" Tlist_Menu_Refresh
+" Refresh the taglist menu
+function! s:Tlist_Menu_Refresh()
+    call s:Tlist_Log_Msg('Refreshing the tags menu')
+    let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
+    if fidx != -1
+        " Invalidate the cached menu command
+        let s:tlist_{fidx}_menu_cmd = ''
+    endif
+
+    " Update the taglist, menu and window
+    call s:Tlist_Update_Current_File()
+endfunction
+
+" Tlist_Menu_Jump_To_Tag
+" Jump to the selected tag
+function! s:Tlist_Menu_Jump_To_Tag(tidx)
+    let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
+    if fidx == -1
+        return
+    endif
+
+    let tagpat = s:Tlist_Get_Tag_SearchPat(fidx, a:tidx)
+    if tagpat == ''
+        return
+    endif
+
+    " Add the current cursor position to the jump list, so that user can
+    " jump back using the ' and ` marks.
+    mark '
+
+    silent call search(tagpat, 'w')
+
+    " Bring the line to the middle of the window
+    normal! z.
+
+    " If the line is inside a fold, open the fold
+    if foldclosed('.') != -1
+        .foldopen
+    endif
+endfunction
+
+" Tlist_Menu_Init
+" Initialize the taglist menu
+function! s:Tlist_Menu_Init()
+    call s:Tlist_Menu_Add_Base_Menu()
+
+    " Automatically add the tags defined in the current file to the menu
+    augroup TagListMenuCmds
+        autocmd!
+
+        if !g:Tlist_Process_File_Always
+            autocmd BufEnter * call s:Tlist_Refresh()
+        endif
+        autocmd BufLeave * call s:Tlist_Menu_Remove_File()
+    augroup end
+
+    call s:Tlist_Menu_Update_File(0)
+endfunction
+
+" Tlist_Vim_Session_Load
+" Initialize the taglist window/buffer, which is created when loading
+" a Vim session file.
+function! s:Tlist_Vim_Session_Load()
+    call s:Tlist_Log_Msg('Tlist_Vim_Session_Load')
+
+    " Initialize the taglist window
+    call s:Tlist_Window_Init()
+
+    " Refresh the taglist window
+    call s:Tlist_Window_Refresh()
+endfunction
+
+" Tlist_Set_App
+" Set the name of the external plugin/application to which taglist
+" belongs.
+" Taglist plugin is part of another plugin like cream or winmanager.
+function! Tlist_Set_App(name)
+    if a:name == ""
+        return
+    endif
+
+    let s:tlist_app_name = a:name
+endfunction
+
+" Winmanager integration
+
+" Initialization required for integration with winmanager
+function! TagList_Start()
+    " If current buffer is not taglist buffer, then don't proceed
+    if bufname('%') != '__Tag_List__'
+        return
+    endif
+
+    call Tlist_Set_App('winmanager')
+
+    " Get the current filename from the winmanager plugin
+    let bufnum = WinManagerGetLastEditedFile()
+    if bufnum != -1
+        let filename = fnamemodify(bufname(bufnum), ':p')
+        let ftype = s:Tlist_Get_Buffer_Filetype(bufnum)
+    endif
+
+    " Initialize the taglist window, if it is not already initialized
+    if !exists('s:tlist_window_initialized') || !s:tlist_window_initialized
+        call s:Tlist_Window_Init()
+        call s:Tlist_Window_Refresh()
+        let s:tlist_window_initialized = 1
+    endif
+
+    " Update the taglist window
+    if bufnum != -1
+        if !s:Tlist_Skip_File(filename, ftype) && g:Tlist_Auto_Update
+            call s:Tlist_Window_Refresh_File(filename, ftype)
+        endif
+    endif
+endfunction
+
+function! TagList_IsValid()
+    return 0
+endfunction
+
+function! TagList_WrapUp()
+    return 0
+endfunction
+
+" restore 'cpo'
+let &cpo = s:cpo_save
+unlet s:cpo_save
+
diff --git a/vimrc/.vim/bundle/tig-explorer.vim b/vimrc/.vim/bundle/tig-explorer.vim
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/tig-explorer.vim
@@ -0,0 +1 @@
+Subproject commit 677391a11050f968c04e4c334a1fc329c6159c4d-dirty
diff --git a/vimrc/.vim/bundle/tlib_vim b/vimrc/.vim/bundle/tlib_vim
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/tlib_vim
@@ -0,0 +1 @@
+Subproject commit d3bdad7b5e4253dc7ce6793342d7b8755c67ff0c
diff --git a/vimrc/.vim/bundle/vala.vim b/vimrc/.vim/bundle/vala.vim
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/vala.vim
@@ -0,0 +1 @@
+Subproject commit ce569e187bf8f9b506692ef08c10b584595f8e2d
diff --git a/vimrc/.vim/bundle/vim-addon-mw-utils b/vimrc/.vim/bundle/vim-addon-mw-utils
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/vim-addon-mw-utils
@@ -0,0 +1 @@
+Subproject commit 6aaf4fee472db7cbec6d2c8eea69fdf3a8f8a75d
diff --git a/vimrc/.vim/bundle/vim-anyfold b/vimrc/.vim/bundle/vim-anyfold
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/vim-anyfold
@@ -0,0 +1 @@
+Subproject commit 4267ae2acc11f7b1e5832617f2e79996f309c431-dirty
diff --git a/vimrc/.vim/bundle/vim-autoformat b/vimrc/.vim/bundle/vim-autoformat
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/vim-autoformat
@@ -0,0 +1 @@
+Subproject commit 32589b15623915a4a5626533df35c8811f46085f-dirty
diff --git a/vimrc/.vim/bundle/vim-buffergator b/vimrc/.vim/bundle/vim-buffergator
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/vim-buffergator
@@ -0,0 +1 @@
+Subproject commit c663ae0cf3e9337d4639ad3bb3235fdfccb4e488-dirty
diff --git a/vimrc/.vim/bundle/vim-docker-compose-syntax b/vimrc/.vim/bundle/vim-docker-compose-syntax
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/vim-docker-compose-syntax
@@ -0,0 +1 @@
+Subproject commit a4985510d1559736a42fef766f42625a202777e3
diff --git a/vimrc/.vim/bundle/vim-fetch b/vimrc/.vim/bundle/vim-fetch
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/vim-fetch
@@ -0,0 +1 @@
+Subproject commit c8887b12b17bc9b52164a5d6f9f11ab0d19a47d1-dirty
diff --git a/vimrc/.vim/bundle/vim-fugitive b/vimrc/.vim/bundle/vim-fugitive
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/vim-fugitive
@@ -0,0 +1 @@
+Subproject commit c3da0bd1a950c3d7b9f546b5e34dd2e0354e0aed-dirty
diff --git a/vimrc/.vim/bundle/vim-ghost b/vimrc/.vim/bundle/vim-ghost
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/vim-ghost
@@ -0,0 +1 @@
+Subproject commit 115e2600481c92c0bfb69d82ccbd8af7dc052a03
diff --git a/vimrc/.vim/bundle/vim-gradle b/vimrc/.vim/bundle/vim-gradle
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/vim-gradle
@@ -0,0 +1 @@
+Subproject commit 508629fa2a3be1b2052e4e553593f60d12dfc090
diff --git a/vimrc/.vim/bundle/vim-javascript-syntax b/vimrc/.vim/bundle/vim-javascript-syntax
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/vim-javascript-syntax
@@ -0,0 +1 @@
+Subproject commit 939d84b538480e7cb7810fde5ad807e9ecb477f6-dirty
diff --git a/vimrc/.vim/bundle/vim-log-syntax b/vimrc/.vim/bundle/vim-log-syntax
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/vim-log-syntax
@@ -0,0 +1 @@
+Subproject commit 6c244f27dc552b6093b851f9070c3d22e3a38523-dirty
diff --git a/vimrc/.vim/bundle/vim-pbcopy b/vimrc/.vim/bundle/vim-pbcopy
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/vim-pbcopy
@@ -0,0 +1 @@
+Subproject commit d6adab9d76d3d1ac6e85680f8579b543733ed3d7-dirty
diff --git a/vimrc/.vim/bundle/vim-pdf b/vimrc/.vim/bundle/vim-pdf
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/vim-pdf
@@ -0,0 +1 @@
+Subproject commit 4e7a8d39a4ace365e17962245c7f3f69bffec50f
diff --git a/vimrc/.vim/bundle/vim-php-cs-fixer b/vimrc/.vim/bundle/vim-php-cs-fixer
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/vim-php-cs-fixer
@@ -0,0 +1 @@
+Subproject commit c993a1381454e97048383a8ff6f18eecafc763dc
diff --git a/vimrc/.vim/bundle/vim-ps1 b/vimrc/.vim/bundle/vim-ps1
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/vim-ps1
@@ -0,0 +1 @@
+Subproject commit 502590f90a21f0de2b7664d6d0dcc90e5bb28a9c
diff --git a/vimrc/.vim/bundle/vim-rails b/vimrc/.vim/bundle/vim-rails
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/vim-rails
@@ -0,0 +1 @@
+Subproject commit 959e94b76e6ebdf984acef61649ba7d0f62bd425
diff --git a/vimrc/.vim/bundle/vim-scala b/vimrc/.vim/bundle/vim-scala
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/vim-scala
@@ -0,0 +1 @@
+Subproject commit 7657218f14837395a4e6759f15289bad6febd1b4
diff --git a/vimrc/.vim/bundle/vim-snipmate b/vimrc/.vim/bundle/vim-snipmate
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/vim-snipmate
@@ -0,0 +1 @@
+Subproject commit b8fe3fb6b127c417290c0fe1a85a8dd0173cef05-dirty
diff --git a/vimrc/.vim/bundle/vundle.vim b/vimrc/.vim/bundle/vundle.vim
new file mode 160000
--- /dev/null
+++ ./vimrc/.vim/bundle/vundle.vim
@@ -0,0 +1 @@
+Subproject commit b255382d6242d7ea3877bf059d2934125e0c4d95
diff --git a/vimrc/.vim/bundle/zip/autoload/zip.vim b/vimrc/.vim/bundle/zip/autoload/zip.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/bundle/zip/autoload/zip.vim
@@ -0,0 +1,233 @@
+" zip.vim: Handles browsing zipfiles recursively (needs python)
+"            AUTOLOAD PORTION
+" Date:		Dec 23, 2009
+" Version:	1.1
+" Last Modification By:	Arno <arenevier@fdn.fr>
+" Original Author: That file is based on autoload/zip.vim from 
+"                  Charles E Campbell, Jr <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
+" License:	    Vim License  (see vim's :help license)
+" Copyright:    Copyright (C) 2008-2009 Arno
+"               Permission is hereby granted to use and distribute this code,
+"               with or without modifications, provided that this copyright
+"               notice is copied with it. Like anything else that's free,
+"               zip.vim and zipPlugin.vim are provided *as is* and comes with
+"               no warranty of any kind, either expressed or implied. By using
+"               this plugin, you agree that in no event will the copyright
+"               holder be liable for any damages resulting from the use
+"               of this software.
+
+let s:keepcpo= &cpo
+set cpo&vim
+
+if &cp || exists("g:loaded_zip") || v:version < 700 || !has("python")
+ finish
+endif
+
+let g:loaded_zip     = "v1"
+let s:zipfile_escape = ' ?&;\|'
+
+python import sys, os, vim, re, tempfile
+python from zipfile import ZipFile, ZIP_STORED, ZIP_DEFLATED
+python from StringIO import StringIO
+
+" ZipBrowseSelect: {{{2
+fun! s:ZipBrowseSelect()
+  let repkeep= &report
+  set report=10
+  let fname= getline(".")
+
+  " sanity check
+  if fname =~ '^"'
+   let &report= repkeep
+   return
+  endif
+  if fname =~ '/$'
+   redraw!
+   echohl Error | echo "***error*** (zip#Browse) Please specify a file, not a directory" | echohl None
+   let &report= repkeep
+   return
+  endif
+  "FIXME: file whose name contain '::' are considered as combined zip files
+  if fname =~ '::'
+   redraw!
+   echohl Error | echo "***error*** (zip#Browse) cannot handle files whose name contain '::'. sorry :(" | echohl None
+   return
+  endif
+
+  " get zipfile to the new-window
+  let zipfile = b:zipfile
+  let curfile= expand("%")
+
+  new
+  wincmd _
+  exe "e zipfile:".escape(zipfile,s:zipfile_escape).'::'.escape(fname,s:zipfile_escape)
+  filetype detect
+
+  let &report= repkeep
+endfun
+
+fun! zip#Load(fname)
+    " we need this to avoid combined zipfile to be read twice: once because it
+    " ends it begins with zipfile: and once because it ends with .zip
+    if a:fname !~ '^zipfile:'
+        call zip#Read(a:fname)
+    endif
+endfun
+
+fun! zip#Read(fname)
+  let repkeep= &report
+  set report=10
+
+  try
+    let pyarg = a:fname
+    python pyZipCat()
+  catch
+    echohl Error | echo "***error*** (zip#Read) error uncompressing " . a:fname | echohl None
+  endtry
+
+  let &report= repkeep
+endfun
+
+fun! zip#Write(fname)
+
+  let repkeep= &report
+  set report=10
+
+  try
+    let pyarg = a:fname
+    python pyZipWrite()
+  catch
+    echohl Error | echo "***error*** (zip#Write) error updating " . a:fname | echohl None
+  endtry
+
+  let &report= repkeep
+  setlocal nomod
+
+endfun
+
+python << EOF
+
+def zipSetupOptions():
+  vim.command("setlocal noswapfile")
+  vim.command("setlocal buftype=nofile")
+  vim.command("setlocal bufhidden=hide")
+  vim.command("setlocal nobuflisted")
+  vim.command("setlocal nowrap")
+  vim.command("setlocal ft=tar")
+  vim.command("setlocal nomodifiable")
+  vim.command("setlocal readonly")
+  vim.command("setlocal nomodified")
+  vim.command("noremap <silent> <buffer> <cr> :call <SID>ZipBrowseSelect()<cr>")
+
+def zipDisplayHeaders(name):
+  vim.current.buffer.append("\" Browsing zipfile %s" % (name))
+  vim.current.buffer.append("\" Select a file with cursor and press ENTER")
+  vim.current.buffer.append("\"")
+  del (vim.current.buffer[0])
+
+def zipList(file, name):
+    vim.command("setlocal modifiable noreadonly")
+    zipDisplayHeaders(name)
+    for f in file.filelist:
+        vim.current.buffer.append (f.orig_filename)
+    zipSetupOptions()
+
+def zipContent(file, target):
+    vim.command("setlocal modifiable noreadonly")
+    for line in file.read(target).split('\n'):
+        vim.current.buffer.append(line)
+    del vim.current.buffer[0]
+    vim.command("set nomodified")
+
+def pause():
+    vim.command("call input(\"\")")
+
+def pyZipCat():
+    name = vim.eval("pyarg")
+    fullname = re.sub('^zipfile:', '', name)
+    list = fullname.split('::')
+
+    fd = open(list[0], 'rb')
+    archive = ZipFile(fd)
+
+    if len(list) == 1: # only one file. display it's content
+        zipList(archive, list[0])
+        archive.close()
+        fd.close()
+        vim.command("let b:zipfile = \"%s\"" % fullname);
+        return
+
+    for file in list[1:-1]:
+        str = StringIO()
+        str.write(archive.read(file))
+        archive = ZipFile(str)
+
+    target = list[-1]
+
+    if os.path.splitext(target)[-1] in ['.zip', '.jar', '.xpi']: # zip file: list content
+        str = StringIO()
+        str.write(archive.read(target))
+        archive = ZipFile(str)
+        zipList(archive, target)
+    else: # normal file: display content
+        zipContent(archive, target)
+    archive.close()
+    fd.close()
+    vim.command("let b:zipfile = \"%s\"" % fullname);
+
+def pyZipUpdate(archive, filetorep, buffer):
+    """ in a zipfile, replace some file with a new content, and return a
+    buffer containing new archive bytes """
+    str = StringIO()
+    newarch = ZipFile(str, 'a')
+    for name in archive.namelist():
+        if name == filetorep:
+            buffer.seek(0)
+            content = buffer.read()
+        else:
+            content = archive.read(name)
+        zipinfo = archive.getinfo(name)
+        if zipinfo.compress_type not in [ZIP_STORED, ZIP_DEFLATED]:
+            archive_info.compress_type = ZIP_DEFLATED
+        newarch.writestr(zipinfo, content)
+    newarch.close()
+    str.seek(0)
+    return str
+
+def pyZipWrite():
+    name = vim.eval("pyarg")
+    list = re.sub('^zipfile:', '', name).split('::')
+
+    # first, extract archives from outer to inner
+    fd = open(list[0], 'rb')
+    archive = ZipFile(fd)
+    archives = [archive]
+
+    for file in list[1:-1]:
+        str = StringIO()
+        str.write(archive.read(file))
+        archive = ZipFile(str)
+        archives.append(archive)
+
+    # current buffer
+    buf = StringIO()
+    buf.write('\n'.join(vim.current.buffer[:]))
+
+    # now, go backward to update and recompress them
+    for (arch, file) in reversed(zip(archives, list[1:])):
+         newbuf = StringIO()
+         newbuf.write(pyZipUpdate(arch, file, buf).read())
+         buf = newbuf
+         arch.close()
+    buf.seek(0)
+
+    fd.close()
+    fd = open(list[0], 'wb')
+    fd.write(buf.read())
+    fd.close()
+    buf.close()
+
+EOF
+
+let &cpo= s:keepcpo
+unlet s:keepcpo
diff --git a/vimrc/.vim/bundle/zip/plugin/zipPlugin.vim b/vimrc/.vim/bundle/zip/plugin/zipPlugin.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/bundle/zip/plugin/zipPlugin.vim
@@ -0,0 +1,37 @@
+" zipPlugin.vim: Handles browsing zipfiles
+"            PLUGIN PORTION
+" Date:			Mar 29, 2008
+" Last Modification By:	Arno <arenevier@fdn.fr>
+" Original Author: That file is based on plugin/zipPlugin.vim from 
+"                  Charles E Campbell, Jr <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
+" License:		Vim License  (see vim's :help license)
+" Copyright:    Copyright (C) 2008 Arno
+"               Permission is hereby granted to use and distribute this code,
+"               with or without modifications, provided that this copyright
+"               notice is copied with it. Like anything else that's free,
+"               zipPlugin.vim is provided *as is* and comes with no warranty
+"               of any kind, either expressed or implied. By using this
+"               plugin, you agree that in no event will the copyright
+"               holder be liable for any damages resulting from the use
+"               of this software.
+"
+if &cp || exists("g:loaded_zipPlugin") || !has("python")
+ finish
+endif
+let g:loaded_zipPlugin = 1
+let s:keepcpo          = &cpo
+set cpo&vim
+
+augroup zip
+ au!
+ 
+ au BufReadCmd   zipfile:*/*	call zip#Read(expand("<amatch>"))
+ au BufWriteCmd  zipfile:*/*	call zip#Write(expand("<amatch>"))
+
+ au BufReadCmd   *.zip		call zip#Load(expand("<amatch>"))
+ au BufReadCmd   *.jar		call zip#Load(expand("<amatch>"))
+ au BufReadCmd   *.xpi		call zip#Load(expand("<amatch>"))
+augroup END
+
+let &cpo= s:keepcpo
+unlet s:keepcpo
diff --git a/vimrc/.vim/doc/SQLUtilities.txt b/vimrc/.vim/doc/SQLUtilities.txt
new file mode 100755
--- /dev/null
+++ ./vimrc/.vim/doc/SQLUtilities.txt
@@ -0,0 +1,1202 @@
+*SQLUtilities.txt*      For Vim version 7.0. 
+
+Author:	        David Fishburn                             December 3, 2012
+
+SQLUtilities:   Variety of tools for working with SQL
+Version:        7.0.0
+Homepage:       http://www.vim.org/scripts/script.php?script_id=492
+Feedback:	    David Fishburn <dfishburn dot vim at gmail dot com>
+
+For instructions on installing this file, type
+	:help add-local-help |add-local-help| inside Vim.
+
+
+==============================================================================
+1. Contents                                      *sqlutil* *sqlutil-contents*
+
+    1. Contents.......................................: |sqlutil-contents|
+    2. Tutorial.......................................: |sqlutil-tutorial|
+    3. Commands.......................................: |sqlutil-commands|
+       3.1 SQLUFormatter..............................: |sqlutil-formatter|
+           3.1.1 Formatting Examples..................: |sqlutil-examples|
+           3.1.2 Formatting Options...................: |sqlutil-format-options|
+                 3.1.2.1  Align Where Clause..........: |sqlutil-align-where|
+                 3.1.2.2  Align Comma.................: |sqlutil-align-comma|
+                 3.1.2.3  Align First Word............: |sqlutil-align-first-word|
+                 3.1.2.4  Align Keyword Right.........: |sqlutil-align-keyword-right|
+                 3.1.2.5  Change Keyword Case.........: |sqlutil-change_keyword-case|
+                 3.1.2.6  Indent Nested Blocks........: |sqlutil-indent_nested|
+                 3.1.2.7  Wrap Width..................: |sqlutil-wrap-wdith|
+                 3.1.2.8  Wrap Long Lines.............: |sqlutil-wrap-long-lines|
+                 3.1.2.9  Wrap Function Calls.........: |sqlutil-wrap-function-calls|
+                 3.1.2.10 Split Unbalanced Parentheses: |sqlutil-split_unbalanced-paran|
+       3.2 SQLUCreateColumnList.......................: |sqlutil-column-list|
+       3.3 SQLUGetColumnDef...........................: |sqlutil-column-definition|
+           SQLUGetColumnDataType......................: |sqlutil-column-datatype|
+       3.4 SQLUCreateProcedure........................: |sqlutil-procedure|
+    4. Suggested Mappings.............................: |sqlutil-mappings|
+    5. Global Options.................................: |sqlutil-options|
+    6. Customization..................................: |sqlutil-customization|
+        6.1 Cmd Terminator............................: |sqlutil-customization|
+        6.2 Vim Menu..................................: |sqlutil-customization|
+        6.3 Vim's Syntax Support......................: |sqlutil-customization|
+    7. History........................................: |sqlutil-history|
+    8. Dependencies...................................: |sqlutil-dependencies|
+    9. Complementary Plugins..........................: |sqlutil-complementary-plugins|
+    10.TODO...........................................: |sqlutil-todo|
+
+
+==============================================================================
+2. Tutorial                                      *sqlutil-tutorial*
+
+My most used command is the formatting capability of SQLUtilities.  Please
+ensure the Align.vim plugin has already been installed see
+|sqlutil-dependencies|.
+
+Section 3 covers each command in detail, but to use these commands you can 
+do the following.  Assume you have a SQL statement you would like to 
+be formatted. >
+    SELECT t1.c1, t1.c2, t1.c3, t2.column1, t2.column2 
+    FROM t1 JOIN t2 WHERE t1.c1 = 'hello'
+    AND t2.column2 = 'goodbye';
+
+There are several ways to format this statement.
+
+    1.  Start |visual-mode| using any of the modes (i.e. v, V or CTRL-V),
+        highlight the 2 lines and (assuming the default |<Leader>|) you can 
+        use the visual map: >
+            \sf (sql - format).
+<
+    2.  Start |visual-mode| using any of the modes (i.e. v, V or CTRL-V),
+        highlight the 2 lines and run the SQLUFormatter command: >
+            :'<,'>SQLUFormatter
+<            
+    3.  If using Vim in GUI mode, the plugin provides a menu to make accessing
+        the commands easier.  It also shows the mapping, to assist with 
+        remembering them.  After visually selecting the lines you can 
+        use the (default) menu as: >
+            Plugin->SQLUtil->Format Statement
+<            
+    4.  Specify the range of lines and run the SQLUFormatter command: >
+            :1,2SQLUFormatter
+<
+The default settings produce a formatted statement as: >
+    SELECT t1.c1, t1.c2, t1.c3, t2.column1, t2.column2
+      FROM t1
+      JOIN t2
+     WHERE t1.c1      = 'hello'
+       AND t2.column2 = 'goodbye';
+<
+Using the menu Plugin -> SQLUtil -> Toggle Align Where and reformat the
+statement: >
+    SELECT t1.c1, t1.c2, t1.c3, t2.column1, t2.column2
+      FROM t1
+      JOIN t2
+     WHERE t1.c1 = 'hello'
+       AND t2.column2 = 'goodbye';
+<
+Using the menu Plugin -> SQLUtil -> Toggle Right Align Keywords and 
+reformat the statement: >
+    SELECT t1.c1, t1.c2, t1.c3, t2.column1, t2.column2
+    FROM   t1
+    JOIN   t2
+    WHERE  t1.c1 = 'hello'
+    AND    t2.column2 = 'goodbye';
+<    
+Using the menu Plugin -> SQLUtil -> Toggle Align Comma and re-toggle
+Plugin -> SQLUtil -> Toggle Right Align Keywords and reformat the
+statement: >
+    SELECT t1.c1
+         , t1.c2
+         , t1.c3
+         , t2.column1
+         , t2.column2
+      FROM t1
+      JOIN t2
+     WHERE t1.c1 = 'hello'
+       AND t2.column2 = 'goodbye';
+<    
+Using the menu Plugin -> SQLUtil -> Lowercase Keywords and reformat the
+statement: >
+    select t1.c1, t1.c2, t1.c3, t2.column1, t2.column2
+      from t1
+      join t2
+     where t1.c1 = 'hello'
+       and t2.column2 = 'goodbye';
+<
+Since there are many options to control how the statement is formatted, these 
+can be set from the command line (though it is easier using the menus): >
+    let g:sqlutil_align_where = 1
+    let g:sqlutil_<tab> to cycle through the various option names.
+<
+These features are much more easily set via the menu, which does a number of 
+things for you:
+    1.  Allows you to toggle the setting of the options.
+    2.  Does not require you to remember the option names.
+    3.  Shows the current setting of each of the options.
+
+The remaining commands all rely upon have the CREATE TABLE statements open 
+in Vim (either in the same buffer or a different one) and will work 
+over those statements: >
+    SQLUCreateColumnList
+    SQLUGetColumnDef
+    SQLUGetColumnDataType
+    SQLUCreateProcedure
+
+Each of these statements work on the current word the cursor is on.
+So if the cursor is on the "t1" word in the above SQL statement 
+the you can either use the command:
+    :SQLUCreateColumnList
+or 
+    \scl 
+
+See below for more information in the mappings.
+
+
+If you do not have the CREATE TABLE statements handy in a SQL file, the 
+dbext plugin (which I also author) can pull this information directly from 
+within the database.  So typically, I only use this plugin to format 
+SQL statements and use the dbext plugin to execute statement against a 
+database.  See |sqlutil-complementary-plugins| for more details.
+
+
+==============================================================================
+3. Commands                                      *sqlutil-commands*
+
+3.1 SQLUFormatter                                *sqlutil-formatter*
+
+  [range]SQLUFormatter(..list..)                
+
+       - Formats one statement at a time, this is not meant to be
+         an indenter for SQL files.
+       - Reformats the SQL statements over the specified range.  
+       - Statement will lined up given the existing indent of the first word.
+       - Formats SQL statements into a easily readable form.
+       - Breaks keywords onto new lines.
+       - Forces column lists to be split over as many lines as
+         necessary to fit the current textwidth of the buffer,
+         so that lines do not wrap.
+       - If parentheses are unbalanced (ie a subselect) it will
+         indent everything within the unbalanced parenthesis.
+       - Works for SELECT, INSERT, UPDATE, DELETE statements.
+
+3.1.1 Formatting Examples:                       *sqlutil-examples*
+
+    Original: >
+    SELECT m.MSG_ID, m.PRIORITY_ID, CUST.CUST_NBR, CUST.CUST_NM, 
+    CUST.CUST_LEGAL_NM, CUST.STORE_ADDR_1, CUST.STORE_ADDR_2, 
+    CUST.CROSS_STREET, XMLELEMENT( 'Alerts', XMLELEMENT( 'Alert_alert_id', 
+    alert_id ), XMLELEMENT( 'Alert_agent_id', agent_id ), XMLELEMENT( 
+    'Alert_alert_type_id', alert_type_desc), XMLELEMENT( 
+    'Alert_alert_date', alert_date), XMLELEMENT( 
+    'Alert_url_reference', url_reference), XMLELEMENT( 
+    'Alert_read_status', read_status )) CUST.STORE_CITY, 
+    CUST.STORE_ST, CUST.POST_CODE, CUST.STORE_MGR_NM, FROM MESSAGES m JOIN 
+    PRIORITY_CD P WHERE m.to_person_id = ?  AND p.NAME = 'PRI_EMERGENCY' AND 
+    p.JOB = 'Plumber' AND m.status_id < ( SELECT s.STATUS_ID FROM 
+    MSG_STATUS_CD s WHERE s.NAME = 'MSG_READ') ORDER BY m.msg_id desc
+<    
+
+  Formatted: >
+    SELECT m.MSG_ID, m.PRIORITY_ID, CUST.CUST_NBR, CUST.CUST_NM,
+           CUST.CUST_LEGAL_NM, CUST.STORE_ADDR_1, CUST.STORE_ADDR_2,
+           CUST.CROSS_STREET,
+           XMLELEMENT(
+               'Alerts', XMLELEMENT( 'Alert_alert_id', alert_id ),
+               XMLELEMENT( 'Alert_agent_id', agent_id ),
+               XMLELEMENT( 'Alert_alert_type_id', alert_type_desc),
+               XMLELEMENT( 'Alert_alert_date', alert_date),
+               XMLELEMENT(
+                   'Alert_url_reference', url_reference
+                ), XMLELEMENT( 'Alert_read_status', read_status )
+           ) CUST.STORE_CITY, CUST.STORE_ST, CUST.POST_CODE, 
+           CUST.STORE_MGR_NM
+      FROM MESSAGES m
+      JOIN PRIORITY_CD P
+     WHERE m.to_person_id = ?
+       AND p.NAME = 'PRI_EMERGENCY'
+       AND p.JOB = 'Plumber'
+       AND m.status_id < (
+            SELECT s.STATUS_ID
+              FROM MSG_STATUS_CD s
+             WHERE s.NAME = 'MSG_READ'
+           )
+     ORDER BY m.msg_id desc
+<    
+    
+
+  Original: >
+    UPDATE "SERVICE_REQUEST" SET "BUILDING_ID" = ?, "UNIT_ID" = ?, 
+    "REASON_ID" = ?, "PERSON_ID" = ?, "PRIORITY_ID" = ?, "STATUS_ID" = ?, 
+    "CREATED" = ?, "REQUESTED" = ?, "ARRIVED" = ?  WHERE "REQUEST_ID" = ?
+<
+
+  Formatted: >
+    UPDATE "SERVICE_REQUEST"
+       SET "BUILDING_ID" = ?,
+           "UNIT_ID" = ?,
+           "REASON_ID" = ?,
+           "PERSON_ID" = ?,
+           "PRIORITY_ID" = ?,
+           "STATUS_ID" = ?,
+           "CREATED" = ?,
+           "REQUESTED" = ?,
+           "ARRIVED" = ?,
+     WHERE "REQUEST_ID"  = ?
+<
+
+
+  Original: >
+    INSERT INTO "MESSAGES" ( "MSG_ID", "TO_PERSON_ID", 
+    "FROM_PERSON_ID", "REQUEST_ID", "CREATED", "PRIORITY_ID", 
+    "MSG_TYPE_ID", "STATUS_ID", "READ_WHEN", "TIMEOUT", 
+    "MSG_TXT", "RESEND_COUNT" ) VALUES ( ?, ?, ?, 
+    ?, ?, ?, ?, ?, ?, ?, ?, ? )
+<
+
+  Formatted: >
+    INSERT INTO "MESSAGES" ( "MSG_ID", "TO_PERSON_ID",
+           "FROM_PERSON_ID", "REQUEST_ID", "CREATED",
+           "PRIORITY_ID", "MSG_TYPE_ID", "STATUS_ID",
+           "READ_WHEN", "TIMEOUT", "MSG_TXT", "RESEND_COUNT" )
+    VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )
+<
+
+
+3.1.2 Formatting Options                         *sqlutil-format-options*
+
+  There are several options which can control how the SQL statements are
+  formatted.
+  
+3.1.2.1 Align Where Clause                       *sqlutil-align-where*
+
+  sqlutil_align_where is used to align operators. Valid operators are: 
+       =, =, >, <, >=, <=, !=, !<, !>, <> 
+  This option is "ON" by default.  When formatting SQL statements with many 
+  nested statements, the results can shifted too much.  You can disable it,
+  format the statement and enable it again afterwards: >
+       let g:sqlutil_align_where = 1
+
+       SELECT CategoryID, CategoryName, CategorySystemName, (
+               SELECT B.CATEGORYID CATID
+                 FROM CATEGORY
+                WHERE B.CATEGORYID      =  intCategoryID
+                  AND B.REVIDDFD        =  intRevID
+                  AND B.REVID           >  intRevID
+                  AND B.REVIDDFDSDSF    <  intRevID
+                  AND B.REVIDDFD        >= intRevID
+                  AND B.REVIDD          <= intRevID
+                  AND B.REVIDLLKKKK     != intRevID
+                  AND B.REVIDK          !< intRevID
+                  AND B.REVIDDD         !> intRevID
+                  AND B.REV             <> intRevID
+                  AND B.DEL             =  0
+                UNION ALL
+               SELECT B.CATEGORYID
+                 FROM CATEGORYHDR B
+                WHERE intCategoryID IS NULL
+              ) tmp
+        WHERE TMP.CATID         =  PCat.CategoryID
+          AND PCat.RevID        =  intRevID
+          AND P.RevID           =  PCat.RevID
+          AND CATHDR.CATEGORYID =  PCAT.CATEGORYID
+<
+
+  To disable: >
+       let g:sqlutil_align_where = 0
+
+       SELECT CategoryID, CategoryName, CategorySystemName, (
+               SELECT B.CATEGORYID CATID
+                 FROM CATEGORY
+                WHERE B.CATEGORYID = intCategoryID
+                  AND B.REVIDDFD = intRevID
+                  AND B.REVID > intRevID
+                  AND B.REVIDDFDSDSF < intRevID
+                  AND B.REVIDDFD >= intRevID
+                  AND B.REVIDD <= intRevID
+                  AND B.REVIDLLKKKK != intRevID
+                  AND B.REVIDK !< intRevID
+                  AND B.REVIDDD !> intRevID
+                  AND B.REV <> intRevID
+                  AND B.DEL = 0
+                UNION ALL
+               SELECT B.CATEGORYID
+                 FROM CATEGORYHDR B
+                WHERE intCategoryID IS NULL
+              ) tmp
+        WHERE TMP.CATID = PCat.CategoryID
+          AND PCat.RevID = intRevID
+          AND P.RevID = PCat.RevID
+          AND CATHDR.CATEGORYID = PCAT.CATEGORYID
+<
+
+3.1.2.2 Align Comma                              *sqlutil-align-comma*
+
+  sqlutil_align_comma is used to force each column in a column list to be
+  placed on a new line.  The SET statement in a UPDATE clause already 
+  does this by default.
+  This option is "OFF" by default. >
+       let g:sqlutil_align_comma = 0
+
+       SELECT PK_BranchID, PK_ItemID, FK_VaultID, FK_ItemType,
+              ItemBarCode, FK_CommodityType, FK_CommodityTypeCode,
+              ItemQuantity, ItemSealNumber, FK_ItemDenominationType,
+              ItemSaidToContain, ItemNotes, FK_PackageDeliveryLocationID,
+              FK_PackagePickupLocationID, FK_ItemParentID
+         FROM some_table
+<
+
+  To enable: >
+       let g:sqlutil_align_comma = 1
+
+       SELECT PK_BranchID
+            , PK_ItemID
+            , FK_VaultID
+            , FK_ItemType
+            , ItemBarCode
+            , FK_CommodityType
+            , FK_CommodityTypeCode
+            , ItemQuantity
+            , ItemSealNumber
+            , FK_ItemDenominationType
+            , ItemSaidToContain
+            , ItemNotes
+            , FK_PackageDeliveryLocationID
+            , FK_PackagePickupLocationID
+            , FK_ItemParentID
+         FROM some_table
+<
+
+3.1.2.3 Align First Word                         *sqlutil-align-first-word*
+
+  sqlutil_align_first_word is used to control how the keywords are 
+  aligned when formatting.  The default behaviour is the keywords
+  are RIGHT justified on the first word of the phrase.  So for an
+  ORDER BY statement the keywords are aligned between the ORDER and the 
+  BY words.  
+  This option is "ON" by default. >
+       let g:sqlutil_align_first_word = 1
+
+       SELECT CategoryID
+            , CategoryName
+            , CategorySystemName
+            , (
+               SELECT B.CATEGORYID CATID
+                 FROM CATEGORY B
+                START WITH B.CATEGORYID     = intCategoryID
+                  AND B.REVID               = intRevID
+                  AND B.DEL                 = 0
+              CONNECT BY PRIOR B.CATEGORYID = B.PARENTCATEGORYID
+                  AND B.REVID               = intRevID
+                  AND B.DEL                 = 0
+                UNION ALL
+               SELECT B.CATEGORYID
+                 FROM CATEGORYHDR B
+                WHERE intCategoryID IS NULL
+              ) tmp
+        WHERE TMP.CATID             = PCat.CategoryID
+          AND PCat.RevID            = intRevID
+          AND P.RevID               = PCat.RevID
+          AND CATHDR.CATEGORYID     = PCAT.CATEGORYID
+        ORDER BY CategoryID
+<
+
+  To disable: >
+       let g:sqlutil_align_first_word = 0
+
+          SELECT CategoryID
+               , CategoryName
+               , CategorySystemName
+               , (
+                  SELECT B.CATEGORYID CATID
+                    FROM CATEGORY B
+              START WITH B.CATEGORYID      = intCategoryID
+                     AND B.REVID           = intRevID
+                     AND B.DEL             = 0
+        CONNECT BY PRIOR B.CATEGORYID      = B.PARENTCATEGORYID
+                     AND B.REVID           = intRevID
+                     AND B.DEL             = 0
+               UNION ALL 
+                  SELECT B.CATEGORYID
+                    FROM CATEGORYHDR B
+                   WHERE intCategoryID IS NULL
+                 ) tmp
+           WHERE TMP.CATID         = PCat.CategoryID
+             AND PCat.RevID        = intRevID
+             AND P.RevID           = PCat.RevID
+             AND CATHDR.CATEGORYID = PCAT.CATEGORYID
+        ORDER BY CategoryID
+<
+
+3.1.2.4 Align Keyword Right                     *sqlutil-align-keyword-right*
+
+  sqlutil_align_keyword_right is used to control how the keywords are 
+  aligned when formatting.  The default behaviour is the keywords
+  are RIGHT justified on the first keyword.  This option allows you to
+  choose whether the keywords are left or right justified.
+  This option is "1" by default. >
+       let g:sqlutil_align_keyword_right = 1
+
+           SELECT B.CATEGORYID CATID
+             FROM CATEGORY B
+            WHERE B.CATEGORYID     = intCategoryID
+              AND B.REVID          = intRevID
+              AND B.DEL            = 0
+<
+
+  To toggle: >
+       let g:sqlutil_align_keyword_right = 0
+
+           SELECT B.CATEGORYID CATID
+           FROM   CATEGORY B
+           WHERE  B.CATEGORYID     = intCategoryID
+           AND    B.REVID          = intRevID
+           AND    B.DEL            = 0
+<
+
+3.1.2.5 Change Keyword Case                      *sqlutil-change_keyword-case*
+
+  sqlutil_keyword_case is used to control if the case of the keywords
+  should be changed when formatting.  This option uses Vim's standard 
+  regular expression syntax |/\l| to control its' behaviour.  
+  The default is to leave the cAsE aS Is.  Assume the first query
+  below is our original statement: >
+       let g:sqlutil_keyword_case = ''
+
+       select CategoryID, CategoryName, CategorySystemName
+        WHERE TMP.CATID         = PCat.CategoryID
+          and PCat.RevID        = intRevID
+          aND P.RevID           = PCat.RevID
+          and CATHDR.CATEGORYID = PCAT.CATEGORYID
+          
+
+       let g:sqlutil_keyword_case = '\U'
+
+       SELECT CategoryID, CategoryName, CategorySystemName
+        WHERE TMP.CATID         =  PCat.CategoryID
+          AND PCat.RevID        =  intRevID
+          AND P.RevID           =  PCat.RevID
+          AND CATHDR.CATEGORYID =  PCAT.CATEGORYID
+
+          
+       let g:sqlutil_keyword_case = '\L'
+
+       select CategoryID, CategoryName, CategorySystemName
+        where TMP.CATID = PCat.CategoryID
+          and PCat.RevID = intRevID
+          and P.RevID = PCat.RevID
+          and CATHDR.CATEGORYID = PCAT.CATEGORYID
+
+          
+       let g:sqlutil_keyword_case = '\u'
+
+       Select CategoryID, CategoryName, CategorySystemName
+        WHERE TMP.CATID = PCat.CategoryID
+          And PCat.RevID = intRevID
+          AND P.RevID = PCat.RevID
+          And CATHDR.CATEGORYID = PCAT.CATEGORYID
+
+          
+       let g:sqlutil_keyword_case = '\l'
+
+       select CategoryID, CategoryName, CategorySystemName
+        wHERE TMP.CATID = PCat.CategoryID
+          and PCat.RevID = intRevID
+          aND P.RevID = PCat.RevID
+          and CATHDR.CATEGORYID = PCAT.CATEGORYID
+<
+
+3.1.2.6 Indent Nested Blocks                     *sqlutil-indent_nested*
+
+  sqlutil_indent_nested_blocks is used to shift blocks right
+  to show indent level. >
+       let g:sqlutil_indent_nested_blocks = 1
+
+       SELECT CategoryID
+            , CategoryName
+            , CategorySystemName
+            , (
+               SELECT nested block
+                 FROM CATEGORY B
+                WHERE intCategoryID IS NULL
+              ) tmp
+
+
+3.1.2.7 Wrap Width                               *sqlutil-wrap-wdith*
+
+  sqlutil_wrap_width defaults to the Vim option |'textwidth'|.
+  If this option is set, it will be used.  The formatter
+  will look at all lines longer than sqlutil_wrap_width and 
+  attempt to shorten it based on some rules.  For those
+  details see |sqlutil_wrap_long_lines|.
+  sqlutil_wrap_long_lines option. >
+       let g:sqlutil_wrap_function_calls = 1
+
+
+3.1.2.8 Wrap Long Lines                          *sqlutil-wrap-long-lines*
+
+  sqlutil_wrap_long_lines is try to fit text on one line in Vim
+  while maintaining shifted text.  Long lines will be detected
+  if the Vim option textwidth is set.  If this option is not 
+  set, then it will default to 80 characters.  See the 
+  |sqlutil_wrap_width| option for more details. 
+  When this option is enabled, the formatter will only attempt 
+  splitting lines when either ()'s or a , is found. >
+       let g:sqlutil_wrap_long_lines = 1
+
+       INSERT INTO rev_comment_header(rev_comment_header_id, rev_comment_header_id, rev_comment_header_id, rev_comment_header_id, project_id)
+
+       INSERT INTO rev_comment_header(
+                  rev_comment_header_id, rev_comment_header_id, rev_comment_header_id,
+                  rev_comment_header_id, project_id
+              )
+
+
+3.1.2.9 Wrap Function Calls                      *sqlutil-wrap-function-calls*
+
+  sqlutil_wrap_function_calls looks for a word followed by
+  a ( and a closing ).  It will leave the ( on the same line
+  but the closing ) will be placed on it's own line.  The 
+  function parameters will be formatted based on the 
+  sqlutil_wrap_long_lines option. >
+       let g:sqlutil_wrap_function_calls = 1
+
+        SELECT XMLELEMENT(
+                   'Alerts', XMLELEMENT( 'Alert_alert_id', alert_id ),
+                   XMLELEMENT( 'Alert_agent_id', agent_id ),
+                   XMLELEMENT( 'Alert_alert_type_id', alert_type_desc),
+                   XMLELEMENT( 'Alert_alert_date', alert_date),
+                   XMLELEMENT(
+                       'Alert_url_reference', url_reference
+                    ), XMLELEMENT( 'Alert_read_status', read_status )
+               ) 
+          FROM MESSAGES m
+
+
+3.1.2.10 Split Unbalanced Parantheses            *sqlutil-split_unbalanced-paran*
+
+  g:sqlutil_split_unbalanced_paran finds all (.  It then checks the 
+  closing ) position.  If the closing ) is on a separate line, it will 
+  make sure the ( stays where it is, anything following it is placed 
+  on a newline, and the closing ) is also placed on it's own line. >
+
+        SELECT XMLELEMENT(
+                   'Alerts', XMLELEMENT( 'Alert_alert_id', alert_id ),
+                   XMLELEMENT( 'Alert_agent_id', agent_id ),
+                   XMLELEMENT( 'Alert_alert_type_id', alert_type_desc),
+                   XMLELEMENT( 'Alert_alert_date', alert_date),
+                   XMLELEMENT(
+                       'Alert_url_reference', url_reference
+                    ), XMLELEMENT( 'Alert_read_status', read_status )
+               ) 
+          FROM MESSAGES m
+
+
+3.2 SQLUCreateColumnList                         *sqlutil-column-list*
+
+  SQLUCreateColumnList( optional parameter(s) )
+
+  Creates a comma separated list of column names for the table name under the
+  cursor, assuming the table definition exists in any open buffer.  The column
+  list is placed in the unnamed buffer.  Be default, an alias is added to 
+  the column list (new to version 1.3.7).
+
+  To determine where a statement ends the g:sqlutil_cmd_terminator is used.
+  This is true for the CREATE TABLE statement, and the ALTER TABLE 
+  statements.
+
+  Normally this command is run by placing your cursor anywhere on the 
+  table name and using the mapping <Leader>scl (or \scl).  The paste
+  buffer contains the column list, and a message is displayed.
+
+  You can also call this from the Vim command line, this function optionally
+  takes 3 parameters: >
+       SQLUCreateColumnList T1 
+<            Creates a column list for T1
+>
+       SQLUCreateColumnList T1 1
+<            Creates a column list for T1 but only for the primary keys for
+             that table.
+>
+       SQLUCreateColumnList T1 0 alias_name
+<            Creates a column list for T1 add appends the supplied 
+             alias_name to each column.
+
+   Assumes either the current file, or any other open buffer, has a CREATE
+   TABLE statement in a format similar to this: >
+       CREATE TABLE customer_list (
+            id	           INT DEFAULT AUTOINCREMENT,
+            last_modified  TIMESTAMP NULL,
+            first_name     VARCHAR(30) NOT NULL,
+            last_name	   VARCHAR(60) NOT NULL,
+            balance	        NUMERIC(10,2),
+            PRIMARY KEY( id )
+       );
+<       
+  If you place the cursor on the word customer, then the unnamed buffer (also
+  displayed by an echo statement) will contain: >
+       cl.id, cl.last_modified, cl.first_name, cl.last_name, cl.balance
+<
+  The table alias has several options / features and is controlled by: >
+       let g:sqlutil_use_tbl_alias = 'd|a|n'
+<
+  Here are the meaning of each setting: >
+       d - Use the default
+       a - Calculate an alias, and prompt the user to override
+       n - Do not use table aliases
+<
+  An alias is determined following a few rules:
+       1.  If the table name has an '_', then use it as a separator: >
+           MY_TABLE_NAME --> MTN
+           my_table_name --> mtn
+           My_table_NAME --> MtN
+<      2.  If the table name does NOT contain a '_', but DOES use 
+           mixed case then the case is used as a separator: >
+           MyTableName --> MTN
+<      3.  If the table name does NOT contain a '_', and does NOT use 
+           mixed case then the first letter of the table is used: >
+           mytablename --> m
+           MYTABLENAME --> M
+<
+  This also uses the g:sqlutil_cmd_terminator to determine when the create
+  table statement ends if none of the following terms (these are the defaults)
+  are found before the final ");". >
+       primary key,reference,unique,check,constraint, [not null] foreign
+< sqlutil_cmd_terminator defaults to ";"
+
+  When building a column list from a script file (ie CREATE TABLE statements),
+  you can customize the script to detect when the column list finishes by
+  creating the following in your |vimrc|: >
+       let g:sqlutil_col_list_terminators = 
+                         \ 'primary,reference,unique,check,foreign'
+<
+  This is necessary to determine where the list of columns finishes and 
+  when the list of table keywords begin in the following examples: >
+       CREATE TABLE customer (
+          id           INT DEFAULT AUTOINCREMENT,
+          first_name   VARCHAR(30) NOT NULL,
+          last_name    VARCHAR(60) NOT NULL,
+          PRIMARY KEY( id )
+       ); 
+
+       CREATE TABLE contact (
+          id           INT DEFAULT AUTOINCREMENT,
+          cust_        INT NOT NULL,
+          first_name   VARCHAR(30) NOT NULL,
+          last_name    VARCHAR(60) NOT NULL,
+          CHECK( id > 0 )
+          FOREIGN KEY fk_customer ( cust_id ) 
+          REFERENCES customer(id)
+          PRIMARY KEY( id )
+       ); 
+<
+
+3.3 SQLUGetColumnDef                             *sqlutil-column-definition*
+    SQLUGetColumnDataType                        *sqlutil-column-datatype*
+
+  SQLUGetColumnDef( optional parameter )           
+  SQLUGetColumnDataType( expand("<cword>"), 1 )
+
+  Assumes either the current file, or any other open buffer, has a CREATE TABLE
+  statement in a format similar to this: >
+
+       CREATE TABLE customer (
+           id	           INT DEFAULT AUTOINCREMENT,
+           last_modified   TIMESTAMP NULL,
+           first_name      VARCHAR(30) NOT NULL,
+           last_name	   VARCHAR(60) NOT NULL,
+           balance	       NUMERIC(10,2),
+           PRIMARY KEY( id )
+       );
+<
+  |hidden| must be enabled for this plugin to cycle through other open 
+  buffers.  If you place the cursor on the word first_name, then the column
+  definition will be placed in the unnamed buffer (and also displayed by an
+  echo statement). >
+       VARCHAR(30) NOT NULL        
+<
+  If the command is called as SQLUGetColumnDef( expand("<cword>"), 1 ) or using
+  the default mapping <Leader>scdt, just the datatype (instead of the column
+  definition) will be returned.  A separate command SQLUGetColumnDataType has
+  been created for this. >
+       VARCHAR(30) 
+<
+
+
+3.4 SQLUCreateProcedure()                        *sqlutil-procedure*
+
+  SQLUCreateProcedure()
+
+  Creates a stored procedure that performs standard operations (SELECT, 
+  INSERT, UPDATE, DELETE) against the table that the cursor is currently under.
+  Once the procedure has been pasted into the buffer, the unwanted statements
+  can be removed.
+
+  Assumes either the current file, or any other open buffer, has a CREATE TABLE
+  statement in a format similar to this: >
+
+       CREATE TABLE customer (
+           id	           INT DEFAULT AUTOINCREMENT,
+           last_modified   TIMESTAMP NULL,
+           first_name      VARCHAR(30) NOT NULL,
+           last_name	   VARCHAR(60) NOT NULL,
+           balance	       NUMERIC(10,2),
+           PRIMARY KEY( id )
+       );
+<       
+  |hidden| must be enabled for this plugin to cycle through other open 
+  buffers.  
+
+
+==============================================================================
+4. Suggested Mappings:                           *sqlutil-mappings*
+
+  vmap <leader>sf        <Plug>SQLU_Formatter<CR>
+  nmap <leader>scl       <Plug>SQLU_CreateColumnList<CR>
+  nmap <leader>scd       <Plug>SQLU_GetColumnDef<CR>
+  nmap <leader>scdt      <Plug>SQLU_GetColumnDataType<CR>
+  nmap <leader>scp       <Plug>SQLU_CreateProcedure<CR>
+
+  mnemonic explanation
+     s - sql
+         f   - format
+         cl  - column list
+         cd  - column definition
+         cdt - column datatype
+         cp  - create procedure
+
+  To prevent the default mappings from being created, place the following in
+  your |vimrc|:
+          let g:sqlutil_load_default_maps = 0
+
+
+==============================================================================
+5. Global Options                                *sqlutil-options*
+
+  Many defaults for the SQLUtilities plugin can be enabled or disabled or 
+  customized via entries in your .vimrc.  Here is a list of all options used 
+  by the plugin and a brief description of what it does.  A more complete
+  example of how to use this option can be found through the doc (if worthy) 
+  so just search for it.
+
+  Many of these options can be controlled via the SQLUtil menu, which is often 
+  far more convenient that tweaking these variables.
+
+  Global variables: >
+    sqlutil_align_where
+<       - See |sqlutil-align-where|
+        - Default: 1 >
+        let g:sqlutil_align_where = 1
+    sqlutil_align_comma
+<       - See |sqlutil-align-comma|
+        - Default: 0 >
+        let g:sqlutil_align_comma = 0
+    sqlutil_align_first_word
+<       - See |sqlutil-align-first-word|
+        - Default: 0 >
+        let g:sqlutil_align_first_word = 0
+    sqlutil_align_keyword_right
+<       - See |sqlutil-align-keyword-right|
+        - Default: 1 >
+        let g:sqlutil_align_keyword_right = 1
+    sqlutil_cmd_terminator
+<       - Certain SQL statements require cmd terminators.  Different databases
+          have different defaults.  This is important when parsing SQL files.
+        - Default: ';' >
+        let g:sqlutil_cmd_terminator = ';'
+        let g:sqlutil_cmd_terminator = "\ngo\n"
+    sqlutil_stmt_keywords
+<       - Used by the SQLUFormatter command to determine which SQL statements 
+          to format.
+        - Default: 'select,insert,update,delete,with,merge' >
+        let g:sqlutil_stmt_keywords = 'select,insert,update,delete,with,merge'
+    sqlutil_keyword_case
+<       - See |sqlutil-change_keyword-case|
+        - Default: '' >
+        let g:sqlutil_keyword_case = ''
+    sqlutil_use_tbl_alias
+<       - See |sqlutil-column-list|
+        - Default: 'a' >
+        let g:sqlutil_use_tbl_alias = 'a'
+    g:sqlutil_use_syntax_support
+<       - See |sqlutil-customization||
+        - Default: 1 >
+        let g:g:sqlutil_use_syntax_support = 1
+    sqlutil_syntax_elements
+<       - See |sqlutil-column-list|
+        - This controls how SQLUtilities determines if the keyword found is
+          within a string or not.  This is a comma separated list of values.
+          Items within these syntax groups will typically be ignored.
+        - Default: 'Constant,sqlString,sqlComment,Comment' >
+        let g:sqlutil_syntax_elements = 'Constant,sqlString,sqlComment,Comment'
+    sqlutil_non_line_break_keywords
+<       - These words will be UPPER or lower cased based on the setting of
+          sqlutil_keyword_case.  These keywords are different from typical`
+          ones (i.e. SELECT, FROM) as those special words should be placed 
+          on their own lines.  These should stay where they are but should
+          their case should be changed.  This allows these options to be
+          extended without having to release a new version of the plugin. 
+          The keywords which should be formatted require extensive testing 
+          and the regex's used for those are based on the SQL grammar 
+          and therefore cannot easily be extended. 
+        - Default: 'Constant,sqlString,sqlComment,Comment' >
+        let g:sqlutil_non_line_break_keywords = 'is,as,like,desc,asc,then'
+    sqlutil_col_list_terminators
+<       - See |sqlutil-change_keyword-case| >
+        let g:sqlutil_col_list_terminators = 
+                    \ 'primary\s\+key.*(' .
+                    \ ',references' .
+                    \ ',match' .
+                    \ ',unique' .
+                    \ ',check' .
+                    \ ',constraint' .
+                    \ ',\%(not\s\+null\s\+\)\?foreign'
+    sqlutil_load_default_maps
+<       - See |sqlutil-mappings|
+        - Default: 1 >
+        let g:sqlutil_load_default_maps = 1
+    sqlutil_default_menu_mode
+<       - See |sqlutil-customization|
+        - Default: 3 >
+        let g:sqlutil_default_menu_mode = 3
+
+==============================================================================
+6. Customization                                 *sqlutil-customization*
+
+6.1 Cmd Terminator
+
+  By default this script assumes a command is terminated by a ; If you are
+  using Microsoft SQL Server a command terminator would be "go", or perhaps
+  "\ngo".
+
+  To permanently override the terminator in your |vimrc| file you can add
+  (note: using double quotes is necessary when using \n): >
+            let g:sqlutil_cmd_terminator = "\ngo"
+<
+6.2 Vim Menu
+
+  By default a menu is created under the Plugin menu.  Menus are useful for a
+  number of reasons:
+        - See a list of available commands
+        - Remember what the shortcut maps are
+        - Have a floating menu when using the plugin a lot
+        - Allow you to quickly and easily toggle various formatting
+          options on a per statement basis.  Especially useful when
+          used with the floating menu.
+        - Quick reference guide
+  
+  You have several choices on where to place the menu.  There are four
+  settings that will control the placement of the menu: 
+        "0": Turns the menu off.
+        "1": Turns the 'SQLUtil' menu on with no menu shortcut.
+        "2": Turns the 'SQLUtil 'menu on with <alt>-d as the shortcut.
+        "3": Turns the 'Plugin -> SQLUtil' menu on with <alt>-s as 
+             the shortcut.
+  The option, g:sqlutil_default_menu_mode defaults to a value of 3 and can be
+  changed by adding the following to your vimrc: >
+            let  g:sqlutil_default_menu_mode = 3
+<
+ You can also control where (and the name of) the SQLUtil menu is created
+ using the g:sqlutil_menu_root option.  It can be used in conjunction with
+ g:sqlutil_default_menu_mode = 3.  To create the menu: 'MyPlugins -> SQLUtil'
+ you can create the following variable: >
+            let  g:sqlutil_menu_root = 'MyPlugin.&SQLUtil'
+<            
+ Menus are created in a documented order by Vim (|menu-priority|).  You can
+ override this setting using sqlutil_menu_priority.  This option allows you to
+ override the setting and shift the SQLUtil menu item to the left between the
+ Edit and Tools menu. >
+            let  g:sqlutil_menu_priority = 30
+
+6.3 Vim's Syntax Support
+
+  New to 5.0 of SQLUtilities, when reformatting a SQL statement Vim's syntax
+  rules are used to determine if the keyword found (i.e. SELECT, FROM, WHERE, 
+  ...) is within a string.  Consider the following statement: >
+    SELECT 1, 'text with keywords IN FROM CASE WHERE AND OR ' FROM T1 WHERE c1 = 1
+<
+  Formatting this statement with g:sqlutil_use_syntax_support = 0 results in: >
+    SELECT 'text
+      with keywords IN
+      FROM CASE
+     WHERE 
+       AND 
+        OR '
+      FROM T1
+     WHERE c1 = 1
+<
+  As you can see the keywords found within the string were aligned like all
+  other keywords.  To address this, when the keyword is found and Vim is
+  highlighting the text (i.e. syntax on is enabled) then determine the 
+  syntax group.  If the group is within the comma separated list of 
+  groups listed in g:sqlutil_syntax_elements, then it will be bypassed.
+  The resulting query with g:sqlutil_use_syntax_support = 1 will be 
+  formatted as: >
+    SELECT 1, 'some text with sql keywords IN FROM CASE WHERE AND OR '
+      FROM T1
+     WHERE c1 = 1
+<
+  To help you determine what the correct groups are, you can install: >
+    SyntaxAttr.vim
+    http://vim.sourceforge.net/script.php?script_id=383
+<
+  Then create a mapping: >
+    nnoremap -a :call SyntaxAttr()<CR>
+<
+  Place your cursor on the word which is hightlighted in the colour you 
+  are interested in and hit -a.  The output displayed looks something like 
+  this: >
+    group: sqlString->Constant guifg=White(#ffffff)
+<
+  With this information, you can override the default for SQLUtilities 
+  using the following line in my .vimrc: >
+    let g:sqlutil_syntax_elements = 'Constant,sqlString'
+
+==============================================================================
+7. History                                       *sqlutil-history*
+
+  7.0.0: December 3, 2012: 
+         NF: Comments in your SQL are now allowed and will be formatted
+             appropriately (which usually means ignored).
+             If you Vim does not have syntax support, all comments 
+             will be removed prior to formatting (you are asked to confirm).
+         NF: A major overhaul to how SQL is formatted.  
+             Fixed a few bugs which crept up while testing 
+             the new methods.
+             The main change was how long lines are handled.
+             Now, long lines are only split when a comma or open
+             parenthesis is found.  This can still leave lines long
+             but the previous method could leave the new SQL nearly
+             unreadable depending on it's content.  Thanks to
+             Jeremey Hustman for providing the ColdFusion code
+             samples.
+         NF: Added new options which allow you to override
+             which (small set of) keywords are flipped to 
+             UPPER or lower case.  This means if a few keywords
+             are missing they can easily be added to your 
+             .vimrc while waiting for an update to the plugin. 
+             See help on: >
+                g:sqlutil_non_line_break_keywords
+<        NF: Added new options which allows you to turn off
+             different formatting options.  This is really 
+             only useful for debugging, but if you run into 
+             an issue you can turn off that piece of formatting.
+             See help for more details, the new options are: >
+                g:sqlutil_indent_nested_blocks
+                g:sqlutil_wrap_long_lines
+                g:sqlutil_wrap_function_calls
+                g:sqlutil_wrap_width
+                g:sqlutil_split_unbalanced_paran
+<        BF: Long lines were not wrapped appropriately (Don Parker).
+         BF: Based on certain conditions, the formatter could get
+             into an endless loop (Don Parker).
+         BF: ColdFusion placeholders were incorrectly formatted (Jeremy Hustman).
+         BF: Some keywords (i.e. LIKE, AS, ASC, DESC, ...) were not UPPER cased
+             (Jeremy Hustman).
+         BF: Delete statements were not formatted (Jeremy Hustman).
+ 
+  6.0.0: October 10, 2012: 
+         NF: When formatting INSERT statements, the sqlutil_align_comma
+             is also respected to place each column on a newline.
+         NF: When formatting UPDATE statements and sqlutil_align_comma is set
+             comments at the end of the line were removed (Rodrigo Laporte).
+
+  5.0.0: February 10, 2012: 
+         NF: Now an extra check is made for the Align plugin.  If not 
+             found when attempting to format a SQL statement a friendly 
+             message is shown (Enrico Teotti).
+         NF: Updated documentation added the Global Options section plus
+             updated the Customization section.
+         NF: Problem: Keywords within strings were being formatted 
+             (Olivier Laurent).
+             Solution: Added an option, g:sqlutil_use_syntax_support, to 
+             determine whether or not to use Vim's syntax support 
+             to decide if the keyword is highlighted as a "string".
+             If so, leave it and move on to the next keyword.
+             Default value is 1 (enabled).
+             See |sqlutil-customization| for details on usage.
+         NF: Added an option, g:sqlutil_syntax_elements, to 
+             allow the user to decide which syntax elements 
+             should be considered a string.
+             Default value is 'Constant,sqlString'.
+
+  4.1.0: August 18, 2010: 
+         NF: Store and reset the value of the |gdefault| option before
+             formatting SQL statements (Sebastian Kusnier).
+         BF: When g:sqlutil_align_keyword_right = 0 and 
+             g:sqlutil_align_comma = 1 commas where left aligned
+             with the keywords instead of left aligned with the 
+             column list (Per Winkvist).
+
+  4.0.0: August 13, 2010: 
+         NF: Added a tutorial to take users through the common features 
+             of the plugin.
+         NF: Added an option, g:sqlutil_align_keyword_right, to left or 
+             right (default) align the keywords (Per Winkvist).
+         NF: Documented and added new global variables (g:sqlutil_menu_root,
+             g:sqlutil_menu_priority) to customize the location of the 
+             SQLUtil menu.
+         BF: SQLite used slightly different syntax specifying UNIQUE
+             values and would not correctly generate a column list
+             from the CREATE TABLE statement (Oliver Peters).
+         BF: Ensured all normal commands used ! to ensure no mappings
+             interfered with the commands (Benoit Mortgat).
+
+  3.0.0: January 15, 2009: 
+         NF: Added new menu links so that commonly used options can be
+             quickly and easily toggled without having to remember the 
+             global variable names or values.  For example, if you cut the 
+             menu so that it floats beside your buffer you can easily
+             hit "Toggle Align Where" or "Uppercase Keywords".  
+         NF: Using the menu_mode option you can control if and where the
+             SQLUtil menu is created.  See the menu_mode option for more
+             details.
+         NF: Added the default maps to the menus.  If you use a floating 
+             menu, or simply view the menu you can more easily memorize
+             your most commonly used maps.
+         BF: UPPER and lower case of keywords did not work for multi-word
+             keywords (ORDER BY, LEFT OUTER JOIN, ...).
+
+  2.0.0: September 09, 2007: 
+         NF: Added support for Vim 7's autoload functionality
+
+  1.4.1: October 07, 2005: 
+         NF: Added additional statements to g:sqlutil_col_list_terminators
+         BF: Forgot to increment g:loaded_sqlutilities
+
+  1.4.0: March 10, 2005: 
+         BF: If a statement has parenthesis inside of strings, the formatter
+             was not ignoring them.  This could result in the formatter
+             reporting there were mismatched parenthesis.
+             Example: select 'string' + '(' from dummy
+         BF: If a keyword was not followed by a space, it was not placed on
+             a newline.  
+             Example:  SELECT * FROM(T1)
+         BF: Nested function calls could potentially lead to an endless loop.  
+
+  1.3.9: February 10, 2005: 
+         BF: When g:sqlutil_align_comma=1 and a select list spanned more than 1
+             line (via functions calls and so on), it was possible the
+             remaining comma separated list was not aligned properly.
+
+  1.3.8: December 2, 2004: 
+         NF: Enhanced the feature to change the case of keywords, to include
+             the optional join words, left, right, full, inner, outer.  These
+             words were missed prior to this change and only the JOIN word was
+             capitalized.
+         C: Changed the default for g:sqlutil_use_tbl_alias = 'a' (ask) from
+             being on at all times.  This can be overridden in your vimrc.
+
+  1.3.7: July 21, 2004: 
+         NF: Added new option g:sqlutil_use_tbl_alias, which is on by default.
+             When creating a column list for a table, it will add a table
+             alias to each column.  The table alias is calculated based on 
+             rules.  This feature has 3 settings:
+                n - no alias
+                d - default calculated alias
+                a - ask the user using default alias
+         NF: Updated g:sqlutil_col_list_terminators to handle some additional
+             cases.
+         BF: In some cases -@- could be left in the query.  This seems to be
+             a bug in Vim, where the marks could move.  Unsure why, but put
+             a workaround in.
+         BF: When g:sqlutil_align_comma=1, and the lines did not begin with
+             commas, the formatting was incorrect.
+         BF: When searching through buffers (SQLU_CreateColumnList), the 
+             alternate buffer could be changed.
+
+  1.3.6: June 21, 2004: 
+         NF: Added support for window functions (OVER, PARTITION BY, ROWS,
+             RANGE), and additional Oracle SELECT keywords (DIMENSION,
+             MEASURES, ITERATE, WITHIN GROUP, IGNORE, KEEP, RETURN, RULES)
+
+  1.3.5: Mar 05, 2004: 
+         NF: Added global variable sqlutil_align_where, sqlutil_align_comma,
+             sqlutil_align_first_word for customization of alignment rules.
+
+  1.3.3: Sep 05, 2003: 
+         NF: Added global variable sqlutil_col_list_terminators for
+             customization.
+
+  1.3.2: Aug 24, 2003: 
+         NF: Changed all functions to be prefixed by SQLU_ for consistency.
+         BF: Fixed SQLU_GetColumnDataType and SQLU_GetColumnDef to handle tabs.
+         
+  1.3.1: Aug 21, 2003: 
+         BF: -@- could be left after incorrect formatting.
+
+  1.3.0: Mar 30, 2003: 
+         NF: Support the formatting of FUNCTIONS or stored procedures used as
+             derived tables.  This will nest the function calls on new lines
+             and correctly split the parenthesis on new lines if the function
+             call is longer than one line.  You would notice this mainly in the
+             SELECT column list.
+         NF: Support the formatting of nested CASE statements.
+         NF: Added the SQLU_GetColumnDataType command. 
+         NF: Improved primary key determination, it no longer requires the
+             PRIMARY KEY statement to be part of the CREATE TABLE statement, it
+             can be part of an ALTER TABLE statement.
+         NF: Improved formatting of SQL keywords.  INSERT INTO statement, the
+             INTO will no longer be split onto a new line.
+         NF: Now correctly format the various JOIN keywords: NATURAL RIGHT
+             OUTER JOIN will be placed one online instead of just the JOIN
+             keyword as before.
+         BF: Did not properly handle the formatting of nested open parenthesis
+             in all cases.
+         BF: Using new technique to determine how to change the textwidth to
+             utilize more screen space when wrapping long lines.
+                           
+  1.2.0: Nov 30, 2002: 
+         NF: Create procedure uses shiftwidth for indent.
+         BF: Save/restore previous search.
+         
+  1.0.0: Nov 13, 2002: 
+         NF: Initial version.
+    
+
+==============================================================================
+8. Dependencies                                  *sqlutil-dependencies*
+
+       Align.vim - Version 15 (as a minimum)
+                 - Author: Charles E. Campbell, Jr.
+                 - http://www.vim.org/script.php?script_id=294
+                 - SQLUtilities uses this to extensively
+
+
+==============================================================================
+9. Complementary Plugins                       *sqlutil-complementary-plugins*
+
+       dbext.vim  - Author: Peter Bagyinszki and David Fishburn
+                  - http://www.vim.org/script.php?script_id=356
+                  - Works with almost all databases
+                  - Allows you to execute commands, browse through objects
+                    and many more items.
+
+       SrchRplcHiGrp.vim  
+                  - Author: David Fishburn
+                  - http://www.vim.org/script.php?script_id=848
+                  - Search and Replace based on a syntax highlight
+                    group name.  For example, you can visually select
+                    a block of code and tell it to change all the
+                    "yellow" words to UPPER case.
+                    
+       Intellisense.vim  
+                  - Author: Ravi Shankar
+                  - SQL plugin Author: David Fishburn
+                  - http://www.vim.org/scripts/script.php?script_id=747
+                  - Performs popup method completion for SQL development
+                    this includes, keywords, functions, tables, columns,
+                    procedures and more.
+
+
+==============================================================================
+10. TODO                                          *sqlutil-todo*
+
+  TODO:
+    1. Suggestions welcome please email <dfishburn dot vim at gmail dot com>
+
+
+==============================================================================
+
+
+vim: ts=4 ft=help
diff --git a/vimrc/.vim/doc/taglist-plus.txt b/vimrc/.vim/doc/taglist-plus.txt
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/doc/taglist-plus.txt
@@ -0,0 +1,1499 @@
+*taglist-plus.txt*	Plugin for browsing source code
+
+Author: Yegappan Lakshmanan  (yegappan AT yahoo DOT com)
+Modified By: Jezreel Ng (jezreel AT gmail DOT com)
+For Vim version 6.0 and above
+
+1. Overview 					|taglist-intro|
+2. Requirements					|taglist-requirements|
+3. Installation 				|taglist-install|
+4. Usage 					|taglist-using|
+5. Options 					|taglist-options|
+6. Commands 					|taglist-commands|
+7. Global functions 				|taglist-functions|
+8. Extending 					|taglist-extend|
+9. FAQ  					|taglist-faq|
+10. License 					|taglist-license|
+11. Todo					|taglist-todo|
+
+==============================================================================
+						*taglist-intro*
+1. Overview~
+
+The "Tag List" plugin is a source code browser plugin for Vim. This plugin
+allows you to efficiently browse through source code files for different
+programming languages. The "Tag List" plugin provides the following features:
+
+    * Displays the tags (functions, classes, structures, variables, etc.) 
+      defined in a file in a vertically or horizontally split Vim window.
+    * In GUI Vim, optionally displays the tags in the Tags drop-down menu and
+      in the popup menu.
+    * Automatically updates the taglist window as you switch between
+      files/buffers. As you open new files, the tags defined in the new files
+      are added to the existing file list and the tags defined in all the
+      files are displayed grouped by the filename.
+    * When a tag name is selected from the taglist window, positions the
+      cursor at the definition of the tag in the source file.
+    * Automatically highlights the current tag name.
+    * Groups the tags by their type and displays them in a foldable tree.
+    * Can display the prototype and scope of a tag.
+    * Can optionally display the tag prototype instead of the tag name in the
+      taglist window.
+    * The tag list can be sorted either by name or by chronological order.
+    * Supports the following language files: Assembly, ASP, Awk, Beta, C,
+      C++, C#, Cobol, Eiffel, Erlang, Fortran, HTML, Java, Javascript, Lisp,
+      Lua, Make, Pascal, Perl, PHP, Python, Rexx, Ruby, Scheme, Shell, Slang,
+      SML, Sql, TCL, Verilog, Vim and Yacc.
+    * Can be easily extended to support new languages. Support for
+      existing languages can be modified easily.
+    * Provides functions to display the current tag name in the Vim status
+      line or the window title bar.
+    * The list of tags and files in the taglist can be saved and
+      restored across Vim sessions.
+    * Provides commands to get the name and prototype of the current tag.
+    * Runs in both console/terminal and GUI versions of Vim.
+    * Works with the winmanager plugin. Using the winmanager plugin, you
+      can use Vim plugins like the file explorer, buffer explorer and the
+      taglist plugin at the same time like an IDE.
+    * Can be used in both Unix and MS-Windows systems.
+
+==============================================================================
+						*taglist-requirements*
+2. Requirements~
+
+The taglist plugin requires the following:
+
+    * Vim version 6.0 and above
+    * Exuberant ctags 5.0 and above
+
+The taglist plugin will work on all the platforms where the exuberant ctags
+utility and Vim are supported (this includes MS-Windows and Unix based
+systems).
+
+The taglist plugin relies on the exuberant ctags utility to dynamically
+generate the tag listing.  The exuberant ctags utility must be installed in
+your system to use this plugin.  The exuberant ctags utility is shipped with
+most of the Linux distributions.  You can download the exuberant ctags utility
+from
+>
+	http://ctags.sourceforge.net
+<
+The taglist plugin doesn't use or create a tags file and there is no need to
+create a tags file to use this plugin. The taglist plugin will not work with
+the GNU ctags or the Unix ctags utility.
+
+This plugin relies on the Vim "filetype" detection mechanism to determine the
+type of the current file. You have to turn on the Vim filetype detection by
+adding the following line to your .vimrc file:
+>
+	filetype on
+<
+The taglist plugin will not work if you run Vim in the restricted mode (using
+the -Z command-line argument).
+
+The taglist plugin uses the Vim system() function to invoke the exuberant
+ctags utility. If Vim is compiled without the system() function then you
+cannot use the taglist plugin. Some of the Linux distributions (Suse) compile
+Vim without the system() function for security reasons.
+
+==============================================================================
+						*taglist-install*
+3. Installation~
+
+1. Download the taglist.zip file and unzip the files to the $HOME/.vim or the
+   $HOME/vimfiles or the $VIM/vimfiles directory. After this step, you should
+   have the following two files (the directory structure should be preserved):
+
+	plugin/taglist.vim - main taglist plugin file
+	doc/taglist.txt    - documentation (help) file
+
+   Refer to the |add-plugin|and |'runtimepath'| Vim help pages for more
+   details about installing Vim plugins.
+2. Change to the $HOME/.vim/doc or $HOME/vimfiles/doc or $VIM/vimfiles/doc
+   directory, start Vim and run the ":helptags ." command to process the
+   taglist help file. Without this step, you cannot jump to the taglist help
+   topics.
+3. If the exuberant ctags utility is not present in one of the directories in
+   the PATH environment variable, then set the 'Tlist_Ctags_Cmd' variable to
+   point to the location of the exuberant ctags utility (not to the directory)
+   in the .vimrc file.
+4. If you are running a terminal/console version of Vim and the terminal
+   doesn't support changing the window width then set the
+   'Tlist_Inc_Winwidth' variable to 0 in the .vimrc file.
+5. Restart Vim.
+6. You can now use the ":TlistToggle" command to open/close the taglist
+   window. You can use the ":help taglist" command to get more information
+   about using the taglist plugin.
+
+To uninstall the taglist plugin, remove the plugin/taglist.vim and
+doc/taglist.txt files from the $HOME/.vim or $HOME/vimfiles directory.
+
+==============================================================================
+						*taglist-using*
+4. Usage~
+
+The taglist plugin can be used in several different ways.
+
+1. You can keep the taglist window open during the entire editing session. On
+   opening the taglist window, the tags defined in all the files in the Vim
+   buffer list will be displayed in the taglist window. As you edit files, the
+   tags defined in them will be added to the taglist window. You can select a
+   tag from the taglist window and jump to it. The current tag will be
+   highlighted in the taglist window. You can close the taglist window when
+   you no longer need the window.
+2. You can configure the taglist plugin to process the tags defined in all the
+   edited files always. In this configuration, even if the taglist window is
+   closed and the taglist menu is not displayed, the taglist plugin will
+   processes the tags defined in newly edited files. You can then open the
+   taglist window only when you need to select a tag and then automatically
+   close the taglist window after selecting the tag.
+3. You can configure the taglist plugin to display only the tags defined in
+   the current file in the taglist window. By default, the taglist plugin
+   displays the tags defined in all the files in the Vim buffer list. As you
+   switch between files, the taglist window will be refreshed to display only
+   the tags defined in the current file.
+4. In GUI Vim, you can use the Tags pull-down and popup menu created by the
+   taglist plugin to display the tags defined in the current file and select a
+   tag to jump to it. You can use the menu without opening the taglist window.
+   By default, the Tags menu is disabled.
+5. You can configure the taglist plugin to display the name of the current tag
+   in the Vim window status line or in the Vim window title bar. For this to
+   work without the taglist window or menu, you need to configure the taglist
+   plugin to process the tags defined in a file always.
+6. You can save the tags defined in multiple files to a taglist session file
+   and load it when needed. You can also configure the taglist plugin to not
+   update the taglist window when editing new files. You can then manually add
+   files to the taglist window.
+
+Opening the taglist window~
+You can open the taglist window using the ":TlistOpen" or the ":TlistToggle"
+commands. The ":TlistOpen" command opens the taglist window and jumps to it.
+The ":TlistToggle" command opens or closes (toggle) the taglist window and the
+cursor remains in the current window. If the 'Tlist_GainFocus_On_ToggleOpen'
+variable is set to 1, then the ":TlistToggle" command opens the taglist window
+and moves the cursor to the taglist window.
+
+You can map a key to invoke these commands. For example, the following command
+creates a normal mode mapping for the <F8> key to toggle the taglist window.
+>
+	nnoremap <silent> <F8> :TlistToggle<CR>
+<
+Add the above mapping to your ~/.vimrc or $HOME/_vimrc file.
+
+To automatically open the taglist window on Vim startup, set the
+'Tlist_Auto_Open' variable to 1.
+
+You can also open the taglist window on startup using the following command
+line:
+>
+	$ vim +TlistOpen
+<
+Closing the taglist window~
+You can close the taglist window from the taglist window by pressing 'q' or
+using the Vim ":q" command. You can also use any of the Vim window commands to
+close the taglist window. Invoking the ":TlistToggle" command when the taglist
+window is opened, closes the taglist window. You can also use the
+":TlistClose" command to close the taglist window.
+
+To automatically close the taglist window when a tag or file is selected, you
+can set the 'Tlist_Close_On_Select' variable to 1.  To exit Vim when only the
+taglist window is present, set the 'Tlist_Exit_OnlyWindow' variable to 1.
+
+Jumping to a tag or a file~
+You can select a tag in the taglist window either by pressing the <Enter> key
+or by double clicking the tag name using the mouse. To jump to a tag on a
+single mouse click set the 'Tlist_Use_SingleClick' variable to 1.
+
+If the selected file is already opened in a window, then the cursor is moved
+to that window. If the file is not currently opened in a window then the file
+is opened in the window used by the taglist plugin to show the previously
+selected file. If there are no usable windows, then the file is opened in a
+new window.  The file is not opened in special windows like the quickfix
+window, preview window and windows containing buffer with the 'buftype' option
+set.
+
+To jump to the tag in a new window, press the 'o' key. To open the file in the
+previous window (Ctrl-W_p) use the 'P' key. You can press the 'p' key to jump
+to the tag but still keep the cursor in the taglist window (preview).
+
+To open the selected file in a tab, use the 't' key.  If the file is already
+present in a tab then the cursor is moved to that tab otherwise the file is
+opened in a new tab. To jump to a tag in a new tab press Ctrl-t.  The taglist
+window is automatically opened in the newly created tab.
+
+Instead of jumping to a tag, you can open a file by pressing the <Enter> key
+or by double clicking the file name using the mouse.
+
+In the taglist window, you can use the [[ or <Backspace> key to jump to the
+beginning of the previous file. You can use the ]] or <Tab> key to jump to the
+beginning of the next file. When you reach the first or last file, the search
+wraps around and the jumps to the next/previous file.
+
+Highlighting the current tag~
+The taglist plugin automatically highlights the name of the current tag in the
+taglist window. The Vim |CursorHold| autocmd event is used for this. If the
+current tag name is not visible in the taglist window, then the taglist window
+contents are scrolled to make that tag name visible. You can also use the
+":TlistHighlightTag" command to force the highlighting of the current tag.
+
+The tag name is highlighted if no activity is performed for |'updatetime'|
+milliseconds. The default value for this Vim option is 4 seconds. To avoid
+unexpected problems, you should not set the |'updatetime'| option to a very
+low value.
+
+To disable the automatic highlighting of the current tag name in the taglist
+window, set the 'Tlist_Auto_Highlight_Tag' variable to zero.
+
+When entering a Vim buffer/window, the taglist plugin automatically highlights
+the current tag in that buffer/window.  If you like to disable the automatic
+highlighting of the current tag when entering a buffer, set the
+'Tlist_Highlight_Tag_On_BufEnter' variable to zero.
+
+Adding files to the taglist~
+When the taglist window is opened, all the files in the Vim buffer list are
+processed and the supported files are added to the taglist.  When you edit a
+file in Vim, the taglist plugin automatically processes this file and adds it
+to the taglist. If you close the taglist window, the tag information in the
+taglist is retained.
+
+To process files even when the taglist window is not open, set the
+'Tlist_Process_File_Always' variable to 1.
+
+You can manually add multiple files to the taglist without opening them using
+the ":TlistAddFiles" and the ":TlistAddFilesRecursive" commands.
+
+For example, to add all the C files in the /my/project/dir directory to the
+taglist, you can use the following command:
+>
+	:TlistAddFiles /my/project/dir/*.c
+<
+Note that when adding several files with a large number of tags or a large
+number of files, it will take several seconds to several minutes for the
+taglist plugin to process all the files. You should not interrupt the taglist
+plugin by pressing <CTRL-C>.
+
+You can recursively add multiple files from a directory tree using the
+":TlistAddFilesRecursive" command:
+>
+	:TlistAddFilesRecursive /my/project/dir *.c
+<
+This command takes two arguments. The first argument specifies the directory
+from which to recursively add the files. The second optional argument
+specifies the wildcard matching pattern for selecting the files to add. The
+default pattern is * and all the files are added.
+
+Displaying tags for only one file~
+The taglist window displays the tags for all the files in the Vim buffer list
+and all the manually added files. To display the tags for only the current
+active buffer, set the 'Tlist_Show_One_File' variable to 1.
+
+Removing files from the taglist~
+You can remove a file from the taglist window, by pressing the 'd' key when the
+cursor is on one of the tags listed for the file in the taglist window. The
+removed file will no longer be displayed in the taglist window in the current
+Vim session. To again display the tags for the file, open the file in a Vim
+window and then use the ":TlistUpdate" command or use ":TlistAddFiles" command
+to add the file to the taglist.
+
+When a buffer is removed from the Vim buffer list using the ":bdelete" or the
+":bwipeout" command, the taglist is updated to remove the stored information
+for this buffer.
+
+Updating the tags displayed for a file~
+The taglist plugin keeps track of the modification time of a file. When the
+modification time changes (the file is modified), the taglist plugin
+automatically updates the tags listed for that file. The modification time of
+a file is checked when you enter a window containing that file or when you
+load that file.
+
+You can also update or refresh the tags displayed for a file by pressing the
+"u" key in the taglist window. If an existing file is modified, after the file
+is saved, the taglist plugin automatically updates the tags displayed for the
+file.
+
+You can also use the ":TlistUpdate" command to update the tags for the current
+buffer after you made some changes to it. You should save the modified buffer
+before you update the taglist window. Otherwise the listed tags will not
+include the new tags created in the buffer. 
+
+If you have deleted the tags displayed for a file in the taglist window using
+the 'd' key, you can again display the tags for that file using the
+":TlistUpdate" command.
+
+Controlling the taglist updates~
+To disable the automatic processing of new files or modified files, you can
+set the 'Tlist_Auto_Update' variable to zero. When this variable is set to
+zero, the taglist is updated only when you use the ":TlistUpdate" command or
+the ":TlistAddFiles" or the ":TlistAddFilesRecursive" commands. You can use
+this option to control which files are added to the taglist.
+
+You can use the ":TlistLock" command to lock the taglist contents. After this
+command is executed, new files are not automatically added to the taglist.
+When the taglist is locked, you can use the ":TlistUpdate" command to add the
+current file or the ":TlistAddFiles" or ":TlistAddFilesRecursive" commands to
+add new files to the taglist.  To unlock the taglist, use the ":TlistUnlock"
+command.
+
+Displaying the tag prototype~
+To display the prototype of the tag under the cursor in the taglist window,
+press the space bar. If you place the cursor on a tag name in the taglist
+window, then the tag prototype is displayed at the Vim status line after
+|'updatetime'| milliseconds. The default value for the |'updatetime'| Vim
+option is 4 seconds.
+
+You can get the name and prototype of a tag without opening the taglist window
+and the taglist menu using the ":TlistShowTag" and the ":TlistShowPrototype"
+commands. These commands will work only if the current file is already present
+in the taglist. To use these commands without opening the taglist window, set
+the 'Tlist_Process_File_Always' variable to 1.
+
+You can use the ":TlistShowTag" command to display the name of the tag at or
+before the specified line number in the specified file.  If the file name and
+line number are not supplied, then this command will display the name of the
+current tag. For example,
+>
+	:TlistShowTag
+	:TlistShowTag myfile.java 100
+<
+You can use the ":TlistShowPrototype" command to display the prototype of the
+tag at or before the specified line number in the specified file.  If the file
+name and the line number are not supplied, then this command will display the
+prototype of the current tag.  For example,
+>
+	:TlistShowPrototype
+	:TlistShowPrototype myfile.c 50
+<
+In the taglist window, when the mouse is moved over a tag name, the tag
+prototype is displayed in a balloon. This works only in GUI versions where
+balloon evaluation is supported.
+
+Taglist window contents~
+The taglist window contains the tags defined in various files in the taglist
+grouped by the filename and by the tag type (variable, function, class, etc.).
+For tags with scope information (like class members, structures inside
+structures, etc.), the scope information is displayed in square brackets "[]"
+after the tag name.
+
+The contents of the taglist buffer/window are managed by the taglist plugin.
+The |'filetype'| for the taglist buffer is set to 'taglist'.  The Vim
+|'modifiable'| option is turned off for the taglist buffer. You should not
+manually edit the taglist buffer, by setting the |'modifiable'| flag. If you
+manually edit the taglist buffer contents, then the taglist plugin will be out
+of sync with the taglist buffer contents and the plugin will no longer work
+correctly. To redisplay the taglist buffer contents again, close the taglist
+window and reopen it.
+
+Opening and closing the tag and file tree~
+In the taglist window, the tag names are displayed as a foldable tree using
+the Vim folding support. You can collapse the tree using the '-' key or using
+the Vim |zc| fold command. You can open the tree using the '+' key or using
+the Vim |zo| fold command. You can open all the folds using the '*' key or
+using the Vim |zR| fold command. You can also use the mouse to open/close the
+folds. You can close all the folds using the '=' key. You should not manually
+create or delete the folds in the taglist window.
+
+To automatically close the fold for the inactive files/buffers and open only
+the fold for the current buffer in the taglist window, set the
+'Tlist_File_Fold_Auto_Close' variable to 1.
+
+Sorting the tags for a file~
+The tags displayed in the taglist window can be sorted either by their name or
+by their chronological order. The default sorting method is by the order in
+which the tags appear in a file. You can change the default sort method by
+setting the 'Tlist_Sort_Type' variable to either "name" or "order". You can
+sort the tags by their name by pressing the "s" key in the taglist window. You
+can again sort the tags by their chronological order using the "s" key. Each
+file in the taglist window can be sorted using different order.
+
+Zooming in and out of the taglist window~
+You can press the 'x' key in the taglist window to maximize the taglist
+window width/height. The window will be maximized to the maximum possible
+width/height without closing the other existing windows. You can again press
+'x' to restore the taglist window to the default width/height.
+
+						*taglist-session*
+Taglist Session~
+A taglist session refers to the group of files and their tags stored in the
+taglist in a Vim session.
+
+You can save and restore a taglist session (and all the displayed tags) using
+the ":TlistSessionSave" and ":TlistSessionLoad" commands.
+
+To save the information about the tags and files in the taglist to a file, use
+the ":TlistSessionSave" command and specify the filename:
+>
+	:TlistSessionSave <file name>
+<
+To load a saved taglist session, use the ":TlistSessionLoad" command: >
+
+	:TlistSessionLoad <file name>
+<
+When you load a taglist session file, the tags stored in the file will be
+added to the tags already stored in the taglist.
+
+The taglist session feature can be used to save the tags for large files or a
+group of frequently used files (like a project). By using the taglist session
+file, you can minimize the amount to time it takes to load/refresh the taglist
+for multiple files.
+
+You can create more than one taglist session file for multiple groups of
+files.
+
+Displaying the tag name in the Vim status line or the window title bar~
+You can use the Tlist_Get_Tagname_By_Line() function provided by the taglist
+plugin to display the current tag name in the Vim status line or the window
+title bar. Similarly, you can use the Tlist_Get_Tag_Prototype_By_Line()
+function to display the current tag prototype in the Vim status line or the
+window title bar.
+
+For example, the following command can be used to display the current tag name
+in the status line:
+>
+	:set statusline=%<%f%=%([%{Tlist_Get_Tagname_By_Line()}]%)
+<
+The following command can be used to display the current tag name in the
+window title bar:
+>
+	:set title titlestring=%<%f\ %([%{Tlist_Get_Tagname_By_Line()}]%)
+<
+Note that the current tag name can be displayed only after the file is
+processed by the taglist plugin. For this, you have to either set the
+'Tlist_Process_File_Always' variable to 1 or open the taglist window or use
+the taglist menu. For more information about configuring the Vim status line,
+refer to the documentation for the Vim |'statusline'| option.
+
+Changing the taglist window highlighting~
+The following Vim highlight groups are defined and used to highlight the
+various entities in the taglist window:
+
+    TagListTagName  - Used for tag names
+    TagListTagScope - Used for tag scope
+    TagListTitle    - Used for tag titles
+    TagListComment  - Used for comments
+    TagListFileName - Used for filenames
+
+By default, these highlight groups are linked to the standard Vim highlight
+groups. If you want to change the colors used for these highlight groups,
+prefix the highlight group name with 'My' and define it in your .vimrc or
+.gvimrc file: MyTagListTagName, MyTagListTagScope, MyTagListTitle,
+MyTagListComment and MyTagListFileName.  For example, to change the colors
+used for tag names, you can use the following command:
+>
+    :highlight MyTagListTagName guifg=blue ctermfg=blue
+<
+Controlling the taglist window~
+To use a horizontally split taglist window, instead of a vertically split
+window, set the 'Tlist_Use_Horiz_Window' variable to 1.
+
+To use a vertically split taglist window on the rightmost side of the Vim
+window, set the 'Tlist_Use_Right_Window' variable to 1.
+
+You can specify the width of the vertically split taglist window, by setting
+the 'Tlist_WinWidth' variable.  You can specify the height of the horizontally
+split taglist window, by setting the 'Tlist_WinHeight' variable.
+
+When opening a vertically split taglist window, the Vim window width is
+increased to accommodate the new taglist window. When the taglist window is
+closed, the Vim window is reduced. To disable this, set the
+'Tlist_Inc_Winwidth' variable to zero.
+
+To reduce the number of empty lines in the taglist window, set the
+'Tlist_Compact_Format' variable to 1.
+
+To not display the Vim fold column in the taglist window, set the
+'Tlist_Enable_Fold_Column' variable to zero.
+
+To display the tag prototypes instead of the tag names in the taglist window,
+set the 'Tlist_Display_Prototype' variable to 1.
+
+To not display the scope of the tags next to the tag names, set the
+'Tlist_Display_Tag_Scope' variable to zero.
+
+						*taglist-keys*
+Taglist window key list~
+The following table lists the description of the keys that can be used
+in the taglist window.
+
+  Key           Description~
+
+  <CR>          Jump to the location where the tag under cursor is
+                defined.
+  o             Jump to the location where the tag under cursor is
+                defined in a new window.
+  P             Jump to the tag in the previous (Ctrl-W_p) window.
+  p             Display the tag definition in the file window and
+                keep the cursor in the taglist window itself.
+  t             Jump to the tag in a new tab. If the file is already
+                opened in a tab, move to that tab.
+  Ctrl-t	Jump to the tag in a new tab.
+  <Space>       Display the prototype of the tag under the cursor.
+  		For file names, display the full path to the file,
+		file type and the number of tags. For tag types, display the
+		tag type and the number of tags.
+  u             Update the tags listed in the taglist window
+  s             Change the sort order of the tags (by name or by order)
+  d             Remove the tags for the file under the cursor
+  x             Zoom-in or Zoom-out the taglist window
+  +             Open a fold
+  -             Close a fold
+  *             Open all folds
+  =             Close all folds
+  [[		Jump to the beginning of the previous file
+  <Backspace>	Jump to the beginning of the previous file
+  ]]		Jump to the beginning of the next file
+  <Tab>		Jump to the beginning of the next file
+  q             Close the taglist window
+  <F1>          Display help
+
+The above keys will work in both the normal mode and the insert mode.
+
+						*taglist-menu*
+Taglist menu~
+When using GUI Vim, the taglist plugin can display the tags defined in the
+current file in the drop-down menu and the popup menu. By default, this
+feature is turned off. To turn on this feature, set the 'Tlist_Show_Menu'
+variable to 1.
+
+You can jump to a tag by selecting the tag name from the menu. You can use the
+taglist menu independent of the taglist window i.e. you don't need to open the
+taglist window to get the taglist menu.
+
+When you switch between files/buffers, the taglist menu is automatically
+updated to display the tags defined in the current file/buffer.
+
+The tags are grouped by their type (variables, functions, classes, methods,
+etc.) and displayed as a separate sub-menu for each type. If all the tags
+defined in a file are of the same type (e.g. functions), then the sub-menu is
+not used.
+
+If the number of items in a tag type submenu exceeds the value specified by
+the 'Tlist_Max_Submenu_Items' variable, then the submenu will be split into
+multiple submenus. The default setting for 'Tlist_Max_Submenu_Items' is 25.
+The first and last tag names in the submenu are used to form the submenu name.
+The menu items are prefixed by alpha-numeric characters for easy selection by
+keyboard.
+
+If the popup menu support is enabled (the |'mousemodel'| option contains
+"popup"), then the tags menu is added to the popup menu. You can access
+the popup menu by right clicking on the GUI window.
+
+You can regenerate the tags menu by selecting the 'Tags->Refresh menu' entry.
+You can sort the tags listed in the menu either by name or by order by
+selecting the 'Tags->Sort menu by->Name/Order' menu entry.
+
+You can tear-off the Tags menu and keep it on the side of the Vim window
+for quickly locating the tags.
+
+Using the taglist plugin with the winmanager plugin~
+You can use the taglist plugin with the winmanager plugin. This will allow you
+to use the file explorer, buffer explorer and the taglist plugin at the same
+time in different windows. To use the taglist plugin with the winmanager
+plugin, set 'TagList' in the 'winManagerWindowLayout' variable. For example,
+to use the file explorer plugin and the taglist plugin at the same time, use
+the following setting: >
+
+	let winManagerWindowLayout = 'FileExplorer|TagList'
+<
+Getting help~
+If you have installed the taglist help file (this file), then you can use the
+Vim ":help taglist-<keyword>" command to get help on the various taglist
+topics.
+
+You can press the <F1> key in the taglist window to display the help
+information about using the taglist window. If you again press the <F1> key,
+the help information is removed from the taglist window.
+
+						*taglist-debug*
+Debugging the taglist plugin~
+You can use the ":TlistDebug" command to enable logging of the debug messages
+from the taglist plugin. To display the logged debug messages, you can use the
+":TlistMessages" command. To disable the logging of the debug messages, use
+the ":TlistUndebug" command.
+
+You can specify a file name to the ":TlistDebug" command to log the debug
+messages to a file. Otherwise, the debug messages are stored in a script-local
+variable. In the later case, to minimize memory usage, only the last 3000
+characters from the debug messages are stored.
+
+==============================================================================
+						*taglist-options*
+5. Options~
+
+A number of Vim variables control the behavior of the taglist plugin. These
+variables are initialized to a default value. By changing these variables you
+can change the behavior of the taglist plugin. You need to change these
+settings only if you want to change the behavior of the taglist plugin. You
+should use the |:let| command in your .vimrc file to change the setting of any
+of these variables. 
+
+The configurable taglist variables are listed below. For a detailed
+description of these variables refer to the text below this table.
+
+|'Tlist_Auto_Highlight_Tag'|	Automatically highlight the current tag in the
+				taglist.
+|'Tlist_Auto_Open'|		Open the taglist window when Vim starts.
+|'Tlist_Auto_Update'|		Automatically update the taglist to include
+				newly edited files.
+|'Tlist_Close_On_Select'|	Close the taglist window when a file or tag is
+				selected.
+|'Tlist_Compact_Format'|	Remove extra information and blank lines from
+       				the taglist window.
+|'Tlist_Ctags_Cmd'|		Specifies the path to the ctags utility.
+|'Tlist_Display_Prototype'|	Show prototypes and not tags in the taglist
+				window.
+|'Tlist_Display_Tag_Scope'|	Show tag scope next to the tag name.
+|'Tlist_Enable_Fold_Column'|	Show the fold indicator column in the taglist
+				window.
+|'Tlist_Exit_OnlyWindow'|	Close Vim if the taglist is the only window.
+|'Tlist_File_Fold_Auto_Close'|	Close tag folds for inactive buffers.
+|'Tlist_GainFocus_On_ToggleOpen'|
+				Jump to taglist window on open.
+|'Tlist_Highlight_Tag_On_BufEnter'|
+				On entering a buffer, automatically highlight
+				the current tag.
+|'Tlist_Inc_Winwidth'|		Increase the Vim window width to accommodate
+				the taglist window.
+|'Tlist_Max_Submenu_Items'|	Maximum number of items in a tags sub-menu.
+|'Tlist_Max_Tag_Length'|	Maximum tag length used in a tag menu entry.
+|'Tlist_Process_File_Always'|	Process files even when the taglist window is
+				closed.
+|'Tlist_Show_Menu'|		Display the tags menu.
+|'Tlist_Show_One_File'|		Show tags for the current buffer only.
+|'Tlist_Sort_Type'|		Sort method used for arranging the tags.
+|'Tlist_Use_Horiz_Window'|	Use a horizontally split window for the
+				taglist window.
+|'Tlist_Use_Right_Window'|	Place the taglist window on the right side.
+|'Tlist_Use_SingleClick'|	Single click on a tag jumps to it.
+|'Tlist_WinHeight'|		Horizontally split taglist window height.
+|'Tlist_WinWidth'|		Vertically split taglist window width.
+|'Tlist_javascript_Hide_Extras'| Hide extra tag data produced by jsctags.
+
+						*'Tlist_Auto_Highlight_Tag'*
+Tlist_Auto_Highlight_Tag~
+The taglist plugin will automatically highlight the current tag in the taglist
+window. If you want to disable this, then you can set the
+'Tlist_Auto_Highlight_Tag' variable to zero. Note that even though the current
+tag highlighting is disabled, the tags for a new file will still be added to
+the taglist window.
+>
+	let Tlist_Auto_Highlight_Tag = 0
+<
+With the above variable set to 1, you can use the ":TlistHighlightTag" command
+to highlight the current tag.
+
+						*'Tlist_Auto_Open'*
+Tlist_Auto_Open~
+To automatically open the taglist window, when you start Vim, you can set the
+'Tlist_Auto_Open' variable to 1. By default, this variable is set to zero and
+the taglist window will not be opened automatically on Vim startup.
+>
+	let Tlist_Auto_Open = 1
+<
+The taglist window is opened only when a supported type of file is opened on
+Vim startup. For example, if you open text files, then the taglist window will
+not be opened.
+
+						*'Tlist_Auto_Update'*
+Tlist_Auto_Update~
+When a new file is edited, the tags defined in the file are automatically
+processed and added to the taglist. To stop adding new files to the taglist,
+set the 'Tlist_Auto_Update' variable to zero. By default, this variable is set
+to 1.
+>
+	let Tlist_Auto_Update = 0
+<
+With the above variable set to 1, you can use the ":TlistUpdate" command to
+add the tags defined in the current file to the taglist.
+
+						*'Tlist_Close_On_Select'*
+Tlist_Close_On_Select~
+If you want to close the taglist window when a file or tag is selected, then
+set the 'Tlist_Close_On_Select' variable to 1. By default, this variable is
+set zero and when you select a tag or file from the taglist window, the window
+is not closed.
+>
+	let Tlist_Close_On_Select = 1
+<
+						*'Tlist_Compact_Format'*
+Tlist_Compact_Format~
+By default, empty lines are used to separate different tag types displayed for
+a file and the tags displayed for different files in the taglist window. If
+you want to display as many tags as possible in the taglist window, you can
+set the 'Tlist_Compact_Format' variable to 1 to get a compact display.
+>
+	let Tlist_Compact_Format = 1
+<
+						*'Tlist_Ctags_Cmd'*
+Tlist_Ctags_Cmd~
+The 'Tlist_Ctags_Cmd' variable specifies the location (path) of the exuberant
+ctags utility. If exuberant ctags is present in any one of the directories in
+the PATH environment variable, then there is no need to set this variable.
+
+The exuberant ctags tool can be installed under different names.  When the
+taglist plugin starts up, if the 'Tlist_Ctags_Cmd' variable is not set, it
+checks for the names exuberant-ctags, exctags, ctags, ctags.exe and tags in
+the PATH environment variable.  If any one of the named executable is found,
+then the Tlist_Ctags_Cmd variable is set to that name.
+
+If exuberant ctags is not present in one of the directories specified in the
+PATH environment variable, then set this variable to point to the location of
+the ctags utility in your system. Note that this variable should point to the
+fully qualified exuberant ctags location and NOT to the directory in which
+exuberant ctags is installed. If the exuberant ctags tool is not found in
+either PATH or in the specified location, then the taglist plugin will not be
+loaded. Examples:
+>
+	let Tlist_Ctags_Cmd = 'd:\tools\ctags.exe'
+	let Tlist_Ctags_Cmd = '/usr/local/bin/ctags'
+<
+						*'Tlist_Display_Prototype'*
+Tlist_Display_Prototype~
+By default, only the tag name will be displayed in the taglist window. If you
+like to see tag prototypes instead of names, set the 'Tlist_Display_Prototype'
+variable to 1. By default, this variable is set to zero and only tag names
+will be displayed.
+>
+	let Tlist_Display_Prototype = 1
+<
+						*'Tlist_Display_Tag_Scope'*
+Tlist_Display_Tag_Scope~
+By default, the scope of a tag (like a C++ class) will be displayed in
+square brackets next to the tag name. If you don't want the tag scopes
+to be displayed, then set the 'Tlist_Display_Tag_Scope' to zero. By default,
+this variable is set to 1 and the tag scopes will be displayed.
+>
+	let Tlist_Display_Tag_Scope = 0
+<
+						*'Tlist_Enable_Fold_Column'*
+Tlist_Enable_Fold_Column~
+By default, the Vim fold column is enabled and displayed in the taglist
+window. If you wish to disable this (for example, when you are working with a
+narrow Vim window or terminal), you can set the 'Tlist_Enable_Fold_Column'
+variable to zero.
+>
+	let Tlist_Enable_Fold_Column = 1
+<
+						*'Tlist_Exit_OnlyWindow'*
+Tlist_Exit_OnlyWindow~
+If you want to exit Vim if only the taglist window is currently opened, then
+set the 'Tlist_Exit_OnlyWindow' variable to 1. By default, this variable is
+set to zero and the Vim instance will not be closed if only the taglist window
+is present.
+>
+	let Tlist_Exit_OnlyWindow = 1
+<
+						*'Tlist_File_Fold_Auto_Close'*
+Tlist_File_Fold_Auto_Close~
+By default, the tags tree displayed in the taglist window for all the files is
+opened. You can close/fold the tags tree for the files manually. To
+automatically close the tags tree for inactive files, you can set the
+'Tlist_File_Fold_Auto_Close' variable to 1. When this variable is set to 1,
+the tags tree for the current buffer is automatically opened and for all the
+other buffers is closed.
+>
+	let Tlist_File_Fold_Auto_Close = 1
+<
+					    *'Tlist_GainFocus_On_ToggleOpen'*
+Tlist_GainFocus_On_ToggleOpen~
+When the taglist window is opened using the ':TlistToggle' command, this
+option controls whether the cursor is moved to the taglist window or remains
+in the current window. By default, this option is set to 0 and the cursor
+remains in the current window. When this variable is set to 1, the cursor
+moves to the taglist window after opening the taglist window.
+>
+	let Tlist_GainFocus_On_ToggleOpen = 1
+<
+					    *'Tlist_Highlight_Tag_On_BufEnter'*
+Tlist_Highlight_Tag_On_BufEnter~
+When you enter a Vim buffer/window, the current tag in that buffer/window is
+automatically highlighted in the taglist window. If the current tag name is
+not visible in the taglist window, then the taglist window contents are
+scrolled to make that tag name visible. If you like to disable the automatic
+highlighting of the current tag when entering a buffer, you can set the
+'Tlist_Highlight_Tag_On_BufEnter' variable to zero. The default setting for
+this variable is 1.
+>
+	let Tlist_Highlight_Tag_On_BufEnter = 0
+<
+						*'Tlist_Inc_Winwidth'*
+Tlist_Inc_Winwidth~
+By default, when the width of the window is less than 100 and a new taglist
+window is opened vertically, then the window width is increased by the value
+set in the 'Tlist_WinWidth' variable to accommodate the new window. The value
+of this variable is used only if you are using a vertically split taglist
+window.
+
+If your terminal doesn't support changing the window width from Vim (older
+version of xterm running in a Unix system) or if you see any weird problems in
+the screen due to the change in the window width or if you prefer not to
+adjust the window width then set the 'Tlist_Inc_Winwidth' variable to zero.
+CAUTION: If you are using the MS-Windows version of Vim in a MS-DOS command
+window then you must set this variable to zero, otherwise the system may hang
+due to a Vim limitation (explained in :help win32-problems)
+>
+	let Tlist_Inc_Winwidth = 0
+<
+						*'Tlist_Max_Submenu_Items'*
+Tlist_Max_Submenu_Items~
+If a file contains too many tags of a particular type (function, variable,
+class, etc.), greater than that specified by the 'Tlist_Max_Submenu_Items'
+variable, then the menu for that tag type will be split into multiple
+sub-menus. The default setting for the 'Tlist_Max_Submenu_Items' variable is
+25.  This can be changed by setting the 'Tlist_Max_Submenu_Items' variable:
+>
+	let Tlist_Max_Submenu_Items = 20
+<
+The name of the submenu is formed using the names of the first and the last
+tag entries in that submenu.
+
+						*'Tlist_Max_Tag_Length'*
+Tlist_Max_Tag_Length~
+Only the first 'Tlist_Max_Tag_Length' characters from the tag names will be
+used to form the tag type submenu name. The default value for this variable is
+10.  Change the 'Tlist_Max_Tag_Length' setting if you want to include more or
+less characters:
+>
+	let Tlist_Max_Tag_Length = 10
+<
+						*'Tlist_Process_File_Always'*
+Tlist_Process_File_Always~
+By default, the taglist plugin will generate and process the tags defined in
+the newly opened files only when the taglist window is opened or when the
+taglist menu is enabled. When the taglist window is closed, the taglist plugin
+will stop processing the tags for newly opened files.
+
+You can set the 'Tlist_Process_File_Always' variable to 1 to generate the list
+of tags for new files even when the taglist window is closed and the taglist
+menu is disabled.
+>
+	let Tlist_Process_File_Always = 1
+<
+To use the ":TlistShowTag" and the ":TlistShowPrototype" commands without the
+taglist window and the taglist menu, you should set this variable to 1.
+
+						*'Tlist_Show_Menu'*
+Tlist_Show_Menu~
+When using GUI Vim, you can display the tags defined in the current file in a
+menu named "Tags". By default, this feature is turned off. To turn on this
+feature, set the 'Tlist_Show_Menu' variable to 1:
+>
+	let Tlist_Show_Menu = 1
+<
+						*'Tlist_Show_One_File'*
+Tlist_Show_One_File~
+By default, the taglist plugin will display the tags defined in all the loaded
+buffers in the taglist window. If you prefer to display the tags defined only
+in the current buffer, then you can set the 'Tlist_Show_One_File' to 1. When
+this variable is set to 1, as you switch between buffers, the taglist window
+will be refreshed to display the tags for the current buffer and the tags for
+the previous buffer will be removed.
+>
+	let Tlist_Show_One_File = 1
+<
+						*'Tlist_Sort_Type'*
+Tlist_Sort_Type~
+The 'Tlist_Sort_Type' variable specifies the sort order for the tags in the
+taglist window. The tags can be sorted either alphabetically by their name or
+by the order of their appearance in the file (chronological order). By
+default, the tag names will be listed by the order in which they are defined
+in the file. You can change the sort type (from name to order or from order to
+name) by pressing the "s" key in the taglist window. You can also change the
+default sort order by setting 'Tlist_Sort_Type' to "name" or "order":
+>
+	let Tlist_Sort_Type = "name"
+<
+						*'Tlist_Use_Horiz_Window'*
+Tlist_Use_Horiz_Window~
+Be default, the tag names are displayed in a vertically split window. If you
+prefer a horizontally split window, then set the 'Tlist_Use_Horiz_Window'
+variable to 1. If you are running MS-Windows version of Vim in a MS-DOS
+command window, then you should use a horizontally split window instead of a
+vertically split window. Also, if you are using an older version of xterm in a
+Unix system that doesn't support changing the xterm window width, you should
+use a horizontally split window.
+>
+	let Tlist_Use_Horiz_Window = 1
+<
+						*'Tlist_Use_Right_Window'*
+Tlist_Use_Right_Window~
+By default, the vertically split taglist window will appear on the left hand
+side. If you prefer to open the window on the right hand side, you can set the
+'Tlist_Use_Right_Window' variable to 1:
+>
+	let Tlist_Use_Right_Window = 1
+<
+						*'Tlist_Use_SingleClick'*
+Tlist_Use_SingleClick~
+By default, when you double click on the tag name using the left mouse 
+button, the cursor will be positioned at the definition of the tag. You 
+can set the 'Tlist_Use_SingleClick' variable to 1 to jump to a tag when
+you single click on the tag name using the mouse. By default this variable
+is set to zero.
+>
+	let Tlist_Use_SingleClick = 1
+<
+Due to a bug in Vim, if you set 'Tlist_Use_SingleClick' to 1 and try to resize
+the taglist window using the mouse, then Vim will crash. This problem is fixed
+in Vim 6.3 and above. In the meantime, instead of resizing the taglist window
+using the mouse, you can use normal Vim window resizing commands to resize the
+taglist window.
+
+						*'Tlist_WinHeight'*
+Tlist_WinHeight~
+The default height of the horizontally split taglist window is 10. This can be
+changed by modifying the 'Tlist_WinHeight' variable:
+>
+	let Tlist_WinHeight = 20
+<
+The |'winfixheight'| option is set for the taglist window, to maintain the
+height of the taglist window, when new Vim windows are opened and existing
+windows are closed.
+
+						*'Tlist_WinWidth'*
+Tlist_WinWidth~
+The default width of the vertically split taglist window is 30. This can be
+changed by modifying the 'Tlist_WinWidth' variable:
+>
+	let Tlist_WinWidth = 20
+<
+Setting Tlist_WinWidth to 'auto' causes the taglist window to resize
+automatically to fit the contents.
+
+Note that the value of the |'winwidth'| option setting determines the minimum
+width of the current window. If you set the 'Tlist_WinWidth' variable to a
+value less than that of the |'winwidth'| option setting, then Vim will use the
+value of the |'winwidth'| option.
+
+When new Vim windows are opened and existing windows are closed, the taglist
+plugin will try to maintain the width of the taglist window to the size
+specified by the 'Tlist_WinWidth' variable.
+
+						*'Tlist_javascript_Hide_Extras'*
+Tlist_javascript_Hide_Extras~
+
+To hide the type inference data generated by jsctags, modify this variable:
+
+    let Tlist_javascript_Hide_Extras = ['type']
+
+Note that 'javascript' here is not capitalized!
+
+==============================================================================
+						*taglist-commands*
+6. Commands~
+
+The taglist plugin provides the following ex-mode commands:
+
+|:TlistAddFiles|	Add multiple files to the taglist.
+|:TlistAddFilesRecursive|
+			Add files recursively to the taglist.
+|:TlistClose|		Close the taglist window.
+|:TlistDebug|		Start logging of taglist debug messages.
+|:TlistLock|		Stop adding new files to the taglist.
+|:TlistMessages|	Display the logged taglist plugin debug messages.
+|:TlistOpen|		Open and jump to the taglist window.
+|:TlistSessionSave|	Save the information about files and tags in the
+			taglist to a session file.
+|:TlistSessionLoad|	Load the information about files and tags stored
+			in a session file to taglist.
+|:TlistShowPrototype|	Display the prototype of the tag at or before the
+		    	specified line number.
+|:TlistShowTag|		Display the name of the tag defined at or before the
+			specified line number.
+|:TlistHighlightTag|	Highlight the current tag in the taglist window.
+|:TlistToggle|		Open or close (toggle) the taglist window.
+|:TlistUndebug|		Stop logging of taglist debug messages.
+|:TlistUnlock|		Start adding new files to the taglist.
+|:TlistUpdate|		Update the tags for the current buffer.
+
+						*:TlistAddFiles*
+:TlistAddFiles {file(s)} [file(s) ...]
+		Add one or more specified files to the taglist. You can
+		specify multiple filenames using wildcards. To specify a
+		file name with space character, you should escape the space
+		character with a backslash.
+		Examples:
+>
+		    :TlistAddFiles *.c *.cpp
+		    :TlistAddFiles file1.html file2.html
+<
+		If you specify a large number of files, then it will take some
+		time for the taglist plugin to process all of them. The
+		specified files will not be edited in a Vim window and will
+		not be added to the Vim buffer list.
+
+						*:TlistAddFilesRecursive*
+:TlistAddFilesRecursive {directory} [ {pattern} ]
+		Add files matching {pattern} recursively from the specified
+		{directory} to the taglist. If {pattern} is not specified,
+		then '*' is assumed. To specify the current directory, use "."
+		for {directory}. To specify a directory name with space
+		character, you should escape the space character with a
+		backslash.
+		Examples:
+>
+		    :TlistAddFilesRecursive myproject *.java
+		    :TlistAddFilesRecursive smallproject
+<
+		If large number of files are present in the specified
+		directory tree, then it will take some time for the taglist
+		plugin to process all of them.
+
+						*:TlistClose*
+:TlistClose	Close the taglist window. This command can be used from any
+		one of the Vim windows.
+
+						*:TlistDebug*
+:TlistDebug [filename]
+		Start logging of debug messages from the taglist plugin.
+		If {filename} is specified, then the debug messages are stored
+		in the specified file. Otherwise, the debug messages are
+		stored in a script local variable. If the file {filename} is
+		already present, then it is overwritten.
+
+						*:TlistLock*
+:TlistLock
+		Lock the taglist and don't process new files. After this
+		command is executed, newly edited files will not be added to
+		the taglist.
+
+						*:TlistMessages*
+:TlistMessages
+		Display the logged debug messages from the taglist plugin
+		in a window.  This command works only when logging to a
+		script-local variable.
+
+						*:TlistOpen*
+:TlistOpen	Open and jump to the taglist window. Creates the taglist
+		window, if the window is not opened currently. After executing
+		this command, the cursor is moved to the taglist window.  When
+		the taglist window is opened for the first time, all the files
+		in the buffer list are processed and the tags defined in them
+		are displayed in the taglist window.
+
+						*:TlistSessionSave*
+:TlistSessionSave {filename}
+		Saves the information about files and tags in the taglist to
+		the specified file. This command can be used to save and
+		restore the taglist contents across Vim sessions.
+
+						*:TlistSessionLoad*
+:TlistSessionLoad {filename}
+		Load the information about files and tags stored in the
+		specified session file to the taglist.
+
+						*:TlistShowPrototype*
+:TlistShowPrototype [filename] [linenumber]
+		Display the prototype of the tag at or before the specified
+		line number. If the file name and the line number are not
+		specified, then the current file name and line number are
+		used. A tag spans multiple lines starting from the line where
+		it is defined to the line before the next tag. This command
+		displays the prototype for the tag for any line number in this
+		range. 
+
+						*:TlistShowTag*
+:TlistShowTag [filename] [linenumber]
+		Display the name of the tag defined at or before the specified
+		line number. If the file name and the line number are not
+		specified, then the current file name and line number are
+		used. A tag spans multiple lines starting from the line where
+		it is defined to the line before the next tag. This command
+		displays the tag name for any line number in this range. 
+
+						*:TlistHighlightTag*
+:TlistHighlightTag
+		Highlight the current tag in the taglist window. By default,
+		the taglist plugin periodically updates the taglist window to
+		highlight the current tag. This command can be used to force
+		the taglist plugin to highlight the current tag.
+
+						*:TlistToggle*
+:TlistToggle	Open or close (toggle) the taglist window. Opens the taglist
+		window, if the window is not opened currently. Closes the
+		taglist window, if the taglist window is already opened. When
+		the taglist window is opened for the first time, all the files
+		in the buffer list are processed and the tags are displayed in
+		the taglist window. After executing this command, the cursor
+		is not moved from the current window to the taglist window.
+
+						*:TlistUndebug*
+:TlistUndebug
+		Stop logging of debug messages from the taglist plugin.
+
+						*:TlistUnlock*
+:TlistUnlock
+		Unlock the taglist and start processing newly edited files.
+
+						*:TlistUpdate*
+:TlistUpdate	Update the tags information for the current buffer. This
+		command can be used to re-process the current file/buffer and
+		get the tags information. As the taglist plugin uses the file
+		saved in the disk (instead of the file displayed in a Vim
+		buffer), you should save a modified buffer before you update
+		the taglist. Otherwise the listed tags will not include the
+		new tags created in the buffer. You can use this command even
+		when the taglist window is not opened.
+
+==============================================================================
+						*taglist-functions*
+7. Global functions~
+
+The taglist plugin provides several global functions that can be used from
+other Vim plugins to interact with the taglist plugin. These functions are
+described below.
+
+|Tlist_Update_File_Tags()|		Update the tags for the specified file
+|Tlist_Get_Tag_Prototype_By_Line()|	Return the prototype of the tag at or
+				    	before the specified line number in the
+				    	specified file.
+|Tlist_Get_Tagname_By_Line()|		Return the name of the tag at or
+					before the specified line number in
+					the specified file.
+|Tlist_Set_App()|			Set the name of the application
+					controlling the taglist window.
+
+					    *Tlist_Update_File_Tags()*
+Tlist_Update_File_Tags({filename}, {filetype})
+		Update the tags for the file {filename}. The second argument
+		specifies the Vim filetype for the file. If the taglist plugin
+		has not processed the file previously, then the exuberant
+		ctags tool is invoked to generate the tags for the file.
+
+					    *Tlist_Get_Tag_Prototype_By_Line()*
+Tlist_Get_Tag_Prototype_By_Line([{filename}, {linenumber}])
+		Return the prototype of the tag at or before the specified
+		line number in the specified file. If the filename and line
+		number are not specified, then the current buffer name and the
+		current line number are used.
+
+					    *Tlist_Get_Tagname_By_Line()*
+Tlist_Get_Tagname_By_Line([{filename}, {linenumber}])
+		Return the name of the tag at or before the specified line
+		number in the specified file. If the filename and line number
+		are not specified, then the current buffer name and the
+		current line number are used.
+
+					    *Tlist_Set_App()*
+Tlist_Set_App({appname})
+		Set the name of the plugin that controls the taglist plugin
+		window and buffer. This can be used to integrate the taglist
+		plugin with other Vim plugins.
+		
+		For example, the winmanager plugin and the Cream package use
+		this function and specify the appname as "winmanager" and
+		"cream" respectively.
+		
+		By default, the taglist plugin is a stand-alone plugin and
+		controls the taglist window and buffer. If the taglist window
+		is controlled by an external plugin, then the appname should
+		be set appropriately.
+
+==============================================================================
+						*taglist-extend*
+8. Extending~
+
+The taglist plugin supports all the languages supported by the exuberant ctags
+tool, which includes the following languages: Assembly, ASP, Awk, Beta, C,
+C++, C#, Cobol, Eiffel, Erlang, Fortran, HTML, Java, Javascript, Lisp, Lua,
+Make, Pascal, Perl, PHP, Python, Rexx, Ruby, Scheme, Shell, Slang, SML, Sql,
+TCL, Verilog, Vim and Yacc.
+
+You can extend the taglist plugin to add support for new languages and also
+modify the support for the above listed languages.
+
+You should NOT make modifications to the taglist plugin script file to add
+support for new languages. You will lose these changes when you upgrade to the
+next version of the taglist plugin. Instead you should follow the below
+described instructions to extend the taglist plugin.
+
+You can extend the taglist plugin by setting variables in the .vimrc or _vimrc
+file. The name of these variables depends on the language name and is
+described below.
+
+Modifying support for an existing language~
+To modify the support for an already supported language, you have to set the
+tlist_xxx_settings variable in the ~/.vimrc or $HOME/_vimrc file. Replace xxx
+with the Vim filetype name for the language file.  For example, to modify the
+support for the perl language files, you have to set the tlist_perl_settings
+variable. To modify the support for java files, you have to set the
+tlist_java_settings variable.
+
+To determine the filetype name used by Vim for a file, use the following
+command in the buffer containing the file:
+
+	:set filetype
+
+The above command will display the Vim filetype for the current buffer.
+
+The format of the value set in the tlist_xxx_settings variable is
+
+    <language_name>;flag1:name1;flag2:name2;flag3:name3
+
+The different fields in the value are separated by the ';' character.
+
+The first field 'language_name' is the name used by exuberant ctags to refer
+to this language file. This name can be different from the file type name used
+by Vim. For example, for C++, the language name used by ctags is 'c++' but the
+filetype name used by Vim is 'cpp'. To get the list of language names
+supported by exuberant ctags, use the following command:
+
+	$ ctags --list-maps=all
+
+The remaining fields follow the format "flag:name". The sub-field 'flag' is
+the language specific flag used by exuberant ctags to generate the
+corresponding tags. For example, for the C language, to list only the
+functions, the 'f' flag is used. To get the list of flags supported by
+exuberant ctags for the various languages use the following command:
+
+	$ ctags --list-kinds=all
+
+The sub-field 'name' specifies the title text to use for displaying the tags
+of a particular type. For example, 'name' can be set to 'functions'. This
+field can be set to any text string name.
+
+For example, to list only the classes and functions defined in a C++ language
+file, add the following line to your .vimrc file:
+
+	let tlist_cpp_settings = 'c++;c:class;f:function'
+
+In the above setting, 'cpp' is the Vim filetype name and 'c++' is the name
+used by the exuberant ctags tool. 'c' and 'f' are the flags passed to
+exuberant ctags to list C++ classes and functions and 'class' is the title
+used for the class tags and 'function' is the title used for the function tags
+in the taglist window.
+
+For example, to display only functions defined in a C file and to use "My
+Functions" as the title for the function tags, use
+
+	let tlist_c_settings = 'c;f:My Functions'
+
+When you set the tlist_xxx_settings variable, you will override the default
+setting used by the taglist plugin for the 'xxx' language. You cannot add to
+the default options used by the taglist plugin for a particular file type. To
+add to the options used by the taglist plugin for a language, copy the option
+values from the taglist plugin file to your .vimrc file and modify it.
+
+Adding support for a new language~
+If you want to add support for a new language to the taglist plugin, you need
+to first extend the exuberant ctags tool. For more information about extending
+exuberant ctags, visit the following page:
+
+    http://ctags.sourceforge.net/EXTENDING.html
+
+To add support for a new language, set the tlist_xxx_settings variable in the
+~/.vimrc file appropriately as described above. Replace 'xxx' in the variable
+name with the Vim filetype name for the new language.
+
+For example, to extend the taglist plugin to support the latex language, you
+can use the following line (assuming, you have already extended exuberant
+ctags to support the latex language):
+
+	let tlist_tex_settings='latex;b:bibitem;c:command;l:label'
+
+With the above line, when you edit files of filetype "tex" in Vim, the taglist
+plugin will invoke the exuberant ctags tool passing the "latex" filetype and
+the flags b, c and l to generate the tags. The text heading 'bibitem',
+'command' and 'label' will be used in the taglist window for the tags which
+are generated for the flags b, c and l respectively.
+
+==============================================================================
+						*taglist-faq*
+9. Frequently Asked Questions~
+
+Q. The taglist plugin doesn't work. The taglist window is empty and the tags
+   defined in a file are not displayed. 
+A. Are you using Vim version 6.0 and above? The taglist plugin relies on the
+   features supported by Vim version 6.0 and above. You can use the following
+   command to get the Vim version:
+>
+	$ vim --version
+<
+   Are you using exuberant ctags version 5.0 and above? The taglist plugin
+   relies on the features supported by exuberant ctags and will not work with
+   GNU ctags or the Unix ctags utility. You can use the following command to
+   determine whether the ctags installed in your system is exuberant ctags:
+>
+	$ ctags --version
+<
+   Is exuberant ctags present in one of the directories in your PATH? If not,
+   you need to set the Tlist_Ctags_Cmd variable to point to the location of
+   exuberant ctags. Use the following Vim command to verify that this is setup
+   correctly:
+>
+	:echo system(Tlist_Ctags_Cmd . ' --version')
+<
+   The above command should display the version information for exuberant
+   ctags.
+
+   Did you turn on the Vim filetype detection? The taglist plugin relies on
+   the filetype detected by Vim and passes the filetype to the exuberant ctags
+   utility to parse the tags. Check the output of the following Vim command:
+>
+	:filetype
+<
+   The output of the above command should contain "filetype detection:ON".
+   To turn on the filetype detection, add the following line to the .vimrc or
+   _vimrc file:
+>
+	filetype on
+<
+   Is your version of Vim compiled with the support for the system() function?
+   The following Vim command should display 1:
+>
+	:echo exists('*system')
+<
+   In some Linux distributions (particularly Suse Linux), the default Vim
+   installation is built without the support for the system() function. The
+   taglist plugin uses the system() function to invoke the exuberant ctags
+   utility. You need to rebuild Vim after enabling the support for the
+   system() function. If you use the default build options, the system()
+   function will be supported. 
+
+   Do you have the |'shellslash'| option set? You can try disabling the
+   |'shellslash'| option. When the taglist plugin invokes the exuberant ctags
+   utility with the path to the file, if the incorrect slashes are used, then
+   you will see errors.
+   
+   Check the shell related Vim options values using the following command:
+>
+	:set shell? shellcmdflag? shellpipe?
+	:set shellquote? shellredir? shellxquote?
+<
+   If these options are set in your .vimrc or _vimrc file, try removing those
+   lines.
+
+   Are you using a Unix shell in a MS-Windows environment? For example,
+   the Unix shell from the MKS-toolkit. Do you have the SHELL environment
+   set to point to this shell? You can try resetting the SHELL environment
+   variable.
+
+   If you are using a Unix shell on MS-Windows, you should try to use
+   exuberant ctags that is compiled for Unix-like environments so that
+   exuberant ctags will understand path names with forward slash characters.
+
+   Is your filetype supported by the exuberant ctags utility? The file types
+   supported by the exuberant ctags utility are listed in the ctags help. If a
+   file type is not supported, you have to extend exuberant ctags. You can use
+   the following command to list the filetypes supported by exuberant ctags:
+>
+	ctags --list-languages
+<
+   Run the following command from the shell prompt and check whether the tags
+   defined in your file are listed in the output from exuberant ctags:
+>
+	ctags -f - --format=2 --excmd=pattern --fields=nks <filename>
+<
+   If you see your tags in the output from the above command, then the
+   exuberant ctags utility is properly parsing your file.
+
+   Do you have the .ctags or _ctags or the ctags.cnf file in your home
+   directory for specifying default options or for extending exuberant ctags?
+   If you do have this file, check the options in this file and make sure
+   these options are not interfering with the operation of the taglist plugin.
+
+   If you are using MS-Windows, check the value of the TEMP and TMP
+   environment variables. If these environment variables are set to a path
+   with space characters in the name, then try using the DOS 8.3 short name
+   for the path or set them to a path without the space characters in the
+   name. For example, if the temporary directory name is "C:\Documents and
+   Settings\xyz\Local Settings\Temp", then try setting the TEMP variable to
+   the following:
+>
+	set TEMP=C:\DOCUMEN~1\xyz\LOCALS~1\Temp
+<
+   If exuberant ctags is installed in a directory with space characters in the
+   name, then try adding the directory to the PATH environment variable or try
+   setting the 'Tlist_Ctags_Cmd' variable to the shortest path name to ctags
+   or try copying the exuberant ctags to a path without space characters in
+   the name. For example, if exuberant ctags is installed in the directory
+   "C:\Program Files\Ctags", then try setting the 'Tlist_Ctags_Cmd' variable
+   as below:
+>
+	let Tlist_Ctags_Cmd='C:\Progra~1\Ctags\ctags.exe'
+<
+   If you are using a cygwin compiled version of exuberant ctags on MS-Windows,
+   make sure that either you have the cygwin compiled sort utility installed
+   and available in your PATH or compile exuberant ctags with internal sort
+   support. Otherwise, when exuberant ctags sorts the tags output by invoking
+   the sort utility, it may end up invoking the MS-Windows version of
+   sort.exe, thereby resulting in failure.
+
+Q. When I try to open the taglist window, I am seeing the following error
+   message. How do I fix this problem?
+
+   Taglist: Failed to generate tags for /my/path/to/file
+   ctags: illegal option -- -^@usage: ctags [-BFadtuwvx] [-f tagsfile] file ...
+
+A. The taglist plugin will work only with the exuberant ctags tool. You
+   cannot use the GNU ctags or the Unix ctags program with the taglist plugin.
+   You will see an error message similar to the one shown above, if you try
+   use a non-exuberant ctags program with Vim. To fix this problem, either add
+   the exuberant ctags tool location to the PATH environment variable or set
+   the 'Tlist_Ctags_Cmd' variable.
+
+Q. A file has more than one tag with the same name. When I select a tag name
+   from the taglist window, the cursor is positioned at the incorrect tag
+   location. 
+A. The taglist plugin uses the search pattern generated by the exuberant ctags
+   utility to position the cursor at the location of a tag definition. If a
+   file has more than one tag with the same name and same prototype, then the
+   search pattern will be the same. In this case, when searching for the tag
+   pattern, the cursor may be positioned at the incorrect location. 
+
+Q. I have made some modifications to my file and introduced new
+   functions/classes/variables. I have not yet saved my file. The taglist
+   plugin is not displaying the new tags when I update the taglist window.
+A. The exuberant ctags utility will process only files that are present in the
+   disk. To list the tags defined in a file, you have to save the file and
+   then update the taglist window. 
+
+Q. I have created a ctags file using the exuberant ctags utility for my source
+   tree. How do I configure the taglist plugin to use this tags file? 
+A. The taglist plugin doesn't use a tags file stored in disk. For every opened
+   file, the taglist plugin invokes the exuberant ctags utility to get the
+   list of tags dynamically. The Vim system() function is used to invoke
+   exuberant ctags and get the ctags output. This function internally uses a
+   temporary file to store the output. This file is deleted after the output
+   from the command is read. So you will never see the file that contains the
+   output of exuberant ctags.
+
+Q. When I set the |'updatetime'| option to a low value (less than 1000) and if
+   I keep pressing a key with the taglist window open, the current buffer
+   contents are changed. Why is this?
+A. The taglist plugin uses the |CursorHold| autocmd to highlight the current
+   tag. The CursorHold autocmd triggers for every |'updatetime'| milliseconds.
+   If the |'updatetime'| option is set to a low value, then the CursorHold
+   autocmd will be triggered frequently. As the taglist plugin changes
+   the focus to the taglist window to highlight the current tag, this could
+   interfere with the key movement resulting in changing the contents of
+   the current buffer. The workaround for this problem is to not set the
+   |'updatetime'| option to a low value.
+
+==============================================================================
+						*taglist-license*
+10. License~
+Permission is hereby granted to use and distribute the taglist plugin, with or
+without modifications, provided that this copyright notice is copied with it.
+Like anything else that's free, taglist.vim is provided *as is* and comes with
+no warranty of any kind, either expressed or implied. In no event will the
+copyright holder be liable for any damamges resulting from the use of this
+software.
+
+==============================================================================
+						*taglist-todo*
+11. Todo~
+
+1. Group tags according to the scope and display them. For example,
+   group all the tags belonging to a C++/Java class 
+2. Support for displaying tags in a modified (not-yet-saved) file. 
+3. Automatically open the taglist window only for selected filetypes.
+   For other filetypes, close the taglist window. 
+4. When using the shell from the MKS toolkit, the taglist plugin 
+   doesn't work.
+5. The taglist plugin doesn't work with files edited remotely using the
+   netrw plugin. The exuberant ctags utility cannot process files over
+   scp/rcp/ftp, etc.
+
+==============================================================================
+
+vim:tw=78:ts=8:noet:ft=help:
diff --git a/vimrc/.vim/doc/taglist.txt b/vimrc/.vim/doc/taglist.txt
new file mode 100755
--- /dev/null
+++ ./vimrc/.vim/doc/taglist.txt
@@ -0,0 +1,1501 @@
+*taglist.txt*	Plugin for browsing source code
+
+Author: Yegappan Lakshmanan  (yegappan AT yahoo DOT com)
+For Vim version 6.0 and above
+Last change: 2007 May 24
+
+1. Overview 					|taglist-intro|
+2. Taglist on the internet			|taglist-internet|
+3. Requirements					|taglist-requirements|
+4. Installation 				|taglist-install|
+5. Usage 					|taglist-using|
+6. Options 					|taglist-options|
+7. Commands 					|taglist-commands|
+8. Global functions 				|taglist-functions|
+9. Extending 					|taglist-extend|
+10. FAQ 					|taglist-faq|
+11. License 					|taglist-license|
+12. Todo					|taglist-todo|
+
+==============================================================================
+						*taglist-intro*
+1. Overview~
+
+The "Tag List" plugin is a source code browser plugin for Vim. This plugin
+allows you to efficiently browse through source code files for different
+programming languages. The "Tag List" plugin provides the following features:
+
+    * Displays the tags (functions, classes, structures, variables, etc.) 
+      defined in a file in a vertically or horizontally split Vim window.
+    * In GUI Vim, optionally displays the tags in the Tags drop-down menu and
+      in the popup menu.
+    * Automatically updates the taglist window as you switch between
+      files/buffers. As you open new files, the tags defined in the new files
+      are added to the existing file list and the tags defined in all the
+      files are displayed grouped by the filename.
+    * When a tag name is selected from the taglist window, positions the
+      cursor at the definition of the tag in the source file.
+    * Automatically highlights the current tag name.
+    * Groups the tags by their type and displays them in a foldable tree.
+    * Can display the prototype and scope of a tag.
+    * Can optionally display the tag prototype instead of the tag name in the
+      taglist window.
+    * The tag list can be sorted either by name or by chronological order.
+    * Supports the following language files: Assembly, ASP, Awk, Beta, C,
+      C++, C#, Cobol, Eiffel, Erlang, Fortran, HTML, Java, Javascript, Lisp,
+      Lua, Make, Pascal, Perl, PHP, Python, Rexx, Ruby, Scheme, Shell, Slang,
+      SML, Sql, TCL, Verilog, Vim and Yacc.
+    * Can be easily extended to support new languages. Support for
+      existing languages can be modified easily.
+    * Provides functions to display the current tag name in the Vim status
+      line or the window title bar.
+    * The list of tags and files in the taglist can be saved and
+      restored across Vim sessions.
+    * Provides commands to get the name and prototype of the current tag.
+    * Runs in both console/terminal and GUI versions of Vim.
+    * Works with the winmanager plugin. Using the winmanager plugin, you
+      can use Vim plugins like the file explorer, buffer explorer and the
+      taglist plugin at the same time like an IDE.
+    * Can be used in both Unix and MS-Windows systems.
+
+==============================================================================
+						*taglist-internet*
+2. Taglist on the internet~
+
+The home page of the taglist plugin is at:
+>
+	http://vim-taglist.sourceforge.net/
+<
+You can subscribe to the taglist mailing list to post your questions or
+suggestions for improvement or to send bug reports. Visit the following page
+for subscribing to the mailing list:
+>
+	http://groups.yahoo.com/group/taglist
+<
+==============================================================================
+						*taglist-requirements*
+3. Requirements~
+
+The taglist plugin requires the following:
+
+    * Vim version 6.0 and above
+    * Exuberant ctags 5.0 and above
+
+The taglist plugin will work on all the platforms where the exuberant ctags
+utility and Vim are supported (this includes MS-Windows and Unix based
+systems).
+
+The taglist plugin relies on the exuberant ctags utility to dynamically
+generate the tag listing.  The exuberant ctags utility must be installed in
+your system to use this plugin.  The exuberant ctags utility is shipped with
+most of the Linux distributions.  You can download the exuberant ctags utility
+from
+>
+	http://ctags.sourceforge.net
+<
+The taglist plugin doesn't use or create a tags file and there is no need to
+create a tags file to use this plugin. The taglist plugin will not work with
+the GNU ctags or the Unix ctags utility.
+
+This plugin relies on the Vim "filetype" detection mechanism to determine the
+type of the current file. You have to turn on the Vim filetype detection by
+adding the following line to your .vimrc file:
+>
+	filetype on
+<
+The taglist plugin will not work if you run Vim in the restricted mode (using
+the -Z command-line argument).
+
+The taglist plugin uses the Vim system() function to invoke the exuberant
+ctags utility. If Vim is compiled without the system() function then you
+cannot use the taglist plugin. Some of the Linux distributions (Suse) compile
+Vim without the system() function for security reasons.
+
+==============================================================================
+						*taglist-install*
+4. Installation~
+
+1. Download the taglist.zip file and unzip the files to the $HOME/.vim or the
+   $HOME/vimfiles or the $VIM/vimfiles directory. After this step, you should
+   have the following two files (the directory structure should be preserved):
+
+	plugin/taglist.vim - main taglist plugin file
+	doc/taglist.txt    - documentation (help) file
+
+   Refer to the |add-plugin|and |'runtimepath'| Vim help pages for more
+   details about installing Vim plugins.
+2. Change to the $HOME/.vim/doc or $HOME/vimfiles/doc or $VIM/vimfiles/doc
+   directory, start Vim and run the ":helptags ." command to process the
+   taglist help file. Without this step, you cannot jump to the taglist help
+   topics.
+3. If the exuberant ctags utility is not present in one of the directories in
+   the PATH environment variable, then set the 'Tlist_Ctags_Cmd' variable to
+   point to the location of the exuberant ctags utility (not to the directory)
+   in the .vimrc file.
+4. If you are running a terminal/console version of Vim and the terminal
+   doesn't support changing the window width then set the
+   'Tlist_Inc_Winwidth' variable to 0 in the .vimrc file.
+5. Restart Vim.
+6. You can now use the ":TlistToggle" command to open/close the taglist
+   window. You can use the ":help taglist" command to get more information
+   about using the taglist plugin.
+
+To uninstall the taglist plugin, remove the plugin/taglist.vim and
+doc/taglist.txt files from the $HOME/.vim or $HOME/vimfiles directory.
+
+==============================================================================
+						*taglist-using*
+5. Usage~
+
+The taglist plugin can be used in several different ways.
+
+1. You can keep the taglist window open during the entire editing session. On
+   opening the taglist window, the tags defined in all the files in the Vim
+   buffer list will be displayed in the taglist window. As you edit files, the
+   tags defined in them will be added to the taglist window. You can select a
+   tag from the taglist window and jump to it. The current tag will be
+   highlighted in the taglist window. You can close the taglist window when
+   you no longer need the window.
+2. You can configure the taglist plugin to process the tags defined in all the
+   edited files always. In this configuration, even if the taglist window is
+   closed and the taglist menu is not displayed, the taglist plugin will
+   processes the tags defined in newly edited files. You can then open the
+   taglist window only when you need to select a tag and then automatically
+   close the taglist window after selecting the tag.
+3. You can configure the taglist plugin to display only the tags defined in
+   the current file in the taglist window. By default, the taglist plugin
+   displays the tags defined in all the files in the Vim buffer list. As you
+   switch between files, the taglist window will be refreshed to display only
+   the tags defined in the current file.
+4. In GUI Vim, you can use the Tags pull-down and popup menu created by the
+   taglist plugin to display the tags defined in the current file and select a
+   tag to jump to it. You can use the menu without opening the taglist window.
+   By default, the Tags menu is disabled.
+5. You can configure the taglist plugin to display the name of the current tag
+   in the Vim window status line or in the Vim window title bar. For this to
+   work without the taglist window or menu, you need to configure the taglist
+   plugin to process the tags defined in a file always.
+6. You can save the tags defined in multiple files to a taglist session file
+   and load it when needed. You can also configure the taglist plugin to not
+   update the taglist window when editing new files. You can then manually add
+   files to the taglist window.
+
+Opening the taglist window~
+You can open the taglist window using the ":TlistOpen" or the ":TlistToggle"
+commands. The ":TlistOpen" command opens the taglist window and jumps to it.
+The ":TlistToggle" command opens or closes (toggle) the taglist window and the
+cursor remains in the current window. If the 'Tlist_GainFocus_On_ToggleOpen'
+variable is set to 1, then the ":TlistToggle" command opens the taglist window
+and moves the cursor to the taglist window.
+
+You can map a key to invoke these commands. For example, the following command
+creates a normal mode mapping for the <F8> key to toggle the taglist window.
+>
+	nnoremap <silent> <F8> :TlistToggle<CR>
+<
+Add the above mapping to your ~/.vimrc or $HOME/_vimrc file.
+
+To automatically open the taglist window on Vim startup, set the
+'Tlist_Auto_Open' variable to 1.
+
+You can also open the taglist window on startup using the following command
+line:
+>
+	$ vim +TlistOpen
+<
+Closing the taglist window~
+You can close the taglist window from the taglist window by pressing 'q' or
+using the Vim ":q" command. You can also use any of the Vim window commands to
+close the taglist window. Invoking the ":TlistToggle" command when the taglist
+window is opened, closes the taglist window. You can also use the
+":TlistClose" command to close the taglist window.
+
+To automatically close the taglist window when a tag or file is selected, you
+can set the 'Tlist_Close_On_Select' variable to 1.  To exit Vim when only the
+taglist window is present, set the 'Tlist_Exit_OnlyWindow' variable to 1.
+
+Jumping to a tag or a file~
+You can select a tag in the taglist window either by pressing the <Enter> key
+or by double clicking the tag name using the mouse. To jump to a tag on a
+single mouse click set the 'Tlist_Use_SingleClick' variable to 1.
+
+If the selected file is already opened in a window, then the cursor is moved
+to that window. If the file is not currently opened in a window then the file
+is opened in the window used by the taglist plugin to show the previously
+selected file. If there are no usable windows, then the file is opened in a
+new window.  The file is not opened in special windows like the quickfix
+window, preview window and windows containing buffer with the 'buftype' option
+set.
+
+To jump to the tag in a new window, press the 'o' key. To open the file in the
+previous window (Ctrl-W_p) use the 'P' key. You can press the 'p' key to jump
+to the tag but still keep the cursor in the taglist window (preview).
+
+To open the selected file in a tab, use the 't' key.  If the file is already
+present in a tab then the cursor is moved to that tab otherwise the file is
+opened in a new tab. To jump to a tag in a new tab press Ctrl-t.  The taglist
+window is automatically opened in the newly created tab.
+
+Instead of jumping to a tag, you can open a file by pressing the <Enter> key
+or by double clicking the file name using the mouse.
+
+In the taglist window, you can use the [[ or <Backspace> key to jump to the
+beginning of the previous file. You can use the ]] or <Tab> key to jump to the
+beginning of the next file. When you reach the first or last file, the search
+wraps around and the jumps to the next/previous file.
+
+Highlighting the current tag~
+The taglist plugin automatically highlights the name of the current tag in the
+taglist window. The Vim |CursorHold| autocmd event is used for this. If the
+current tag name is not visible in the taglist window, then the taglist window
+contents are scrolled to make that tag name visible. You can also use the
+":TlistHighlightTag" command to force the highlighting of the current tag.
+
+The tag name is highlighted if no activity is performed for |'updatetime'|
+milliseconds. The default value for this Vim option is 4 seconds. To avoid
+unexpected problems, you should not set the |'updatetime'| option to a very
+low value.
+
+To disable the automatic highlighting of the current tag name in the taglist
+window, set the 'Tlist_Auto_Highlight_Tag' variable to zero.
+
+When entering a Vim buffer/window, the taglist plugin automatically highlights
+the current tag in that buffer/window.  If you like to disable the automatic
+highlighting of the current tag when entering a buffer, set the
+'Tlist_Highlight_Tag_On_BufEnter' variable to zero.
+
+Adding files to the taglist~
+When the taglist window is opened, all the files in the Vim buffer list are
+processed and the supported files are added to the taglist.  When you edit a
+file in Vim, the taglist plugin automatically processes this file and adds it
+to the taglist. If you close the taglist window, the tag information in the
+taglist is retained.
+
+To process files even when the taglist window is not open, set the
+'Tlist_Process_File_Always' variable to 1.
+
+You can manually add multiple files to the taglist without opening them using
+the ":TlistAddFiles" and the ":TlistAddFilesRecursive" commands.
+
+For example, to add all the C files in the /my/project/dir directory to the
+taglist, you can use the following command:
+>
+	:TlistAddFiles /my/project/dir/*.c
+<
+Note that when adding several files with a large number of tags or a large
+number of files, it will take several seconds to several minutes for the
+taglist plugin to process all the files. You should not interrupt the taglist
+plugin by pressing <CTRL-C>.
+
+You can recursively add multiple files from a directory tree using the
+":TlistAddFilesRecursive" command:
+>
+	:TlistAddFilesRecursive /my/project/dir *.c
+<
+This command takes two arguments. The first argument specifies the directory
+from which to recursively add the files. The second optional argument
+specifies the wildcard matching pattern for selecting the files to add. The
+default pattern is * and all the files are added.
+
+Displaying tags for only one file~
+The taglist window displays the tags for all the files in the Vim buffer list
+and all the manually added files. To display the tags for only the current
+active buffer, set the 'Tlist_Show_One_File' variable to 1.
+
+Removing files from the taglist~
+You can remove a file from the taglist window, by pressing the 'd' key when the
+cursor is on one of the tags listed for the file in the taglist window. The
+removed file will no longer be displayed in the taglist window in the current
+Vim session. To again display the tags for the file, open the file in a Vim
+window and then use the ":TlistUpdate" command or use ":TlistAddFiles" command
+to add the file to the taglist.
+
+When a buffer is removed from the Vim buffer list using the ":bdelete" or the
+":bwipeout" command, the taglist is updated to remove the stored information
+for this buffer.
+
+Updating the tags displayed for a file~
+The taglist plugin keeps track of the modification time of a file. When the
+modification time changes (the file is modified), the taglist plugin
+automatically updates the tags listed for that file. The modification time of
+a file is checked when you enter a window containing that file or when you
+load that file.
+
+You can also update or refresh the tags displayed for a file by pressing the
+"u" key in the taglist window. If an existing file is modified, after the file
+is saved, the taglist plugin automatically updates the tags displayed for the
+file.
+
+You can also use the ":TlistUpdate" command to update the tags for the current
+buffer after you made some changes to it. You should save the modified buffer
+before you update the taglist window. Otherwise the listed tags will not
+include the new tags created in the buffer. 
+
+If you have deleted the tags displayed for a file in the taglist window using
+the 'd' key, you can again display the tags for that file using the
+":TlistUpdate" command.
+
+Controlling the taglist updates~
+To disable the automatic processing of new files or modified files, you can
+set the 'Tlist_Auto_Update' variable to zero. When this variable is set to
+zero, the taglist is updated only when you use the ":TlistUpdate" command or
+the ":TlistAddFiles" or the ":TlistAddFilesRecursive" commands. You can use
+this option to control which files are added to the taglist.
+
+You can use the ":TlistLock" command to lock the taglist contents. After this
+command is executed, new files are not automatically added to the taglist.
+When the taglist is locked, you can use the ":TlistUpdate" command to add the
+current file or the ":TlistAddFiles" or ":TlistAddFilesRecursive" commands to
+add new files to the taglist.  To unlock the taglist, use the ":TlistUnlock"
+command.
+
+Displaying the tag prototype~
+To display the prototype of the tag under the cursor in the taglist window,
+press the space bar. If you place the cursor on a tag name in the taglist
+window, then the tag prototype is displayed at the Vim status line after
+|'updatetime'| milliseconds. The default value for the |'updatetime'| Vim
+option is 4 seconds.
+
+You can get the name and prototype of a tag without opening the taglist window
+and the taglist menu using the ":TlistShowTag" and the ":TlistShowPrototype"
+commands. These commands will work only if the current file is already present
+in the taglist. To use these commands without opening the taglist window, set
+the 'Tlist_Process_File_Always' variable to 1.
+
+You can use the ":TlistShowTag" command to display the name of the tag at or
+before the specified line number in the specified file.  If the file name and
+line number are not supplied, then this command will display the name of the
+current tag. For example,
+>
+	:TlistShowTag
+	:TlistShowTag myfile.java 100
+<
+You can use the ":TlistShowPrototype" command to display the prototype of the
+tag at or before the specified line number in the specified file.  If the file
+name and the line number are not supplied, then this command will display the
+prototype of the current tag.  For example,
+>
+	:TlistShowPrototype
+	:TlistShowPrototype myfile.c 50
+<
+In the taglist window, when the mouse is moved over a tag name, the tag
+prototype is displayed in a balloon. This works only in GUI versions where
+balloon evaluation is supported.
+
+Taglist window contents~
+The taglist window contains the tags defined in various files in the taglist
+grouped by the filename and by the tag type (variable, function, class, etc.).
+For tags with scope information (like class members, structures inside
+structures, etc.), the scope information is displayed in square brackets "[]"
+after the tag name.
+
+The contents of the taglist buffer/window are managed by the taglist plugin.
+The |'filetype'| for the taglist buffer is set to 'taglist'.  The Vim
+|'modifiable'| option is turned off for the taglist buffer. You should not
+manually edit the taglist buffer, by setting the |'modifiable'| flag. If you
+manually edit the taglist buffer contents, then the taglist plugin will be out
+of sync with the taglist buffer contents and the plugin will no longer work
+correctly. To redisplay the taglist buffer contents again, close the taglist
+window and reopen it.
+
+Opening and closing the tag and file tree~
+In the taglist window, the tag names are displayed as a foldable tree using
+the Vim folding support. You can collapse the tree using the '-' key or using
+the Vim |zc| fold command. You can open the tree using the '+' key or using
+the Vim |zo| fold command. You can open all the folds using the '*' key or
+using the Vim |zR| fold command. You can also use the mouse to open/close the
+folds. You can close all the folds using the '=' key. You should not manually
+create or delete the folds in the taglist window.
+
+To automatically close the fold for the inactive files/buffers and open only
+the fold for the current buffer in the taglist window, set the
+'Tlist_File_Fold_Auto_Close' variable to 1.
+
+Sorting the tags for a file~
+The tags displayed in the taglist window can be sorted either by their name or
+by their chronological order. The default sorting method is by the order in
+which the tags appear in a file. You can change the default sort method by
+setting the 'Tlist_Sort_Type' variable to either "name" or "order". You can
+sort the tags by their name by pressing the "s" key in the taglist window. You
+can again sort the tags by their chronological order using the "s" key. Each
+file in the taglist window can be sorted using different order.
+
+Zooming in and out of the taglist window~
+You can press the 'x' key in the taglist window to maximize the taglist
+window width/height. The window will be maximized to the maximum possible
+width/height without closing the other existing windows. You can again press
+'x' to restore the taglist window to the default width/height.
+
+						*taglist-session*
+Taglist Session~
+A taglist session refers to the group of files and their tags stored in the
+taglist in a Vim session.
+
+You can save and restore a taglist session (and all the displayed tags) using
+the ":TlistSessionSave" and ":TlistSessionLoad" commands.
+
+To save the information about the tags and files in the taglist to a file, use
+the ":TlistSessionSave" command and specify the filename:
+>
+	:TlistSessionSave <file name>
+<
+To load a saved taglist session, use the ":TlistSessionLoad" command: >
+
+	:TlistSessionLoad <file name>
+<
+When you load a taglist session file, the tags stored in the file will be
+added to the tags already stored in the taglist.
+
+The taglist session feature can be used to save the tags for large files or a
+group of frequently used files (like a project). By using the taglist session
+file, you can minimize the amount to time it takes to load/refresh the taglist
+for multiple files.
+
+You can create more than one taglist session file for multiple groups of
+files.
+
+Displaying the tag name in the Vim status line or the window title bar~
+You can use the Tlist_Get_Tagname_By_Line() function provided by the taglist
+plugin to display the current tag name in the Vim status line or the window
+title bar. Similarly, you can use the Tlist_Get_Tag_Prototype_By_Line()
+function to display the current tag prototype in the Vim status line or the
+window title bar.
+
+For example, the following command can be used to display the current tag name
+in the status line:
+>
+	:set statusline=%<%f%=%([%{Tlist_Get_Tagname_By_Line()}]%)
+<
+The following command can be used to display the current tag name in the
+window title bar:
+>
+	:set title titlestring=%<%f\ %([%{Tlist_Get_Tagname_By_Line()}]%)
+<
+Note that the current tag name can be displayed only after the file is
+processed by the taglist plugin. For this, you have to either set the
+'Tlist_Process_File_Always' variable to 1 or open the taglist window or use
+the taglist menu. For more information about configuring the Vim status line,
+refer to the documentation for the Vim |'statusline'| option.
+
+Changing the taglist window highlighting~
+The following Vim highlight groups are defined and used to highlight the
+various entities in the taglist window:
+
+    TagListTagName  - Used for tag names
+    TagListTagScope - Used for tag scope
+    TagListTitle    - Used for tag titles
+    TagListComment  - Used for comments
+    TagListFileName - Used for filenames
+
+By default, these highlight groups are linked to the standard Vim highlight
+groups. If you want to change the colors used for these highlight groups,
+prefix the highlight group name with 'My' and define it in your .vimrc or
+.gvimrc file: MyTagListTagName, MyTagListTagScope, MyTagListTitle,
+MyTagListComment and MyTagListFileName.  For example, to change the colors
+used for tag names, you can use the following command:
+>
+    :highlight MyTagListTagName guifg=blue ctermfg=blue
+<
+Controlling the taglist window~
+To use a horizontally split taglist window, instead of a vertically split
+window, set the 'Tlist_Use_Horiz_Window' variable to 1.
+
+To use a vertically split taglist window on the rightmost side of the Vim
+window, set the 'Tlist_Use_Right_Window' variable to 1.
+
+You can specify the width of the vertically split taglist window, by setting
+the 'Tlist_WinWidth' variable.  You can specify the height of the horizontally
+split taglist window, by setting the 'Tlist_WinHeight' variable.
+
+When opening a vertically split taglist window, the Vim window width is
+increased to accommodate the new taglist window. When the taglist window is
+closed, the Vim window is reduced. To disable this, set the
+'Tlist_Inc_Winwidth' variable to zero.
+
+To reduce the number of empty lines in the taglist window, set the
+'Tlist_Compact_Format' variable to 1.
+
+To not display the Vim fold column in the taglist window, set the
+'Tlist_Enable_Fold_Column' variable to zero.
+
+To display the tag prototypes instead of the tag names in the taglist window,
+set the 'Tlist_Display_Prototype' variable to 1.
+
+To not display the scope of the tags next to the tag names, set the
+'Tlist_Display_Tag_Scope' variable to zero.
+
+						*taglist-keys*
+Taglist window key list~
+The following table lists the description of the keys that can be used
+in the taglist window.
+
+  Key           Description~
+
+  <CR>          Jump to the location where the tag under cursor is
+                defined.
+  o             Jump to the location where the tag under cursor is
+                defined in a new window.
+  P             Jump to the tag in the previous (Ctrl-W_p) window.
+  p             Display the tag definition in the file window and
+                keep the cursor in the taglist window itself.
+  t             Jump to the tag in a new tab. If the file is already
+                opened in a tab, move to that tab.
+  Ctrl-t	Jump to the tag in a new tab.
+  <Space>       Display the prototype of the tag under the cursor.
+  		For file names, display the full path to the file,
+		file type and the number of tags. For tag types, display the
+		tag type and the number of tags.
+  u             Update the tags listed in the taglist window
+  s             Change the sort order of the tags (by name or by order)
+  d             Remove the tags for the file under the cursor
+  x             Zoom-in or Zoom-out the taglist window
+  +             Open a fold
+  -             Close a fold
+  *             Open all folds
+  =             Close all folds
+  [[		Jump to the beginning of the previous file
+  <Backspace>	Jump to the beginning of the previous file
+  ]]		Jump to the beginning of the next file
+  <Tab>		Jump to the beginning of the next file
+  q             Close the taglist window
+  <F1>          Display help
+
+The above keys will work in both the normal mode and the insert mode.
+
+						*taglist-menu*
+Taglist menu~
+When using GUI Vim, the taglist plugin can display the tags defined in the
+current file in the drop-down menu and the popup menu. By default, this
+feature is turned off. To turn on this feature, set the 'Tlist_Show_Menu'
+variable to 1.
+
+You can jump to a tag by selecting the tag name from the menu. You can use the
+taglist menu independent of the taglist window i.e. you don't need to open the
+taglist window to get the taglist menu.
+
+When you switch between files/buffers, the taglist menu is automatically
+updated to display the tags defined in the current file/buffer.
+
+The tags are grouped by their type (variables, functions, classes, methods,
+etc.) and displayed as a separate sub-menu for each type. If all the tags
+defined in a file are of the same type (e.g. functions), then the sub-menu is
+not used.
+
+If the number of items in a tag type submenu exceeds the value specified by
+the 'Tlist_Max_Submenu_Items' variable, then the submenu will be split into
+multiple submenus. The default setting for 'Tlist_Max_Submenu_Items' is 25.
+The first and last tag names in the submenu are used to form the submenu name.
+The menu items are prefixed by alpha-numeric characters for easy selection by
+keyboard.
+
+If the popup menu support is enabled (the |'mousemodel'| option contains
+"popup"), then the tags menu is added to the popup menu. You can access
+the popup menu by right clicking on the GUI window.
+
+You can regenerate the tags menu by selecting the 'Tags->Refresh menu' entry.
+You can sort the tags listed in the menu either by name or by order by
+selecting the 'Tags->Sort menu by->Name/Order' menu entry.
+
+You can tear-off the Tags menu and keep it on the side of the Vim window
+for quickly locating the tags.
+
+Using the taglist plugin with the winmanager plugin~
+You can use the taglist plugin with the winmanager plugin. This will allow you
+to use the file explorer, buffer explorer and the taglist plugin at the same
+time in different windows. To use the taglist plugin with the winmanager
+plugin, set 'TagList' in the 'winManagerWindowLayout' variable. For example,
+to use the file explorer plugin and the taglist plugin at the same time, use
+the following setting: >
+
+	let winManagerWindowLayout = 'FileExplorer|TagList'
+<
+Getting help~
+If you have installed the taglist help file (this file), then you can use the
+Vim ":help taglist-<keyword>" command to get help on the various taglist
+topics.
+
+You can press the <F1> key in the taglist window to display the help
+information about using the taglist window. If you again press the <F1> key,
+the help information is removed from the taglist window.
+
+						*taglist-debug*
+Debugging the taglist plugin~
+You can use the ":TlistDebug" command to enable logging of the debug messages
+from the taglist plugin. To display the logged debug messages, you can use the
+":TlistMessages" command. To disable the logging of the debug messages, use
+the ":TlistUndebug" command.
+
+You can specify a file name to the ":TlistDebug" command to log the debug
+messages to a file. Otherwise, the debug messages are stored in a script-local
+variable. In the later case, to minimize memory usage, only the last 3000
+characters from the debug messages are stored.
+
+==============================================================================
+						*taglist-options*
+6. Options~
+
+A number of Vim variables control the behavior of the taglist plugin. These
+variables are initialized to a default value. By changing these variables you
+can change the behavior of the taglist plugin. You need to change these
+settings only if you want to change the behavior of the taglist plugin. You
+should use the |:let| command in your .vimrc file to change the setting of any
+of these variables. 
+
+The configurable taglist variables are listed below. For a detailed
+description of these variables refer to the text below this table.
+
+|'Tlist_Auto_Highlight_Tag'|	Automatically highlight the current tag in the
+				taglist.
+|'Tlist_Auto_Open'|		Open the taglist window when Vim starts.
+|'Tlist_Auto_Update'|		Automatically update the taglist to include
+				newly edited files.
+|'Tlist_Close_On_Select'|	Close the taglist window when a file or tag is
+				selected.
+|'Tlist_Compact_Format'|	Remove extra information and blank lines from
+       				the taglist window.
+|'Tlist_Ctags_Cmd'|		Specifies the path to the ctags utility.
+|'Tlist_Display_Prototype'|	Show prototypes and not tags in the taglist
+				window.
+|'Tlist_Display_Tag_Scope'|	Show tag scope next to the tag name.
+|'Tlist_Enable_Fold_Column'|	Show the fold indicator column in the taglist
+				window.
+|'Tlist_Exit_OnlyWindow'|	Close Vim if the taglist is the only window.
+|'Tlist_File_Fold_Auto_Close'|	Close tag folds for inactive buffers.
+|'Tlist_GainFocus_On_ToggleOpen'|
+				Jump to taglist window on open.
+|'Tlist_Highlight_Tag_On_BufEnter'|
+				On entering a buffer, automatically highlight
+				the current tag.
+|'Tlist_Inc_Winwidth'|		Increase the Vim window width to accommodate
+				the taglist window.
+|'Tlist_Max_Submenu_Items'|	Maximum number of items in a tags sub-menu.
+|'Tlist_Max_Tag_Length'|	Maximum tag length used in a tag menu entry.
+|'Tlist_Process_File_Always'|	Process files even when the taglist window is
+				closed.
+|'Tlist_Show_Menu'|		Display the tags menu.
+|'Tlist_Show_One_File'|		Show tags for the current buffer only.
+|'Tlist_Sort_Type'|		Sort method used for arranging the tags.
+|'Tlist_Use_Horiz_Window'|	Use a horizontally split window for the
+				taglist window.
+|'Tlist_Use_Right_Window'|	Place the taglist window on the right side.
+|'Tlist_Use_SingleClick'|	Single click on a tag jumps to it.
+|'Tlist_WinHeight'|		Horizontally split taglist window height.
+|'Tlist_WinWidth'|		Vertically split taglist window width.
+
+						*'Tlist_Auto_Highlight_Tag'*
+Tlist_Auto_Highlight_Tag~
+The taglist plugin will automatically highlight the current tag in the taglist
+window. If you want to disable this, then you can set the
+'Tlist_Auto_Highlight_Tag' variable to zero. Note that even though the current
+tag highlighting is disabled, the tags for a new file will still be added to
+the taglist window.
+>
+	let Tlist_Auto_Highlight_Tag = 0
+<
+With the above variable set to 1, you can use the ":TlistHighlightTag" command
+to highlight the current tag.
+
+						*'Tlist_Auto_Open'*
+Tlist_Auto_Open~
+To automatically open the taglist window, when you start Vim, you can set the
+'Tlist_Auto_Open' variable to 1. By default, this variable is set to zero and
+the taglist window will not be opened automatically on Vim startup.
+>
+	let Tlist_Auto_Open = 1
+<
+The taglist window is opened only when a supported type of file is opened on
+Vim startup. For example, if you open text files, then the taglist window will
+not be opened.
+
+						*'Tlist_Auto_Update'*
+Tlist_Auto_Update~
+When a new file is edited, the tags defined in the file are automatically
+processed and added to the taglist. To stop adding new files to the taglist,
+set the 'Tlist_Auto_Update' variable to zero. By default, this variable is set
+to 1.
+>
+	let Tlist_Auto_Update = 0
+<
+With the above variable set to 1, you can use the ":TlistUpdate" command to
+add the tags defined in the current file to the taglist.
+
+						*'Tlist_Close_On_Select'*
+Tlist_Close_On_Select~
+If you want to close the taglist window when a file or tag is selected, then
+set the 'Tlist_Close_On_Select' variable to 1. By default, this variable is
+set zero and when you select a tag or file from the taglist window, the window
+is not closed.
+>
+	let Tlist_Close_On_Select = 1
+<
+						*'Tlist_Compact_Format'*
+Tlist_Compact_Format~
+By default, empty lines are used to separate different tag types displayed for
+a file and the tags displayed for different files in the taglist window. If
+you want to display as many tags as possible in the taglist window, you can
+set the 'Tlist_Compact_Format' variable to 1 to get a compact display.
+>
+	let Tlist_Compact_Format = 1
+<
+						*'Tlist_Ctags_Cmd'*
+Tlist_Ctags_Cmd~
+The 'Tlist_Ctags_Cmd' variable specifies the location (path) of the exuberant
+ctags utility. If exuberant ctags is present in any one of the directories in
+the PATH environment variable, then there is no need to set this variable.
+
+The exuberant ctags tool can be installed under different names.  When the
+taglist plugin starts up, if the 'Tlist_Ctags_Cmd' variable is not set, it
+checks for the names exuberant-ctags, exctags, ctags, ctags.exe and tags in
+the PATH environment variable.  If any one of the named executable is found,
+then the Tlist_Ctags_Cmd variable is set to that name.
+
+If exuberant ctags is not present in one of the directories specified in the
+PATH environment variable, then set this variable to point to the location of
+the ctags utility in your system. Note that this variable should point to the
+fully qualified exuberant ctags location and NOT to the directory in which
+exuberant ctags is installed. If the exuberant ctags tool is not found in
+either PATH or in the specified location, then the taglist plugin will not be
+loaded. Examples:
+>
+	let Tlist_Ctags_Cmd = 'd:\tools\ctags.exe'
+	let Tlist_Ctags_Cmd = '/usr/local/bin/ctags'
+<
+						*'Tlist_Display_Prototype'*
+Tlist_Display_Prototype~
+By default, only the tag name will be displayed in the taglist window. If you
+like to see tag prototypes instead of names, set the 'Tlist_Display_Prototype'
+variable to 1. By default, this variable is set to zero and only tag names
+will be displayed.
+>
+	let Tlist_Display_Prototype = 1
+<
+						*'Tlist_Display_Tag_Scope'*
+Tlist_Display_Tag_Scope~
+By default, the scope of a tag (like a C++ class) will be displayed in
+square brackets next to the tag name. If you don't want the tag scopes
+to be displayed, then set the 'Tlist_Display_Tag_Scope' to zero. By default,
+this variable is set to 1 and the tag scopes will be displayed.
+>
+	let Tlist_Display_Tag_Scope = 0
+<
+						*'Tlist_Enable_Fold_Column'*
+Tlist_Enable_Fold_Column~
+By default, the Vim fold column is enabled and displayed in the taglist
+window. If you wish to disable this (for example, when you are working with a
+narrow Vim window or terminal), you can set the 'Tlist_Enable_Fold_Column'
+variable to zero.
+>
+	let Tlist_Enable_Fold_Column = 1
+<
+						*'Tlist_Exit_OnlyWindow'*
+Tlist_Exit_OnlyWindow~
+If you want to exit Vim if only the taglist window is currently opened, then
+set the 'Tlist_Exit_OnlyWindow' variable to 1. By default, this variable is
+set to zero and the Vim instance will not be closed if only the taglist window
+is present.
+>
+	let Tlist_Exit_OnlyWindow = 1
+<
+						*'Tlist_File_Fold_Auto_Close'*
+Tlist_File_Fold_Auto_Close~
+By default, the tags tree displayed in the taglist window for all the files is
+opened. You can close/fold the tags tree for the files manually. To
+automatically close the tags tree for inactive files, you can set the
+'Tlist_File_Fold_Auto_Close' variable to 1. When this variable is set to 1,
+the tags tree for the current buffer is automatically opened and for all the
+other buffers is closed.
+>
+	let Tlist_File_Fold_Auto_Close = 1
+<
+					    *'Tlist_GainFocus_On_ToggleOpen'*
+Tlist_GainFocus_On_ToggleOpen~
+When the taglist window is opened using the ':TlistToggle' command, this
+option controls whether the cursor is moved to the taglist window or remains
+in the current window. By default, this option is set to 0 and the cursor
+remains in the current window. When this variable is set to 1, the cursor
+moves to the taglist window after opening the taglist window.
+>
+	let Tlist_GainFocus_On_ToggleOpen = 1
+<
+					    *'Tlist_Highlight_Tag_On_BufEnter'*
+Tlist_Highlight_Tag_On_BufEnter~
+When you enter a Vim buffer/window, the current tag in that buffer/window is
+automatically highlighted in the taglist window. If the current tag name is
+not visible in the taglist window, then the taglist window contents are
+scrolled to make that tag name visible. If you like to disable the automatic
+highlighting of the current tag when entering a buffer, you can set the
+'Tlist_Highlight_Tag_On_BufEnter' variable to zero. The default setting for
+this variable is 1.
+>
+	let Tlist_Highlight_Tag_On_BufEnter = 0
+<
+						*'Tlist_Inc_Winwidth'*
+Tlist_Inc_Winwidth~
+By default, when the width of the window is less than 100 and a new taglist
+window is opened vertically, then the window width is increased by the value
+set in the 'Tlist_WinWidth' variable to accommodate the new window. The value
+of this variable is used only if you are using a vertically split taglist
+window.
+
+If your terminal doesn't support changing the window width from Vim (older
+version of xterm running in a Unix system) or if you see any weird problems in
+the screen due to the change in the window width or if you prefer not to
+adjust the window width then set the 'Tlist_Inc_Winwidth' variable to zero.
+CAUTION: If you are using the MS-Windows version of Vim in a MS-DOS command
+window then you must set this variable to zero, otherwise the system may hang
+due to a Vim limitation (explained in :help win32-problems)
+>
+	let Tlist_Inc_Winwidth = 0
+<
+						*'Tlist_Max_Submenu_Items'*
+Tlist_Max_Submenu_Items~
+If a file contains too many tags of a particular type (function, variable,
+class, etc.), greater than that specified by the 'Tlist_Max_Submenu_Items'
+variable, then the menu for that tag type will be split into multiple
+sub-menus. The default setting for the 'Tlist_Max_Submenu_Items' variable is
+25.  This can be changed by setting the 'Tlist_Max_Submenu_Items' variable:
+>
+	let Tlist_Max_Submenu_Items = 20
+<
+The name of the submenu is formed using the names of the first and the last
+tag entries in that submenu.
+
+						*'Tlist_Max_Tag_Length'*
+Tlist_Max_Tag_Length~
+Only the first 'Tlist_Max_Tag_Length' characters from the tag names will be
+used to form the tag type submenu name. The default value for this variable is
+10.  Change the 'Tlist_Max_Tag_Length' setting if you want to include more or
+less characters:
+>
+	let Tlist_Max_Tag_Length = 10
+<
+						*'Tlist_Process_File_Always'*
+Tlist_Process_File_Always~
+By default, the taglist plugin will generate and process the tags defined in
+the newly opened files only when the taglist window is opened or when the
+taglist menu is enabled. When the taglist window is closed, the taglist plugin
+will stop processing the tags for newly opened files.
+
+You can set the 'Tlist_Process_File_Always' variable to 1 to generate the list
+of tags for new files even when the taglist window is closed and the taglist
+menu is disabled.
+>
+	let Tlist_Process_File_Always = 1
+<
+To use the ":TlistShowTag" and the ":TlistShowPrototype" commands without the
+taglist window and the taglist menu, you should set this variable to 1.
+
+						*'Tlist_Show_Menu'*
+Tlist_Show_Menu~
+When using GUI Vim, you can display the tags defined in the current file in a
+menu named "Tags". By default, this feature is turned off. To turn on this
+feature, set the 'Tlist_Show_Menu' variable to 1:
+>
+	let Tlist_Show_Menu = 1
+<
+						*'Tlist_Show_One_File'*
+Tlist_Show_One_File~
+By default, the taglist plugin will display the tags defined in all the loaded
+buffers in the taglist window. If you prefer to display the tags defined only
+in the current buffer, then you can set the 'Tlist_Show_One_File' to 1. When
+this variable is set to 1, as you switch between buffers, the taglist window
+will be refreshed to display the tags for the current buffer and the tags for
+the previous buffer will be removed.
+>
+	let Tlist_Show_One_File = 1
+<
+						*'Tlist_Sort_Type'*
+Tlist_Sort_Type~
+The 'Tlist_Sort_Type' variable specifies the sort order for the tags in the
+taglist window. The tags can be sorted either alphabetically by their name or
+by the order of their appearance in the file (chronological order). By
+default, the tag names will be listed by the order in which they are defined
+in the file. You can change the sort type (from name to order or from order to
+name) by pressing the "s" key in the taglist window. You can also change the
+default sort order by setting 'Tlist_Sort_Type' to "name" or "order":
+>
+	let Tlist_Sort_Type = "name"
+<
+						*'Tlist_Use_Horiz_Window'*
+Tlist_Use_Horiz_Window~
+Be default, the tag names are displayed in a vertically split window. If you
+prefer a horizontally split window, then set the 'Tlist_Use_Horiz_Window'
+variable to 1. If you are running MS-Windows version of Vim in a MS-DOS
+command window, then you should use a horizontally split window instead of a
+vertically split window. Also, if you are using an older version of xterm in a
+Unix system that doesn't support changing the xterm window width, you should
+use a horizontally split window.
+>
+	let Tlist_Use_Horiz_Window = 1
+<
+						*'Tlist_Use_Right_Window'*
+Tlist_Use_Right_Window~
+By default, the vertically split taglist window will appear on the left hand
+side. If you prefer to open the window on the right hand side, you can set the
+'Tlist_Use_Right_Window' variable to 1:
+>
+	let Tlist_Use_Right_Window = 1
+<
+						*'Tlist_Use_SingleClick'*
+Tlist_Use_SingleClick~
+By default, when you double click on the tag name using the left mouse 
+button, the cursor will be positioned at the definition of the tag. You 
+can set the 'Tlist_Use_SingleClick' variable to 1 to jump to a tag when
+you single click on the tag name using the mouse. By default this variable
+is set to zero.
+>
+	let Tlist_Use_SingleClick = 1
+<
+Due to a bug in Vim, if you set 'Tlist_Use_SingleClick' to 1 and try to resize
+the taglist window using the mouse, then Vim will crash. This problem is fixed
+in Vim 6.3 and above. In the meantime, instead of resizing the taglist window
+using the mouse, you can use normal Vim window resizing commands to resize the
+taglist window.
+
+						*'Tlist_WinHeight'*
+Tlist_WinHeight~
+The default height of the horizontally split taglist window is 10. This can be
+changed by modifying the 'Tlist_WinHeight' variable:
+>
+	let Tlist_WinHeight = 20
+<
+The |'winfixheight'| option is set for the taglist window, to maintain the
+height of the taglist window, when new Vim windows are opened and existing
+windows are closed.
+
+						*'Tlist_WinWidth'*
+Tlist_WinWidth~
+The default width of the vertically split taglist window is 30. This can be
+changed by modifying the 'Tlist_WinWidth' variable:
+>
+	let Tlist_WinWidth = 20
+<
+Note that the value of the |'winwidth'| option setting determines the minimum
+width of the current window. If you set the 'Tlist_WinWidth' variable to a
+value less than that of the |'winwidth'| option setting, then Vim will use the
+value of the |'winwidth'| option.
+
+When new Vim windows are opened and existing windows are closed, the taglist
+plugin will try to maintain the width of the taglist window to the size
+specified by the 'Tlist_WinWidth' variable.
+
+==============================================================================
+						*taglist-commands*
+7. Commands~
+
+The taglist plugin provides the following ex-mode commands:
+
+|:TlistAddFiles|	Add multiple files to the taglist.
+|:TlistAddFilesRecursive|
+			Add files recursively to the taglist.
+|:TlistClose|		Close the taglist window.
+|:TlistDebug|		Start logging of taglist debug messages.
+|:TlistLock|		Stop adding new files to the taglist.
+|:TlistMessages|	Display the logged taglist plugin debug messages.
+|:TlistOpen|		Open and jump to the taglist window.
+|:TlistSessionSave|	Save the information about files and tags in the
+			taglist to a session file.
+|:TlistSessionLoad|	Load the information about files and tags stored
+			in a session file to taglist.
+|:TlistShowPrototype|	Display the prototype of the tag at or before the
+		    	specified line number.
+|:TlistShowTag|		Display the name of the tag defined at or before the
+			specified line number.
+|:TlistHighlightTag|	Highlight the current tag in the taglist window.
+|:TlistToggle|		Open or close (toggle) the taglist window.
+|:TlistUndebug|		Stop logging of taglist debug messages.
+|:TlistUnlock|		Start adding new files to the taglist.
+|:TlistUpdate|		Update the tags for the current buffer.
+
+						*:TlistAddFiles*
+:TlistAddFiles {file(s)} [file(s) ...]
+		Add one or more specified files to the taglist. You can
+		specify multiple filenames using wildcards. To specify a
+		file name with space character, you should escape the space
+		character with a backslash.
+		Examples:
+>
+		    :TlistAddFiles *.c *.cpp
+		    :TlistAddFiles file1.html file2.html
+<
+		If you specify a large number of files, then it will take some
+		time for the taglist plugin to process all of them. The
+		specified files will not be edited in a Vim window and will
+		not be added to the Vim buffer list.
+
+						*:TlistAddFilesRecursive*
+:TlistAddFilesRecursive {directory} [ {pattern} ]
+		Add files matching {pattern} recursively from the specified
+		{directory} to the taglist. If {pattern} is not specified,
+		then '*' is assumed. To specify the current directory, use "."
+		for {directory}. To specify a directory name with space
+		character, you should escape the space character with a
+		backslash.
+		Examples:
+>
+		    :TlistAddFilesRecursive myproject *.java
+		    :TlistAddFilesRecursive smallproject
+<
+		If large number of files are present in the specified
+		directory tree, then it will take some time for the taglist
+		plugin to process all of them.
+
+						*:TlistClose*
+:TlistClose	Close the taglist window. This command can be used from any
+		one of the Vim windows.
+
+						*:TlistDebug*
+:TlistDebug [filename]
+		Start logging of debug messages from the taglist plugin.
+		If {filename} is specified, then the debug messages are stored
+		in the specified file. Otherwise, the debug messages are
+		stored in a script local variable. If the file {filename} is
+		already present, then it is overwritten.
+
+						*:TlistLock*
+:TlistLock
+		Lock the taglist and don't process new files. After this
+		command is executed, newly edited files will not be added to
+		the taglist.
+
+						*:TlistMessages*
+:TlistMessages
+		Display the logged debug messages from the taglist plugin
+		in a window.  This command works only when logging to a
+		script-local variable.
+
+						*:TlistOpen*
+:TlistOpen	Open and jump to the taglist window. Creates the taglist
+		window, if the window is not opened currently. After executing
+		this command, the cursor is moved to the taglist window.  When
+		the taglist window is opened for the first time, all the files
+		in the buffer list are processed and the tags defined in them
+		are displayed in the taglist window.
+
+						*:TlistSessionSave*
+:TlistSessionSave {filename}
+		Saves the information about files and tags in the taglist to
+		the specified file. This command can be used to save and
+		restore the taglist contents across Vim sessions.
+
+						*:TlistSessionLoad*
+:TlistSessionLoad {filename}
+		Load the information about files and tags stored in the
+		specified session file to the taglist.
+
+						*:TlistShowPrototype*
+:TlistShowPrototype [filename] [linenumber]
+		Display the prototype of the tag at or before the specified
+		line number. If the file name and the line number are not
+		specified, then the current file name and line number are
+		used. A tag spans multiple lines starting from the line where
+		it is defined to the line before the next tag. This command
+		displays the prototype for the tag for any line number in this
+		range. 
+
+						*:TlistShowTag*
+:TlistShowTag [filename] [linenumber]
+		Display the name of the tag defined at or before the specified
+		line number. If the file name and the line number are not
+		specified, then the current file name and line number are
+		used. A tag spans multiple lines starting from the line where
+		it is defined to the line before the next tag. This command
+		displays the tag name for any line number in this range. 
+
+						*:TlistHighlightTag*
+:TlistHighlightTag
+		Highlight the current tag in the taglist window. By default,
+		the taglist plugin periodically updates the taglist window to
+		highlight the current tag. This command can be used to force
+		the taglist plugin to highlight the current tag.
+
+						*:TlistToggle*
+:TlistToggle	Open or close (toggle) the taglist window. Opens the taglist
+		window, if the window is not opened currently. Closes the
+		taglist window, if the taglist window is already opened. When
+		the taglist window is opened for the first time, all the files
+		in the buffer list are processed and the tags are displayed in
+		the taglist window. After executing this command, the cursor
+		is not moved from the current window to the taglist window.
+
+						*:TlistUndebug*
+:TlistUndebug
+		Stop logging of debug messages from the taglist plugin.
+
+						*:TlistUnlock*
+:TlistUnlock
+		Unlock the taglist and start processing newly edited files.
+
+						*:TlistUpdate*
+:TlistUpdate	Update the tags information for the current buffer. This
+		command can be used to re-process the current file/buffer and
+		get the tags information. As the taglist plugin uses the file
+		saved in the disk (instead of the file displayed in a Vim
+		buffer), you should save a modified buffer before you update
+		the taglist. Otherwise the listed tags will not include the
+		new tags created in the buffer. You can use this command even
+		when the taglist window is not opened.
+
+==============================================================================
+						*taglist-functions*
+8. Global functions~
+
+The taglist plugin provides several global functions that can be used from
+other Vim plugins to interact with the taglist plugin. These functions are
+described below.
+
+|Tlist_Update_File_Tags()|		Update the tags for the specified file
+|Tlist_Get_Tag_Prototype_By_Line()|	Return the prototype of the tag at or
+				    	before the specified line number in the
+				    	specified file.
+|Tlist_Get_Tagname_By_Line()|		Return the name of the tag at or
+					before the specified line number in
+					the specified file.
+|Tlist_Set_App()|			Set the name of the application
+					controlling the taglist window.
+
+					    *Tlist_Update_File_Tags()*
+Tlist_Update_File_Tags({filename}, {filetype})
+		Update the tags for the file {filename}. The second argument
+		specifies the Vim filetype for the file. If the taglist plugin
+		has not processed the file previously, then the exuberant
+		ctags tool is invoked to generate the tags for the file.
+
+					    *Tlist_Get_Tag_Prototype_By_Line()*
+Tlist_Get_Tag_Prototype_By_Line([{filename}, {linenumber}])
+		Return the prototype of the tag at or before the specified
+		line number in the specified file. If the filename and line
+		number are not specified, then the current buffer name and the
+		current line number are used.
+
+					    *Tlist_Get_Tagname_By_Line()*
+Tlist_Get_Tagname_By_Line([{filename}, {linenumber}])
+		Return the name of the tag at or before the specified line
+		number in the specified file. If the filename and line number
+		are not specified, then the current buffer name and the
+		current line number are used.
+
+					    *Tlist_Set_App()*
+Tlist_Set_App({appname})
+		Set the name of the plugin that controls the taglist plugin
+		window and buffer. This can be used to integrate the taglist
+		plugin with other Vim plugins.
+		
+		For example, the winmanager plugin and the Cream package use
+		this function and specify the appname as "winmanager" and
+		"cream" respectively.
+		
+		By default, the taglist plugin is a stand-alone plugin and
+		controls the taglist window and buffer. If the taglist window
+		is controlled by an external plugin, then the appname should
+		be set appropriately.
+
+==============================================================================
+						*taglist-extend*
+9. Extending~
+
+The taglist plugin supports all the languages supported by the exuberant ctags
+tool, which includes the following languages: Assembly, ASP, Awk, Beta, C,
+C++, C#, Cobol, Eiffel, Erlang, Fortran, HTML, Java, Javascript, Lisp, Lua,
+Make, Pascal, Perl, PHP, Python, Rexx, Ruby, Scheme, Shell, Slang, SML, Sql,
+TCL, Verilog, Vim and Yacc.
+
+You can extend the taglist plugin to add support for new languages and also
+modify the support for the above listed languages.
+
+You should NOT make modifications to the taglist plugin script file to add
+support for new languages. You will lose these changes when you upgrade to the
+next version of the taglist plugin. Instead you should follow the below
+described instructions to extend the taglist plugin.
+
+You can extend the taglist plugin by setting variables in the .vimrc or _vimrc
+file. The name of these variables depends on the language name and is
+described below.
+
+Modifying support for an existing language~
+To modify the support for an already supported language, you have to set the
+tlist_xxx_settings variable in the ~/.vimrc or $HOME/_vimrc file. Replace xxx
+with the Vim filetype name for the language file.  For example, to modify the
+support for the perl language files, you have to set the tlist_perl_settings
+variable. To modify the support for java files, you have to set the
+tlist_java_settings variable.
+
+To determine the filetype name used by Vim for a file, use the following
+command in the buffer containing the file:
+
+	:set filetype
+
+The above command will display the Vim filetype for the current buffer.
+
+The format of the value set in the tlist_xxx_settings variable is
+
+    <language_name>;flag1:name1;flag2:name2;flag3:name3
+
+The different fields in the value are separated by the ';' character.
+
+The first field 'language_name' is the name used by exuberant ctags to refer
+to this language file. This name can be different from the file type name used
+by Vim. For example, for C++, the language name used by ctags is 'c++' but the
+filetype name used by Vim is 'cpp'. To get the list of language names
+supported by exuberant ctags, use the following command:
+
+	$ ctags --list-maps=all
+
+The remaining fields follow the format "flag:name". The sub-field 'flag' is
+the language specific flag used by exuberant ctags to generate the
+corresponding tags. For example, for the C language, to list only the
+functions, the 'f' flag is used. To get the list of flags supported by
+exuberant ctags for the various languages use the following command:
+
+	$ ctags --list-kinds=all
+
+The sub-field 'name' specifies the title text to use for displaying the tags
+of a particular type. For example, 'name' can be set to 'functions'. This
+field can be set to any text string name.
+
+For example, to list only the classes and functions defined in a C++ language
+file, add the following line to your .vimrc file:
+
+	let tlist_cpp_settings = 'c++;c:class;f:function'
+
+In the above setting, 'cpp' is the Vim filetype name and 'c++' is the name
+used by the exuberant ctags tool. 'c' and 'f' are the flags passed to
+exuberant ctags to list C++ classes and functions and 'class' is the title
+used for the class tags and 'function' is the title used for the function tags
+in the taglist window.
+
+For example, to display only functions defined in a C file and to use "My
+Functions" as the title for the function tags, use
+
+	let tlist_c_settings = 'c;f:My Functions'
+
+When you set the tlist_xxx_settings variable, you will override the default
+setting used by the taglist plugin for the 'xxx' language. You cannot add to
+the default options used by the taglist plugin for a particular file type. To
+add to the options used by the taglist plugin for a language, copy the option
+values from the taglist plugin file to your .vimrc file and modify it.
+
+Adding support for a new language~
+If you want to add support for a new language to the taglist plugin, you need
+to first extend the exuberant ctags tool. For more information about extending
+exuberant ctags, visit the following page:
+
+    http://ctags.sourceforge.net/EXTENDING.html
+
+To add support for a new language, set the tlist_xxx_settings variable in the
+~/.vimrc file appropriately as described above. Replace 'xxx' in the variable
+name with the Vim filetype name for the new language.
+
+For example, to extend the taglist plugin to support the latex language, you
+can use the following line (assuming, you have already extended exuberant
+ctags to support the latex language):
+
+	let tlist_tex_settings='latex;b:bibitem;c:command;l:label'
+
+With the above line, when you edit files of filetype "tex" in Vim, the taglist
+plugin will invoke the exuberant ctags tool passing the "latex" filetype and
+the flags b, c and l to generate the tags. The text heading 'bibitem',
+'command' and 'label' will be used in the taglist window for the tags which
+are generated for the flags b, c and l respectively.
+
+==============================================================================
+						*taglist-faq*
+10. Frequently Asked Questions~
+
+Q. The taglist plugin doesn't work. The taglist window is empty and the tags
+   defined in a file are not displayed. 
+A. Are you using Vim version 6.0 and above? The taglist plugin relies on the
+   features supported by Vim version 6.0 and above. You can use the following
+   command to get the Vim version:
+>
+	$ vim --version
+<
+   Are you using exuberant ctags version 5.0 and above? The taglist plugin
+   relies on the features supported by exuberant ctags and will not work with
+   GNU ctags or the Unix ctags utility. You can use the following command to
+   determine whether the ctags installed in your system is exuberant ctags:
+>
+	$ ctags --version
+<
+   Is exuberant ctags present in one of the directories in your PATH? If not,
+   you need to set the Tlist_Ctags_Cmd variable to point to the location of
+   exuberant ctags. Use the following Vim command to verify that this is setup
+   correctly:
+>
+	:echo system(Tlist_Ctags_Cmd . ' --version')
+<
+   The above command should display the version information for exuberant
+   ctags.
+
+   Did you turn on the Vim filetype detection? The taglist plugin relies on
+   the filetype detected by Vim and passes the filetype to the exuberant ctags
+   utility to parse the tags. Check the output of the following Vim command:
+>
+	:filetype
+<
+   The output of the above command should contain "filetype detection:ON".
+   To turn on the filetype detection, add the following line to the .vimrc or
+   _vimrc file:
+>
+	filetype on
+<
+   Is your version of Vim compiled with the support for the system() function?
+   The following Vim command should display 1:
+>
+	:echo exists('*system')
+<
+   In some Linux distributions (particularly Suse Linux), the default Vim
+   installation is built without the support for the system() function. The
+   taglist plugin uses the system() function to invoke the exuberant ctags
+   utility. You need to rebuild Vim after enabling the support for the
+   system() function. If you use the default build options, the system()
+   function will be supported. 
+
+   Do you have the |'shellslash'| option set? You can try disabling the
+   |'shellslash'| option. When the taglist plugin invokes the exuberant ctags
+   utility with the path to the file, if the incorrect slashes are used, then
+   you will see errors.
+   
+   Check the shell related Vim options values using the following command:
+>
+	:set shell? shellcmdflag? shellpipe?
+	:set shellquote? shellredir? shellxquote?
+<
+   If these options are set in your .vimrc or _vimrc file, try removing those
+   lines.
+
+   Are you using a Unix shell in a MS-Windows environment? For example,
+   the Unix shell from the MKS-toolkit. Do you have the SHELL environment
+   set to point to this shell? You can try resetting the SHELL environment
+   variable.
+
+   If you are using a Unix shell on MS-Windows, you should try to use
+   exuberant ctags that is compiled for Unix-like environments so that
+   exuberant ctags will understand path names with forward slash characters.
+
+   Is your filetype supported by the exuberant ctags utility? The file types
+   supported by the exuberant ctags utility are listed in the ctags help. If a
+   file type is not supported, you have to extend exuberant ctags. You can use
+   the following command to list the filetypes supported by exuberant ctags:
+>
+	ctags --list-languages
+<
+   Run the following command from the shell prompt and check whether the tags
+   defined in your file are listed in the output from exuberant ctags:
+>
+	ctags -f - --format=2 --excmd=pattern --fields=nks <filename>
+<
+   If you see your tags in the output from the above command, then the
+   exuberant ctags utility is properly parsing your file.
+
+   Do you have the .ctags or _ctags or the ctags.cnf file in your home
+   directory for specifying default options or for extending exuberant ctags?
+   If you do have this file, check the options in this file and make sure
+   these options are not interfering with the operation of the taglist plugin.
+
+   If you are using MS-Windows, check the value of the TEMP and TMP
+   environment variables. If these environment variables are set to a path
+   with space characters in the name, then try using the DOS 8.3 short name
+   for the path or set them to a path without the space characters in the
+   name. For example, if the temporary directory name is "C:\Documents and
+   Settings\xyz\Local Settings\Temp", then try setting the TEMP variable to
+   the following:
+>
+	set TEMP=C:\DOCUMEN~1\xyz\LOCALS~1\Temp
+<
+   If exuberant ctags is installed in a directory with space characters in the
+   name, then try adding the directory to the PATH environment variable or try
+   setting the 'Tlist_Ctags_Cmd' variable to the shortest path name to ctags
+   or try copying the exuberant ctags to a path without space characters in
+   the name. For example, if exuberant ctags is installed in the directory
+   "C:\Program Files\Ctags", then try setting the 'Tlist_Ctags_Cmd' variable
+   as below:
+>
+	let Tlist_Ctags_Cmd='C:\Progra~1\Ctags\ctags.exe'
+<
+   If you are using a cygwin compiled version of exuberant ctags on MS-Windows,
+   make sure that either you have the cygwin compiled sort utility installed
+   and available in your PATH or compile exuberant ctags with internal sort
+   support. Otherwise, when exuberant ctags sorts the tags output by invoking
+   the sort utility, it may end up invoking the MS-Windows version of
+   sort.exe, thereby resulting in failure.
+
+Q. When I try to open the taglist window, I am seeing the following error
+   message. How do I fix this problem?
+
+   Taglist: Failed to generate tags for /my/path/to/file
+   ctags: illegal option -- -^@usage: ctags [-BFadtuwvx] [-f tagsfile] file ...
+
+A. The taglist plugin will work only with the exuberant ctags tool. You
+   cannot use the GNU ctags or the Unix ctags program with the taglist plugin.
+   You will see an error message similar to the one shown above, if you try
+   use a non-exuberant ctags program with Vim. To fix this problem, either add
+   the exuberant ctags tool location to the PATH environment variable or set
+   the 'Tlist_Ctags_Cmd' variable.
+
+Q. A file has more than one tag with the same name. When I select a tag name
+   from the taglist window, the cursor is positioned at the incorrect tag
+   location. 
+A. The taglist plugin uses the search pattern generated by the exuberant ctags
+   utility to position the cursor at the location of a tag definition. If a
+   file has more than one tag with the same name and same prototype, then the
+   search pattern will be the same. In this case, when searching for the tag
+   pattern, the cursor may be positioned at the incorrect location. 
+
+Q. I have made some modifications to my file and introduced new
+   functions/classes/variables. I have not yet saved my file. The taglist
+   plugin is not displaying the new tags when I update the taglist window.
+A. The exuberant ctags utility will process only files that are present in the
+   disk. To list the tags defined in a file, you have to save the file and
+   then update the taglist window. 
+
+Q. I have created a ctags file using the exuberant ctags utility for my source
+   tree. How do I configure the taglist plugin to use this tags file? 
+A. The taglist plugin doesn't use a tags file stored in disk. For every opened
+   file, the taglist plugin invokes the exuberant ctags utility to get the
+   list of tags dynamically. The Vim system() function is used to invoke
+   exuberant ctags and get the ctags output. This function internally uses a
+   temporary file to store the output. This file is deleted after the output
+   from the command is read. So you will never see the file that contains the
+   output of exuberant ctags.
+
+Q. When I set the |'updatetime'| option to a low value (less than 1000) and if
+   I keep pressing a key with the taglist window open, the current buffer
+   contents are changed. Why is this?
+A. The taglist plugin uses the |CursorHold| autocmd to highlight the current
+   tag. The CursorHold autocmd triggers for every |'updatetime'| milliseconds.
+   If the |'updatetime'| option is set to a low value, then the CursorHold
+   autocmd will be triggered frequently. As the taglist plugin changes
+   the focus to the taglist window to highlight the current tag, this could
+   interfere with the key movement resulting in changing the contents of
+   the current buffer. The workaround for this problem is to not set the
+   |'updatetime'| option to a low value.
+
+==============================================================================
+						*taglist-license*
+11. License~
+Permission is hereby granted to use and distribute the taglist plugin, with or
+without modifications, provided that this copyright notice is copied with it.
+Like anything else that's free, taglist.vim is provided *as is* and comes with
+no warranty of any kind, either expressed or implied. In no event will the
+copyright holder be liable for any damamges resulting from the use of this
+software.
+
+==============================================================================
+						*taglist-todo*
+12. Todo~
+
+1. Group tags according to the scope and display them. For example,
+   group all the tags belonging to a C++/Java class 
+2. Support for displaying tags in a modified (not-yet-saved) file. 
+3. Automatically open the taglist window only for selected filetypes.
+   For other filetypes, close the taglist window. 
+4. When using the shell from the MKS toolkit, the taglist plugin 
+   doesn't work.
+5. The taglist plugin doesn't work with files edited remotely using the
+   netrw plugin. The exuberant ctags utility cannot process files over
+   scp/rcp/ftp, etc.
+
+==============================================================================
+
+vim:tw=78:ts=8:noet:ft=help:
diff --git a/vimrc/.vim/doc/tags b/vimrc/.vim/doc/tags
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/doc/tags
@@ -0,0 +1,153 @@
+'Tlist_Auto_Highlight_Tag'	taglist-plus.txt	/*'Tlist_Auto_Highlight_Tag'*
+'Tlist_Auto_Highlight_Tag'	taglist.txt	/*'Tlist_Auto_Highlight_Tag'*
+'Tlist_Auto_Open'	taglist-plus.txt	/*'Tlist_Auto_Open'*
+'Tlist_Auto_Open'	taglist.txt	/*'Tlist_Auto_Open'*
+'Tlist_Auto_Update'	taglist-plus.txt	/*'Tlist_Auto_Update'*
+'Tlist_Auto_Update'	taglist.txt	/*'Tlist_Auto_Update'*
+'Tlist_Close_On_Select'	taglist-plus.txt	/*'Tlist_Close_On_Select'*
+'Tlist_Close_On_Select'	taglist.txt	/*'Tlist_Close_On_Select'*
+'Tlist_Compact_Format'	taglist-plus.txt	/*'Tlist_Compact_Format'*
+'Tlist_Compact_Format'	taglist.txt	/*'Tlist_Compact_Format'*
+'Tlist_Ctags_Cmd'	taglist-plus.txt	/*'Tlist_Ctags_Cmd'*
+'Tlist_Ctags_Cmd'	taglist.txt	/*'Tlist_Ctags_Cmd'*
+'Tlist_Display_Prototype'	taglist-plus.txt	/*'Tlist_Display_Prototype'*
+'Tlist_Display_Prototype'	taglist.txt	/*'Tlist_Display_Prototype'*
+'Tlist_Display_Tag_Scope'	taglist-plus.txt	/*'Tlist_Display_Tag_Scope'*
+'Tlist_Display_Tag_Scope'	taglist.txt	/*'Tlist_Display_Tag_Scope'*
+'Tlist_Enable_Fold_Column'	taglist-plus.txt	/*'Tlist_Enable_Fold_Column'*
+'Tlist_Enable_Fold_Column'	taglist.txt	/*'Tlist_Enable_Fold_Column'*
+'Tlist_Exit_OnlyWindow'	taglist-plus.txt	/*'Tlist_Exit_OnlyWindow'*
+'Tlist_Exit_OnlyWindow'	taglist.txt	/*'Tlist_Exit_OnlyWindow'*
+'Tlist_File_Fold_Auto_Close'	taglist-plus.txt	/*'Tlist_File_Fold_Auto_Close'*
+'Tlist_File_Fold_Auto_Close'	taglist.txt	/*'Tlist_File_Fold_Auto_Close'*
+'Tlist_GainFocus_On_ToggleOpen'	taglist-plus.txt	/*'Tlist_GainFocus_On_ToggleOpen'*
+'Tlist_GainFocus_On_ToggleOpen'	taglist.txt	/*'Tlist_GainFocus_On_ToggleOpen'*
+'Tlist_Highlight_Tag_On_BufEnter'	taglist-plus.txt	/*'Tlist_Highlight_Tag_On_BufEnter'*
+'Tlist_Highlight_Tag_On_BufEnter'	taglist.txt	/*'Tlist_Highlight_Tag_On_BufEnter'*
+'Tlist_Inc_Winwidth'	taglist-plus.txt	/*'Tlist_Inc_Winwidth'*
+'Tlist_Inc_Winwidth'	taglist.txt	/*'Tlist_Inc_Winwidth'*
+'Tlist_Max_Submenu_Items'	taglist-plus.txt	/*'Tlist_Max_Submenu_Items'*
+'Tlist_Max_Submenu_Items'	taglist.txt	/*'Tlist_Max_Submenu_Items'*
+'Tlist_Max_Tag_Length'	taglist-plus.txt	/*'Tlist_Max_Tag_Length'*
+'Tlist_Max_Tag_Length'	taglist.txt	/*'Tlist_Max_Tag_Length'*
+'Tlist_Process_File_Always'	taglist-plus.txt	/*'Tlist_Process_File_Always'*
+'Tlist_Process_File_Always'	taglist.txt	/*'Tlist_Process_File_Always'*
+'Tlist_Show_Menu'	taglist-plus.txt	/*'Tlist_Show_Menu'*
+'Tlist_Show_Menu'	taglist.txt	/*'Tlist_Show_Menu'*
+'Tlist_Show_One_File'	taglist-plus.txt	/*'Tlist_Show_One_File'*
+'Tlist_Show_One_File'	taglist.txt	/*'Tlist_Show_One_File'*
+'Tlist_Sort_Type'	taglist-plus.txt	/*'Tlist_Sort_Type'*
+'Tlist_Sort_Type'	taglist.txt	/*'Tlist_Sort_Type'*
+'Tlist_Use_Horiz_Window'	taglist-plus.txt	/*'Tlist_Use_Horiz_Window'*
+'Tlist_Use_Horiz_Window'	taglist.txt	/*'Tlist_Use_Horiz_Window'*
+'Tlist_Use_Right_Window'	taglist-plus.txt	/*'Tlist_Use_Right_Window'*
+'Tlist_Use_Right_Window'	taglist.txt	/*'Tlist_Use_Right_Window'*
+'Tlist_Use_SingleClick'	taglist-plus.txt	/*'Tlist_Use_SingleClick'*
+'Tlist_Use_SingleClick'	taglist.txt	/*'Tlist_Use_SingleClick'*
+'Tlist_WinHeight'	taglist-plus.txt	/*'Tlist_WinHeight'*
+'Tlist_WinHeight'	taglist.txt	/*'Tlist_WinHeight'*
+'Tlist_WinWidth'	taglist-plus.txt	/*'Tlist_WinWidth'*
+'Tlist_WinWidth'	taglist.txt	/*'Tlist_WinWidth'*
+'Tlist_javascript_Hide_Extras'	taglist-plus.txt	/*'Tlist_javascript_Hide_Extras'*
+:TlistAddFiles	taglist-plus.txt	/*:TlistAddFiles*
+:TlistAddFiles	taglist.txt	/*:TlistAddFiles*
+:TlistAddFilesRecursive	taglist-plus.txt	/*:TlistAddFilesRecursive*
+:TlistAddFilesRecursive	taglist.txt	/*:TlistAddFilesRecursive*
+:TlistClose	taglist-plus.txt	/*:TlistClose*
+:TlistClose	taglist.txt	/*:TlistClose*
+:TlistDebug	taglist-plus.txt	/*:TlistDebug*
+:TlistDebug	taglist.txt	/*:TlistDebug*
+:TlistHighlightTag	taglist-plus.txt	/*:TlistHighlightTag*
+:TlistHighlightTag	taglist.txt	/*:TlistHighlightTag*
+:TlistLock	taglist-plus.txt	/*:TlistLock*
+:TlistLock	taglist.txt	/*:TlistLock*
+:TlistMessages	taglist-plus.txt	/*:TlistMessages*
+:TlistMessages	taglist.txt	/*:TlistMessages*
+:TlistOpen	taglist-plus.txt	/*:TlistOpen*
+:TlistOpen	taglist.txt	/*:TlistOpen*
+:TlistSessionLoad	taglist-plus.txt	/*:TlistSessionLoad*
+:TlistSessionLoad	taglist.txt	/*:TlistSessionLoad*
+:TlistSessionSave	taglist-plus.txt	/*:TlistSessionSave*
+:TlistSessionSave	taglist.txt	/*:TlistSessionSave*
+:TlistShowPrototype	taglist-plus.txt	/*:TlistShowPrototype*
+:TlistShowPrototype	taglist.txt	/*:TlistShowPrototype*
+:TlistShowTag	taglist-plus.txt	/*:TlistShowTag*
+:TlistShowTag	taglist.txt	/*:TlistShowTag*
+:TlistToggle	taglist-plus.txt	/*:TlistToggle*
+:TlistToggle	taglist.txt	/*:TlistToggle*
+:TlistUndebug	taglist-plus.txt	/*:TlistUndebug*
+:TlistUndebug	taglist.txt	/*:TlistUndebug*
+:TlistUnlock	taglist-plus.txt	/*:TlistUnlock*
+:TlistUnlock	taglist.txt	/*:TlistUnlock*
+:TlistUpdate	taglist-plus.txt	/*:TlistUpdate*
+:TlistUpdate	taglist.txt	/*:TlistUpdate*
+SQLUtilities.txt	SQLUtilities.txt	/*SQLUtilities.txt*
+Tlist_Get_Tag_Prototype_By_Line()	taglist-plus.txt	/*Tlist_Get_Tag_Prototype_By_Line()*
+Tlist_Get_Tag_Prototype_By_Line()	taglist.txt	/*Tlist_Get_Tag_Prototype_By_Line()*
+Tlist_Get_Tagname_By_Line()	taglist-plus.txt	/*Tlist_Get_Tagname_By_Line()*
+Tlist_Get_Tagname_By_Line()	taglist.txt	/*Tlist_Get_Tagname_By_Line()*
+Tlist_Set_App()	taglist-plus.txt	/*Tlist_Set_App()*
+Tlist_Set_App()	taglist.txt	/*Tlist_Set_App()*
+Tlist_Update_File_Tags()	taglist-plus.txt	/*Tlist_Update_File_Tags()*
+Tlist_Update_File_Tags()	taglist.txt	/*Tlist_Update_File_Tags()*
+sqlutil	SQLUtilities.txt	/*sqlutil*
+sqlutil-align-comma	SQLUtilities.txt	/*sqlutil-align-comma*
+sqlutil-align-first-word	SQLUtilities.txt	/*sqlutil-align-first-word*
+sqlutil-align-keyword-right	SQLUtilities.txt	/*sqlutil-align-keyword-right*
+sqlutil-align-where	SQLUtilities.txt	/*sqlutil-align-where*
+sqlutil-change_keyword-case	SQLUtilities.txt	/*sqlutil-change_keyword-case*
+sqlutil-column-datatype	SQLUtilities.txt	/*sqlutil-column-datatype*
+sqlutil-column-definition	SQLUtilities.txt	/*sqlutil-column-definition*
+sqlutil-column-list	SQLUtilities.txt	/*sqlutil-column-list*
+sqlutil-commands	SQLUtilities.txt	/*sqlutil-commands*
+sqlutil-complementary-plugins	SQLUtilities.txt	/*sqlutil-complementary-plugins*
+sqlutil-contents	SQLUtilities.txt	/*sqlutil-contents*
+sqlutil-customization	SQLUtilities.txt	/*sqlutil-customization*
+sqlutil-dependencies	SQLUtilities.txt	/*sqlutil-dependencies*
+sqlutil-examples	SQLUtilities.txt	/*sqlutil-examples*
+sqlutil-format-options	SQLUtilities.txt	/*sqlutil-format-options*
+sqlutil-formatter	SQLUtilities.txt	/*sqlutil-formatter*
+sqlutil-history	SQLUtilities.txt	/*sqlutil-history*
+sqlutil-indent_nested	SQLUtilities.txt	/*sqlutil-indent_nested*
+sqlutil-mappings	SQLUtilities.txt	/*sqlutil-mappings*
+sqlutil-options	SQLUtilities.txt	/*sqlutil-options*
+sqlutil-procedure	SQLUtilities.txt	/*sqlutil-procedure*
+sqlutil-split_unbalanced-paran	SQLUtilities.txt	/*sqlutil-split_unbalanced-paran*
+sqlutil-todo	SQLUtilities.txt	/*sqlutil-todo*
+sqlutil-tutorial	SQLUtilities.txt	/*sqlutil-tutorial*
+sqlutil-wrap-function-calls	SQLUtilities.txt	/*sqlutil-wrap-function-calls*
+sqlutil-wrap-long-lines	SQLUtilities.txt	/*sqlutil-wrap-long-lines*
+sqlutil-wrap-wdith	SQLUtilities.txt	/*sqlutil-wrap-wdith*
+taglist-commands	taglist-plus.txt	/*taglist-commands*
+taglist-commands	taglist.txt	/*taglist-commands*
+taglist-debug	taglist-plus.txt	/*taglist-debug*
+taglist-debug	taglist.txt	/*taglist-debug*
+taglist-extend	taglist-plus.txt	/*taglist-extend*
+taglist-extend	taglist.txt	/*taglist-extend*
+taglist-faq	taglist-plus.txt	/*taglist-faq*
+taglist-faq	taglist.txt	/*taglist-faq*
+taglist-functions	taglist-plus.txt	/*taglist-functions*
+taglist-functions	taglist.txt	/*taglist-functions*
+taglist-install	taglist-plus.txt	/*taglist-install*
+taglist-install	taglist.txt	/*taglist-install*
+taglist-internet	taglist.txt	/*taglist-internet*
+taglist-intro	taglist-plus.txt	/*taglist-intro*
+taglist-intro	taglist.txt	/*taglist-intro*
+taglist-keys	taglist-plus.txt	/*taglist-keys*
+taglist-keys	taglist.txt	/*taglist-keys*
+taglist-license	taglist-plus.txt	/*taglist-license*
+taglist-license	taglist.txt	/*taglist-license*
+taglist-menu	taglist-plus.txt	/*taglist-menu*
+taglist-menu	taglist.txt	/*taglist-menu*
+taglist-options	taglist-plus.txt	/*taglist-options*
+taglist-options	taglist.txt	/*taglist-options*
+taglist-plus.txt	taglist-plus.txt	/*taglist-plus.txt*
+taglist-requirements	taglist-plus.txt	/*taglist-requirements*
+taglist-requirements	taglist.txt	/*taglist-requirements*
+taglist-session	taglist-plus.txt	/*taglist-session*
+taglist-session	taglist.txt	/*taglist-session*
+taglist-todo	taglist-plus.txt	/*taglist-todo*
+taglist-todo	taglist.txt	/*taglist-todo*
+taglist-using	taglist-plus.txt	/*taglist-using*
+taglist-using	taglist.txt	/*taglist-using*
+taglist.txt	taglist.txt	/*taglist.txt*
diff --git a/vimrc/.vim/file_line.vim b/vimrc/.vim/file_line.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/file_line.vim
@@ -0,0 +1,47 @@
+" Avoid installing twice or when in unsupported Vim version.
+if exists('g:loaded_file_line') || (v:version < 700)
+	finish
+endif
+let g:loaded_file_line = 1
+
+function! s:gotoline()
+	let file = bufname("%")
+
+	" :e command calls BufRead even though the file is a new one.
+	" As a workarround Jonas Pfenniger<jonas@pfenniger.name> added an
+	" AutoCmd BufRead, this will test if this file actually exists before
+	" searching for a file and line to goto.
+	if (filereadable(file))
+		return
+	endif
+
+	" Accept file:line:column: or file:line:column and file:line also
+	let names =  matchlist( file, '\(.\{-1,}\):\%(\(\d\+\)\%(:\(\d*\):\?\)\?\)\?$')
+
+	if empty(names)
+		return
+	endif
+
+	let file_name = names[1]
+	let line_num  = names[2] == ''? '0' : names[2]
+	let  col_num  = names[3] == ''? '0' : names[3]
+
+	if filereadable(file_name)
+		let l:bufn = bufnr("%")
+		exec ":bwipeout " l:bufn
+
+		exec "keepalt edit " . file_name
+		exec ":" . line_num
+		exec "normal! " . col_num . '|'
+		if foldlevel(line_num) > 0
+			exec "normal! zv"
+		endif
+
+
+		exec "normal! zz"
+	endif
+
+endfunction
+
+autocmd! BufNewFile *:* nested call s:gotoline()
+autocmd! BufRead *:* nested call s:gotoline()
diff --git a/vimrc/.vim/ftdetect/cql.vim b/vimrc/.vim/ftdetect/cql.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/ftdetect/cql.vim
@@ -0,0 +1,3 @@
+if has("autocmd")
+  au  BufNewFile,BufRead *.cql set filetype=cql
+endif
diff --git a/vimrc/.vim/ftdetect/json.vim b/vimrc/.vim/ftdetect/json.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/ftdetect/json.vim
@@ -0,0 +1,2 @@
+autocmd BufNewFile,BufRead *.json set filetype=json
+autocmd BufNewFile,BufRead *.jsonp set filetype=json
diff --git a/vimrc/.vim/ftdetect/swift.vim b/vimrc/.vim/ftdetect/swift.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/ftdetect/swift.vim
@@ -0,0 +1,12 @@
+autocmd BufNewFile,BufRead *.swift set filetype=swift
+autocmd BufRead * call s:Swift()
+function! s:Swift()
+  if !empty(&filetype)
+    return
+  endif
+
+  let line = getline(1)
+  if line =~ "^#!.*swift"
+    setfiletype swift
+  endif
+endfunction
diff --git a/vimrc/.vim/ftplugin/java.vim b/vimrc/.vim/ftplugin/java.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/ftplugin/java.vim
@@ -0,0 +1,8 @@
+fun! JavaCodeFormatter()
+  let s:hostname = substitute(system("hostname"), '\n', '', '')
+  if s:hostname == ".local"
+    let &formatprg = "~/eclipse/jee-mars/Eclipse.app/Contents/MacOS/eclipse -nosplash -application org.eclipse.jdt.core.JavaCodeFormatter -quiet -config ~/loadrc/vimrc/.vim/ftplugin/org.eclipse.jdt.core.prefs " . '"' . expand('%:p') . '"'
+    exe "!".&formatprg
+  endif
+endfunction
+au! BufWritePost <buffer> call JavaCodeFormatter()
diff --git a/vimrc/.vim/ftplugin/json.vim b/vimrc/.vim/ftplugin/json.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/ftplugin/json.vim
@@ -0,0 +1,38 @@
+" Vim syntax file
+" Language:	JSON
+" Maintainer:	Eli Parra <eli@elzr.com> https://github.com/elzr/vim-json
+" Last Change:	2014-05-20 added warning toggle
+
+"uncomment to enable folding of `{...}` and `[...]` blocks
+setlocal foldmethod=syntax
+
+"conceal by default
+if !exists("g:vim_json_syntax_conceal")
+	let g:vim_json_syntax_conceal = 1
+end
+
+"have warnings by default
+if !exists("g:vim_json_warnings")
+	let g:vim_json_warnings = 1
+end
+
+"set concealcursor blank by default
+"this should turn off the concealing in the current line (where the cursor is at),
+"on all modes (normal, visual, insert)
+if !exists("g:vim_json_syntax_concealcursor")
+	let g:vim_json_syntax_concealcursor = ""
+end
+
+if has('conceal')
+	if (g:vim_json_syntax_conceal == 1)
+		"level 2 means concealed text gets completely hidden unless a
+		"replacement is defined (none is defined by us)
+		setlocal conceallevel=2
+		let &l:concealcursor = g:vim_json_syntax_concealcursor
+	else
+		"level 0 means text is shown normally = no concealing
+		setlocal conceallevel=0
+	endif
+	"maybe g:vim_json_syntax_conceal could be settable to 0,1,2 to map
+	"directly to vim's conceallevels? unsure if anyone cares
+endif
diff --git a/vimrc/.vim/ftplugin/org.eclipse.jdt.core.prefs b/vimrc/.vim/ftplugin/org.eclipse.jdt.core.prefs
new file mode 100755
--- /dev/null
+++ ./vimrc/.vim/ftplugin/org.eclipse.jdt.core.prefs
@@ -0,0 +1,5 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.8
+org.eclipse.jdt.core.compiler.compliance=1.8
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=warning
+org.eclipse.jdt.core.compiler.source=1.8
diff --git a/vimrc/.vim/indent/json.vim b/vimrc/.vim/indent/json.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/indent/json.vim
@@ -0,0 +1,169 @@
+" Vim indent file
+" Language:		JSON
+" Mantainer:		Eli Parra <eli@elzr.com> https://github.com/elzr/vim-json
+" Last Change:          2014-05-13: merged Fix for square bracket matching by Jakar 
+"   https://github.com/jakar/vim-json/commit/20b650e22aa750c4ab6a66aa646bdd95d7cd548a#diff-e81fc111b2052e306d126bd9989f7b7c
+" Original Author:	Rogerz Zhang <rogerz.zhang at gmail.com> http://github.com/rogerz/vim-json
+" Acknowledgement:      Based off of vim-javascript maintained by Darrick Wiebe 
+"                       http://www.vim.org/scripts/script.php?script_id=2765
+
+" 0. Initialization {{{1
+" =================
+
+" Only load this indent file when no other was loaded.
+if exists("b:did_indent")
+  finish
+endif
+let b:did_indent = 1
+
+setlocal nosmartindent
+
+" Now, set up our indentation expression and keys that trigger it.
+setlocal indentexpr=GetJSONIndent()
+setlocal indentkeys=0{,0},0),0[,0],!^F,o,O,e
+
+" Only define the function once.
+if exists("*GetJSONIndent")
+  finish
+endif
+
+let s:cpo_save = &cpo
+set cpo&vim
+
+" 1. Variables {{{1
+" ============
+
+let s:line_term = '\s*\%(\%(\/\/\).*\)\=$'
+" Regex that defines blocks.
+let s:block_regex = '\%({\)\s*\%(|\%([*@]\=\h\w*,\=\s*\)\%(,\s*[*@]\=\h\w*\)*|\)\=' . s:line_term
+
+" 2. Auxiliary Functions {{{1
+" ======================
+
+" Check if the character at lnum:col is inside a string.
+function s:IsInString(lnum, col)
+  return synIDattr(synID(a:lnum, a:col, 1), 'name') == jsonString
+endfunction
+
+" Find line above 'lnum' that isn't empty, or in a string.
+function s:PrevNonBlankNonString(lnum)
+  let lnum = prevnonblank(a:lnum)
+  while lnum > 0
+    " If the line isn't empty or in a string, end search.
+    let line = getline(lnum)
+    if !(s:IsInString(lnum, 1) && s:IsInString(lnum, strlen(line)))
+      break
+    endif
+    let lnum = prevnonblank(lnum - 1)
+  endwhile
+  return lnum
+endfunction
+
+" Check if line 'lnum' has more opening brackets than closing ones.
+function s:LineHasOpeningBrackets(lnum)
+  let open_0 = 0
+  let open_2 = 0
+  let open_4 = 0
+  let line = getline(a:lnum)
+  let pos = match(line, '[][(){}]', 0)
+  while pos != -1
+    let idx = stridx('(){}[]', line[pos])
+    if idx % 2 == 0
+      let open_{idx} = open_{idx} + 1
+    else
+      let open_{idx - 1} = open_{idx - 1} - 1
+    endif
+    let pos = match(line, '[][(){}]', pos + 1)
+  endwhile
+  return (open_0 > 0) . (open_2 > 0) . (open_4 > 0)
+endfunction
+
+function s:Match(lnum, regex)
+  let col = match(getline(a:lnum), a:regex) + 1
+  return col > 0 && !s:IsInString(a:lnum, col) ? col : 0
+endfunction
+
+" 3. GetJSONIndent Function {{{1
+" =========================
+
+function GetJSONIndent()
+  " 3.1. Setup {{{2
+  " ----------
+
+  " Set up variables for restoring position in file.  Could use v:lnum here.
+  let vcol = col('.')
+
+  " 3.2. Work on the current line {{{2
+  " -----------------------------
+
+  " Get the current line.
+  let line = getline(v:lnum)
+  let ind = -1
+
+  " If we got a closing bracket on an empty line, find its match and indent
+  " according to it.
+  let col = matchend(line, '^\s*[]}]')
+
+  if col > 0 && !s:IsInString(v:lnum, col)
+    call cursor(v:lnum, col)
+    let bs = strpart('{}[]', stridx('}]', line[col - 1]) * 2, 2)
+
+    let pairstart = escape(bs[0], '[')
+    let pairend = escape(bs[1], ']')
+    let pairline = searchpair(pairstart, '', pairend, 'bW')
+
+    if pairline > 0 
+      let ind = indent(pairline)
+    else
+      let ind = virtcol('.') - 1
+    endif
+
+    return ind
+  endif
+
+  " If we are in a multi-line string, don't do anything to it.
+  if s:IsInString(v:lnum, matchend(line, '^\s*') + 1)
+    return indent('.')
+  endif
+
+  " 3.3. Work on the previous line. {{{2
+  " -------------------------------
+
+  let lnum = prevnonblank(v:lnum - 1)
+
+  if lnum == 0
+    return 0
+  endif
+
+  " Set up variables for current line.
+  let line = getline(lnum)
+  let ind = indent(lnum)
+
+  " If the previous line ended with a block opening, add a level of indent.
+  " if s:Match(lnum, s:block_regex)
+    " return indent(lnum) + &sw
+  " endif
+
+  " If the previous line contained an opening bracket, and we are still in it,
+  " add indent depending on the bracket type.
+  if line =~ '[[({]'
+    let counts = s:LineHasOpeningBrackets(lnum)
+    if counts[0] == '1' || counts[1] == '1' || counts[2] == '1'
+      return ind + &sw
+    else
+      call cursor(v:lnum, vcol)
+    end
+  endif
+
+  " }}}2
+
+  return ind
+endfunction
+
+" }}}1
+
+let &cpo = s:cpo_save
+unlet s:cpo_save
+
+" vim:set sw=2 sts=2 ts=8 noet:
+
diff --git a/vimrc/.vim/plugin/AddSubtract.vim b/vimrc/.vim/plugin/AddSubtract.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/AddSubtract.vim
@@ -0,0 +1,10 @@
+function! AddSubtract(char, back)
+  let pattern = &nrformats =~ 'alpha' ? '[[:alpha:][:digit:]]' : '[[:digit:]]'
+  call search(pattern, 'cw' . a:back)
+  execute 'normal! ' . v:count1 . a:char
+  silent! call repeat#set(":\<C-u>call AddSubtract('" .a:char. "', '" .a:back. "')\<CR>")
+endfunction
+nnoremap <silent>         <C-a> :<C-u>call AddSubtract("\<C-a>", '')<CR>
+nnoremap <silent> <Leader><C-a> :<C-u>call AddSubtract("\<C-a>", 'b')<CR>
+nnoremap <silent>         <C-x> :<C-u>call AddSubtract("\<C-x>", '')<CR>
+nnoremap <silent> <Leader><C-x> :<C-u>call AddSubtract("\<C-x>", 'b')<CR>
diff --git a/vimrc/.vim/plugin/IndexedSearch.vim b/vimrc/.vim/plugin/IndexedSearch.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/IndexedSearch.vim
@@ -0,0 +1,168 @@
+" File:         IndexedSearch.vim
+" Author:       Yakov Lerner <iler.ml@gmail.com>
+" URL:          http://www.vim.org/scripts/script.php?script_id=1682
+" Last change:  2014-10-10
+
+" This script redefines 6 search commands (/,?,n,N,*,#). At each search,
+" it shows at which match number you are, and the total number
+" of matches, like this: "At Nth match out of M". This is printed
+" at the bottom line at every n,N,/,?,*,# search command, automatically.
+"
+" To try out the plugin, source it and play with N,n,*,#,/,? commands.
+" At the bottom line, you'll see wha it shows. There are no new
+" commands and no new behavior to learn. Just additional info
+" on the bottom line, whenever you perform search.
+"
+" Works on vim6 and vim7. On very large files, won't cause slowdown
+" because it checks the file size.
+" Don't use if you're sensitive to one of its components :-)
+"
+" I am posting this plugin because I find it useful.
+" -----------------------------------------------------
+" Checking Where You Are with respect to Search Matches
+" .....................................................
+" You can press \\ or \/ (that's backslach then slash),
+" or :ShowSearchIndex to show at which match index you are,
+" without moving cursor.
+"
+" If cursor is exactly on the match, the message is:
+"     At Nth match of M
+" If cursor is between matches, following messages are displayed:
+"     Betwen matches 189-190 of 300
+"     Before first match, of 300
+"     After last match, of 300
+" ------------------------------------------------------
+" To disable colors for messages, set 'let g:indexed_search_colors=0'.
+" ------------------------------------------------------
+" Performance. Plugin bypasses match counting when it would take
+" too much time (too many matches, too large file). You can
+" tune performance limits below, after comment "Performance tuning limits"
+" ------------------------------------------------------
+" In case of bugs and wishes, please email: iler.ml at gmail.com
+" ------------------------------------------------------
+
+if exists("g:loaded_indexed_search") || &cp || v:version < 700
+    finish
+endif
+let g:loaded_indexed_search = 1
+
+let s:save_cpo = &cpo
+set cpo&vim
+
+
+" Performance tuning limits
+if !exists('g:indexed_search_max_lines')
+    " Max filesize (in lines) up to where the plugin works
+    let g:indexed_search_max_lines = 70000
+endif
+
+if !exists("g:indexed_search_max_hits")
+    " Max number of matches up to where the plugin stops counting
+    let g:indexed_search_max_hits = 10000
+endif
+
+" Appearance settings
+if !exists('g:indexed_search_colors')
+    " 1 or null - use colors for messages,
+    " 0         - no colors
+    let g:indexed_search_colors = 1
+endif
+
+if !exists('g:indexed_search_shortmess')
+    " 1         - shorter messages;
+    " 0 or null - longer messages.
+    let g:indexed_search_shortmess = 0
+endif
+
+" Mappings
+if !exists('g:indexed_search_mappings')
+    let g:indexed_search_mappings = 1
+endif
+
+if !exists('g:indexed_search_dont_move')
+    let g:indexed_search_dont_move = 0
+endif
+
+if !exists('g:indexed_search_unfold')
+    let g:indexed_search_unfold = 1
+endif
+
+command! -bang ShowSearchIndex :call indexed_search#show_index(<bang>0)
+
+if g:indexed_search_mappings
+    " before 061120,  I had cmapping for <cr> which was very intrusive.
+    "                 Didn't work with supertab iInde<c-x><c-p> resulted in
+    "                 something like recursive <c-r>=.
+    " after  061120,  I remap [/?] instead of remapping <cr>. Works in vim6, too
+    nnoremap /  :ShowSearchIndex<CR>/
+    nnoremap ?  :ShowSearchIndex<CR>?
+
+    " before 061114  we had op invocation inside the function but this did not
+    "                properly keep @/ and direction (func.return restores @/
+    "                and direction)
+    " after  061114  invoking op inside the function does not work because
+    "                @/ and direction is restored at return from function
+    "                We must have op invocation at the toplevel of mapping even
+    "                though this makes mappings longer.
+    if g:indexed_search_dont_move
+        nnoremap <silent>* *N:ShowSearchIndex<CR>
+        nnoremap <silent># #N:ShowSearchIndex<CR>
+    else
+        nnoremap <silent>* *:ShowSearchIndex<CR>
+        nnoremap <silent># #:ShowSearchIndex<CR>
+    endif
+
+    if g:indexed_search_unfold
+        nnoremap <silent>n nzv:ShowSearchIndex<CR>
+        nnoremap <silent>N Nzv:ShowSearchIndex<CR>
+    else
+        nnoremap <silent>n n:ShowSearchIndex<CR>
+        nnoremap <silent>N N:ShowSearchIndex<CR>
+    endif
+endif
+
+
+let &cpo = s:save_cpo
+
+" Last changes
+" 2006-10-20 added limitation by # of matches
+" 061021 lerner fixed problem with cmap <enter> that screwed maps
+" 061021 colors added
+" 061022 fixed g/ when too many matches
+" 061106 got message to work with check for largefile right
+" 061110 addition of DelayedEcho(ScheduledEcho) fixes and simplifies things
+" 061110 mapping for nN*# greately simplifified by switching to ScheduledEcho
+" 061110 fixed problem with i<c-o>/pat<cr> and c/PATTERN<CR> Markus Braun
+" 061110 fixed bug in / and ?, Counting moved to Delayd
+" 061110 fixed bug extra line+enter prompt in [/?] by addinf redraw
+" 061110 fixed overwriting builtin errmsg with ">1000 matches"
+" 061111 fixed bug with gg & 'set nosol' (gg->gg0)
+" 061113 fixed mysterious eschewing of @/ wfte *,#
+" 061113 fixed counting of match at the very beginning of file
+" 061113 added msgs "Before single match", "After single match"
+" 061113 fixed bug with &ut not always restored. This could happen if
+"        ScheduleEcho() was called twice in a row.
+" 061114 fixed problem with **#n. Direction of the last n is incorrect (must be backward
+"              but was incorrectly forward)
+" 061114 fixed disappearrance of "Hit BOTTOM" native msg when file<max and numhits>max
+" 061116 changed hlgroup os "At last match" from DiffChange to LineNr. Looks more natural.
+" 061120 shortened text messages.
+" 061120 made to work on vim6
+" 061120 bugfix for vim6 (virtcol() not col())
+" 061120 another bug with virtcol() vs col()
+" 061120 fixed [/?] on vim6 (vim6 doesn't have getcmdtype())
+" 061121 fixed mapping in <cr> with supertab.vim. Switched to [/?] mapping, removed <cr> mapping.
+"        also shortened code considerably, made vim6 and vim7 work same way, removed need
+"        for getcmdtype().
+" 061121 fixed handling of g:indexed_search_colors (Markus Braun)
+
+
+" Wishlist
+" -  using high-precision timer of vim7, count number of millisec
+"    to run the counters, and base auto-disabling on time it takes.
+"    very complex regexes can be terribly slow even of files like 'man bash'
+"    which is mere 5k lines long. Also when there are >10k matches in the file
+"    set limit to 200 millisec
+" - implement CursorHold bg counting to which too_slow will resort
+" - even on large files, we can show "At last match", "After last match"
+" - define global vars for all highlights, with defaults
diff --git a/vimrc/.vim/plugin/Rename2.vim b/vimrc/.vim/plugin/Rename2.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/Rename2.vim
@@ -0,0 +1,32 @@
+" Rename2.vim  -  Rename a buffer within Vim and on disk
+"
+" Copyright July 2009 by Manni Heumann <vim at lxxi.org>
+"
+" based on Rename.vim
+" Copyright June 2007 by Christian J. Robinson <infynity@onewest.net>
+"
+" Distributed under the terms of the Vim license.  See ":help license".
+"
+" Usage:
+"
+" :Rename[!] {newname}
+
+command! -nargs=* -complete=file -bang Rename :call Rename("<args>", "<bang>")
+
+function! Rename(name, bang)
+    let l:curfile = expand("%:p")
+    let l:curfilepath = expand("%:p:h")
+    let l:newname = l:curfilepath . "/" . a:name
+    let v:errmsg = ""
+    silent! exe "saveas" . a:bang . " " . l:newname
+    if v:errmsg =~# '^$\|^E329'
+        if expand("%:p") !=# l:curfile && filewritable(expand("%:p"))
+            silent exe "bwipe! " . l:curfile
+            if delete(l:curfile)
+                echoerr "Could not delete " . l:curfile
+            endif
+        endif
+    else
+        echoerr v:errmsg
+    endif
+endfunction
diff --git a/vimrc/.vim/plugin/SQLUtilities.vim b/vimrc/.vim/plugin/SQLUtilities.vim
new file mode 100755
--- /dev/null
+++ ./vimrc/.vim/plugin/SQLUtilities.vim
@@ -0,0 +1,412 @@
+" SQLUtilities:   Variety of tools for writing SQL
+"   Author:	      David Fishburn <dfishburn dot vim at gmail dot com>
+"   Date:	      Nov 23, 2002
+"   Last Changed: 2012 Dec 04
+"   Version:	  7.0.0
+"   Script:	      http://www.vim.org/script.php?script_id=492
+"   License:      GPL (http://www.gnu.org/licenses/gpl.html)
+"
+"   Dependencies:
+"        Align.vim - Version 15 (as a minimum)
+"                  - Author: Charles E. Campbell, Jr.
+"                  - http://www.vim.org/script.php?script_id=294
+"   Documentation:
+"        :h SQLUtilities.txt 
+"
+
+" Prevent duplicate loading
+if exists("g:loaded_sqlutilities")
+    finish
+endif
+let g:loaded_sqlutilities = 700
+
+" Turn on support for line continuations when creating the script
+let s:cpo_save = &cpo
+set cpo&vim
+
+if !exists('g:sqlutil_align_where')
+    let g:sqlutil_align_where = 1
+endif
+
+if !exists('g:sqlutil_align_comma')
+    let g:sqlutil_align_comma = 0
+endif
+
+if !exists('g:sqlutil_align_first_word')
+    let g:sqlutil_align_first_word = 1
+endif
+
+if !exists('g:sqlutil_align_keyword_right')
+    let g:sqlutil_align_keyword_right = 1
+endif
+
+if !exists('g:sqlutil_indent_nested_blocks')
+    let g:sqlutil_indent_nested_blocks = 1
+endif
+
+if !exists('g:sqlutil_wrap_long_lines')
+    let g:sqlutil_wrap_long_lines = 1
+endif
+
+if !exists('g:sqlutil_wrap_function_calls')
+    let g:sqlutil_wrap_function_calls = 1
+endif
+
+if !exists('g:sqlutil_wrap_width')
+    let g:sqlutil_wrap_width = (&textwidth > 0 ? &textwidth : 76)
+endif
+
+if !exists('g:sqlutil_split_unbalanced_paran')
+    let g:sqlutil_split_unbalanced_paran = 1
+endif
+
+if !exists('g:sqlutil_cmd_terminator')
+    let g:sqlutil_cmd_terminator = ';'
+endif
+
+if !exists('g:sqlutil_stmt_keywords')
+    let g:sqlutil_stmt_keywords = 'select,insert,update,delete,with,merge'
+endif
+
+if !exists('g:sqlutil_keyword_case')
+    " This controls whether keywords should be made
+    " upper or lower case.
+    " The default is to leave them in current case.
+    let g:sqlutil_keyword_case = ''
+endif
+
+if !exists('g:sqlutil_use_tbl_alias')
+    " If this is set to 1, when you run SQLU_CreateColumnList
+    " and you do not specify a 3rd parameter, you will be
+    " prompted for the alias name to append to the column list.
+    "
+    " The default for the alias are the initials for the table:
+    "     some_thing_with_under_bars -> stwub
+    "     somethingwithout           -> s
+    "
+    " The default is no asking
+    "   d - use by default
+    "   a - ask (prompt)
+    "   n - no
+    let g:sqlutil_use_tbl_alias = 'a'
+endif
+
+if !exists('g:sqlutil_col_list_terminators')
+    " You can override which keywords will determine
+    " when a column list finishes:
+    "        CREATE TABLE customer (
+    "        	id	INT DEFAULT AUTOINCREMENT,
+    "        	last_modified TIMESTAMP NULL,
+    "        	first_name     	VARCHAR(30) NOT NULL,
+    "        	last_name	VARCHAR(60) NOT NULL,
+    "        	balance	        NUMERIC(10,2),
+    "        	PRIMARY KEY( id )
+    "        );
+    " So in the above example, when "primary" is reached, we
+    " know the column list is complete.
+    "     PRIMARY KEY
+    "     foreign keys
+    "     indicies
+    "     check contraints
+    "     table contraints
+    "     foreign keys
+    " 
+    let g:sqlutil_col_list_terminators = 
+                \ 'primary\s\+key.*(' .
+                \ ',references' .
+                \ ',match' .
+                \ ',unique' .
+                \ ',check' .
+                \ ',constraint' .
+                \ ',\%(not\s\+null\s\+\)\?foreign'
+endif
+
+if !exists('g:sqlutil_use_syntax_support')
+    " This controls whether search and replace
+    " of various keywords as part of the formatting 
+    " of sql statements should use Vim's built in
+    " syntax support.
+    " The default to use the syntax id to help
+    " determine if keywords are within strings
+    " and therefore not aligning them.
+    let g:sqlutil_use_syntax_support = 1
+else
+    if exists('g:syntax_on') 
+        let g:sqlutil_use_syntax_support = 1
+    else
+        let g:sqlutil_use_syntax_support = 0
+    endif
+endif
+
+if !exists('g:sqlutil_syntax_elements')
+    " This controls how SQLUtilities determines if
+    " the keyword found is within a string or not.
+    " This is a comma separated list of values.
+    " Items within these syntax groups will 
+    " typically be ignored.
+    " The default is Constant,sqlString,sqlComment,Comment.
+    let g:sqlutil_syntax_elements = 'Constant,sqlString,sqlComment,Comment'
+endif
+
+if !exists('g:sqlutil_non_line_break_keywords')
+    " These keywords will be affected by the sqlutil_keyword_case
+    " option.
+    let g:sqlutil_non_line_break_keywords = 'is,as,in,to,of,at,all,first,top,start,limit,offset,recursive,local,temporary,table,read,only,window,over,like,desc,asc,then,not,exists,between,null,any,distinct,similar,contains,only,true,false,unknown'
+endif
+
+" Determines which menu items will be recreated
+let s:sqlutil_menus_created = 0
+
+" Public Interface:
+command! -range=% -nargs=* SQLUFormatStmts <line1>,<line2> 
+            \ call SQLUtilities#SQLU_FormatStmts(<q-args>)
+command! -range -nargs=* SQLUFormatter <line1>,<line2> 
+            \ call SQLUtilities#SQLU_Formatter(<q-args>)
+command!        -nargs=* SQLUCreateColumnList  
+            \ call SQLU_CreateColumnList(<f-args>)
+command!        -nargs=* SQLUGetColumnDef 
+            \ call SQLU_GetColumnDef(<f-args>)
+command!        -nargs=* SQLUGetColumnDataType 
+            \ call SQLU_GetColumnDef(expand("<cword>"), 1)
+command!        -nargs=* SQLUCreateProcedure 
+            \ call SQLU_CreateProcedure(<f-args>)
+command!        -nargs=* SQLUToggleValue 
+            \ call SQLU_ToggleValue(<f-args>)
+
+if !exists("g:sqlutil_load_default_maps")
+    let g:sqlutil_load_default_maps = 1
+endif 
+
+if(g:sqlutil_load_default_maps == 1)
+    if !hasmapto('<Plug>SQLUFormatStmts')
+        nmap <unique> <Leader>sfr <Plug>SQLUFormatStmts
+        vmap <unique> <Leader>sfr <Plug>SQLUFormatStmts
+    endif 
+    if !hasmapto('<Plug>SQLUFormatter')
+        nmap <unique> <Leader>sfs <Plug>SQLUFormatter
+        vmap <unique> <Leader>sfs <Plug>SQLUFormatter
+        nmap <unique> <Leader>sf <Plug>SQLUFormatter
+        vmap <unique> <Leader>sf <Plug>SQLUFormatter
+    endif 
+    if !hasmapto('<Plug>SQLUCreateColumnList')
+        nmap <unique> <Leader>scl <Plug>SQLUCreateColumnList
+    endif 
+    if !hasmapto('<Plug>SQLUGetColumnDef')
+        nmap <unique> <Leader>scd <Plug>SQLUGetColumnDef
+    endif 
+    if !hasmapto('<Plug>SQLUGetColumnDataType')
+        nmap <unique> <Leader>scdt <Plug>SQLUGetColumnDataType
+    endif 
+    if !hasmapto('<Plug>SQLUCreateProcedure')
+        nmap <unique> <Leader>scp <Plug>SQLUCreateProcedure
+    endif 
+endif 
+
+if exists("g:loaded_sqlutilities_global_maps")
+    vunmap <unique> <script> <Plug>SQLUFormatStmts
+    nunmap <unique> <script> <Plug>SQLUFormatStmts
+    vunmap <unique> <script> <Plug>SQLUFormatter
+    nunmap <unique> <script> <Plug>SQLUFormatter
+    nunmap <unique> <script> <Plug>SQLUCreateColumnList
+    nunmap <unique> <script> <Plug>SQLUGetColumnDef
+    nunmap <unique> <script> <Plug>SQLUGetColumnDataType
+    nunmap <unique> <script> <Plug>SQLUCreateProcedure
+endif
+
+" Global Maps:
+vmap <unique> <script> <Plug>SQLUFormatStmts       :SQLUFormatStmts v<CR>
+nmap <unique> <script> <Plug>SQLUFormatStmts       :SQLUFormatStmts n<CR>
+vmap <unique> <script> <Plug>SQLUFormatter         :SQLUFormatter v<CR>
+nmap <unique> <script> <Plug>SQLUFormatter         :SQLUFormatter n<CR>
+nmap <unique> <script> <Plug>SQLUCreateColumnList  :SQLUCreateColumnList<CR>
+nmap <unique> <script> <Plug>SQLUGetColumnDef      :SQLUGetColumnDef<CR>
+nmap <unique> <script> <Plug>SQLUGetColumnDataType :SQLUGetColumnDataType<CR>
+nmap <unique> <script> <Plug>SQLUCreateProcedure   :SQLUCreateProcedure<CR>
+let g:loaded_sqlutilities_global_maps = 1
+
+if !exists('g:sqlutil_default_menu_mode')
+    let g:sqlutil_default_menu_mode = 3
+endif
+
+function! SQLU_Menu()
+    if has("menu") && g:sqlutil_default_menu_mode != 0
+        if g:sqlutil_default_menu_mode == 1
+            let menuRoot     = 'SQLUtil'
+            let menuPriority = exists("g:sqlutil_menu_priority") ? g:sqlutil_menu_priority : ''
+        elseif g:sqlutil_default_menu_mode == 2
+            let menuRoot     = '&SQLUtil'
+            let menuPriority = exists("g:sqlutil_menu_priority") ? g:sqlutil_menu_priority : ''
+        elseif g:sqlutil_default_menu_mode == 3
+            let menuRoot     = exists("g:sqlutil_menu_root") ? g:sqlutil_menu_root : '&Plugin.&SQLUtil'
+            let menuPriority = exists("g:sqlutil_menu_priority") ? g:sqlutil_menu_priority : ''
+        else
+            let menuRoot     = '&Plugin.&SQLUtil'
+            let menuPriority = exists("g:sqlutil_menu_priority") ? g:sqlutil_menu_priority : ''
+        endif
+
+        let leader = '\'
+        if exists('g:mapleader')
+            let leader = g:mapleader
+        endif
+        let leader = escape(leader, '\')
+
+        if s:sqlutil_menus_created == 0 
+            exec 'vnoremenu <script> '.menuPriority.' '.menuRoot.'.Format\ Range\ Stmts<TAB>'.leader.'sfr :SQLUFormatStmts<CR>'
+            exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Format\ Range\ Stmts<TAB>'.leader.'sfr :SQLUFormatStmts<CR>'
+            exec 'vnoremenu <script> '.menuPriority.' '.menuRoot.'.Format\ Statement<TAB>'.leader.'sfs :SQLUFormatter<CR>'
+            exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Format\ Statement<TAB>'.leader.'sfs :SQLUFormatter<CR>'
+            exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Create\ Procedure<TAB>'.leader.'scp :SQLUCreateProcedure<CR>'
+            exec 'inoremenu <script> '.menuPriority.' '.menuRoot.'.Create\ Procedure<TAB>'.leader.'scp  
+                        \ <C-O>:SQLUCreateProcedure<CR>'
+            exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Create\ Column\ List<TAB>'.leader.'sl   
+                        \ :SQLUCreateColumnList<CR>'
+            exec 'inoremenu <script> '.menuPriority.' '.menuRoot.'.Create\ Column\ List<TAB>'.leader.'sl 
+                        \ <C-O>:SQLUCreateColumnList<CR>'
+            exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Column\ Definition<TAB>'.leader.'scd 
+                        \ :SQLUGetColumnDef<CR>'
+            exec 'inoremenu <script> '.menuPriority.' '.menuRoot.'.Column\ Definition<TAB>'.leader.'scd 
+                        \ <C-O>:SQLUGetColumnDef<CR>'
+            exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Column\ Datatype<TAB>'.leader.'scdt
+                        \ :SQLUGetColumnDataType<CR>'
+            exec 'inoremenu <script> '.menuPriority.' '.menuRoot.'.Column\ Datatype<TAB>'.leader.'scdt
+                        \ <C-O>:SQLUGetColumnDataType<CR>'
+
+            let s:sqlutil_menus_created = 1
+        endif
+        silent! exec 'aunmenu  <script> '.menuPriority.' '.menuRoot.'.Toggle\ Align\ Where'
+        exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Toggle\ Align\ Where'.
+                    \ (g:sqlutil_align_where==1?'<TAB>(on) ':'<TAB>(off) ').
+                    \ ':SQLUToggleValue g:sqlutil_align_where<CR>'
+        silent! exec 'aunmenu '.menuPriority.' '.menuRoot.'.Toggle\ Align\ Comma'
+        exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Toggle\ Align\ Comma'.
+                    \ (g:sqlutil_align_comma==1?'<TAB>(on) ':'<TAB>(off) ').
+                    \ ':SQLUToggleValue g:sqlutil_align_comma<CR>'
+        silent! exec 'aunmenu '.menuPriority.' '.menuRoot.'.Toggle\ Align\ First\ Word'
+        exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Toggle\ Align\ First\ Word'.
+                    \ (g:sqlutil_align_first_word==1?'<TAB>(on) ':'<TAB>(off) ').
+                    \ ':SQLUToggleValue g:sqlutil_align_first_word<CR>'
+        silent! exec 'aunmenu '.menuPriority.' '.menuRoot.'.Toggle\ Right\ Align\ Keywords'
+        exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Toggle\ Right\ Align\ Keywords'.
+                    \ (g:sqlutil_align_keyword_right=='1'?'<TAB>(on) ':'<TAB>(off) ').
+                    \ ':SQLUToggleValue g:sqlutil_align_keyword_right<CR>'
+        silent! exec 'aunmenu '.menuPriority.' '.menuRoot.'.Uppercase\ Keywords'
+        exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Uppercase\ Keywords'.
+                    \ (g:sqlutil_keyword_case=='\U'?'<TAB>(on) ':' ').
+                    \ ':SQLUToggleValue g:sqlutil_keyword_case \U<CR>'
+        silent! exec 'aunmenu '.menuPriority.' '.menuRoot.'.Lowercase\ Keywords'
+        exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Lowercase\ Keywords'.
+                    \ (g:sqlutil_keyword_case=='\L'?'<TAB>(on) ':' ').
+                    \ ':SQLUToggleValue g:sqlutil_keyword_case \L<CR>'
+        silent! exec 'aunmenu '.menuPriority.' '.menuRoot.'.Default\ Case\ Keywords'
+        exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Default\ Case\ Keywords'.
+                    \ (g:sqlutil_keyword_case==''?'<TAB>(on) ':' ').
+                    \ ':SQLUToggleValue g:sqlutil_keyword_case default<CR>'
+        silent! exec 'aunmenu '.menuPriority.' '.menuRoot.'.-Debug-'
+        exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.-Debug- :'
+        silent! exec 'aunmenu '.menuPriority.' '.menuRoot.'.Toggle\ Indent\ Nested\ Blocks'
+        exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Toggle\ Indent\ Nested\ Blocks'.
+                    \ (g:sqlutil_indent_nested_blocks=='1'?'<TAB>(on) ':'<TAB>(off) ').
+                    \ ':SQLUToggleValue g:sqlutil_indent_nested_blocks<CR>'
+        silent! exec 'aunmenu '.menuPriority.' '.menuRoot.'.Toggle\ Wrap\ Long\ Lines'
+        exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Toggle\ Wrap\ Long\ Lines'.
+                    \ (g:sqlutil_wrap_long_lines=='1'?'<TAB>(on) ':'<TAB>(off) ').
+                    \ ':SQLUToggleValue g:sqlutil_wrap_long_lines<CR>'
+        silent! exec 'aunmenu '.menuPriority.' '.menuRoot.'.Toggle\ Wrap\ Function\ Calls'
+        exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Toggle\ Wrap\ Function\ Calls'.
+                    \ (g:sqlutil_wrap_function_calls=='1'?'<TAB>(on) ':'<TAB>(off) ').
+                    \ ':SQLUToggleValue g:sqlutil_wrap_function_calls<CR>'
+        silent! exec 'aunmenu '.menuPriority.' '.menuRoot.'.Toggle\ Split\ Unbalanced\ Paranthesis'
+        exec 'noremenu  <script> '.menuPriority.' '.menuRoot.'.Toggle\ Split\ Unbalanced\ Paranthesis'.
+                    \ (g:sqlutil_split_unbalanced_paran=='1'?'<TAB>(on) ':'<TAB>(off) ').
+                    \ ':SQLUToggleValue g:sqlutil_split_unbalanced_paran<CR>'
+    endif
+endfunction
+
+" Puts a command separate list of columns given a table name
+" Will search through the file looking for the create table command
+" It assumes that each column is on a separate line
+" It places the column list in unnamed buffer
+function! SQLU_CreateColumnList(...)
+    if(a:0 > 1) 
+        call SQLUtilities#SQLU_CreateColumnList(a:1, a:2)
+    elseif(a:0 > 0) 
+        call SQLUtilities#SQLU_CreateColumnList(a:1)
+    else
+        call SQLUtilities#SQLU_CreateColumnList()
+    endif
+endfunction
+
+
+" Strip the datatype from a column definition line
+function! SQLU_GetColumnDatatype( line, need_type )
+    return SQLUtilities#SQLU_GetColumnDatatype(a:line, a:need_type)
+endfunction
+
+
+" Puts a comma separated list of columns given a table name
+" Will search through the file looking for the create table command
+" It assumes that each column is on a separate line
+" It places the column list in unnamed buffer
+function! SQLU_GetColumnDef( ... )
+    if(a:0 > 1) 
+        return SQLUtilities#SQLU_GetColumnDef(a:1, a:2)
+    elseif(a:0 > 0) 
+        return SQLUtilities#SQLU_GetColumnDef(a:1)
+    else
+        return SQLUtilities#SQLU_GetColumnDef()
+    endif
+endfunction
+
+
+
+" Creates a procedure defintion into the unnamed buffer for the 
+" table that the cursor is currently under.
+function! SQLU_CreateProcedure(...)
+    if(a:0 > 0) 
+        return SQLUtilities#SQLU_CreateProcedure(a:1)
+    else
+        return SQLUtilities#SQLU_CreateProcedure()
+    endif
+endfunction
+
+
+
+" Compares two strings, and will remove all names from the first 
+" parameter, if the same name exists in the second column name.
+" The 2 parameters take comma separated lists
+function! SQLU_RemoveMatchingColumns( full_col_list, dup_col_list )
+    return SQLUtilities#SQLU_RemoveMatchingColumns( a:full_col_list, a:dup_col_list )
+endfunction
+
+
+
+" Toggles the value of some configuration parameters.
+" Mainly used by the menu.
+function! SQLU_ToggleValue( ... )
+    if (a:0 == 0)
+        echohl WarningMsg
+        echomsg "SQLUToggle value requires at least 1 parameter"
+        echohl None
+    elseif (a:0 == 1)
+        if exists('{a:1}') 
+            let {a:1} = (({a:1} == 0)?1:0)
+        endif
+    else
+        if exists('{a:1}') 
+            " Use defaults as the default for this function
+            if a:2 == 'default'
+                let {a:1} = ''
+            else
+                let {a:1} = a:2
+            endif
+        endif
+    endif
+    call SQLU_Menu()
+endfunction
+
+call SQLU_Menu()
+
+let &cpo = s:cpo_save
+unlet s:cpo_save
+
+" vim:fdm=marker:nowrap:ts=4:expandtab:ff=unix:
diff --git a/vimrc/.vim/plugin/ShowVITAG.vim b/vimrc/.vim/plugin/ShowVITAG.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/ShowVITAG.vim
@@ -0,0 +1,4 @@
+function! ShowVITAG()
+    call Cd2ProjectRoot("files.proj")
+    call OpenOrSwitch('files.proj', 'vs')
+endfunction
diff --git a/vimrc/.vim/plugin/WordCount.vim b/vimrc/.vim/plugin/WordCount.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/WordCount.vim
@@ -0,0 +1,19 @@
+let g:word_count="<unknown>"
+function WordCount()
+  return g:word_count
+endfunction
+function UpdateWordCount()
+  let lnum = 1
+  let n = 0
+  while lnum <= line('$')
+    let n = n + len(split(getline(lnum)))
+    let lnum = lnum + 1
+  endwhile
+  let g:word_count = n
+endfunction
+" Update the count when cursor is idle in command or insert mode.
+" Update when idle for 1000 msec (default is 4000 msec).
+set updatetime=1000
+augroup WordCounter
+  au! CursorHold,CursorHoldI * call UpdateWordCount()
+augroup END
diff --git a/vimrc/.vim/plugin/auto_cscope.vim b/vimrc/.vim/plugin/auto_cscope.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/auto_cscope.vim
@@ -0,0 +1,8 @@
+function! s:auto_cscope()
+    call UpdateProj()
+endfunction
+
+augroup auto_cscope
+    au!
+    au BufWritePost,TextChanged * call <SID>auto_cscope()
+augroup END
diff --git a/vimrc/.vim/plugin/auto_deploy.vim b/vimrc/.vim/plugin/auto_deploy.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/auto_deploy.vim
@@ -0,0 +1,15 @@
+function! s:auto_deploy_augroup()
+    call Cd2ProjectRoot('files.proj')
+
+    if !filereadable('files.proj')
+        return
+    endif
+
+    call asyncrun#run('<bang>', '', '~/loadrc/bashrc/deploy.sh 2>&1 | tee deploy.findresult')
+    call CHANGE_CURR_DIR() 
+endfunction
+
+augroup auto_deploy_augroup
+    au!
+    au BufWritePost,TextChanged * call <SID>auto_deploy_augroup()
+augroup END
diff --git a/vimrc/.vim/plugin/buffergator.vim b/vimrc/.vim/plugin/buffergator.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/buffergator.vim
@@ -0,0 +1,3 @@
+let g:buffergator_sort_regime = "mru"
+let g:buffergator_suppress_keymaps = 1
+nnoremap <silent> mm :BuffergatorOpen<CR>
diff --git a/vimrc/.vim/plugin/bundle.vim b/vimrc/.vim/plugin/bundle.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/bundle.vim
@@ -0,0 +1,31 @@
+" let Vundle manage Vundle
+" required! 
+Bundle 'gmarik/vundle'
+" My bundles here:
+"
+" original repos on GitHub
+" Bundle 'huangyingw/vim-fugitive'
+Bundle 'Lokaltog/vim-easymotion'
+Bundle 'rstacruz/sparkup', {'rtp': 'vim/'}
+Bundle 'tpope/vim-rails.git'
+" vim-scripts repos
+Bundle 'L9'
+Bundle 'FuzzyFinder'
+" non-GitHub repos
+" Bundle 'git://git.wincent.com/command-t.git'
+" Git repos on your local machine (i.e. when working on your own plugin)
+" Bundle 'file:///Users/gmarik/path/to/plugin'
+" ...
+"
+" Brief help
+" :BundleList          - list configured bundles
+" :BundleInstall(!)    - install (update) bundles
+" :BundleSearch(!) foo - search (or refresh cache first) for foo
+" :BundleClean(!)      - confirm (or auto-approve) removal of unused bundles
+"
+" see :h vundle for more details or wiki for FAQ
+" NOTE: comments after Bundle commands are not allowed.
+Bundle "huangyingw/vim-autoformat"
+" Bundle "Valloric/YouCompleteMe"
+Bundle "ekalinin/Dockerfile.vim"
+Bundle "huangyingw/bash-support.vim.git"
diff --git a/vimrc/.vim/plugin/clipboard.vim b/vimrc/.vim/plugin/clipboard.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/clipboard.vim
@@ -0,0 +1,7 @@
+let os = substitute(system('uname'), "\n", "", "")
+
+if os == "Linux"
+    set clipboard=unnamedplus
+else
+    set clipboard=unnamed
+endif
diff --git a/vimrc/.vim/plugin/commands.vim b/vimrc/.vim/plugin/commands.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/commands.vim
@@ -0,0 +1,4 @@
+au BufEnter * set noro
+" Don't let Vim's "Found a swap file" message block input
+set shortmess+=A
+command W :execute ':silent w !sudo tee % > /dev/null' | :edit!
diff --git a/vimrc/.vim/plugin/common.vim b/vimrc/.vim/plugin/common.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/common.vim
@@ -0,0 +1,305 @@
+function! CHANGE_CURR_DIR()
+    let _dir = expand("%:p:h")
+
+    try
+        exec "cd " . fnameescape(_dir)
+    catch /.*/
+        return
+    endtry
+
+    unlet _dir
+
+    if filereadable(".vimdc")
+        source .vimdc
+    endif
+endfunction
+"
+" autoclose html/xml tag autocmd BufNewFile,BufRead *.html,*.htm,*.xml inoremap </ </<c-x><c-o>
+function! RemovePairs()
+    let l:line = getline(".")
+    let l:previous_char = l:line[col(".")-1] " 
+
+    if index(["(", "[", "{"], l:previous_char) != -1
+        let l:original_pos = getpos(".")
+        execute "normal %"
+        let l:new_pos = getpos(".")
+
+        " 
+        if l:original_pos == l:new_pos
+            execute "normal! a\<BS>"
+            return
+        endif
+
+        let l:line2 = getline(".")
+        if len(l:line2) == col(".")
+            " 
+            execute "normal! v%xa"
+        else
+            " 
+            execute "normal! v%xi"
+        endif
+    else
+        execute "normal! a\<BS>"
+    endif
+endfunction
+
+function! RemoveNextDoubleChar(char)
+    let l:line = getline(".")
+    let l:next_char = l:line[col(".")] " 
+
+    if a:char == l:next_char
+        execute "normal! l"
+    else
+        execute "normal! i" . a:char . ""
+    endif
+endfunction
+
+" $HOME~
+function! CurDir()
+    let curdir = substitute(getcwd(), $HOME, "~", "g")
+    return curdir
+endfunction
+
+function! MyFoldText()
+    let line = getline(v:foldstart)
+    if match( line, '^[ \t]*\(\/\*\|\/\/\)[*/\\]*[ \t]*$' ) == 0
+        let initial = substitute( line, '^\([ \t]\)*\(\/\*\|\/\/\)\(.*\)', '\1\2', '' )
+        let linenum = v:foldstart + 1
+        while linenum < v:foldend
+            let line = getline( linenum )
+            let comment_content = substitute( line, '^\([ \t\/\*]*\)\(.*\)$', '\2', 'g' )
+            if comment_content != ''
+                break
+            endif
+            let linenum = linenum + 1
+        endwhile
+        let sub = initial . ' ' . comment_content
+    else
+        let sub = line
+        let startbrace = substitute( line, '^.*{[ \t]*$', '{', 'g')
+        if startbrace == '{'
+            let line = getline(v:foldend)
+            let endbrace = substitute( line, '^[ \t]*}\(.*\)$', '}', 'g')
+            if endbrace == '}'
+                let sub = sub.substitute( line, '^[ \t]*}\(.*\)$', '...}\1', 'g')
+            endif
+        endif
+    endif
+    let n = v:foldend - v:foldstart + 1
+    let info = " " . n . " lines"
+    let sub = sub . "                                                                                                                  "
+    let num_w = getwinvar( 0, '&number' ) * getwinvar( 0, '&numberwidth' )
+    let fold_w = getwinvar( 0, '&foldcolumn' )
+    let sub = strpart( sub, 0, winwidth(0) - strlen( info ) - num_w - fold_w - 1 )
+    return sub . info
+endfunction
+
+function! ResCur()
+    if line("'\"") <= line("$")
+        try
+            normal! g`"
+        catch /./
+        endtry
+
+        return 1
+    endif
+endfunction
+
+"==
+" Find_in_parent
+" find the file argument and returns the path to it.
+" Starting with the current working dir, it walks up the parent folders
+" until it finds the file, or it hits the stop dir.
+" If it doesn't find it, it returns "Nothing"
+function! Find_in_parent(fln, flsrt, flstp)
+    let here = a:flsrt
+
+    while ( strlen( here) > 0 )
+        if filereadable( here . "/" . a:fln )
+            return here
+        elseif isdirectory( here . "/" . a:fln )
+            return here
+        endif
+
+        let fr = match(here, "/[^/]*$")
+
+        if fr == -1
+            break
+        endif
+
+        let here = strpart(here, 0, fr)
+
+        if here == a:flstp
+            break
+        endif
+    endwhile
+
+    return "Nothing"
+endfunc
+
+function! GetWorktree()
+    return substitute(system("~/loadrc/gitrc/get_worktree.sh " . '"' . expand('%:p') . '"'), '\n', '', '')
+endfunction
+
+function! OpenOrSwitch(buffername, openMode, ...)
+    let fileName = a:buffername
+
+    if !filereadable(a:buffername)
+        let curline = getline(line("."))
+        let curline = substitute(curline, '\\', '', 'g')
+        let curline = substitute(curline, "^\"", "", "")
+        let curline = substitute(curline, "\"$", "", "")
+        if filereadable(curline)
+            let fileName = curline
+        endif
+    endif
+
+    let topleft = (a:0 >= 1) ? a:1 : 'topleft'
+
+    if a:openMode ==? "goto"
+        call fetch#cfile(fileName, 'e')
+    else
+        call fetch#cfile(fileName, 'vs')
+    endif
+endfunction
+
+"==
+" windowdir
+"  Gets the directory for the file in the current window
+"  Or the current working dir if there isn't one for the window.
+"  Use tr to allow that other OS paths, too
+function! Windowdir()
+    if winbufnr(0) == -1
+        let unislash = getcwd()
+    else
+        let unislash = fnamemodify(bufname(winbufnr(0)), ':p:h')
+
+        if unislash =~ '^term://'
+            let unislash = getcwd()
+        endif
+
+        if unislash =~ '^fugitive:/'
+            let unislash = substitute(unislash, '^fugitive:\/\/', '', 'g')
+            let unislash = substitute(unislash, '.git.*', '', 'g')
+        endif
+    endif
+
+    return tr(unislash, '\', '/')
+endfunc
+
+function! GetEscapedKeyword(keywordStr)
+    let result = a:keywordStr
+    let result = substitute(result, '/', '\/', 'g')
+    let result = substitute(result, '\"', '\\"', 'g')
+    let result = substitute(result, '\$', '\\$', 'g')
+    let result = substitute(result, '^\_s\+', '', 'g')
+    let result = substitute(result, '\_s\+$', '', 'g')
+    let result = substitute(result, '\_s', ' ', 'g')
+    let result = substitute(result, '\n', '\\n', 'g')
+    let result = substitute(result, '`', '\\`', 'g')
+    let result = substitute(result, '\#', '\\#', 'g')
+    let result = substitute(result, '!', '\\!', 'g')
+    return result
+endfunc
+
+function! GetEscapedResult(keywordStr)
+    let result = a:keywordStr
+    try
+        let result = substitute(result, " ", "", "g")
+        let result = substitute(result, "/", "", "g")
+        let result = substitute(result, "|", "", "g")
+        let result = substitute(result, "(", "", "g")
+        let result = substitute(result, ")", "", "g")
+        let result = substitute(result, '\\c', '', 'g')
+        let result = substitute(result, '\\V', '', 'g')
+        let result = substitute(result, '\"', '', 'g')
+        let result = substitute(result, '\,', '', 'g')
+        let result = substitute(result, '\\', '', 'g')
+        let result = substitute(result, '\$', '', 'g')
+        let result = substitute(result, '#', '', 'g')
+        let result = substitute(result, '!', '', 'g')
+        let result = substitute(result, "<", "", "g")
+        let result = substitute(result, ">", "", "g")
+        let result = substitute(result, "~", "", "g")
+        let result = substitute(result, "*", "", "g")
+        let result = substitute(result, "%", "", "g")
+        let result = substitute(result, ":", "", "g")
+        let result = substitute(result, "[", "_", "g")
+        let result = substitute(result, "]", "_", "g")
+        let result = substitute(result, "+", "_", "g")
+        let result = substitute(result, "-", "_", "g")
+        return result
+    catch /./
+    endtry
+endfunc
+
+function! VsMax(fileName)
+    call OpenOrSwitch(a:fileName, 'vs')
+endfunc
+
+function! RunShell(shell, ...)
+    let arg1 = (a:0 >= 1) ? a:1 : ''
+    let arg2 = (a:0 >= 2) ? a:2 : ''
+    let silent = substitute(system('git config vrun.silent'), '\n', '', '')
+    let async = substitute(system('git config vrun.async'), '\n', '', '')
+    let temp_log = arg2 . '.findresult'
+    let run_string = a:shell . ' ' . '"' .  arg1 . '"' .  ' ' . '2>&1 | tee' . ' ' . temp_log
+
+    if async ==? "true"
+        call asyncrun#run('<bang>', '', ' ' . run_string)
+    else
+        if silent ==? "true"
+            silent exec '!' . run_string
+        else
+            exec '!' . run_string
+        endif
+    endif
+    silent exec '!cp' . ' -fv ' . '"' .  temp_log . '"' . ' ' . '"' .  arg2 . '"'
+    silent exec '!~/loadrc/bashrc/removing_ansi_color_codes.sh' . ' ' . '"' .  arg2 . '"'
+endfunc
+
+function! Filter2Findresult()
+    let worktree = Cd2Worktree()
+    let keyword = @/
+    let b:result = GetEscapedResult(keyword)
+
+    if expand('%:e') != "findresult"
+        let buffername = b:result . '.findresult'
+
+        if bufexists(buffername)
+            exe "bd!" . buffername
+        endif
+
+        silent exec '!cp -fv ' . ' ' . '"' .  expand('%:p') . '"' . ' ' . '"' .  buffername . '"'
+        let worktree = Cd2Worktree()
+        call OpenOrSwitch(buffername, 'vs')
+    endif
+endfunc
+
+function! Cd2ProjectRoot(filename)
+    let csdbpath = Find_in_parent(a:filename, getcwd(), "/")
+
+    if csdbpath != "Nothing"
+        exec "cd " . csdbpath
+        return csdbpath
+    endif
+endfunc
+
+function! Cd2Worktree()
+    let worktree = GetWorktree()
+
+    try
+        exec "cd " . fnameescape(worktree)
+    catch /./
+    endtry
+
+    return worktree
+endfunc
+
+function! GetCurrentFileName()
+    return '"' . expand("%:p") . '"'
+endfunc
+
+function! GetUnnamedRegister()
+    return '"' . @" . '"'
+endfunc
diff --git a/vimrc/.vim/plugin/dictionary.vim b/vimrc/.vim/plugin/dictionary.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/dictionary.vim
@@ -0,0 +1,2 @@
+set dictionary+=/usr/share/dict/words
+set complete+=k
diff --git a/vimrc/.vim/plugin/diff-options.vim b/vimrc/.vim/plugin/diff-options.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/diff-options.vim
@@ -0,0 +1,7 @@
+if (expand('%:e') !=# 'py')
+    set diffopt+=iwhiteall
+endif
+
+set diffopt+=iblank
+set diffopt+=algorithm:patience
+set diffopt+=indent-heuristic
diff --git a/vimrc/.vim/plugin/fugitive.vim b/vimrc/.vim/plugin/fugitive.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/fugitive.vim
@@ -0,0 +1,857 @@
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject AppendRate :execute s:AppendRate(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject ApplyBranch :execute s:ApplyBranch(<q-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject BinaryGrep :execute s:BinaryGrep(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject CatDu :execute s:CatDu(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject CatMove :execute s:CatMove(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject CatPlay :execute s:CatPlay(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject CatRate :execute s:CatRate(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject CatBadFiles :execute s:CatBadFiles(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject CatRun :execute s:CatRun(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Copy :execute s:Copy(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Dodev :execute s:Dodev()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Dps :execute s:Dps()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Fcscope :execute s:Fcscope()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Fdisklog :execute s:Fdisklog()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject FileMove :execute s:FileMove(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject FindDeleted :execute s:FindDeleted()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Fnotinuse :execute s:Fnotinuse()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Fr :execute s:Fr(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Fsync :execute s:Fsync()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject G :execute s:G(<q-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Ga :execute s:Ga(<q-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gbib :execute s:Gbib()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gbidebug :execute s:Gbidebug()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gbig :execute s:Gbig()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gbil :execute s:Gbil()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gbis :execute s:Gbis()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gbr :execute s:Gbr()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gbra :execute s:Gbra()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gbrd :execute s:Gbrd(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gbrm :execute s:Gbrm(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gclean :execute s:Gclean()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gco :execute s:Gco(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gcob :execute s:Gcob(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gcof :execute s:Gcof(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gcom :execute s:Gcom(<q-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gcp :execute s:Gcp(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gdev :execute s:Gdev()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gdi :execute s:Gdi(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gdi2 :execute s:Gdi2(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gdif :execute s:Gdif(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gdio :execute s:Gdio(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gdit :execute s:Gdit()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject GenerateIpynb :execute s:GenerateIpynb()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gfix :execute s:Gfix()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gicb :execute s:Gicb()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gitk :execute s:Gitk(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gkd :execute s:Gkd(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gkdo :execute s:Gkdo()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Glf :execute s:Glf()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Glg :execute s:Glg()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gme2 :execute s:Gme2(<q-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gpl :execute s:Gpl()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gps :execute s:Gps()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gres :execute s:Gres()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject GrevApply :execute s:GrevApply()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Grsh :execute s:Grsh(<q-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Grta :execute s:Grta(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Grtu :execute s:Grtu()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Grtv :execute s:Grtv()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gs :execute s:Gs()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gsave :execute s:Gsave()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gshow :execute s:Gshow(<q-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gst :execute s:Gst()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gsti :execute s:Gsti()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gstl :execute s:Gstl()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gstlv :execute s:Gstlv()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gstp :execute s:Gstp(<q-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gstv :execute s:Gstv(<q-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gsubbr :execute s:Gsubbr()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gsync :execute s:Gsync()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gtg :execute s:Gtg()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Gwap :execute s:Gwap()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Hdi :execute s:Hdi()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Jformat :execute s:Jformat()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject KdiffFile :execute s:KdiffFile()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject LcTest :execute s:LcTest()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject LogFilter :execute s:LogFilter(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Portsforward :execute s:Portsforward()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Prune :execute s:Prune()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Reapply :execute s:Reapply()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject RmCat :execute s:RmCat(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject SelectMove :execute s:SelectMove(<f-args>)
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject SortBySize :execute s:SortBySize()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject SortByTime :execute s:SortByTime()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Split :execute s:Split()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject SvnApply :execute s:SvnApply()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject SvnDiff :execute s:SvnDiff()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject SvnReset :execute s:SvnReset()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject SvnRevert :execute s:SvnRevert()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject SvnSt :execute s:SvnSt()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject SvnUp :execute s:SvnUp()
+command! -bang -bar -nargs=* -complete=customlist,fugitive#CompleteObject Tail :execute s:Tail()
+
+function! s:LogFilter(...) abort
+    let worktree = Cd2Worktree()
+    let arg1 = (a:0 >= 1) ? a:1 : ''
+    call asyncrun#run('<bang>', '', '~/loadrc/bashrc/logFilter.sh ' . '"' .  expand('%:p') . '" "' .  arg1 . '"')
+endfunction
+
+function! s:Jformat(...) abort
+    let worktree = Cd2Worktree()
+    call asyncrun#run('<bang>', '', '~/loadrc/bashrc/jformat.sh ')
+endfunction
+
+function! s:Gkd(...) abort
+    let worktree = Cd2Worktree()
+
+    if expand('%:t') != 'index'
+        if a:0 == 0
+            call asyncrun#run('<bang>', '', '~/loadrc/gitrc/gkd.sh ' . 'HEAD ' . '"' .  expand('%:p') . '"')
+        else
+            let arg1 = (a:0 >= 1) ? a:1 : ''
+            call asyncrun#run('<bang>', '', '~/loadrc/gitrc/gkd.sh ' . '"' .  arg1 . '" "' .  expand('%:p') . '"')
+        endif
+    else
+        let arg1 = (a:0 >= 1) ? a:1 : ''
+        let arg2 = (a:0 >= 2) ? a:2 : ''
+        call asyncrun#run('<bang>', '', '~/loadrc/gitrc/gkd.sh ' . '"' .  arg1 . '" "' .  arg2 . '"')
+    endif
+endfunction
+
+function! s:Gkdo() abort
+    let worktree = Cd2Worktree()
+    let target = substitute(system("git config gsync.target"), '\n', '', '')
+
+    if expand('%:t') != 'index'
+        call asyncrun#run('<bang>', '', '~/loadrc/gitrc/gkd.sh ' . '"' .  target . '" "' .  expand('%:p') . '"')
+    else
+        call asyncrun#run('<bang>', '', '~/loadrc/gitrc/gkd.sh ' . '"' .  target . '"')
+    endif
+endfunction
+
+function! s:Ga(args, ...) abort
+    let worktree = Cd2Worktree()
+    call asyncrun#run('<bang>', '', '~/loadrc/gitrc/ga.sh ' . '"' .  a:args . '"')
+endfunction
+
+function! s:Gsave() abort
+    let worktree = Cd2Worktree()
+    call asyncrun#run('<bang>', '', '~/loadrc/gitrc/gsave.sh')
+endfunction
+
+function! s:Gst() abort
+    let worktree = Cd2Worktree()
+    call asyncrun#run('<bang>', '', '~/loadrc/gitrc/gst.sh')
+endfunction
+
+function! s:Gcp(...) abort
+    let worktree = Cd2Worktree()
+    let arg1 = (a:0 >= 1) ? a:1 : ''
+    let arg2 = (a:0 >= 2) ? a:2 : ''
+    call asyncrun#run('<bang>', '', '~/loadrc/gitrc/gcp.sh ' . '"' .  arg1 . '" "' .  arg2 . '"')
+endfunction
+
+function! s:BinaryGrep(...) abort
+    call Cd2ProjectRoot("files.proj")
+    let b:keyword = (a:0 >= 1) ? a:1 : ''
+    call asyncrun#run('<bang>', '', '~/loadrc/bashrc/binaryGrep.sh ' . '"' .  b:keyword . '"')
+    let b:keyword = substitute(b:keyword, " ", "_", "g")
+    let b:keyword = substitute(b:keyword, "/", "_", "g")
+    call OpenOrSwitch(b:keyword . '.binaryGrep.findresult', 'vs')
+endfunction
+
+function! s:Fnotinuse() abort
+    call Cd2ProjectRoot("files.proj")
+    call asyncrun#run('<bang>', '', '~/loadrc/bashrc/fnotinuse.sh')
+    call OpenOrSwitch('fnotinuse.findresult', 'vs')
+endfunction
+
+function! s:Fcscope() abort
+    let worktree = Cd2Worktree()
+    call asyncrun#run('<bang>', '', '~/loadrc/bashrc/fcscope.sh')
+endfunction
+
+
+function! s:Fdisklog() abort
+    let worktree = Cd2Worktree()
+    exec '!~/loadrc/bashrc/fdisk_log.sh'
+    call OpenOrSwitch(expand("$HOME") . '/loadrc/fdisk.log', 'vs')
+endfunction
+
+function! s:Glf() abort
+    let worktree = Cd2Worktree()
+    silent exec '!git ls-files | tee glf.runresult'
+    call OpenOrSwitch('glf.runresult', 'vs')
+endfunction
+
+function! s:Glg() abort
+    let worktree = Cd2Worktree()
+    silent exec '!~/loadrc/gitrc/glg.sh'
+    call OpenOrSwitch('glg.findresult', 'vs')
+endfunction
+
+function! s:Gps() abort
+    let worktree = Cd2Worktree()
+    call asyncrun#run('<bang>', '', '~/loadrc/gitrc/gps.sh 2>&1 | tee gps.findresult')
+endfunction
+
+function! s:Gstp(args, ...) abort
+    let worktree = Cd2Worktree()
+    call asyncrun#run('<bang>', '', '~/loadrc/gitrc/gstp.sh ' . '"' .  a:args . '"')
+endfunction
+
+function! s:Gstv(args, ...) abort
+    let worktree = Cd2Worktree()
+    call asyncrun#run('<bang>', '', '~/loadrc/gitrc/gstv.sh ' . '"' .  a:args . '"')
+endfunction
+
+function! s:Gcof(...) abort
+    let worktree = Cd2Worktree()
+    let b:relativePath = substitute(expand('%:p'), worktree . '/', "", "g")
+    let arg1 = (a:0 >= 1) ? a:1 : ''
+    silent exec '!~/loadrc/gitrc/gcof.sh ' . '"' .  b:relativePath . '" "' .  arg1 . '"'
+    call OpenOrSwitch(expand('%:p') . '.bak', 'vs')
+endfunction
+
+function! s:Gpl() abort
+    let worktree = Cd2Worktree()
+    exec '!~/loadrc/gitrc/gpl.sh 2>&1 | tee gpl.findresult'
+    call OpenOrSwitch('gpl.findresult', 'vs')
+endfunction
+
+function! s:Fsync() abort
+    let worktree = Cd2Worktree()
+    call asyncrun#run('<bang>', '', '~/loadrc/gitrc/fsync.sh 2>&1 | tee fsync.findresult')
+    call OpenOrSwitch('fsync.findresult', 'vs')
+endfunction
+
+function! s:Gbis() abort
+    let worktree = Cd2Worktree()
+    exec '!~/loadrc/gitrc/gbis.sh'
+endfunction
+
+function! s:Gbidebug() abort
+    let worktree = Cd2Worktree()
+    exec '!~/loadrc/gitrc/gbidebug.sh'
+endfunction
+
+function! s:Gbib() abort
+    let worktree = Cd2Worktree()
+    exec '!~/loadrc/gitrc/gbib.sh | tee gbil.log.runresult'
+    call OpenOrSwitch('gbil.log.runresult', 'vs')
+endfunction
+
+function! s:Gbig() abort
+    let worktree = Cd2Worktree()
+    exec '!~/loadrc/gitrc/gbig.sh | tee gbil.log.runresult'
+    call OpenOrSwitch('gbil.log.runresult', 'vs')
+endfunction
+
+function! s:Gbil() abort
+    let worktree = Cd2Worktree()
+    exec '!~/loadrc/gitrc/gbil.sh'
+    call OpenOrSwitch('gbil.log', 'vs')
+endfunction
+
+function! s:Gbr() abort
+    let worktree = Cd2Worktree()
+    silent exec '!~/loadrc/gitrc/gbr.sh'
+    call OpenOrSwitch('gbr.log', 'vs')
+endfunction
+
+function! s:Gclean() abort
+    let worktree = Cd2Worktree()
+    silent exec '!~/loadrc/gitrc/gclean.sh'
+endfunction
+
+function! s:Gbra() abort
+    let worktree = Cd2Worktree()
+    silent exec '!~/loadrc/gitrc/gbra.sh'
+    call OpenOrSwitch('gbra.log', 'vs')
+endfunction
+
+function! s:Gs() abort
+    if expand('%:p') =~ '^fugitive:/'
+        let indexFolder = substitute(expand('%:p'), '^fugitive:\/\/', '', 'g')
+        let indexFolder = substitute(indexFolder, '.git.*', '.git', 'g')
+    else
+        let indexFolder = substitute(system("~/loadrc/gitrc/get_git.sh " . '"' . expand('%:p') . '"'), '\n', '', '')
+    endif
+
+    call OpenOrSwitch(indexFolder . '/index', 'vs')
+endfunction
+
+function! s:Gsync() abort
+    let worktree = Cd2Worktree()
+    call asyncrun#run('<bang>', '', '~/loadrc/gitrc/gsync.sh 2>&1 | tee gsync.findresult')
+    call OpenOrSwitch('gsync.findresult', 'vs')
+endfunction
+
+function! s:Grta(...) abort
+    let worktree = Cd2Worktree()
+    let arg1 = (a:0 >= 1) ? a:1 : ''
+    let arg2 = (a:0 >= 2) ? a:2 : ''
+    silent exec '!git remote add ' . '"' .  arg1 . '" "' .  arg2 . '"'
+endfunction
+
+function! s:Grsh(args, ...) abort
+    let worktree = Cd2Worktree()
+    silent exec '!~/loadrc/gitrc/grsh.sh ' . '"' .  a:args . '"'
+endfunction
+
+function! s:Gsti() abort
+    let worktree = Cd2Worktree()
+    call asyncrun#run('<bang>', '', '~/loadrc/gitrc/gsti.sh')
+endfunction
+
+function! s:Gstl() abort
+    let worktree = Cd2Worktree()
+    silent exec '!~/loadrc/gitrc/gstl.sh'
+    call OpenOrSwitch('gstl.findresult', 'vs')
+endfunction
+
+function! s:Gstlv() abort
+    let worktree = Cd2Worktree()
+    call asyncrun#run('<bang>', '', '~/loadrc/gitrc/gstlv.sh')
+endfunction
+
+function! s:Gme2(args, ...) abort
+    let worktree = Cd2Worktree()
+    exec '!~/loadrc/gitrc/gme2.sh ' . '"' .  a:args . '" 2>&1 | tee gme2.findresult'
+    call OpenOrSwitch(worktree . '/' . 'gme2.findresult', 'vs')
+endfunction
+
+function! s:G(args, ...) abort
+    if &modified
+        echom 'Please check and save your file first!!!'
+        return 0
+    endif
+
+    if expand('%:p') =~ '^fugitive:/'
+        return
+    endif
+
+    if &diff
+        exec '!git reset HEAD ; git add ' . '"' .  expand('%:p') . '"'
+    endif
+
+    let worktree = Cd2Worktree()
+    call asyncrun#run('<bang>', '', '~/loadrc/gitrc/g.sh ' . '"' .  a:args . '" 2>&1 | tee g.runresult')
+
+    if &diff
+        call s:Gs()
+        on
+        set winwidth=999999
+        wincmd |
+        syntax on
+        windo diffoff
+        windo set wrap
+        e
+    endif
+endfunction
+
+function! s:Gdev() abort
+    let worktree = Cd2Worktree()
+    call asyncrun#run('<bang>', '', '~/loadrc/gitrc/gdev.sh')
+endfunction
+
+function! s:Hdi() abort
+    let worktree = Cd2Worktree()
+    let output = 'hdi.diff'
+
+    silent exec '!~/loadrc/hgrc/hdi.sh' . ' HEAD 2>&1 | tee ' . '"' .  output . '"'
+
+    if bufwinnr('^' . output . '$') > 0
+        exe "bd!" . output
+    endif
+
+    call OpenOrSwitch(output, 'vs')
+endfunction
+
+function! s:Gdi(...) abort
+    let worktree = Cd2Worktree()
+    let arg1 = (a:0 >= 1) ? a:1 : ''
+    let output = 'gdi.diff'
+
+    if expand('%:t') != 'index'
+        if arg1 == ''
+            call fugitive#Diffsplit(0, 1, "vert", '', [])
+        elseif tolower(arg1) == 'o'
+            let target = substitute(system("git config gsync.target"), '\n', '', '')
+            call fugitive#Diffsplit(1, 0, 'vert', target, [target])
+        else
+            call fugitive#Diffsplit(0, 1, "vert", arg1, [arg1])
+        endif
+        return
+    else
+        let arg1 = (a:0 >= 1) ? a:1 : ''
+        exec '!~/loadrc/gitrc/gdi.sh HEAD ' . '"' .  arg1 . '" 2>&1 | tee ' . '"' .  output . '"'
+    endif
+
+    if bufwinnr('^' . output . '$') > 0
+        exe "bd!" . output
+    endif
+
+    let worktree = Cd2Worktree()
+    call OpenOrSwitch(output, 'vs')
+endfunction
+
+function! s:Gdit() abort
+    let worktree = Cd2Worktree()
+    let current_branch = substitute(system("~/loadrc/gitrc/get_current_branch.sh"), '\n', '', '')
+    let output = current_branch . '.gdit.diff'
+    let output = substitute(output, "/", "_", "g")
+    exec '!~/loadrc/gitrc/gdit.sh' . ' ' . '"' .  output . '" 2>&1 | tee ' . 'gdit.runresult'
+
+    if bufwinnr('^' . output . '$') > 0
+        exe "bd!" . output
+    endif
+
+    let worktree = Cd2Worktree()
+    call OpenOrSwitch('gdit.runresult', 'vs')
+    call OpenOrSwitch(output, 'vs')
+endfunction
+
+function! s:Gdio(...) abort
+    let worktree = Cd2Worktree()
+    let current_branch = substitute(system("~/loadrc/gitrc/get_current_branch.sh"), '\n', '', '')
+    let output = current_branch . '.gdio.diff'
+    let output = substitute(output, "/", "_", "g")
+    exec '!~/loadrc/gitrc/gdio.sh'
+
+    if bufwinnr('^' . output . '$') > 0
+        exe "bd!" . output
+    endif
+
+    let worktree = Cd2Worktree()
+    call OpenOrSwitch(output, 'vs')
+endfunction
+
+function! s:Gdi2(...) abort
+    if (expand("%") !~ '.*fix.gdit.diff')
+        return
+    endif
+
+    let worktree = Cd2Worktree()
+    let output = 'gdi2.runresult'
+    let arg1 = (a:0 >= 1) ? a:1 : ''
+    exec '!~/loadrc/gitrc/gdi2.sh ' . '"' .  arg1 . '"' . ' 2>&1 | tee ' . '"' .  output . '"'
+    call OpenOrSwitch(output, 'vs')
+endfunction
+
+function! s:Grtv() abort
+    let worktree = Cd2Worktree()
+    call OpenOrSwitch('git/config', 'vs')
+endfunction
+
+function! s:Grtu() abort
+    let worktree = Cd2Worktree()
+    silent exec '!git remote update'
+endfunction
+
+function! s:Gtg() abort
+    let worktree = Cd2Worktree()
+    silent exec '!git tag -l -n1 2>&1 | tee gtg.findresult'
+    call OpenOrSwitch('gtg.findresult', 'vs')
+endfunction
+
+function! s:Gmet() abort
+    let worktree = Cd2Worktree()
+    call asyncrun#run('<bang>', '', 'git mergetool')
+endfunction
+
+function! s:Gicb() abort
+    let worktree = Cd2Worktree()
+    call asyncrun#run('<bang>', '', '~/loadrc/gitrc/gicb.sh')
+endfunction
+
+function! s:Gitk(...) abort
+    let worktree = Cd2Worktree()
+    let arg1 = (a:0 >= 1) ? a:1 : ''
+    let arg2 = (a:0 >= 2) ? a:2 : ''
+    call asyncrun#run('<bang>', '', 'gitk ' . '"' .  arg1 . '"' . ' ' . '"' .  arg2 . '"')
+endfunction
+
+function! s:Gbrm(...) abort
+    let worktree = Cd2Worktree()
+    let arg1 = (a:0 >= 1) ? a:1 : ''
+    exec '!~/loadrc/gitrc/gbrm.sh ' . '"' .  arg1 . '"'
+endfunction
+
+function! s:Gbrd(...) abort
+    let worktree = Cd2Worktree()
+    let arg1 = (a:0 >= 1) ? a:1 : ''
+    exec '!~/loadrc/gitrc/gbrd.sh ' . '"' .  arg1 . '"'
+endfunction
+
+function! s:Gdif(...) abort
+    let worktree = Cd2Worktree()
+    let target = substitute(system("git config gsync.target"), '\n', '', '')
+    let target = (a:0 >= 1) ? a:1 : target
+    let reverse = (a:0 >= 2) ? a:2 : ''
+
+    if target ==# '-r'
+        let target = substitute(system("git config gsync.target"), '\n', '', '')
+        let reverse = '-r'
+    endif
+
+    let output = GetEscapedResult(target) . '.diff'
+    exec '!~/loadrc/gitrc/gdif.sh ' . '-b "' .  target . '" -f "' .  expand("%:p") . '" ' . reverse .  ' 2>&1 | tee ' . output
+    call OpenOrSwitch(output, 'vs')
+endfunction
+
+function! s:Gco(...) abort
+    let worktree = Cd2Worktree()
+    let arg1 = (a:0 >= 1) ? a:1 : ''
+    exec '!~/loadrc/gitrc/gco.sh ' . '"' .  arg1 . '" 2>&1 | tee ' . 'gco.runresult'
+    call OpenOrSwitch('gco.runresult', 'vs')
+endfunction
+
+function! s:Gcob(...) abort
+    let worktree = Cd2Worktree()
+    let arg1 = (a:0 >= 1) ? a:1 : ''
+    let arg2 = (a:0 >= 2) ? a:2 : ''
+    call asyncrun#run('<bang>', '', '~/loadrc/gitrc/gcob.sh ' . '"' .  arg1 . '" "' .  arg2 . '"')
+endfunction
+
+function! s:Dodev() abort
+    let worktree = Cd2Worktree()
+    call OpenOrSwitch('docker-compose.yml', 'vs')
+endfunction
+
+function! s:KdiffFile() abort
+    only
+    call asyncrun#stop('<bang>')
+    call asyncrun#run('<bang>', '', '~/loadrc/leetcoderc/KdiffFile.py ' . '"' .  expand("%:p") . '"')
+endfunction
+
+function! s:ApplyBranch(args, ...) abort
+    let worktree = Cd2Worktree()
+    exec '!~/loadrc/gitrc/apply_branch.sh ' . '"' .  a:args . '"'
+    call s:Gs()
+endfunction
+
+function! s:Gcom(args, ...) abort
+    let worktree = Cd2Worktree()
+    exec '!~/loadrc/gitrc/gcom.sh ' . '"' .  a:args . '"'
+endfunction
+
+function! s:Gshow(args, ...) abort
+    let worktree = Cd2Worktree()
+    let output = a:args . '.diff'
+    silent exec '!~/loadrc/gitrc/gshow.sh ' . '"' .  a:args . '" 2>&1 | tee ' . output
+    call OpenOrSwitch(output, 'vs')
+endfunction
+
+function! s:Gsubbr() abort
+    let worktree = Cd2Worktree()
+    let output = 'git_submodules_branch.log'
+    silent exec '!~/loadrc/gitrc/git_submodules_branch.sh 2>&1 | tee ' . output
+    call OpenOrSwitch(output, 'vs')
+endfunction
+
+function! s:Copy(...) abort
+    if &modified
+        echom 'Please check and save your file first!!!'
+        return 0
+    endif
+
+    let newFile = (a:0 >= 1) ? a:1 : expand("%:p") . '.bak'
+    exec '!rm ' . newFile
+    exec 'w ' . newFile
+    call OpenOrSwitch(newFile, 'vs')
+endfunction
+
+function! s:CatPlay(...) abort
+    if &modified
+        echom 'Please check and save your file first!!!'
+        return 0
+    endif
+
+    call asyncrun#stop('<bang>')
+    let b:output = expand("%:p") . '.runresult'
+    call asyncrun#run('<bang>', '', '~/loadrc/vishrc/cat_play.sh ' . '"' . expand("%:p") . '"' . ' 2>&1 | tee ' . b:output)
+    call OpenOrSwitch(b:output, 'vs')
+endfunction
+
+function! s:SelectMove(...) abort
+    if &modified
+        echom 'Please check and save your file first!!!'
+        return 0
+    endif
+
+    if a:0 >= 1
+        let b:output = expand("%:p") . '.runresult'
+        exec '!~/loadrc/bashrc/select_move.sh ' . '"' .  expand("%:p") . '"' . ' ' . '"' . a:1 . '" 2>&1 | tee ' . b:output
+        call OpenOrSwitch(b:output, 'vs')
+    endif
+
+    if a:0 >= 2
+        exec '!' . '"' . a:2 . '"'
+    endif
+
+    call asyncrun#run('<bang>', '', '~/loadrc/bashrc/update_proj.sh')
+endfunction
+
+function! s:CatMove(...) abort
+    if &modified
+        echom 'Please check and save your file first!!!'
+        return 0
+    endif
+
+    if a:0 >= 1
+        exec '!~/loadrc/vishrc/cat_move.sh ' . '"' .  expand("%:p") . '"' . ' ' . '"' . a:1 . '"'
+    endif
+
+    call asyncrun#run('<bang>', '', '~/loadrc/bashrc/update_proj.sh')
+endfunction
+
+function! s:FileMove(...) abort
+    if a:0 >= 1
+        let curword = GetWord()
+        let b:netrw_curdir = getcwd()
+        let map_escape = "<|\n\r\\\<C-V>\""
+        let mapsafecurdir = escape(b:netrw_curdir, map_escape)
+        let oldname = ComposePath(mapsafecurdir, curword)
+
+        if filereadable(oldname)
+            exec '!~/loadrc/bashrc/file_move.sh ' . '"' .  oldname . '"' . ' ' . '"' . a:1 . '"'
+            let newname = a:1 . '/' . substitute(system("basename " . '"' . oldname . '"'), '\n', '', '')
+            let newname = substitute(system("realpath " . '"' . newname . '"'), '\n', '', '')
+            let newname = substitute(newname, getcwd(), '.', 'e')
+            call setline('.', '"' . newname . '"')
+            call UpdateProj()
+        endif
+
+    endif
+
+    call asyncrun#run('<bang>', '', '~/loadrc/bashrc/update_proj.sh')
+endfunction
+
+
+function! s:AppendRate(...) abort
+    if a:0 >= 1
+        let curword = GetWord()
+        let b:netrw_curdir = getcwd()
+        let map_escape = "<|\n\r\\\<C-V>\""
+        let mapsafecurdir = escape(b:netrw_curdir, map_escape)
+        let oldname = ComposePath(mapsafecurdir, curword)
+
+        if filereadable(oldname)
+            exec '!~/loadrc/bashrc/append_rate.sh ' . '"' .  oldname . '"' . ' ' . '"' . a:1 . '"'
+            let newname = substitute(system("~/loadrc/bashrc/append_num.sh " . '"' . oldname . '"' . ' ' . '"' . a:1 . '"'), '\n', '', '')
+            let newname = substitute(newname, getcwd(), '.', 'e')
+            call setline('.', '"' . newname . '"')
+            call UpdateProj()
+        endif
+
+    endif
+
+    call asyncrun#run('<bang>', '', '~/loadrc/bashrc/update_proj.sh')
+endfunction
+
+function! s:CatBadFiles(...) abort
+    if &modified
+        echom 'Please check and save your file first!!!'
+        return 0
+    endif
+
+    exec '!~/loadrc/ffmpegrc/cat_bad_files.sh ' . '"' .  expand("%:p") . '" 2>&1 | tee cat_bad_files.runresult'
+
+    if a:0 >= 1
+        exec '!' . '"' . a:1 . '"'
+    endif
+
+    call OpenOrSwitch('cat_bad_files.runresult', 'vs')
+    call asyncrun#run('<bang>', '', '~/loadrc/bashrc/update_proj.sh')
+endfunction
+
+function! s:CatRate(...) abort
+    if &modified
+        echom 'Please check and save your file first!!!'
+        return 0
+    endif
+
+    if a:0 >= 1
+        exec '!~/loadrc/vishrc/cat_rate.sh ' . '"' .  expand("%:p") . '"' . ' ' . '"' . a:1 . '"'
+    endif
+
+    call asyncrun#run('<bang>', '', '~/loadrc/bashrc/update_proj.sh')
+endfunction
+
+function! s:RmCat(...) abort
+    if &modified
+        echom 'Please check and save your file first!!!'
+        return 0
+    endif
+
+    if expand('%:e') != "findresult"
+        echom 'Please only run this command in findresult file'
+        return 0
+    endif
+
+    let b:output = expand("%:p") . '.runresult'
+    call RunShell('~/loadrc/vishrc/rm_cat.sh', expand("%:p"), b:output)
+    call OpenOrSwitch(b:output, 'vs')
+endfunction
+
+function! s:CatDu(...) abort
+    if &modified
+        echom 'Please check and save your file first!!!'
+        return 0
+    endif
+
+    let b:output = expand("%:p") . '.runresult'
+    call RunShell('~/loadrc/vishrc/cat_du.sh', expand("%:p"), b:output)
+    call OpenOrSwitch(b:output, 'vs')
+endfunction
+
+function! s:CatRun(...) abort
+    if &modified
+        echom 'Please check and save your file first!!!'
+        return 0
+    endif
+
+    let b:output = expand("%:p") . '.runresult'
+    call RunShell('~/loadrc/vishrc/cat_run.sh', expand("%:p"), b:output)
+    call OpenOrSwitch(b:output, 'vs')
+endfunction
+
+function! s:Tail() abort
+    exec '!tail -f ' . expand("%:p")
+endfunction
+
+function! s:Gres() abort
+    let worktree = Cd2Worktree()
+    exec '!~/loadrc/gitrc/gres.sh'
+endfunction
+
+function! s:GrevApply() abort
+    exec '!git apply --reverse --reject --whitespace=fix --recount ' . '"' .  expand('%:p') . '"'
+endfunction
+
+function! s:Dps() abort
+    let worktree = Cd2Worktree()
+    silent exec '!~/loadrc/dockerrc/dps.sh'
+    call OpenOrSwitch('dps.findresult', 'vs')
+endfunction
+
+function! s:SvnUp() abort
+    let worktree = Cd2Worktree()
+    call asyncrun#run('<bang>', '', '~/loadrc/svnrc/svnup.sh')
+endfunction
+
+function! s:SvnReset() abort
+    let worktree = Cd2Worktree()
+    silent exec '!~/loadrc/svnrc/svnreset.sh'
+    call OpenOrSwitch('svnreset.findresult', 'vs')
+endfunction
+
+function! s:SvnRevert() abort
+    let worktree = Cd2Worktree()
+    call asyncrun#run('<bang>', '', '~/loadrc/svnrc/svnrevert.sh ' . '"' .  expand('%:p') . '"')
+endfunction
+
+function! s:SvnSt() abort
+    let worktree = Cd2Worktree()
+    silent exec '!~/loadrc/svnrc/svnst.sh'
+    call OpenOrSwitch('svnst.findresult', 'vs')
+endfunction
+
+function! s:SvnApply() abort
+    let worktree = Cd2Worktree()
+    call asyncrun#run('<bang>', '', '~/loadrc/svnrc/svnapply.sh')
+endfunction
+
+function! s:SvnDiff() abort
+    let worktree = Cd2Worktree()
+    call asyncrun#run('<bang>', '', '~/loadrc/svnrc/svndiff.sh ' . '"' .  expand('%:p') . '"')
+endfunction
+
+function! s:LcTest() abort
+    if (expand("%") !~ '.*leetcode.*') || (expand("%") =~ '.*\.sh')
+        return
+    endif
+    silent exec '!~/loadrc/vishrc/lc_test.sh ' . '"' .  expand('%:p') . '"'
+    call OpenOrSwitch(expand('%:p') . '.sh', 'vs')
+endfunction
+
+function! s:Portsforward() abort
+    call Cd2Worktree()
+    exec '!~/loadrc/bashrc/do_ports_forward.sh 2>&1 | tee do_ports_forward.runresult'
+    call OpenOrSwitch('do_ports_forward.runresult', 'vs')
+endfunction
+
+function! s:Prune() abort
+    call asyncrun#run('<bang>', '', '~/loadrc/vishrc/prune.sh ' . '"' .  expand('%:p') . '"')
+endfunction
+
+function! s:Fr(...) abort
+    let find = (a:0 >= 1) ? a:1 : ''
+    let replace = (a:0 >= 2) ? a:2 : ''
+    let word_only = (a:0 >= 3) ? a:3 : ''
+    call Cd2ProjectRoot("files.proj")
+
+    if expand('%:t') != 'index'
+        let fileList = expand('%:p')
+    else
+        let fileList = "files.proj"
+    endif
+
+    exec '!~/loadrc/bashrc/fr.sh ' . '"' .  find . '"' . ' ' . '"' .  replace . '"' . ' ' . '"' .  fileList . '"' . ' ' . '"' .  word_only . '"'
+    call s:Gs()
+endfunction
+
+function! s:FindDeleted() abort
+    call Cd2Worktree()
+    silent exec '!~/loadrc/gitrc/find_deleted.sh 2>&1 | tee find_deleted.runresult'
+    call OpenOrSwitch('find_deleted.runresult', 'vs')
+endfunction
+
+function! s:Gwap() abort
+    let worktree = Cd2Worktree()
+    silent exec '!~/loadrc/gitrc/gwap.sh'
+    call s:Gs()
+endfunction
+
+function! s:Gfix() abort
+    let worktree = Cd2Worktree()
+    exec '!~/loadrc/gitrc/gfix.sh'
+endfunction
+
+function! s:Reapply() abort
+    if (expand("%") !~ '.*.diff')
+        echom 'Please only run on *gdio.diff!!!'
+        return 0
+    endif
+
+    let worktree = Cd2Worktree()
+    let output = 'reapply.runresult'
+    exec '!~/loadrc/gitrc/reapply.sh ' . '"' .  expand("%:p") . '"' . ' 2>&1 | tee ' . '"' .  output . '"'
+    call OpenOrSwitch(output, 'vs')
+    call s:Gs()
+endfunction
+
+function! s:Split() abort
+    let worktree = Cd2Worktree()
+    exec '!~/loadrc/bashrc/split.sh ' . '"' .  expand('%:t') . '"'
+endfunction
+
+function! s:SortByTime() abort
+    let worktree = Cd2Worktree()
+    exec '!~/loadrc/vishrc/sort_entries.sh ' . '"' .  expand('%:p') . '"' . ' time'
+endfunction
+
+function! s:SortBySize() abort
+    let worktree = Cd2Worktree()
+    exec '!~/loadrc/vishrc/sort_entries.sh ' . '"' .  expand('%:p') . '"' . ' size'
+endfunction
+
+function! s:GenerateIpynb() abort
+    let worktree = Cd2Worktree()
+    exec '!~/loadrc/ipynbrc/generate_ipynb.sh ' . '"' .  expand('%:p') . '"'
+    w
+endfunction
+
+let g:fugitive_legacy_commands = 1
diff --git a/vimrc/.vim/plugin/git.vim b/vimrc/.vim/plugin/git.vim
new file mode 100644
diff --git a/vimrc/.vim/plugin/keymap.vim b/vimrc/.vim/plugin/keymap.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/keymap.vim
@@ -0,0 +1,548 @@
+function! RememberQuit()
+    let @" = expand("%:p")
+
+    if winbufnr(2) == -1 && &buftype !=# "terminal"
+        return
+    endif
+
+    quit
+endfunction
+
+function! ExFilter()
+    if (expand("%") ==# 'fav.log.sort')
+        return
+    endif
+
+    call Filter2Findresult()
+    silent exec 'g/' . @/ . '/d'
+
+    try
+        w!
+    catch
+    endtry
+endfunction
+
+function! ExtractHighLight()
+    if (expand("%") ==# 'fav.log.sort')
+        return
+    endif
+
+    call Filter2Findresult()
+    silent exec '%s/.*\(' . @/ . '\).*/\1/g'
+    w!
+endfunction
+
+
+function! Vdelete()
+    if (expand("%") ==# 'fav.log.sort')
+        return
+    endif
+
+    call Filter2Findresult()
+    silent exec '%s/' . @/ . '//g'
+    w!
+endfunction
+
+if !exists('g:VeryLiteral')
+    let g:VeryLiteral = 0
+endif
+
+function! HighlightKeyword(keyword)
+    let old_reg = getreg('"')
+    let old_regtype = getregtype('"')
+    let @@ = a:keyword
+    if @@ =~? '^[0-9a-z,_]*$' || @@ =~? '^[0-9a-z ,_]*$' && g:VeryLiteral
+        let @/ = '\c' . a:keyword
+    else
+        let pat = escape(@@, '\')
+        if g:VeryLiteral
+            let pat = substitute(pat, '\n', '\\n', 'g')
+        else
+            let pat = substitute(pat, '^\_s\+', '\\s\\+', '')
+            let pat = substitute(pat, '\_s\+$', '\\s\\*', '')
+            let pat = substitute(pat, '\_s\+', '\\_s\\+', 'g')
+            let pat = substitute(pat, '\\!', '!', 'g')
+            let pat = substitute(pat, '\\"', '"', 'g')
+        endif
+        let @/ = '\c' . pat
+    endif
+    normal! gV
+    call setreg('"', old_reg, old_regtype)
+endfunction
+
+function! VFilter()
+    if (expand("%") ==# 'fav.log.sort')
+        return
+    endif
+
+    call Filter2Findresult()
+    silent exec 'g!/' . @/ . '/d'
+
+    try
+        w!
+    catch
+    endtry
+endfunction
+
+function! ShowRemember()
+    let b:csdbpath = Cd2ProjectRoot("files.proj")
+    " let relativePath = substitute(system('realpath --relative-to="' . b:csdbpath . '" ' . expand('%:p')), '\n', '', '')
+
+    " echom relativePath
+    call SendTextToPbCopy(expand('%:p'))
+
+    if &clipboard == 'unnamed'
+        let @* = expand('%:p')
+    else
+        let @+ = expand('%:p')
+    endif
+endfunction
+
+function! Filter()
+    let b:keyword = expand("<cword>")
+    exec '%g!/' . b:keyword . '/d'
+endfunction
+
+function! PlayVideo()
+    if &buftype ==# "terminal"
+        return 0
+    endif
+
+    let line = getline('.')
+    let line = substitute(line, '\_s\+$', '', 'g')
+    let line = substitute(line, '^[^"]', '"' . line[0], '')
+    let line = substitute(line, '[^"]$', line[strlen(line) - 1] . '"', '')
+    call asyncrun#run('<bang>', '', '~/loadrc/pythonrc/vlc.py ' . '"' . expand("%:p") . '"' .  ' ' . line)
+endfunction
+
+function! VDebug()
+    if g:asyncrun_status ==# 'running'
+        echom 'background job is still running'
+        return 0
+    endif
+
+    let b:file_name = expand('%:t')
+    let b:to_run = expand("%:p")
+
+    if filereadable(b:to_run . '.sh')
+        let b:to_run = b:to_run . '.sh'
+    endif
+
+    let b:csdbpath = Cd2ProjectRoot("files.proj")
+    let b:output = b:csdbpath . '/' . b:file_name . '.runresult'
+    call RunShell('~/loadrc/vishrc/vdebug.sh', b:to_run, b:output)
+
+    if b:to_run != 'gbil.log'
+        call OpenOrSwitch(b:output, 'vs')
+    else
+        call OpenOrSwitch('gbil.log', 'vs')
+    endif
+endfunction
+
+function! VRun()
+    if &modified
+        echom 'Please check and save your file first!!!'
+        return 1
+    endif
+
+    if g:asyncrun_status ==# 'running'
+        echom 'background job is still running'
+        return 0
+    endif
+
+    let b:file_name = expand('%:t')
+    let b:to_run = expand("%:p")
+
+    if (expand('%:e') ==# 'php')
+        exec '!~/loadrc/imvurc/generate.sh ' . '"' .  expand('%:p') . '"'
+    endif
+
+    if filereadable(b:to_run . '.lsh')
+        let b:to_run = b:to_run . '.lsh'
+    elseif filereadable(b:to_run . '.sh')
+        let b:to_run = b:to_run . '.sh'
+    endif
+
+    let b:csdbpath = Cd2Worktree()
+    let b:output = b:csdbpath . '/' . b:file_name . '.runresult'
+    silent exec '!~/loadrc/bashrc/deploy.sh 2>&1 | tee deploy.findresult'
+    call RunShell('~/loadrc/vishrc/vrun.sh', b:to_run, b:output)
+
+    if (expand("%") =~ '.*leetcode.*')
+        call asyncrun#run('<bang>', '', '~/loadrc/leetcoderc/post_submit.sh ' . '"' .  b:file_name . '"' . ' 2>&1 | tee post_submit.log')
+    endif
+
+    if b:to_run != 'gbil.log'
+        call OpenOrSwitch(b:output, 'vs', '')
+    else
+        call OpenOrSwitch('gbil.log', 'vs')
+    endif
+
+    call asyncrun#run('<bang>', '', '~/loadrc/bashrc/update_proj.sh')
+endfunction
+
+function! SearchAgain()
+    call Cd2ProjectRoot('files.proj')
+    let keyword = substitute(@/, '\\c', '', '')
+    let keyword = substitute(keyword, '\\<', '', '')
+    let keyword = substitute(keyword, '\\>', '', '')
+    let b:result = GetEscapedResult(keyword)
+    exec '!~/loadrc/vishrc/vsearch.sh ' . expand("%:p") . ' "' .  keyword . '"' . ' "w" ' . '"' . b:result . '"'
+    call OpenOrSwitch(b:result . '.findresult', 'vs')
+endfunction
+
+function! GetFirstColumnOfFile()
+    if (expand('%:e') ==# 'bak')
+        return 0
+    endif
+
+    silent exec '!~/loadrc/bashrc/get_first_column_of_file.sh ' . '"' .  expand("%:p") . '"'
+    call OpenOrSwitch(expand("%:p") . '.tmp', 'vs')
+endfunction
+
+function! CSCSearch(num)
+    " 0 Find this C symbol:
+    " 1 Find this function definition:
+    " 2 Find functions called by this function:
+    " 3 Find functions calling this function:
+    " 4 Find this text string:
+    " 5 Change this text string:
+    " 6 Find this egrep pattern:
+    " 7 Find this file:
+    " 8 Find files #including this file:
+    call Cd2ProjectRoot('files.proj')
+    let keyword = tolower(expand("<cword>"))
+    let b:result = GetEscapedResult(keyword)
+    silent exec '!~/loadrc/vishrc/vsearch.sh ' . "files.proj" . ' "' .  keyword . '"' . ' "' .  a:num . '" ' . '"' . b:result . '"'
+    call OpenOrSwitch(b:result . '.findresult', 'vs')
+    set winwidth=999999
+    call HighlightKeyword(keyword)
+endfunction
+
+function! SearchOpen()
+    normal! gvy<CR>
+    let keyword = @@
+    call Cd2ProjectRoot("files.proj")
+    let find_file = substitute(system("~/loadrc/gitrc/find_files.sh " . '"' .  keyword . '"'), '\n', '', '')
+    call OpenOrSwitch(find_file, 'vs')
+endfunction
+
+function! ShowDiff()
+    let b:commit = expand("<cword>")
+    call asyncrun#run('<bang>', '', '~/loadrc/gitrc/gvlg.sh ' . '"' .  b:commit . '"')
+endfunction
+
+function! Prune()
+    if (expand('%:e') ==# 'findresult' || expand('%:e') ==# 'bak')
+        let line = getline('.')
+        normal dd
+        w
+        silent exec '!~/loadrc/vishrc/prune.sh ' . '"./' .  line . '"'
+    else
+        silent exec '!~/loadrc/vishrc/prune.sh ' . '"' .  expand('%:p') . '"'
+        call RememberQuit()
+    endif
+    call UpdateProj()
+endfunction
+
+function! OpenAll()
+    call GetFirstColumnOfFile()
+    let currentDir = getcwd()
+    let currentFile = expand('%:p')
+    let lines = readfile(currentFile)
+
+    on
+    for line in lines
+        let line = substitute(line, '"', '', "g")
+        exec 'vs ' . currentDir . '/' . line
+    endfor
+    windo set nowrap
+    " set winwidth=999999
+    " wincmd |
+
+    let bnr = bufwinnr('^' . currentFile . '$')
+    exe bnr . "wincmd w"
+    q
+endfunction
+
+function! DiffAll()
+    let currentFile = expand("%:p")
+    if &diff
+        syntax on
+        windo diffoff
+    else
+        set winwidth=1
+        syntax off
+        windo diffthis
+        windo set nowrap
+        wincmd =
+    endif
+    call OpenOrSwitch(currentFile, 'vs')
+endfunction
+
+function! KdiffAll()
+    call GetFirstColumnOfFile()
+
+    if &buftype ==# "terminal"
+        return 0
+    endif
+
+    only
+    call asyncrun#stop('<bang>')
+    call asyncrun#run('<bang>', '', '~/loadrc/vishrc/kdiffall.sh ' . '"' .  expand('%:p') . '"')
+endfunction
+
+function! UpdateProj()
+    call Cd2ProjectRoot("files.proj")
+    call asyncrun#run('<bang>', '', '~/loadrc/bashrc/update_proj.sh')
+    call CHANGE_CURR_DIR()
+endfunction
+
+function! VimOpen()
+    let b:fileName = expand(expand("<cfile>"))
+    let b:filePath = fnamemodify(expand(expand("<cfile>")), ":p:h")
+
+    if b:fileName =~? '\.\(pptx\|doc\|docx\)$'
+        exec '!open ' . '"' .  b:fileName . '"'
+        return
+    endif
+
+    if (expand("%") ==# 'index')
+        let realFile = GetWorktree() . '/' . b:fileName . ''
+        let indexFile = getcwd() . '/../' . b:fileName . '/.git/index'
+        let moduleIndexFile = getcwd() . '/modules/' . b:fileName . '/index'
+
+        if filereadable(realFile)
+            call OpenOrSwitch(realFile, 'vs')
+        elseif filereadable(indexFile)
+            call OpenOrSwitch(indexFile, 'vs')
+        elseif filereadable(moduleIndexFile)
+            call OpenOrSwitch(moduleIndexFile, 'vs')
+        else
+            call OpenOrSwitch(realFile, 'vs')
+        endif
+    elseif (expand("%") ==# 'gbr.findresult')
+        let b:commit = expand("<cword>")
+        exec '!git checkout ' . '"' .  b:commit . '"'
+    elseif (expand("%") ==# 'gbil.log')
+        let b:commit = expand("<cword>")
+        call Cd2Worktree()
+        exec '!~/loadrc/gitrc/discard_unnecessaries.sh ; git checkout ' . '"' .  b:commit . '"'
+    elseif (expand("%") ==# 'glg.findresult')
+        let b:commit = expand("<cword>")
+        exec '!git checkout ' . '"' .  b:commit . '"'
+    elseif (expand("%") ==# 'dps.findresult')
+        let b:commit = expand("<cword>")
+        call asyncrun#run('<bang>', '', '~/loadrc/dockerrc/edocker.sh ' . '"' .  b:commit . '"')
+    elseif (expand("%") ==# 'fdocs.list')
+        exec '!open ' . '"' .  expand(expand("<cfile>")) . '"'
+    elseif (b:fileName =~ '.*.diff$')
+        let b:commit = expand("<cword>")
+        let output = b:commit . '.diff'
+
+        if !filereadable(output)
+            silent exec '!~/loadrc/gitrc/gshow.sh ' . '"' .  b:commit . '" 2>&1 | tee ' . output
+        endif
+
+        call OpenOrSwitch(b:fileName, 'vs')
+    elseif (&filetype ==# 'fugitiveblame')
+        let b:commit = expand("<cword>")
+        call Cd2Worktree()
+        exec '!~/loadrc/gitrc/discard_unnecessaries.sh ; git diff --quiet && git diff HEAD --quiet &&  git checkout -f ' . '"' .  b:commit . '^"'
+        ""call fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . 'blame' . ' " . <q-args>)
+        "let s:cmd = 'Blame'
+        "exec 'command! -bang -nargs=? -range=-1 -complete=customlist,fugitive#' . s:cmd . 'Complete G' . tolower(s:cmd) 'exe fugitive#Command(<line1>, <count>, +"<range>", <bang>0, "<mods>", "' . tolower(s:cmd) . ' " . <q-args>)'
+        ""call fugitive#Gblame()
+    else
+        if !filereadable(b:fileName)
+            if !isdirectory(b:filePath)
+                call mkdir(b:filePath, "p")
+            endif
+        endif
+        call OpenOrSwitch(b:fileName, 'vs')
+    endif
+endfunction
+
+function! GitSearch()
+    let keyword = substitute(@/, '\\c', '', '')
+    let keyword = substitute(keyword, '\\<', '', '')
+    let keyword = substitute(keyword, '\\>', '', '')
+    let keyword = substitute(keyword, '\\V', '', '')
+    let b:result = GetEscapedResult(keyword) . '.runresult'
+    let fileList = expand('%:p')
+
+    call Cd2Worktree()
+    exec '!~/loadrc/gitrc/gsearch.sh ' . '"' .  keyword . '"' . ' "' .  b:result . '"' . ' ' . '"' .  fileList . '"'
+    call OpenOrSwitch(b:result, 'vs')
+    call HighlightKeyword(keyword)
+endfunction
+
+function! VimSearch()
+    normal! gvy<CR>
+    call Cd2ProjectRoot('files.proj')
+    let keyword = GetEscapedKeyword(@@)
+    let b:result = GetEscapedResult(keyword)
+    silent exec '!~/loadrc/vishrc/vsearch.sh ' . "files.proj" . ' "' .  keyword . '"' . ' "w" ' . '"' . b:result . '"'
+    call OpenOrSwitch(b:result . '.findresult', 'vs')
+    exec 'e'
+    call HighlightKeyword(keyword)
+endfunction
+
+function! SwitchWinSize()
+    if &winwidth == 1
+        set winwidth=999999
+        wincmd |
+    else
+        set winwidth=1
+        wincmd =
+    endif
+endfunction
+
+nnoremap <leader>l :TlistClose<CR>:TlistToggle<cr>
+nnoremap <leader>L :TlistClose<cr>
+nnoremap hh <c-w>h
+nnoremap ll <c-w>l
+nnoremap mn :call SwitchWinSize()<cr>
+nnoremap ff <c-f>
+nnoremap vv <c-b>
+nnoremap <c-l> l
+nnoremap <c-h> h
+" Toggle show/hide invisible chars
+nnoremap <leader>i :set list!<cr>
+" Toggle line numbers
+nnoremap <leader>N :setlocal number!<cr>
+" Thanks to Steve Losh for this liberating tip
+" See http://stevelosh.com/blog/2010/09/coming-home-to-vim
+" nnoremap / /\v\c
+" vnoremap / /\v\c
+nnoremap / /\c
+vnoremap / /\c
+nnoremap ? ?\c
+vnoremap ? ?\c
+" Speed up scrolling of the viewport slightly
+nnoremap <C-e> 2<C-e>
+nnoremap <C-y> 2<C-y>
+nnoremap <Space> za
+vnoremap <Space> za
+"inoremap <silent> <leader>f <C-O>za
+"nnoremap <silent> <leader>f za
+"onoremap <silent> <leader>f <C-C>za
+"vnoremap <silent> <leader>f zf
+nnoremap <silent> <leader>e :call VsMax($HOME . "/.bash_history") <CR>
+nnoremap <silent> <leader>f :call ShowRemember()<cr>
+nnoremap <silent> <leader>v :so $MYVIMRC<cr>
+nnoremap <leader>sh :execute "leftabove vs" bufname('#')<cr>
+nnoremap <leader>sl :execute "rightbelow vs" bufname('#')<cr>
+nnoremap W :call VsMax(".")<CR>
+" Quickly reload current file
+nnoremap E :mkview<CR>:e!<CR>
+" Quickly save current file
+nnoremap S :w!<cr>
+" Quickly save and exit
+nnoremap X :x<cr>
+nnoremap <leader>Y "+yy
+nnoremap <leader>p "+p
+nnoremap <leader>P "+P
+nnoremap tt :Autoformat<CR>:w!<cr>
+nnoremap D :call OpenDup()<CR>
+" Quickly open current dir in current windows
+nnoremap <tab> %
+vnoremap <tab> %
+nnoremap M zM
+nnoremap R zR
+nmap <leader>w :call WinDo('set wrap!') <cr>
+
+" nnoremap F :echom expand('%:p')<cr>
+vnoremap <silent>f :call VimSearch()<cr>
+vnoremap <silent>s :call GitSearch()<cr>
+vnoremap <silent>t :call SearchAgain()<cr>
+nnoremap mc :set cursorline!<cr>
+" nnoremap mc :set hlsearch!<cr>
+nnoremap mg :call VFilter()<cr>
+nnoremap me :call ExtractHighLight()<cr>
+nnoremap mf :call ExFilter()<cr>
+nnoremap md :call Vdelete()<cr>
+nnoremap mo :call OpenAll()<cr>
+vnoremap <silent>o :call SearchOpen()<cr>
+nmap <C-s> :call CSCSearch(0)<cr>
+nnoremap <c-space> :call CSCSearch(4)<cr>
+nmap <C-@> :call CSCSearch(4)<cr>
+nmap <C-f> :call CSCSearch(7)<cr>
+nmap <C-e> :call CSCSearch(1)<cr>
+nmap <C-g> :call CSCSearch(3)<cr>
+nnoremap <leader>d :!rm "%:p"<CR>:q<cr>
+nmap <C-j> :call PlayVideo()<cr>
+nmap <C-p> :call Prune()<cr>
+nmap <C-k> :call KdiffAll()<cr>
+nmap <C-d> :call DiffAll()<cr>
+nmap mr :call LocalRename()<cr>
+" Quickly close the current window
+nnoremap Q :call RememberQuit()<cr>
+nnoremap qq :call RememberQuit()<cr>
+nnoremap H :call ShowVITAG()<cr>
+nnoremap F :call GetFirstColumnOfFile()<cr>
+nnoremap T :vs $HOME/all.proj<cr>
+nnoremap L :vs <C-R>"<cr>
+nnoremap <leader>r :call Reverse()<cr>
+map <F5> :call VRun()<cr><cr>
+map <F3> :call VDebug()<cr>
+" nnoremap gf gF<cr>
+nnoremap gf :call OpenOrSwitch(expand(expand("<cfile>")), 'goto')<cr>
+map oo :call VimOpen()<cr>
+nnoremap <silent> <leader>g :call asyncrun#run('<bang>', '', 'gitk --all -p --full-diff -- "' . expand("%:p") . '"')<cr>
+nnoremap <leader>1 :let @" = expand("%:p")<CR>
+
+function! CutFile2()
+    silent exec '!comm -2 -3 <(sort "' . @" . '") <(sort "' . expand("%:p") . '") > "' . @" . '".findresult'
+    silent exec '!cp -fv "' . @" . '.findresult' . '"' . ' ' . '"' . @" . '"'
+    call OpenOrSwitch(@", 'vs')
+endfunc
+
+function! CutCommon()
+    exec '!~/loadrc/bashrc/cutcommon.sh ' . '"' .  @" . '"'  . ' ' . '"' .  expand("%:p") . '"'
+endfunc
+
+nnoremap <leader>2 :call CutCommon()<cr>
+nnoremap <leader>3 :call CutFile2()<cr>
+set pastetoggle=<F3>            " when in insert mode, press <F3> to go to
+"    paste mode, where you can paste mass data
+"    that won't be autoindented
+
+" open tig with Project root path
+nnoremap <Leader>t :TigOpenProjectRootDir<CR>
+nnoremap <leader>T :TigOpenCurrentFile<CR>
+nnoremap <silent> ml :call CopyLineInfo()<cr>
+
+function! CopyLineInfo()
+    normal yy
+    let b:csdbpath = Cd2ProjectRoot("files.proj")
+    let relativePath = expand('%:p')
+    let relativePath = substitute(system('realpath --relative-to="' . b:csdbpath . '" "' . relativePath . '"'), '\n', '', '')
+    let relativePath = substitute(relativePath, '\_s', '\\ ', "g")
+    let content = relativePath . ':' . line('.') . ' ' . @"
+    let @" = content
+endfunction
+
+function! OpenDup()
+    only
+    let is_rej = 0
+
+    if (expand('%:e') ==# 'rej')
+        let is_rej = 1
+        let to_open = substitute(expand('%:p'), '\.rej', '', '')
+        silent exec 'vs ' . to_open
+    else
+        vs %:p
+    endif
+
+    set winwidth=1
+    wincmd =
+
+    if (is_rej == 1)
+        call DiffAll()
+    endif
+endfunction
+
+function! Reverse()
+    exec 'g/^/m0'
+endfunction
diff --git a/vimrc/.vim/plugin/ncm2.vim b/vimrc/.vim/plugin/ncm2.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/ncm2.vim
@@ -0,0 +1,7 @@
+" enable ncm2 for all buffers
+autocmd BufEnter * call ncm2#enable_for_buffer()
+
+" configuration for ncm2
+call ncm2#override_source('bufword', {'priority': 7})
+call ncm2#override_source('otherbuf', {'priority': 6})
+call ncm2#override_source('path', {'priority': 5})
diff --git a/vimrc/.vim/plugin/netrw.vim b/vimrc/.vim/plugin/netrw.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/netrw.vim
@@ -0,0 +1,70 @@
+fun! GetWord()
+    setl nosol
+    let dirname = getline('.')
+    let dirname = substitute(dirname, '\s\+$', '', 'e')
+    let dirname = substitute(dirname, "@$", "", "")
+    let dirname = substitute(dirname, "\*$", "", "")
+    let dirname = substitute(dirname, "^\"", "", "")
+    let dirname = substitute(dirname, "\"$", "", "")
+    return dirname
+endfun
+
+fun! ComposePath(base, subdir)
+    if has("amiga")
+        let ec = a:base[s:Strlen(a:base)-1]
+        if ec != '/' && ec != ':'
+            let ret = a:base."/" . a:subdir
+        else
+            let ret = a:base.a:subdir
+        endif
+
+        " COMBAK: test on windows with changing to root directory: :e C:/
+    elseif a:subdir =~ '^\a:[/\\]\([^/\\]\|$\)' && (has("win32") || has("win95") || has("win64") || has("win16"))
+        let ret= a:subdir
+
+    elseif a:base =~ '^\a:[/\\]\([^/\\]\|$\)' && (has("win32") || has("win95") || has("win64") || has("win16"))
+        if a:base =~ '[/\\]$'
+            let ret= a:base.a:subdir
+        else
+            let ret= a:base.'/'.a:subdir
+        endif
+
+    elseif a:base =~ '^\a\{3,}://'
+        let urlbase = substitute(a:base,'^\(\a\+://.\{-}/\)\(.*\)$','\1','')
+        let curpath = substitute(a:base,'^\(\a\+://.\{-}/\)\(.*\)$','\2','')
+        if a:subdir == '../'
+            if curpath =~ '[^/]/[^/]\+/$'
+                let curpath= substitute(curpath,'[^/]\+/$','','')
+            else
+                let curpath=""
+            endif
+            let ret= urlbase.curpath
+        else
+            let ret= urlbase.curpath.a:subdir
+        endif
+
+    else
+        let ret = substitute(a:base."/".a:subdir, "//", "/", "g")
+        if a:base =~ '^//'
+            " keeping initial '//' for the benefit of network share listing support
+            let ret= '/'.ret
+        endif
+        let ret= simplify(ret)
+    endif
+
+    return ret
+endfun
+fun! LocalRename() range
+    let curline = getline(line("."))
+    let nxtline = getline(line(".") + 1)
+
+    let curline = substitute(curline, '\\', '', 'g')
+    let curline = substitute(curline, "^\"", "", "")
+    let curline = substitute(curline, "\"$", "", "")
+    let nxtline = substitute(nxtline, '\_s\+$', '', 'g')
+    let nxtline = substitute(nxtline, "^\"", "", "")
+    let nxtline = substitute(nxtline, "\"$", "", "")
+    exec '!~/loadrc/bashrc/rename.sh ' . '"' .  curline . '"'  . ' ' . '"' .  nxtline . '"'
+    normal dd
+    call UpdateProj()
+endfun
diff --git a/vimrc/.vim/plugin/nextval.vim b/vimrc/.vim/plugin/nextval.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/nextval.vim
@@ -0,0 +1,270 @@
+"
+" nextval - Increment/decrement the current value with one keystroke
+"
+" Copyright (C) 2013 Michael Arlt
+"
+" Distributed under the GNU General Public License (GPL) 3.0 or higher
+" - see http://www.gnu.org/licenses/gpl.html
+"
+
+" This program is free software: you can redistribute it and/or modify
+" it under the terms of the GNU General Public License as published by
+" the Free Software Foundation, either version 3 of the License, or
+" (at your option) any later version.
+" This program is distributed in the hope that it will be useful,
+" but WITHOUT ANY WARRANTY; without even the implied warranty of
+" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+" GNU General Public License for more details.
+" You should have received a copy of the GNU General Public License
+" along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+" Version: 1.11
+"
+" Changes: 1.11
+" - Bugfix for increment/decrement in last empty line (Serpent)
+" Changes: 1.1
+" - Added boolen for python (True/False)
+" - Added integer surrounded by text
+" - Added many hex-variants
+" - Improved float
+" - Bugfix: inc/dec "worked" if you where near a value
+" - Big thanx to serpent for code/feedback/ideas
+" - Added expamples in source for simpler testing
+" Changes: 1.02
+" - Set default keys to overwrite Vims internal cmd C-a (inc) and C-x (dec)
+" Changes: 1.01
+" - Added standard check if already loaded
+" - Uses <Plug> for automatic mapping (if not already defined)
+"   -> Changed plugin calling - see usage
+" - Removed forgotten debug output (sorry)
+" - Added buffer awareness
+"
+" Installation:
+" # if you use pathogen:
+" mkdir -p ~/.vim/bundle/netxval/plugin
+" cp nextval.vim  ~/.vim/bundle/netxval/plugin
+
+" Usage: (e.g. in .vimrc)
+" This is the default mapping if you did not define a setting on your own
+" nmap <silent> <unique> + <Plug>nextvalInc
+" nmap <silent> <unique> - <Plug>nextvalDec
+" During editing position your cursor on a boolean, integer, number or
+" hex value and press + or - in normal mode (esc).
+
+" Tests:
+" 15 # int
+" -5 # neg. int
+" 0.1 # num/float
+" 0.25 # num/float
+" .2 # num/float
+" -0.1 # num/float
+" test5 # int surrounded
+" test123test # int surrounded
+" true # boolean
+" TRUE # boolean
+" True # boolean
+" 2b # hex
+" 0a # hex
+" 0xf9 # hex
+" 0F # hex
+" f # hex
+" F # hex
+" 5A3 # tex
+" &#x2019 # xml/xhtml
+" \x19 # unix, bash
+" FFh or 05A3H # intel assembly
+" #9 # modulo2
+" 16#5A3# # ada/vhdl
+" 16r5A3 # smalltalk/algol
+" 16#5A7 # postscript/bash
+" \u0019 \U00000019 # bash
+" #16r4a # common lisp
+" &H5A3 or &5a3 # several basic
+" 0h5A3 ti series
+" U+20AD # unicode
+" S=U+9 # integer
+" $5A3 # assembly/basic
+" H'ABCD' # microchip
+" x"5A3" # vhdl
+" 8'hFF # verilog
+" #x4a # common lisp
+" X'5A3' # ibm mainframe
+
+
+" check if already loaded
+if exists('g:nextval_plugin_loaded')
+	finish
+endif
+let g:nextval_plugin_loaded = 1
+
+" default keymappings
+if !hasmapto('<Plug>nextvalInc')
+	nmap <silent> <unique> + <Plug>nextvalInc
+endif
+if !hasmapto('<Plug>nextvalDec')
+	nmap <silent> <unique> - <Plug>nextvalDec
+endif
+" map <Plug> to internal function
+nnoremap <unique> <script> <Plug>nextvalInc <SID>nextvalInc
+nnoremap <SID>nextvalInc :call <SID>nextval('+')<CR>
+nnoremap <unique> <script> <Plug>nextvalDec <SID>nextvalDec
+nnoremap <SID>nextvalDec :call <SID>nextval('-')<CR>
+
+let s:re_hex = "\\(8'h\\|#16r\\|16#\\|16r\\|" " more pre-chars
+let s:re_hex = s:re_hex . 'x"\|#x\|0[xh]\|\\[xuU]\|[XH]' . "'\\|" " 2 pre-chars
+let s:re_hex = s:re_hex . '[#\$hH]\|' " 1 pre-char
+let s:re_hex = s:re_hex . '\|\)' " no pre-chars
+let s:re_hex = s:re_hex . '\([0-9a-fA-F]\+\)' " hex himself
+let s:re_hex = s:re_hex . "\\([hH#\"']\\|\\)" " post-chars
+
+" main
+function s:nextval(operator)
+	if !exists('b:nextval_column')
+		" vars to remember last cursor position and determined word-type
+		let b:nextval_column = ''
+		let b:nextval_line = ''
+		let b:nextval_type = ''
+		let b:nextval_hexupper = 0
+	endif
+
+	" remember and adjust settings
+	if 'a' == 'A'
+		setlocal noignorecase
+		let s:ignorecase = 1
+	endif
+	let s:iskeyword = &iskeyword   " remember current iskeyword
+	silent setlocal iskeyword+=# " enable #XX hex values
+	silent setlocal iskeyword+=$ " enable #XX hex values
+	silent setlocal iskeyword+=\" " enable #XX hex values
+	silent setlocal iskeyword+=' " enable #XX hex values
+	silent setlocal iskeyword+=\\ " enable \xXX hex values
+	silent setlocal iskeyword+=- " enable negative values
+	silent setlocal iskeyword+=. " enable float values
+
+	let word = expand('<cword>')
+
+	" check if cursor is really on the expanded cword (vim-bug?!)
+	if match(word,getline(".")[col(".") - 1]) < 0 || word == ''
+		call s:cleanup()
+		return
+	endif
+
+	" forget type if col/line changed
+	if b:nextval_column != col('.') || b:nextval_line != line('.')
+		let b:nextval_type = ''
+	endif
+
+	" determine type of word (int/hex)
+	if matchstr(word,'\(-\?[1-9][0-9]*\)\|0') == word
+		if b:nextval_type != 'hex'
+			let b:nextval_type = 'int'
+		endif
+	elseif matchstr(word,'-\?[0-9]*\.[0-9]\+') == word
+		let b:nextval_type = 'num'
+	elseif matchstr(word, s:re_hex) == word
+		let b:nextval_type = 'hex'
+	elseif matchstr(word,'true\|false\c') == word
+		let b:nextval_type = 'bool'
+	elseif matchstr(word,'\([^0-9]*\)\([0-9]\+\)\([^0-9]*\)') == word " increment/decrement integer surrounded by text (i.e. abc12)
+		let b:nextval_type = 'int'
+		let word_parts = matchlist(word,'\([^0-9]*\)\([0-9]\+\)\([^0-9]*\)')
+		let word_prefix = word_parts[1]
+		let word = word_parts[2]
+		let word_suffix = word_parts[3]
+		if str2nr(word) == 0 && a:operator == '-'	" do nothing when trying to decrement 0
+			let b:nextval_type = 'ignore'
+			unlet word_parts
+		endif
+	endif
+
+	if b:nextval_type == 'int'
+		let newword = a:operator == '+' ? str2nr(word)+1 : str2nr(word)-1
+	elseif b:nextval_type == 'num'
+		let newword = <SID>nextnum(word,a:operator)
+	elseif b:nextval_type == 'hex'
+		let newword = <SID>nexthex(word,a:operator)
+	elseif b:nextval_type == 'bool'
+		let newword = <SID>nextbool(word)
+	endif
+
+	if exists('word_parts')
+		let newword = word_prefix . newword . word_suffix
+	endif
+
+	if exists('newword')
+		execute 'normal ciw' . newword
+		execute 'normal wb'
+		let b:nextval_column = col('.')
+		let b:nextval_line = line('.')
+		"execute ':w'
+	endif
+	call s:cleanup()
+	return
+endfunction
+
+" restore settings
+function s:cleanup()
+	if exists('s:ignorecase')
+		setlocal ignorecase
+	endif
+	silent execute 'setlocal iskeyword='.s:iskeyword
+	return
+endfunction
+
+" switch boolean value
+function s:nextbool(value)
+	if a:value == 'false'
+		return 'true'
+	elseif a:value == 'true'
+		return 'false'
+	elseif a:value == 'FALSE'
+		return 'TRUE'
+	elseif a:value == 'TRUE'
+		return 'FALSE'
+	elseif a:value == 'False'
+		return 'True'
+	elseif a:value == 'True'
+		return 'False'
+	endif
+endfunction
+
+" change numeric value (n; ,n; n,n)
+function s:nextnum(value,operator)
+	let dotpos = match(a:value,'\.')
+	let fractdigits = len(a:value)-dotpos-1
+	if a:operator == '+'
+		let result = str2float(a:value)+(1/pow(10,fractdigits))
+	else
+		let result = str2float(a:value)-(1/pow(10,fractdigits))
+	endif
+	let newnum = printf('%.' . fractdigits . 'f',result)
+	if dotpos == 0 && result < 1 && result > 0
+		let newnum = strpart(newnum,1)
+	endif
+	return newnum
+endfunction
+
+" change hex value (#X; 0xX; X)
+function s:nexthex(value,operator)
+	let m = matchlist(a:value,s:re_hex)
+	let prefix = m[1]
+	let value = m[2]
+	let suffix = m[3]
+	let len = len(value)
+	let newval = a:operator == '+' ? str2nr(value,16)+1 : str2nr(value,16)-1
+	if strpart(value,0,1) != '0' " || ... todo ?! when will a use have fixed digits?! ... fmod(len,2)
+		let len = 1
+	endif
+	if len(matchstr(value,'[A-F]'))
+		let b:nextval_hexupper = 1
+	elseif len(matchstr(value,'[a-f]'))
+		let b:nextval_hexupper = 0
+	endif
+	if b:nextval_hexupper
+		let newhex = printf('%0' . len . 'X', newval)
+	else
+		let newhex = printf('%0' . len . 'x', newval)
+	endif
+	return prefix . newhex . suffix
+endfunction
+
diff --git a/vimrc/.vim/plugin/pbpaste.vim b/vimrc/.vim/plugin/pbpaste.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/pbpaste.vim
@@ -0,0 +1,17 @@
+function! PopulatePasteBufferFromOSX(mode)
+    if &clipboard == 'unnamed'
+        let @* = system('pbpaste-remote')
+    else
+        let @+ = system('pbpaste-remote')
+    endif
+
+    if a:mode== 'v'
+        normal! gvp
+    else
+        normal! gp
+    endif
+
+endfunction
+
+nnoremap <silent> cp :call PopulatePasteBufferFromOSX('n')<cr>
+vnoremap <silent> cp :call PopulatePasteBufferFromOSX('v')<cr>
diff --git a/vimrc/.vim/plugin/repeat.vim b/vimrc/.vim/plugin/repeat.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/repeat.vim
@@ -0,0 +1,115 @@
+" repeat.vim - Let the repeat command repeat plugin maps
+" Maintainer:   Tim Pope
+" Version:      1.1
+" GetLatestVimScripts: 2136 1 :AutoInstall: repeat.vim
+
+" Installation:
+" Place in either ~/.vim/plugin/repeat.vim (to load at start up) or
+" ~/.vim/autoload/repeat.vim (to load automatically as needed).
+"
+" License:
+" Copyright (c) Tim Pope.  Distributed under the same terms as Vim itself.
+" See :help license
+"
+" Developers:
+" Basic usage is as follows:
+"
+"   silent! call repeat#set("\<Plug>MappingToRepeatCommand",3)
+"
+" The first argument is the mapping that will be invoked when the |.| key is
+" pressed.  Typically, it will be the same as the mapping the user invoked.
+" This sequence will be stuffed into the input queue literally.  Thus you must
+" encode special keys by prefixing them with a backslash inside double quotes.
+"
+" The second argument is the default count.  This is the number that will be
+" prefixed to the mapping if no explicit numeric argument was given.  The
+" value of the v:count variable is usually correct and it will be used if the
+" second parameter is omitted.  If your mapping doesn't accept a numeric
+" argument and you never want to receive one, pass a value of -1.
+"
+" Make sure to call the repeat#set function _after_ making changes to the
+" file.
+"
+" For mappings that use a register and want the same register used on
+" repetition, use:
+"
+"   silent! call repeat#setreg("\<Plug>MappingToRepeatCommand", v:register)
+"
+" This function can (and probably needs to be) called before making changes to
+" the file (as those typically clear v:register).  Therefore, the call sequence
+" in your mapping will look like this:
+"
+"   nnoremap <silent> <Plug>MyMap
+"   \   :<C-U>execute 'silent! call repeat#setreg("\<lt>Plug>MyMap", v:register)'<Bar>
+"   \   call <SID>MyFunction(v:register, ...)<Bar>
+"   \   silent! call repeat#set("\<lt>Plug>MyMap")<CR>
+
+if exists("g:loaded_repeat") || &cp || v:version < 700
+    finish
+endif
+let g:loaded_repeat = 1
+
+let g:repeat_tick = -1
+let g:repeat_reg = ['', '']
+
+" Special function to avoid spurious repeats in a related, naturally repeating
+" mapping when your repeatable mapping doesn't increase b:changedtick.
+function! repeat#invalidate()
+    let g:repeat_tick = -1
+endfunction
+
+function! repeat#set(sequence,...)
+    let g:repeat_sequence = a:sequence
+    let g:repeat_count = a:0 ? a:1 : v:count
+    let g:repeat_tick = b:changedtick
+endfunction
+
+function! repeat#setreg(sequence,register)
+    let g:repeat_reg = [a:sequence, a:register]
+endfunction
+
+function! repeat#run(count)
+    if g:repeat_tick == b:changedtick
+        let r = ''
+        if g:repeat_reg[0] ==# g:repeat_sequence && !empty(g:repeat_reg[1])
+            if g:repeat_reg[1] ==# '='
+                " This causes a re-evaluation of the expression on repeat, which
+                " is what we want.
+                let r = '"=' . getreg('=', 1) . "\<CR>"
+            else
+                let r = '"' . g:repeat_reg[1]
+            endif
+        endif
+
+        let c = g:repeat_count
+        let s = g:repeat_sequence
+        let cnt = c == -1 ? "" : (a:count ? a:count : (c ? c : ''))
+        call feedkeys(r . cnt, 'n')
+        call feedkeys(s)
+    else
+        call feedkeys((a:count ? a:count : '') . '.', 'n')
+    endif
+endfunction
+
+function! repeat#wrap(command,count)
+    let preserve = (g:repeat_tick == b:changedtick)
+    exe 'norm! '.(a:count ? a:count : '').a:command . (&foldopen =~# 'undo' ? 'zv' : '')
+    if preserve
+        let g:repeat_tick = b:changedtick
+    endif
+endfunction
+
+nnoremap <silent> .     :<C-U>call repeat#run(v:count)<CR>
+nnoremap <silent> u     :<C-U>call repeat#wrap('u',v:count)<CR>
+if maparg('U','n') ==# ''
+    nnoremap <silent> U     :<C-U>call repeat#wrap('U',v:count)<CR>
+endif
+nnoremap <silent> <C-R> :<C-U>call repeat#wrap("\<Lt>C-R>",v:count)<CR>
+
+augroup repeatPlugin
+    autocmd!
+    autocmd BufLeave,BufWritePre,BufReadPre * let g:repeat_tick = (g:repeat_tick == b:changedtick || g:repeat_tick == 0) ? 0 : -1
+    autocmd BufEnter,BufWritePost * if g:repeat_tick == 0|let g:repeat_tick = b:changedtick|endif
+augroup END
+
+" vim:set ft=vim et sw=4 sts=4:
diff --git a/vimrc/.vim/plugin/restore_view.vim b/vimrc/.vim/plugin/restore_view.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/restore_view.vim
@@ -0,0 +1,62 @@
+"          FILE: restore_view.vim
+"      Language: vim script
+"    Maintainer: Yichao Zhou (broken.zhou AT gmail dot com)
+"       Created: 2012-02-27 16:12:12
+" Last Modified: 2012 Apr 18 14:06:11
+"   Description: 
+"       This is a simple script to autosave cursor position and fold
+"       information using vim's mkview.  Although you can easily do this job by
+"       just add serveral line to {.,_}vimrc, write a script plugin can make it
+"       more clean and nice.  We assume you use a new enough Vim to enjoy
+"       these feature. Hope you love it:)
+"
+"       Views will be saved when you save/write a file or EXIT VIM.
+"
+" Suggested Setting:
+"       Please put them in you vimrc file.
+"           set viewoptions=cursor,folds,slash,unix
+"       
+"       Set it in a plugin file looks dirty to me.  So you'd better do it your
+"       self.  This only keywords not in viewoptions is "options". I believe it
+"       does not belong to a view.  If you think you need it, feel free to
+"       put it in.  If you do not want views of some files to be saved, please
+"       set g:loaded_restore_view. The longer time you use, the bigger view
+"       folder you will have.  So if you use UNIX environment, you may need to
+"       use cron to do some clean job.
+"
+"       Most of code is from wiki.
+
+if exists("g:loaded_restore_view")
+    finish
+endif
+let g:loaded_restore_view = 1
+
+
+if !exists("g:skipview_files")
+    let g:skipview_files = []
+endif
+
+function! MakeViewCheck()
+    if has('quickfix') && &buftype =~ 'nofile' | return 0 | endif
+    if expand('%') =~ '\[.*\]' | return 0 | endif
+    if empty(glob(expand('%:p'))) | return 0 | endif
+    if &modifiable == 0 | return 0 | endif
+    if len($TEMP) && expand('%:p:h') == $TEMP | return 0 | endif
+    if len($TMP) && expand('%:p:h') == $TMP | return 0 | endif
+
+    let file_name = expand('%:p')
+    for ifiles in g:skipview_files
+        if file_name =~ ifiles
+            return 0
+        endif
+    endfor
+
+    return 1
+endfunction
+
+augroup AutoView
+    autocmd!
+    " Autosave & Load Views.
+    autocmd BufWritePost,WinLeave,BufWinLeave ?* if MakeViewCheck() | mkview | endif
+    autocmd BufWinEnter ?* if MakeViewCheck() | silent! loadview | endif
+augroup END
diff --git a/vimrc/.vim/plugin/spell.vim b/vimrc/.vim/plugin/spell.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/spell.vim
@@ -0,0 +1 @@
+"autocmd BufRead,BufNewFile *.md setlocal spell spelllang=en_us,cjk 
diff --git a/vimrc/.vim/plugin/taglist-plus.vim b/vimrc/.vim/plugin/taglist-plus.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/taglist-plus.vim
@@ -0,0 +1,4620 @@
+" File: taglist-plus.vim
+" Authors: Jezreel Ng (jezreel AT gmail DOT com)
+"          Yegappan Lakshmanan (yegappan AT yahoo DOT com)
+" Version: 1.0
+ "Last Modified: March 16, 2011
+ "Copyright: Copyright (C) 2011 Jezeel Ng
+"            Copyright (C) 2002-2007 Yegappan Lakshmanan
+"            Permission is hereby granted to use and distribute this code,
+"            with or without modifications, provided that this copyright
+"            notice is copied with it. Like anything else that's free,
+"            taglist.vim is provided *as is* and comes with no warranty of any
+"            kind, either expressed or implied. In no event will the copyright
+"            holder be liable for any damamges resulting from the use of this
+"            software.
+"
+" For more information about using this plugin, after installing the
+" taglist plugin, use the ":help taglist" command.
+"
+" Installation
+" ------------
+" 1. Download the taglist.zip file and unzip the files to the $HOME/.vim
+"    or the $HOME/vimfiles or the $VIM/vimfiles directory. This should
+"    unzip the following two files (the directory structure should be
+"    preserved):
+"
+"       plugin/taglist-plus.vim - main taglist plugin file
+"       doc/taglist-plus.txt    - documentation (help) file
+"
+"    Refer to the 'add-plugin', 'add-global-plugin' and 'runtimepath'
+"    Vim help pages for more details about installing Vim plugins.
+" 2. Change to the $HOME/.vim/doc or $HOME/vimfiles/doc or
+"    $VIM/vimfiles/doc directory, start Vim and run the ":helptags ."
+"    command to process the taglist help file.
+" 3. If the exuberant ctags utility is not present in your PATH, then set the
+"    Tlist_Ctags_Cmd variable to point to the location of the exuberant ctags
+"    utility (not to the directory) in the .vimrc file.
+" 4. If you are running a terminal/console version of Vim and the
+"    terminal doesn't support changing the window width then set the
+"    'Tlist_Inc_Winwidth' variable to 0 in the .vimrc file.
+" 5. Restart Vim.
+" 6. You can now use the ":TlistToggle" command to open/close the taglist
+"    window. You can use the ":help taglist" command to get more
+"    information about using the taglist plugin.
+"
+" ****************** Do not modify after this line ************************
+
+" Line continuation used here
+let s:cpo_save = &cpo
+set cpo&vim
+
+if !exists('loaded_taglist')
+    " First time loading the taglist plugin
+    "
+    " To speed up the loading of Vim, the taglist plugin uses autoload
+    " mechanism to load the taglist functions.
+    " Only define the configuration variables, user commands and some
+    " auto-commands and finish sourcing the file
+
+    " The taglist plugin requires the built-in Vim system() function. If this
+    " function is not available, then don't load the plugin.
+    if !exists('*system')
+        echomsg 'Taglist: Vim system() built-in function is not available. ' .
+                    \ 'Plugin is not loaded.'
+        let loaded_taglist = 'no'
+        let &cpo = s:cpo_save
+        finish
+    endif
+
+    " Location of the exuberant ctags tool
+    if !exists('Tlist_Ctags_Cmd')
+        if executable('exuberant-ctags')
+            " On Debian Linux, exuberant ctags is installed
+            " as exuberant-ctags
+            let Tlist_Ctags_Cmd = 'exuberant-ctags'
+        elseif executable('exctags')
+            " On Free-BSD, exuberant ctags is installed as exctags
+            let Tlist_Ctags_Cmd = 'exctags'
+        elseif executable('ctags')
+            let Tlist_Ctags_Cmd = 'ctags'
+        elseif executable('ctags.exe')
+            let Tlist_Ctags_Cmd = 'ctags.exe'
+        elseif executable('tags')
+            let Tlist_Ctags_Cmd = 'tags'
+        else
+            echomsg 'Taglist: Exuberant ctags (http://ctags.sf.net) ' .
+                        \ 'not found in PATH. Plugin is not loaded.'
+            " Skip loading the plugin
+            let loaded_taglist = 'no'
+            let &cpo = s:cpo_save
+            finish
+        endif
+    endif
+
+
+    " Automatically open the taglist window on Vim startup
+    if !exists('Tlist_Auto_Open')
+        let Tlist_Auto_Open = 0
+    endif
+
+    " When the taglist window is toggle opened, move the cursor to the
+    " taglist window
+    if !exists('Tlist_GainFocus_On_ToggleOpen')
+        let Tlist_GainFocus_On_ToggleOpen = 0
+    endif
+
+    " Process files even when the taglist window is not open
+    if !exists('Tlist_Process_File_Always')
+        let Tlist_Process_File_Always = 0
+    endif
+
+    if !exists('Tlist_Show_Menu')
+        let Tlist_Show_Menu = 0
+    endif
+
+    " Tag listing sort type - 'name' or 'order'
+    if !exists('Tlist_Sort_Type')
+        let Tlist_Sort_Type = 'order'
+    endif
+
+    " Tag listing window split (horizontal/vertical) control
+    if !exists('Tlist_Use_Horiz_Window')
+        let Tlist_Use_Horiz_Window = 0
+    endif
+
+    " Open the vertically split taglist window on the left or on the right
+    " side.  This setting is relevant only if Tlist_Use_Horiz_Window is set to
+    " zero (i.e.  only for vertically split windows)
+    if !exists('Tlist_Use_Right_Window')
+        let Tlist_Use_Right_Window = 0
+    endif
+
+    " Increase Vim window width to display vertically split taglist window.
+    " For MS-Windows version of Vim running in a MS-DOS window, this must be
+    " set to 0 otherwise the system may hang due to a Vim limitation.
+    if !exists('Tlist_Inc_Winwidth')
+        if (has('win16') || has('win95')) && !has('gui_running')
+            let Tlist_Inc_Winwidth = 0
+        else
+            let Tlist_Inc_Winwidth = 1
+        endif
+    endif
+
+    " Vertically split taglist window width setting
+    if !exists('Tlist_WinWidth')
+        let Tlist_WinWidth = 30
+        let s:auto_width = 0
+    elseif Tlist_WinWidth == 'auto'
+        let Tlist_WinWidth = 30
+        let s:auto_width = 1
+    endif
+
+    " Horizontally split taglist window height setting
+    if !exists('Tlist_WinHeight')
+        let Tlist_WinHeight = 10
+    endif
+
+    " Display tag prototypes or tag names in the taglist window
+    if !exists('Tlist_Display_Prototype')
+        let Tlist_Display_Prototype = 0
+    endif
+
+    " Display tag scopes in the taglist window
+    if !exists('Tlist_Display_Tag_Scope')
+        let Tlist_Display_Tag_Scope = 1
+    endif
+
+    " Use single left mouse click to jump to a tag. By default this is disabled.
+    " Only double click using the mouse will be processed.
+    if !exists('Tlist_Use_SingleClick')
+        let Tlist_Use_SingleClick = 0
+    endif
+
+    " Control whether additional help is displayed as part of the taglist or
+    " not.  Also, controls whether empty lines are used to separate the tag
+    " tree.
+    if !exists('Tlist_Compact_Format')
+        let Tlist_Compact_Format = 0
+    endif
+
+    " Exit Vim if only the taglist window is currently open. By default, this is
+    " set to zero.
+    if !exists('Tlist_Exit_OnlyWindow')
+        let Tlist_Exit_OnlyWindow = 0
+    endif
+
+    " Automatically close the folds for the non-active files in the taglist
+    " window
+    if !exists('Tlist_File_Fold_Auto_Close')
+        let Tlist_File_Fold_Auto_Close = 0
+    endif
+
+    " Close the taglist window when a tag is selected
+    if !exists('Tlist_Close_On_Select')
+        let Tlist_Close_On_Select = 0
+    endif
+
+    " Automatically update the taglist window to display tags for newly
+    " edited files
+    if !exists('Tlist_Auto_Update')
+        let Tlist_Auto_Update = 1
+    endif
+
+    " Automatically highlight the current tag
+    if !exists('Tlist_Auto_Highlight_Tag')
+        let Tlist_Auto_Highlight_Tag = 1
+    endif
+    
+    " Automatically highlight the current tag on entering a buffer
+    if !exists('Tlist_Highlight_Tag_On_BufEnter')
+        let Tlist_Highlight_Tag_On_BufEnter = 1
+    endif
+
+    " Enable fold column to display the folding for the tag tree
+    if !exists('Tlist_Enable_Fold_Column')
+        let Tlist_Enable_Fold_Column = 1
+    endif
+
+    " Display the tags for only one file in the taglist window
+    if !exists('Tlist_Show_One_File')
+        let Tlist_Show_One_File = 0
+    endif
+
+    if !exists('Tlist_Max_Submenu_Items')
+        let Tlist_Max_Submenu_Items = 20
+    endif
+
+    if !exists('Tlist_Max_Tag_Length')
+        let Tlist_Max_Tag_Length = 10
+    endif
+
+    " Do not change the name of the taglist title variable. The winmanager
+    " plugin relies on this name to determine the title for the taglist
+    " plugin.
+    let TagList_title = "__Tag_List__"
+
+    " Taglist debug messages
+    let s:tlist_msg = ''
+
+    " Define the taglist autocommand to automatically open the taglist window
+    " on Vim startup
+    if g:Tlist_Auto_Open
+        autocmd VimEnter * nested call s:Tlist_Window_Check_Auto_Open()
+    endif
+
+    " Refresh the taglist
+    if g:Tlist_Process_File_Always
+        autocmd BufEnter * call s:Tlist_Refresh()
+    endif
+
+    if g:Tlist_Show_Menu
+        autocmd GUIEnter * call s:Tlist_Menu_Init()
+    endif
+
+    " When the taglist buffer is created when loading a Vim session file,
+    " the taglist buffer needs to be initialized. The BufFilePost event
+    " is used to handle this case.
+    autocmd BufFilePost __Tag_List__ call s:Tlist_Vim_Session_Load()
+
+    " Define the user commands to manage the taglist window
+    command! -nargs=0 -bar TlistToggle call s:Tlist_Window_Toggle()
+    command! -nargs=0 -bar TlistOpen call s:Tlist_Window_Open()
+    " For backwards compatiblity define the Tlist command
+    command! -nargs=0 -bar Tlist TlistToggle
+    command! -nargs=+ -complete=file TlistAddFiles
+                \  call s:Tlist_Add_Files(<f-args>)
+    command! -nargs=+ -complete=dir TlistAddFilesRecursive
+                \ call s:Tlist_Add_Files_Recursive(<f-args>)
+    command! -nargs=0 -bar TlistClose call s:Tlist_Window_Close()
+    command! -nargs=0 -bar TlistUpdate call s:Tlist_Update_Current_File()
+    command! -nargs=0 -bar TlistHighlightTag call s:Tlist_Window_Highlight_Tag(
+                        \ fnamemodify(bufname('%'), ':p'), line('.'), 2, 1)
+    " For backwards compatiblity define the TlistSync command
+    command! -nargs=0 -bar TlistSync TlistHighlightTag
+    command! -nargs=* -complete=buffer TlistShowPrototype
+                \ echo Tlist_Get_Tag_Prototype_By_Line(<f-args>)
+    command! -nargs=* -complete=buffer TlistShowTag
+                \ echo Tlist_Get_Tagname_By_Line(<f-args>)
+    command! -nargs=* -complete=file TlistSessionLoad
+                \ call s:Tlist_Session_Load(<q-args>)
+    command! -nargs=* -complete=file TlistSessionSave
+                \ call s:Tlist_Session_Save(<q-args>)
+    command! -bar TlistLock let Tlist_Auto_Update=0
+    command! -bar TlistUnlock let Tlist_Auto_Update=1
+
+    " Commands for enabling/disabling debug and to display debug messages
+    command! -nargs=? -complete=file -bar TlistDebug
+                \ call s:Tlist_Debug_Enable(<q-args>)
+    command! -nargs=0 -bar TlistUndebug  call s:Tlist_Debug_Disable()
+    command! -nargs=0 -bar TlistMessages call s:Tlist_Debug_Show()
+
+    " Define autocommands to autoload the taglist plugin when needed.
+
+    " Trick to get the current script ID
+    map <SID>xx <SID>xx
+    let s:tlist_sid = substitute(maparg('<SID>xx'), '<SNR>\(\d\+_\)xx$',
+                                \ '\1', '')
+    unmap <SID>xx
+
+    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_Window_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_Menu_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+    exe 'autocmd FuncUndefined Tlist_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+    exe 'autocmd FuncUndefined TagList_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+
+    let loaded_taglist = 'fast_load_done'
+
+    if g:Tlist_Show_Menu && has('gui_running')
+        call s:Tlist_Menu_Init()
+    endif
+
+    " restore 'cpo'
+    let &cpo = s:cpo_save
+    finish
+endif
+
+if !exists('s:tlist_sid')
+    " Two or more versions of taglist plugin are installed. Don't
+    " load this version of the plugin.
+    finish
+endif
+
+unlet! s:tlist_sid
+
+if loaded_taglist != 'fast_load_done'
+    " restore 'cpo'
+    let &cpo = s:cpo_save
+    finish
+endif
+
+" Taglist plugin functionality is available
+let loaded_taglist = 'available'
+
+"------------------- end of user configurable options --------------------
+
+" Default language specific settings for supported file types and tag types
+"
+" Variable name format:
+"
+"       s:tlist_def_{vim_ftype}_settings
+" 
+" vim_ftype - Filetype detected by Vim
+"
+" Value format:
+"
+"       <ctags_ftype>;<flag>:<name>;<flag>:<name>;...
+"
+" ctags_ftype - File type supported by exuberant ctags
+" flag        - Flag supported by exuberant ctags to generate a tag type
+" name        - Name of the tag type used in the taglist window to display the
+"               tags of this type
+"
+
+" assembly language
+let s:tlist_def_asm_settings = 'asm;d:define;l:label;m:macro;t:type'
+
+" aspperl language
+let s:tlist_def_aspperl_settings = 'asp;f:function;s:sub;v:variable'
+
+" aspvbs language
+let s:tlist_def_aspvbs_settings = 'asp;f:function;s:sub;v:variable'
+
+" awk language
+let s:tlist_def_awk_settings = 'awk;f:function'
+
+" beta language
+let s:tlist_def_beta_settings = 'beta;f:fragment;s:slot;v:pattern'
+
+" c language
+let s:tlist_def_c_settings = 'c;d:macro;g:enum;s:struct;u:union;t:typedef;' .
+                           \ 'v:variable;f:function'
+
+" c++ language
+let s:tlist_def_cpp_settings = 'c++;n:namespace;v:variable;d:macro;t:typedef;' .
+                             \ 'c:class;g:enum;s:struct;u:union;f:function'
+
+" c# language
+let s:tlist_def_cs_settings = 'c#;d:macro;t:typedef;n:namespace;c:class;' .
+                             \ 'E:event;g:enum;s:struct;i:interface;' .
+                             \ 'p:properties;m:method'
+
+" cobol language
+let s:tlist_def_cobol_settings = 'cobol;d:data;f:file;g:group;p:paragraph;' .
+                               \ 'P:program;s:section'
+
+" eiffel language
+let s:tlist_def_eiffel_settings = 'eiffel;c:class;f:feature'
+
+" erlang language
+let s:tlist_def_erlang_settings = 'erlang;d:macro;r:record;m:module;f:function'
+
+" expect (same as tcl) language
+let s:tlist_def_expect_settings = 'tcl;c:class;f:method;p:procedure'
+
+" fortran language
+let s:tlist_def_fortran_settings = 'fortran;p:program;b:block data;' .
+                    \ 'c:common;e:entry;i:interface;k:type;l:label;m:module;' .
+                    \ 'n:namelist;t:derived;v:variable;f:function;s:subroutine'
+
+" HTML language
+let s:tlist_def_html_settings = 'html;a:anchor;f:javascript function'
+
+" java language
+let s:tlist_def_java_settings = 'java;p:package;c:class;i:interface;' .
+                              \ 'f:field;m:method'
+
+" javascript language
+let s:tlist_def_javascript_settings = 'javascript;f:function;v:variable'
+if !exists('Tlist_javascript_Ctags_Cmd') && executable('jsctags')
+    let Tlist_javascript_Ctags_Cmd = 'jsctags'
+endif
+let Tlist_javascript_Ctags_Allowed_Flags = ['-f', '--sort']
+
+" lisp language
+let s:tlist_def_lisp_settings = 'lisp;f:function'
+
+" lua language
+let s:tlist_def_lua_settings = 'lua;f:function'
+
+" makefiles
+let s:tlist_def_make_settings = 'make;m:macro'
+
+" pascal language
+let s:tlist_def_pascal_settings = 'pascal;f:function;p:procedure'
+
+" perl language
+let s:tlist_def_perl_settings = 'perl;c:constant;l:label;p:package;s:subroutine'
+
+" php language
+let s:tlist_def_php_settings = 'php;c:class;d:constant;v:variable;f:function'
+
+" python language
+let s:tlist_def_python_settings = 'python;c:class;m:member;f:function'
+
+" rexx language
+let s:tlist_def_rexx_settings = 'rexx;s:subroutine'
+
+" ruby language
+let s:tlist_def_ruby_settings = 'ruby;c:class;f:method;F:function;' .
+                              \ 'm:singleton method'
+
+" scheme language
+let s:tlist_def_scheme_settings = 'scheme;s:set;f:function'
+
+" shell language
+let s:tlist_def_sh_settings = 'sh;f:function'
+
+" C shell language
+let s:tlist_def_csh_settings = 'sh;f:function'
+
+" Z shell language
+let s:tlist_def_zsh_settings = 'sh;f:function'
+
+" slang language
+let s:tlist_def_slang_settings = 'slang;n:namespace;f:function'
+
+" sml language
+let s:tlist_def_sml_settings = 'sml;e:exception;c:functor;s:signature;' .
+                             \ 'r:structure;t:type;v:value;f:function'
+
+" sql language
+let s:tlist_def_sql_settings = 'sql;c:cursor;F:field;P:package;r:record;' .
+            \ 's:subtype;t:table;T:trigger;v:variable;f:function;p:procedure'
+
+" tcl language
+let s:tlist_def_tcl_settings = 'tcl;c:class;f:method;m:method;p:procedure'
+
+" vera language
+let s:tlist_def_vera_settings = 'vera;c:class;d:macro;e:enumerator;' .
+                                \ 'f:function;g:enum;m:member;p:program;' .
+                                \ 'P:prototype;t:task;T:typedef;v:variable;' .
+                                \ 'x:externvar'
+
+"verilog language
+let s:tlist_def_verilog_settings = 'verilog;m:module;c:constant;P:parameter;' .
+            \ 'e:event;r:register;t:task;w:write;p:port;v:variable;f:function'
+
+" vim language
+let s:tlist_def_vim_settings = 'vim;a:autocmds;v:variable;f:function'
+
+" yacc language
+let s:tlist_def_yacc_settings = 'yacc;l:label'
+
+"------------------- end of language specific options --------------------
+
+" Vim window size is changed by the taglist plugin or not
+let s:tlist_winsize_chgd = -1
+" Taglist window is maximized or not
+let s:tlist_win_maximized = 0
+" Name of files in the taglist
+let s:tlist_file_names=''
+" Number of files in the taglist
+let s:tlist_file_count = 0
+" Number of filetypes supported by taglist
+let s:tlist_ftype_count = 0
+" Is taglist part of other plugins like winmanager or cream?
+let s:tlist_app_name = "none"
+" Are we displaying brief help text
+let s:tlist_brief_help = 1
+" List of files removed on user request
+let s:tlist_removed_flist = ""
+" Index of current file displayed in the taglist window
+let s:tlist_cur_file_idx = -1
+" Taglist menu is empty or not
+let s:tlist_menu_empty = 1
+
+" An autocommand is used to refresh the taglist window when entering any
+" buffer. We don't want to refresh the taglist window if we are entering the
+" file window from one of the taglist functions. The 'Tlist_Skip_Refresh'
+" variable is used to skip the refresh of the taglist window and is set
+" and cleared appropriately.
+let s:Tlist_Skip_Refresh = 0
+
+" Tlist_Window_Display_Help()
+function! s:Tlist_Window_Display_Help()
+    if s:tlist_app_name == "winmanager"
+        " To handle a bug in the winmanager plugin, add a space at the
+        " last line
+        call setline('$', ' ')
+    endif
+
+    if s:tlist_brief_help
+        " Add the brief help
+        call append(0, '" Press <F1> to display help text')
+    else
+        " Add the extensive help
+        call append(0, '" <enter> : Jump to tag definition')
+        call append(1, '" o : Jump to tag definition in new window')
+        call append(2, '" p : Preview the tag definition')
+        call append(3, '" <space> : Display tag prototype')
+        call append(4, '" u : Update tag list')
+        call append(5, '" s : Select sort field')
+        call append(6, '" d : Remove file from taglist')
+        call append(7, '" x : Zoom-out/Zoom-in taglist window')
+        call append(8, '" m : Toggle display of more tag info')
+        call append(9, '" + : Open a fold')
+        call append(10, '" - : Close a fold')
+        call append(11, '" * : Open all folds')
+        call append(12, '" = : Close all folds')
+        call append(13, '" [[ : Move to the start of previous file')
+        call append(14, '" ]] : Move to the start of next file')
+        call append(15, '" q : Close the taglist window')
+        call append(16, '" <F1> : Remove help text')
+    endif
+endfunction
+
+" Tlist_Window_Toggle_Help_Text()
+" Toggle taglist plugin help text between the full version and the brief
+" version
+function! s:Tlist_Window_Toggle_Help_Text()
+    if g:Tlist_Compact_Format
+        " In compact display mode, do not display help
+        return
+    endif
+
+    " Include the empty line displayed after the help text
+    let brief_help_size = 1
+    let full_help_size = 16
+
+    setlocal modifiable
+
+    " Set report option to a huge value to prevent informational messages
+    " while deleting the lines
+    let old_report = &report
+    set report=99999
+
+    " Remove the currently highlighted tag. Otherwise, the help text
+    " might be highlighted by mistake
+    match none
+
+    " Toggle between brief and full help text
+    if s:tlist_brief_help
+        let s:tlist_brief_help = 0
+
+        " Remove the previous help
+        exe '1,' . brief_help_size . ' delete _'
+
+        " Adjust the start/end line numbers for the files
+        call s:Tlist_Window_Update_Line_Offsets(0, 1, full_help_size - brief_help_size)
+    else
+        let s:tlist_brief_help = 1
+
+        " Remove the previous help
+        exe '1,' . full_help_size . ' delete _'
+
+        " Adjust the start/end line numbers for the files
+        call s:Tlist_Window_Update_Line_Offsets(0, 0, full_help_size - brief_help_size)
+    endif
+
+    call s:Tlist_Window_Display_Help()
+
+    " Restore the report option
+    let &report = old_report
+
+    setlocal nomodifiable
+endfunction
+
+" Taglist debug support
+let s:tlist_debug = 0
+
+" File for storing the debug messages
+let s:tlist_debug_file = ''
+
+" Tlist_Debug_Enable
+" Enable logging of taglist debug messages.
+function! s:Tlist_Debug_Enable(...)
+    let s:tlist_debug = 1
+
+    " Check whether a valid file name is supplied.
+    if a:1 != ''
+        let s:tlist_debug_file = fnamemodify(a:1, ':p')
+
+        " Empty the log file
+        exe 'redir! > ' . s:tlist_debug_file
+        redir END
+
+        " Check whether the log file is present/created
+        if !filewritable(s:tlist_debug_file)
+            call s:Tlist_Warning_Msg('Taglist: Unable to create log file '
+                        \ . s:tlist_debug_file)
+            let s:tlist_debug_file = ''
+        endif
+    endif
+endfunction
+
+" Tlist_Debug_Disable
+" Disable logging of taglist debug messages.
+function! s:Tlist_Debug_Disable(...)
+    let s:tlist_debug = 0
+    let s:tlist_debug_file = ''
+endfunction
+
+" Tlist_Debug_Show
+" Display the taglist debug messages in a new window
+function! s:Tlist_Debug_Show()
+    if s:tlist_msg == ''
+        call s:Tlist_Warning_Msg('Taglist: No debug messages')
+        return
+    endif
+
+    " Open a new window to display the taglist debug messages
+    new taglist_debug.txt
+    " Delete all the lines (if the buffer already exists)
+    silent! %delete _
+    " Add the messages
+    silent! put =s:tlist_msg
+    " Move the cursor to the first line
+    normal! gg
+endfunction
+
+" Tlist_Log_Msg
+" Log the supplied debug message along with the time
+function! s:Tlist_Log_Msg(msg)
+    if s:tlist_debug
+        if s:tlist_debug_file != ''
+            exe 'redir >> ' . s:tlist_debug_file
+            silent echon strftime('%H:%M:%S') . ': ' . a:msg . "\n"
+            redir END
+        else
+            " Log the message into a variable
+            " Retain only the last 3000 characters
+            let len = strlen(s:tlist_msg)
+            if len > 3000
+                let s:tlist_msg = strpart(s:tlist_msg, len - 3000)
+            endif
+            let s:tlist_msg = s:tlist_msg . strftime('%H:%M:%S') . ': ' . 
+                        \ a:msg . "\n"
+        endif
+    endif
+endfunction
+
+" Tlist_Warning_Msg()
+" Display a message using WarningMsg highlight group
+function! s:Tlist_Warning_Msg(msg)
+    echohl WarningMsg
+    echomsg a:msg
+    echohl None
+endfunction
+
+" Last returned file index for file name lookup.
+" Used to speed up file lookup
+let s:tlist_file_name_idx_cache = -1
+
+" Tlist_Get_File_Index()
+" Return the index of the specified filename
+function! s:Tlist_Get_File_Index(fname)
+    if s:tlist_file_count == 0 || a:fname == ''
+        return -1
+    endif
+
+    " If the new filename is same as the last accessed filename, then
+    " return that index
+    if s:tlist_file_name_idx_cache != -1 &&
+                \ s:tlist_file_name_idx_cache < s:tlist_file_count
+        if s:tlist_{s:tlist_file_name_idx_cache}_filename == a:fname
+            " Same as the last accessed file
+            return s:tlist_file_name_idx_cache
+        endif
+    endif
+
+    " First, check whether the filename is present
+    let s_fname = a:fname . "\n"
+    let i = stridx(s:tlist_file_names, s_fname)
+    if i == -1
+        let s:tlist_file_name_idx_cache = -1
+        return -1
+    endif
+
+    " Second, compute the file name index
+    let nl_txt = substitute(strpart(s:tlist_file_names, 0, i), "[^\n]", '', 'g')
+    let s:tlist_file_name_idx_cache = strlen(nl_txt)
+    return s:tlist_file_name_idx_cache
+endfunction
+
+" Last returned file index for line number lookup.
+" Used to speed up file lookup
+let s:tlist_file_lnum_idx_cache = -1
+
+" Tlist_Window_Get_File_Index_By_Linenum()
+" Return the index of the filename present in the specified line number
+" Line number refers to the line number in the taglist window
+function! s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
+    call s:Tlist_Log_Msg('Tlist_Window_Get_File_Index_By_Linenum (' . a:lnum . ')')
+
+    " First try to see whether the new line number is within the range
+    " of the last returned file
+    if s:tlist_file_lnum_idx_cache != -1 &&
+                \ s:tlist_file_lnum_idx_cache < s:tlist_file_count
+        if a:lnum >= s:tlist_{s:tlist_file_lnum_idx_cache}_start &&
+                    \ a:lnum <= s:tlist_{s:tlist_file_lnum_idx_cache}_end
+            return s:tlist_file_lnum_idx_cache
+        endif
+    endif
+
+    let fidx = -1
+
+    if g:Tlist_Show_One_File
+        " Displaying only one file in the taglist window. Check whether
+        " the line is within the tags displayed for that file
+        if s:tlist_cur_file_idx != -1
+            if a:lnum >= s:tlist_{s:tlist_cur_file_idx}_start
+                        \ && a:lnum <= s:tlist_{s:tlist_cur_file_idx}_end
+                let fidx = s:tlist_cur_file_idx
+            endif
+
+        endif
+    else
+        " Do a binary search in the taglist
+        let left = 0
+        let right = s:tlist_file_count - 1
+
+        while left < right
+            let mid = (left + right) / 2
+
+            if a:lnum >= s:tlist_{mid}_start && a:lnum <= s:tlist_{mid}_end
+                let s:tlist_file_lnum_idx_cache = mid
+                return mid
+            endif
+
+            if a:lnum < s:tlist_{mid}_start
+                let right = mid - 1
+            else
+                let left = mid + 1
+            endif
+        endwhile
+
+        if left >= 0 && left < s:tlist_file_count
+                    \ && a:lnum >= s:tlist_{left}_start
+                    \ && a:lnum <= s:tlist_{left}_end
+            let fidx = left
+        endif
+    endif
+
+    let s:tlist_file_lnum_idx_cache = fidx
+
+    return fidx
+endfunction
+
+" Tlist_Exe_Cmd_No_Acmds
+" Execute the specified Ex command after disabling autocommands
+function! s:Tlist_Exe_Cmd_No_Acmds(cmd)
+    let old_eventignore = &eventignore
+    set eventignore=all
+    exe a:cmd
+    let &eventignore = old_eventignore
+endfunction
+
+" Tlist_Skip_File()
+" Check whether tag listing is supported for the specified file
+function! s:Tlist_Skip_File(filename, ftype)
+    " Skip buffers with no names and buffers with filetype not set
+    if a:filename == '' || a:ftype == ''
+        return 1
+    endif
+
+    " Skip files which are not supported by exuberant ctags
+    " First check whether default settings for this filetype are available.
+    " If it is not available, then check whether user specified settings are
+    " available. If both are not available, then don't list the tags for this
+    " filetype
+    let var = 's:tlist_def_' . a:ftype . '_settings'
+    if !exists(var)
+        let var = 'g:tlist_' . a:ftype . '_settings'
+        if !exists(var)
+            return 1
+        endif
+    endif
+
+    " Skip files which are not readable or files which are not yet stored
+    " to the disk
+    if !filereadable(a:filename)
+        return 1
+    endif
+
+    return 0
+endfunction
+
+" Tlist_User_Removed_File
+" Returns 1 if a file is removed by a user from the taglist
+function! s:Tlist_User_Removed_File(filename)
+    return stridx(s:tlist_removed_flist, a:filename . "\n") != -1
+endfunction
+
+" Tlist_Update_Remove_List
+" Update the list of user removed files from the taglist
+" add == 1, add the file to the removed list
+" add == 0, delete the file from the removed list
+function! s:Tlist_Update_Remove_List(filename, add)
+    if a:add
+        let s:tlist_removed_flist = s:tlist_removed_flist . a:filename . "\n"
+    else
+        let idx = stridx(s:tlist_removed_flist, a:filename . "\n")
+        let text_before = strpart(s:tlist_removed_flist, 0, idx)
+        let rem_text = strpart(s:tlist_removed_flist, idx)
+        let next_idx = stridx(rem_text, "\n")
+        let text_after = strpart(rem_text, next_idx + 1)
+
+        let s:tlist_removed_flist = text_before . text_after
+    endif
+endfunction
+
+" Tlist_FileType_Init
+" Initialize the ctags arguments and tag variable for the specified
+" file type
+function! s:Tlist_FileType_Init(ftype)
+    call s:Tlist_Log_Msg('Tlist_FileType_Init (' . a:ftype . ')')
+    " If the user didn't specify any settings, then use the default
+    " ctags args. Otherwise, use the settings specified by the user
+    let var = 'g:tlist_' . a:ftype . '_settings'
+    if exists(var)
+        " User specified ctags arguments
+        let settings = {var} . ';'
+    else
+        " Default ctags arguments
+        let var = 's:tlist_def_' . a:ftype . '_settings'
+        if !exists(var)
+            " No default settings for this file type. This filetype is
+            " not supported
+            return 0
+        endif
+        let settings = s:tlist_def_{a:ftype}_settings . ';'
+    endif
+
+    let msg = 'Taglist: Invalid ctags option setting - ' . settings
+
+    " Format of the option that specifies the filetype and ctags arugments:
+    "
+    "       <language_name>;flag1:name1;flag2:name2;flag3:name3
+    "
+
+    " Extract the file type to pass to ctags. This may be different from the
+    " file type detected by Vim
+    let pos = stridx(settings, ';')
+    if pos == -1
+        call s:Tlist_Warning_Msg(msg)
+        return 0
+    endif
+    let ctags_ftype = strpart(settings, 0, pos)
+    if ctags_ftype == ''
+        call s:Tlist_Warning_Msg(msg)
+        return 0
+    endif
+    " Make sure a valid filetype is supplied. If the user didn't specify a
+    " valid filetype, then the ctags option settings may be treated as the
+    " filetype
+    if ctags_ftype =~ ':'
+        call s:Tlist_Warning_Msg(msg)
+        return 0
+    endif
+
+    " Remove the file type from settings
+    let settings = strpart(settings, pos + 1)
+    if settings == ''
+        call s:Tlist_Warning_Msg(msg)
+        return 0
+    endif
+
+    " Process all the specified ctags flags. The format is
+    " flag1:name1;flag2:name2;flag3:name3
+    let ctags_flags = ''
+    let cnt = 0
+    while settings != ''
+        " Extract the flag
+        let pos = stridx(settings, ':')
+        if pos == -1
+            call s:Tlist_Warning_Msg(msg)
+            return 0
+        endif
+        let flag = strpart(settings, 0, pos)
+        if flag == ''
+            call s:Tlist_Warning_Msg(msg)
+            return 0
+        endif
+        " Remove the flag from settings
+        let settings = strpart(settings, pos + 1)
+
+        " Extract the tag type name
+        let pos = stridx(settings, ';')
+        if pos == -1
+            call s:Tlist_Warning_Msg(msg)
+            return 0
+        endif
+        let name = strpart(settings, 0, pos)
+        if name == ''
+            call s:Tlist_Warning_Msg(msg)
+            return 0
+        endif
+        let settings = strpart(settings, pos + 1)
+
+        let cnt = cnt + 1
+
+        let s:tlist_{a:ftype}_{cnt}_name = flag
+        let s:tlist_{a:ftype}_{cnt}_fullname = name
+        let ctags_flags = ctags_flags . flag
+    endwhile
+
+    let s:tlist_{a:ftype}_ctags_args = { '--language-force=': ctags_ftype,
+                            \ '--'.ctags_ftype.'-types=': ctags_flags }
+    let s:tlist_{a:ftype}_count = cnt
+    let s:tlist_{a:ftype}_ctags_flags = ctags_flags
+
+    " Save the filetype name
+    let s:tlist_ftype_{s:tlist_ftype_count}_name = a:ftype
+    let s:tlist_ftype_count = s:tlist_ftype_count + 1
+
+    return 1
+endfunction
+
+" Tlist_Detect_Filetype
+" Determine the filetype for the specified file using the filetypedetect
+" autocmd.
+function! s:Tlist_Detect_Filetype(fname)
+    " Ignore the filetype autocommands
+    let old_eventignore = &eventignore
+    set eventignore=FileType
+
+    " Save the 'filetype', as this will be changed temporarily
+    let old_filetype = &filetype
+
+    " Run the filetypedetect group of autocommands to determine
+    " the filetype
+    exe 'doautocmd filetypedetect BufRead ' . a:fname
+
+    " Save the detected filetype
+    let ftype = &filetype
+
+    " Restore the previous state
+    let &filetype = old_filetype
+    let &eventignore = old_eventignore
+
+    return ftype
+endfunction
+
+" Tlist_Get_Buffer_Filetype
+" Get the filetype for the specified buffer
+function! s:Tlist_Get_Buffer_Filetype(bnum)
+    let buf_ft = getbufvar(a:bnum, '&filetype')
+
+    if bufloaded(a:bnum)
+        " For loaded buffers, the 'filetype' is already determined
+        return buf_ft
+    endif
+
+    " For unloaded buffers, if the 'filetype' option is set, return it
+    if buf_ft != ''
+        return buf_ft
+    endif
+
+    " Skip non-existent buffers
+    if !bufexists(a:bnum)
+        return ''
+    endif
+
+    " For buffers whose filetype is not yet determined, try to determine
+    " the filetype
+    let bname = bufname(a:bnum)
+
+    return s:Tlist_Detect_Filetype(bname)
+endfunction
+
+" Tlist_Discard_TagInfo
+" Discard the stored tag information for a file
+function! s:Tlist_Discard_TagInfo(fidx)
+    call s:Tlist_Log_Msg('Tlist_Discard_TagInfo (' .
+                \ s:tlist_{a:fidx}_filename . ')')
+    let ftype = s:tlist_{a:fidx}_filetype
+
+    " Discard information about the tags defined in the file
+    let i = 1
+    while i <= s:tlist_{a:fidx}_tag_count
+        let fidx_i = 's:tlist_' . a:fidx . '_' . i
+        unlet! {fidx_i}_tag
+        unlet! {fidx_i}_tag_name
+        unlet! {fidx_i}_tag_type
+        unlet! {fidx_i}_ttype_idx
+        unlet! {fidx_i}_tag_proto
+        unlet! {fidx_i}_tag_searchpat
+        unlet! {fidx_i}_tag_linenum
+        let i = i + 1
+    endwhile
+
+    let s:tlist_{a:fidx}_tag_count = 0
+
+    " Discard information about tag type groups
+    let i = 1
+    while i <= s:tlist_{ftype}_count
+        let ttype = s:tlist_{ftype}_{i}_name
+        if s:tlist_{a:fidx}_{ttype} != ''
+            let fidx_ttype = 's:tlist_' . a:fidx . '_' . ttype
+            let {fidx_ttype} = ''
+            let {fidx_ttype}_offset = 0
+            let cnt = {fidx_ttype}_count
+            let {fidx_ttype}_count = 0
+            let j = 1
+            while j <= cnt
+                unlet! {fidx_ttype}_{j}
+                let j = j + 1
+            endwhile
+        endif
+        let i = i + 1
+    endwhile
+
+    " Discard the stored menu command also
+    let s:tlist_{a:fidx}_menu_cmd = ''
+endfunction
+
+" Tlist_Window_Update_Line_Offsets
+" Update the line offsets for tags for files starting from start_idx
+" and displayed in the taglist window by the specified offset
+function! s:Tlist_Window_Update_Line_Offsets(start_idx, increment, offset)
+    let i = a:start_idx
+
+    while i < s:tlist_file_count
+        if s:tlist_{i}_visible
+            " Update the start/end line number only if the file is visible
+            if a:increment
+                let s:tlist_{i}_start = s:tlist_{i}_start + a:offset
+                let s:tlist_{i}_end = s:tlist_{i}_end + a:offset
+            else
+                let s:tlist_{i}_start = s:tlist_{i}_start - a:offset
+                let s:tlist_{i}_end = s:tlist_{i}_end - a:offset
+            endif
+        endif
+        let i = i + 1
+    endwhile
+endfunction
+
+" Tlist_Discard_FileInfo
+" Discard the stored information for a file
+function! s:Tlist_Discard_FileInfo(fidx)
+    call s:Tlist_Log_Msg('Tlist_Discard_FileInfo (' .
+                \ s:tlist_{a:fidx}_filename . ')')
+    call s:Tlist_Discard_TagInfo(a:fidx)
+
+    let ftype = s:tlist_{a:fidx}_filetype
+
+    let i = 1
+    while i <= s:tlist_{ftype}_count
+        let ttype = s:tlist_{ftype}_{i}_name
+        unlet! s:tlist_{a:fidx}_{ttype}
+        unlet! s:tlist_{a:fidx}_{ttype}_offset
+        unlet! s:tlist_{a:fidx}_{ttype}_count
+        let i = i + 1
+    endwhile
+
+    unlet! s:tlist_{a:fidx}_filename
+    unlet! s:tlist_{a:fidx}_sort_type
+    unlet! s:tlist_{a:fidx}_filetype
+    unlet! s:tlist_{a:fidx}_mtime
+    unlet! s:tlist_{a:fidx}_start
+    unlet! s:tlist_{a:fidx}_end
+    unlet! s:tlist_{a:fidx}_valid
+    unlet! s:tlist_{a:fidx}_visible
+    unlet! s:tlist_{a:fidx}_tag_count
+    unlet! s:tlist_{a:fidx}_menu_cmd
+endfunction
+
+" Tlist_Window_Remove_File_From_Display
+" Remove the specified file from display
+function! s:Tlist_Window_Remove_File_From_Display(fidx)
+    call s:Tlist_Log_Msg('Tlist_Window_Remove_File_From_Display (' .
+                \ s:tlist_{a:fidx}_filename . ')')
+    " If the file is not visible then no need to remove it
+    if !s:tlist_{a:fidx}_visible
+        return
+    endif
+
+    " Remove the tags displayed for the specified file from the window
+    let start = s:tlist_{a:fidx}_start
+    " Include the empty line after the last line also
+    if g:Tlist_Compact_Format
+        let end = s:tlist_{a:fidx}_end
+    else
+        let end = s:tlist_{a:fidx}_end + 1
+    endif
+
+    setlocal modifiable
+    exe 'silent! ' . start . ',' . end . 'delete _'
+    setlocal nomodifiable
+
+    " Correct the start and end line offsets for all the files following
+    " this file, as the tags for this file are removed
+    call s:Tlist_Window_Update_Line_Offsets(a:fidx + 1, 0, end - start + 1)
+endfunction
+
+" Tlist_Remove_File
+" Remove the file under the cursor or the specified file index
+" user_request - User requested to remove the file from taglist
+function! s:Tlist_Remove_File(file_idx, user_request)
+    let fidx = a:file_idx
+
+    if fidx == -1
+        let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
+        if fidx == -1
+            return
+        endif
+    endif
+    call s:Tlist_Log_Msg('Tlist_Remove_File (' .
+                \ s:tlist_{fidx}_filename . ', ' . a:user_request . ')')
+
+    let save_winnr = winnr()
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        " Taglist window is open, remove the file from display
+
+        if save_winnr != winnum
+            let old_eventignore = &eventignore
+            set eventignore=all
+            exe winnum . 'wincmd w'
+        endif
+
+        call s:Tlist_Window_Remove_File_From_Display(fidx)
+
+        if save_winnr != winnum
+            exe save_winnr . 'wincmd w'
+            let &eventignore = old_eventignore
+        endif
+    endif
+
+    let fname = s:tlist_{fidx}_filename
+
+    if a:user_request
+        " As the user requested to remove the file from taglist,
+        " add it to the removed list
+        call s:Tlist_Update_Remove_List(fname, 1)
+    endif
+
+    " Remove the file name from the taglist list of filenames
+    let idx = stridx(s:tlist_file_names, fname . "\n")
+    let text_before = strpart(s:tlist_file_names, 0, idx)
+    let rem_text = strpart(s:tlist_file_names, idx)
+    let next_idx = stridx(rem_text, "\n")
+    let text_after = strpart(rem_text, next_idx + 1)
+    let s:tlist_file_names = text_before . text_after
+
+    call s:Tlist_Discard_FileInfo(fidx)
+
+    " Shift all the file variables by one index
+    let i = fidx + 1
+
+    while i < s:tlist_file_count
+        let j = i - 1
+
+        let s:tlist_{j}_filename = s:tlist_{i}_filename
+        let s:tlist_{j}_sort_type = s:tlist_{i}_sort_type
+        let s:tlist_{j}_filetype = s:tlist_{i}_filetype
+        let s:tlist_{j}_mtime = s:tlist_{i}_mtime
+        let s:tlist_{j}_start = s:tlist_{i}_start
+        let s:tlist_{j}_end = s:tlist_{i}_end
+        let s:tlist_{j}_valid = s:tlist_{i}_valid
+        let s:tlist_{j}_visible = s:tlist_{i}_visible
+        let s:tlist_{j}_tag_count = s:tlist_{i}_tag_count
+        let s:tlist_{j}_menu_cmd = s:tlist_{i}_menu_cmd
+
+        let k = 1
+        while k <= s:tlist_{j}_tag_count
+            let s:tlist_{j}_{k}_tag = s:tlist_{i}_{k}_tag
+            let s:tlist_{j}_{k}_tag_name = s:tlist_{i}_{k}_tag_name
+            let s:tlist_{j}_{k}_tag_type = s:Tlist_Get_Tag_Type_By_Tag(i, k)
+            let s:tlist_{j}_{k}_ttype_idx = s:tlist_{i}_{k}_ttype_idx
+            let s:tlist_{j}_{k}_tag_proto = s:Tlist_Get_Tag_Prototype(i, k)
+            let s:tlist_{j}_{k}_tag_searchpat = s:Tlist_Get_Tag_SearchPat(i, k)
+            let s:tlist_{j}_{k}_tag_linenum = s:Tlist_Get_Tag_Linenum(i, k)
+            let k = k + 1
+        endwhile
+
+        let ftype = s:tlist_{i}_filetype
+
+        let k = 1
+        while k <= s:tlist_{ftype}_count
+            let ttype = s:tlist_{ftype}_{k}_name
+            let s:tlist_{j}_{ttype} = s:tlist_{i}_{ttype}
+            let s:tlist_{j}_{ttype}_offset = s:tlist_{i}_{ttype}_offset
+            let s:tlist_{j}_{ttype}_count = s:tlist_{i}_{ttype}_count
+            if s:tlist_{j}_{ttype} != ''
+                let l = 1
+                while l <= s:tlist_{j}_{ttype}_count
+                    let s:tlist_{j}_{ttype}_{l} = s:tlist_{i}_{ttype}_{l}
+                    let l = l + 1
+                endwhile
+            endif
+            let k = k + 1
+        endwhile
+
+        " As the file and tag information is copied to the new index,
+        " discard the previous information
+        call s:Tlist_Discard_FileInfo(i)
+
+        let i = i + 1
+    endwhile
+
+    " Reduce the number of files displayed
+    let s:tlist_file_count = s:tlist_file_count - 1
+
+    if g:Tlist_Show_One_File
+        " If the tags for only one file is displayed and if we just
+        " now removed that file, then invalidate the current file idx
+        if s:tlist_cur_file_idx == fidx
+            let s:tlist_cur_file_idx = -1
+        endif
+    endif
+endfunction
+
+" Tlist_Window_Goto_Window
+" Goto the taglist window
+function! s:Tlist_Window_Goto_Window()
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        if winnr() != winnum
+            call s:Tlist_Exe_Cmd_No_Acmds(winnum . 'wincmd w')
+        endif
+    endif
+endfunction
+
+" Tlist_Window_Create
+" Create a new taglist window. If it is already open, jump to it
+function! s:Tlist_Window_Create()
+    call s:Tlist_Log_Msg('Tlist_Window_Create()')
+    " If the window is open, jump to it
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        " Jump to the existing window
+        if winnr() != winnum
+            exe winnum . 'wincmd w'
+        endif
+        return
+    endif
+
+    " If used with winmanager don't open windows. Winmanager will handle
+    " the window/buffer management
+    if s:tlist_app_name == "winmanager"
+        return
+    endif
+
+    " Create a new window. If user prefers a horizontal window, then open
+    " a horizontally split window. Otherwise open a vertically split
+    " window
+    if g:Tlist_Use_Horiz_Window
+        " Open a horizontally split window
+        let win_dir = 'botright'
+        " Horizontal window height
+        let win_size = g:Tlist_WinHeight
+    else
+        if s:tlist_winsize_chgd == -1
+            " Open a vertically split window. Increase the window size, if
+            " needed, to accomodate the new window
+            if g:Tlist_Inc_Winwidth &&
+                        \ &columns < (80 + g:Tlist_WinWidth)
+                " Save the original window position
+                let s:tlist_pre_winx = getwinposx()
+                let s:tlist_pre_winy = getwinposy()
+
+                " one extra column is needed to include the vertical split
+                let &columns= &columns + g:Tlist_WinWidth + 1
+
+                let s:tlist_winsize_chgd = 1
+            else
+                let s:tlist_winsize_chgd = 0
+            endif
+        endif
+
+        if g:Tlist_Use_Right_Window
+            " Open the window at the rightmost place
+            let win_dir = 'botright vertical'
+        else
+            " Open the window at the leftmost place
+            let win_dir = 'topleft vertical'
+        endif
+        let win_size = g:Tlist_WinWidth
+    endif
+
+    " If the tag listing temporary buffer already exists, then reuse it.
+    " Otherwise create a new buffer
+    let bufnum = bufnr(g:TagList_title)
+    if bufnum == -1
+        " Create a new buffer
+        let wcmd = g:TagList_title
+    else
+        " Edit the existing buffer
+        let wcmd = '+buffer' . bufnum
+    endif
+
+    " Create the taglist window
+    exe 'silent! ' . win_dir . ' ' . win_size . 'split ' . wcmd
+
+    " Save the new window position
+    let s:tlist_winx = getwinposx()
+    let s:tlist_winy = getwinposy()
+
+    " Initialize the taglist window
+    call s:Tlist_Window_Init()
+endfunction
+
+" Tlist_Window_Zoom
+" Zoom (maximize/minimize) the taglist window
+function! s:Tlist_Window_Zoom()
+    if s:tlist_win_maximized
+        " Restore the window back to the previous size
+        if g:Tlist_Use_Horiz_Window
+            exe 'resize ' . g:Tlist_WinHeight
+        else
+            exe 'vert resize ' . g:Tlist_WinWidth
+        endif
+        let s:tlist_win_maximized = 0
+    else
+        " Set the window size to the maximum possible without closing other
+        " windows
+        if g:Tlist_Use_Horiz_Window
+            resize
+        else
+            vert resize
+        endif
+        let s:tlist_win_maximized = 1
+    endif
+endfunction
+
+" Tlist_Ballon_Expr
+" When the mouse cursor is over a tag in the taglist window, display the
+" tag prototype (balloon)
+function! Tlist_Ballon_Expr()
+    " Get the file index
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(v:beval_lnum)
+    if fidx == -1
+        return ''
+    endif
+
+    " Get the tag output line for the current tag
+    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, v:beval_lnum)
+    if tidx == 0
+        return ''
+    endif
+
+    " Get the tag search pattern and display it
+    return s:Tlist_Get_Tag_Prototype(fidx, tidx)
+endfunction
+
+" Tlist_Window_Check_Width
+" Check the width of the taglist window. For horizontally split windows, the
+" 'winfixheight' option is used to fix the height of the window. For
+" vertically split windows, Vim doesn't support the 'winfixwidth' option. So
+" need to handle window width changes from this function.
+function! s:Tlist_Window_Check_Width()
+    let tlist_winnr = bufwinnr(g:TagList_title)
+    if tlist_winnr == -1
+        return
+    endif
+
+    let width = winwidth(tlist_winnr)
+    if width != g:Tlist_WinWidth
+        call s:Tlist_Log_Msg("Tlist_Window_Check_Width: Changing window " .
+                    \ "width from " . width . " to " . g:Tlist_WinWidth)
+        let save_winnr = winnr()
+        if save_winnr != tlist_winnr
+            call s:Tlist_Exe_Cmd_No_Acmds(tlist_winnr . 'wincmd w')
+        endif
+        exe 'vert resize ' . g:Tlist_WinWidth
+        if save_winnr != tlist_winnr
+            call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
+        endif
+    endif
+endfunction
+
+" Tlist_Window_Exit_Only_Window
+" If the 'Tlist_Exit_OnlyWindow' option is set, then exit Vim if only the
+" taglist window is present.
+function! s:Tlist_Window_Exit_Only_Window()
+    " Before quitting Vim, delete the taglist buffer so that
+    " the '0 mark is correctly set to the previous buffer.
+    if v:version < 700
+	if winbufnr(2) == -1
+	    bdelete
+	    quit
+	endif
+    else
+	if winbufnr(2) == -1
+	    if tabpagenr('$') == 1
+		" Only one tag page is present
+		bdelete
+		quit
+	    else
+		" More than one tab page is present. Close only the current
+		" tab page
+		close
+	    endif
+	endif
+    endif
+endfunction
+
+" Tlist_Window_Init
+" Set the default options for the taglist window
+function! s:Tlist_Window_Init()
+    call s:Tlist_Log_Msg('Tlist_Window_Init()')
+
+    " The 'readonly' option should not be set for the taglist buffer.
+    " If Vim is started as "view/gview" or if the ":view" command is
+    " used, then the 'readonly' option is set for all the buffers.
+    " Unset it for the taglist buffer
+    setlocal noreadonly
+
+    " Set the taglist buffer filetype to taglist
+    setlocal filetype=taglist
+
+    " Define taglist window element highlighting
+    syntax match TagListComment '^" .*'
+    syntax match TagListFileName '^[^" ].*$'
+    syntax match TagListTitle '^  \S.*$'
+    syntax region TagListTagScope1  start='\[' end='\]' contains=TagListTagScope1 nextgroup=TagListTagScope2 skipwhite
+    syntax region TagListTagScope2 start='\[' end='\]' contained contains=TaglistTagScope2
+
+    " Define the highlighting only if colors are supported
+    if has('gui_running') || &t_Co > 2
+        " Colors to highlight various taglist window elements
+        " If user defined highlighting group exists, then use them.
+        " Otherwise, use default highlight groups.
+        if hlexists('MyTagListTagName')
+            highlight link TagListTagName MyTagListTagName
+        else
+            highlight default link TagListTagName Search
+        endif
+        " Colors to highlight comments and titles
+        if hlexists('MyTagListComment')
+            highlight link TagListComment MyTagListComment
+        else
+            highlight clear TagListComment
+            highlight default link TagListComment Comment
+        endif
+        if hlexists('MyTagListTitle')
+            highlight link TagListTitle MyTagListTitle
+        else
+            highlight clear TagListTitle
+            highlight default link TagListTitle Title
+        endif
+        if hlexists('MyTagListFileName')
+            highlight link TagListFileName MyTagListFileName
+        else
+            highlight clear TagListFileName
+            highlight default TagListFileName guibg=Grey ctermbg=darkgray
+                        \ guifg=white ctermfg=white
+        endif
+        if hlexists('MyTagListTagScope')
+            highlight link TagListTagScope1 MyTagListTagScope
+        else
+            highlight clear TagListTagScope1
+            highlight clear TagListTagScope2
+            highlight default link TagListTagScope1 Identifier
+            highlight default link TagListTagScope2 Keyword
+        endif
+    else
+        highlight default TagListTagName term=reverse cterm=reverse
+    endif
+
+    " Folding related settings
+    setlocal foldenable
+    setlocal foldminlines=0
+    setlocal foldmethod=manual
+    setlocal foldlevel=9999
+    if g:Tlist_Enable_Fold_Column
+        setlocal foldcolumn=3
+    else
+        setlocal foldcolumn=0
+    endif
+    setlocal foldtext=v:folddashes.getline(v:foldstart)
+
+    if s:tlist_app_name != "winmanager"
+        " Mark buffer as scratch
+        silent! setlocal buftype=nofile
+        if s:tlist_app_name == "none"
+            silent! setlocal bufhidden=delete
+        endif
+        silent! setlocal noswapfile
+        " Due to a bug in Vim 6.0, the winbufnr() function fails for unlisted
+        " buffers. So if the taglist buffer is unlisted, multiple taglist
+        " windows will be opened. This bug is fixed in Vim 6.1 and above
+        if v:version >= 601
+            silent! setlocal nobuflisted
+        endif
+    endif
+
+    silent! setlocal nowrap
+
+    " If the 'number' option is set in the source window, it will affect the
+    " taglist window. So forcefully disable 'number' option for the taglist
+    " window
+    silent! setlocal nonumber
+
+    " Use fixed height when horizontally split window is used
+    if g:Tlist_Use_Horiz_Window
+        if v:version >= 602
+            set winfixheight
+        endif
+    endif
+    if !g:Tlist_Use_Horiz_Window && v:version >= 700
+        set winfixwidth
+    endif
+
+    " Setup balloon evaluation to display tag prototype
+    if v:version >= 700 && has('balloon_eval')
+        setlocal balloonexpr=Tlist_Ballon_Expr()
+        set ballooneval
+    endif
+
+    " Setup the cpoptions properly for the maps to work
+    let old_cpoptions = &cpoptions
+    set cpoptions&vim
+
+    " Create buffer local mappings for jumping to the tags and sorting the list
+    nnoremap <buffer> <silent> <CR>
+                \ :call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    " If more languages are required, generate this from a list of options
+    nnoremap <buffer> <silent> m
+                \ :call <SID>Tlist_Window_Toggle_Extra('javascript', 'type')<CR>
+    nnoremap <buffer> <silent> o
+                \ :call <SID>Tlist_Window_Jump_To_Tag('newwin')<CR>
+    nnoremap <buffer> <silent> p
+                \ :call <SID>Tlist_Window_Jump_To_Tag('preview')<CR>
+    nnoremap <buffer> <silent> P
+                \ :call <SID>Tlist_Window_Jump_To_Tag('prevwin')<CR>
+    if v:version >= 700
+    nnoremap <buffer> <silent> t
+                \ :call <SID>Tlist_Window_Jump_To_Tag('checktab')<CR>
+    nnoremap <buffer> <silent> <C-t>
+                \ :call <SID>Tlist_Window_Jump_To_Tag('newtab')<CR>
+    endif
+    nnoremap <buffer> <silent> <2-LeftMouse>
+                \ :call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    nnoremap <buffer> <silent> s
+                \ :call <SID>Tlist_Change_Sort('cmd', 'toggle', '')<CR>
+    nnoremap <buffer> <silent> + :silent! foldopen<CR>
+    nnoremap <buffer> <silent> - :silent! foldclose<CR>
+    nnoremap <buffer> <silent> * :silent! %foldopen!<CR>
+    nnoremap <buffer> <silent> = :silent! %foldclose<CR>
+    nnoremap <buffer> <silent> <kPlus> :silent! foldopen<CR>
+    nnoremap <buffer> <silent> <kMinus> :silent! foldclose<CR>
+    nnoremap <buffer> <silent> <kMultiply> :silent! %foldopen!<CR>
+    nnoremap <buffer> <silent> <Space> :call <SID>Tlist_Window_Show_Info()<CR>
+    nnoremap <buffer> <silent> u :call <SID>Tlist_Window_Update_File()<CR>
+    nnoremap <buffer> <silent> d :call <SID>Tlist_Remove_File(-1, 1)<CR>
+    nnoremap <buffer> <silent> x :call <SID>Tlist_Window_Zoom()<CR>
+    nnoremap <buffer> <silent> [[ :call <SID>Tlist_Window_Move_To_File(-1)<CR>
+    nnoremap <buffer> <silent> <BS> :call <SID>Tlist_Window_Move_To_File(-1)<CR>
+    nnoremap <buffer> <silent> ]] :call <SID>Tlist_Window_Move_To_File(1)<CR>
+    nnoremap <buffer> <silent> <Tab> :call <SID>Tlist_Window_Move_To_File(1)<CR>
+    nnoremap <buffer> <silent> <F1> :call <SID>Tlist_Window_Toggle_Help_Text()<CR>
+    nnoremap <buffer> <silent> q :close<CR>
+
+    " Insert mode mappings
+    inoremap <buffer> <silent> <CR>
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    " Windows needs return
+    inoremap <buffer> <silent> <Return>
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    inoremap <buffer> <silent> o
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('newwin')<CR>
+    inoremap <buffer> <silent> p
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('preview')<CR>
+    inoremap <buffer> <silent> P
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('prevwin')<CR>
+    if v:version >= 700
+    inoremap <buffer> <silent> t
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('checktab')<CR>
+    inoremap <buffer> <silent> <C-t>
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('newtab')<CR>
+    endif
+    inoremap <buffer> <silent> <2-LeftMouse>
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    inoremap <buffer> <silent> s
+                \ <C-o>:call <SID>Tlist_Change_Sort('cmd', 'toggle', '')<CR>
+    inoremap <buffer> <silent> +             <C-o>:silent! foldopen<CR>
+    inoremap <buffer> <silent> -             <C-o>:silent! foldclose<CR>
+    inoremap <buffer> <silent> *             <C-o>:silent! %foldopen!<CR>
+    inoremap <buffer> <silent> =             <C-o>:silent! %foldclose<CR>
+    inoremap <buffer> <silent> <kPlus>       <C-o>:silent! foldopen<CR>
+    inoremap <buffer> <silent> <kMinus>      <C-o>:silent! foldclose<CR>
+    inoremap <buffer> <silent> <kMultiply>   <C-o>:silent! %foldopen!<CR>
+    inoremap <buffer> <silent> <Space>       <C-o>:call
+                                    \ <SID>Tlist_Window_Show_Info()<CR>
+    inoremap <buffer> <silent> u
+                            \ <C-o>:call <SID>Tlist_Window_Update_File()<CR>
+    inoremap <buffer> <silent> d    <C-o>:call <SID>Tlist_Remove_File(-1, 1)<CR>
+    inoremap <buffer> <silent> x    <C-o>:call <SID>Tlist_Window_Zoom()<CR>
+    inoremap <buffer> <silent> [[   <C-o>:call <SID>Tlist_Window_Move_To_File(-1)<CR>
+    inoremap <buffer> <silent> <BS> <C-o>:call <SID>Tlist_Window_Move_To_File(-1)<CR>
+    inoremap <buffer> <silent> ]]   <C-o>:call <SID>Tlist_Window_Move_To_File(1)<CR>
+    inoremap <buffer> <silent> <Tab> <C-o>:call <SID>Tlist_Window_Move_To_File(1)<CR>
+    inoremap <buffer> <silent> <F1>  <C-o>:call <SID>Tlist_Window_Toggle_Help_Text()<CR>
+    inoremap <buffer> <silent> q    <C-o>:close<CR>
+
+    " Map single left mouse click if the user wants this functionality
+    if g:Tlist_Use_SingleClick == 1
+        " Contributed by Bindu Wavell
+        " attempt to perform single click mapping, it would be much
+        " nicer if we could nnoremap <buffer> ... however vim does
+        " not fire the <buffer> <leftmouse> when you use the mouse
+        " to enter a buffer.
+        let clickmap = ':if bufname("%") =~ "__Tag_List__" <bar> ' .
+                    \ 'call <SID>Tlist_Window_Jump_To_Tag("useopen") ' .
+                    \ '<bar> endif <CR>'
+        if maparg('<leftmouse>', 'n') == ''
+            " no mapping for leftmouse
+            exe ':nnoremap <silent> <leftmouse> <leftmouse>' . clickmap
+        else
+            " we have a mapping
+            let mapcmd = ':nnoremap <silent> <leftmouse> <leftmouse>'
+            let mapcmd = mapcmd . substitute(substitute(
+                        \ maparg('<leftmouse>', 'n'), '|', '<bar>', 'g'),
+                        \ '\c^<leftmouse>', '', '')
+            let mapcmd = mapcmd . clickmap
+            exe mapcmd
+        endif
+    endif
+
+    " Define the taglist autocommands
+    augroup TagListAutoCmds
+        autocmd!
+        " Display the tag prototype for the tag under the cursor.
+        autocmd CursorHold __Tag_List__ call s:Tlist_Window_Show_Info()
+        " Highlight the current tag periodically
+        autocmd CursorHold * silent call s:Tlist_Window_Highlight_Tag(
+                            \ fnamemodify(bufname('%'), ':p'), line('.'), 1, 0)
+
+        " Adjust the Vim window width when taglist window is closed
+        autocmd BufUnload __Tag_List__ call s:Tlist_Post_Close_Cleanup()
+        " Close the fold for this buffer when leaving the buffer
+        if g:Tlist_File_Fold_Auto_Close
+            autocmd BufEnter * silent
+                \ call s:Tlist_Window_Open_File_Fold(expand('<abuf>'))
+        endif
+        " Exit Vim itself if only the taglist window is present (optional)
+        if g:Tlist_Exit_OnlyWindow
+	    autocmd BufEnter __Tag_List__ nested
+			\ call s:Tlist_Window_Exit_Only_Window()
+        endif
+        if s:tlist_app_name != "winmanager" &&
+                    \ !g:Tlist_Process_File_Always &&
+                    \ (!has('gui_running') || !g:Tlist_Show_Menu)
+            " Auto refresh the taglist window
+            autocmd BufEnter * call s:Tlist_Refresh()
+        endif
+
+        if !g:Tlist_Use_Horiz_Window
+            if v:version < 700
+                autocmd WinEnter * call s:Tlist_Window_Check_Width()
+            endif
+        endif
+        if v:version >= 700
+            autocmd TabEnter * silent call s:Tlist_Refresh_Folds()
+        endif
+    augroup end
+
+    " Restore the previous cpoptions settings
+    let &cpoptions = old_cpoptions
+endfunction
+
+" Tlist_Window_Refresh
+" Display the tags for all the files in the taglist window
+function! s:Tlist_Window_Refresh()
+    call s:Tlist_Log_Msg('Tlist_Window_Refresh()')
+    " Set report option to a huge value to prevent informational messages
+    " while deleting the lines
+    let old_report = &report
+    set report=99999
+
+    " Mark the buffer as modifiable
+    setlocal modifiable
+
+    " Delete the contents of the buffer to the black-hole register
+    silent! %delete _
+
+    " As we have cleared the taglist window, mark all the files
+    " as not visible
+    let i = 0
+    while i < s:tlist_file_count
+        let s:tlist_{i}_visible = 0
+        let i = i + 1
+    endwhile
+
+    if g:Tlist_Compact_Format == 0
+        " Display help in non-compact mode
+        call s:Tlist_Window_Display_Help()
+    endif
+
+    " Mark the buffer as not modifiable
+    setlocal nomodifiable
+
+    " Restore the report option
+    let &report = old_report
+
+    " If the tags for only one file should be displayed in the taglist
+    " window, then no need to add the tags here. The bufenter autocommand
+    " will add the tags for that file.
+    if g:Tlist_Show_One_File
+        return
+    endif
+
+    " List all the tags for the previously processed files
+    " Do this only if taglist is configured to display tags for more than
+    " one file. Otherwise, when Tlist_Show_One_File is configured,
+    " tags for the wrong file will be displayed.
+    let i = 0
+    while i < s:tlist_file_count
+        call s:Tlist_Window_Refresh_File(s:tlist_{i}_filename,
+                    \ s:tlist_{i}_filetype)
+        let i = i + 1
+    endwhile
+
+    if g:Tlist_Auto_Update
+        " Add and list the tags for all buffers in the Vim buffer list
+        let i = 1
+        let last_bufnum = bufnr('$')
+        while i <= last_bufnum
+            if buflisted(i)
+                let fname = fnamemodify(bufname(i), ':p')
+                let ftype = s:Tlist_Get_Buffer_Filetype(i)
+                " If the file doesn't support tag listing, skip it
+                if !s:Tlist_Skip_File(fname, ftype)
+                    call s:Tlist_Window_Refresh_File(fname, ftype)
+                endif
+            endif
+            let i = i + 1
+        endwhile
+    endif
+
+    " If Tlist_File_Fold_Auto_Close option is set, then close all the folds
+    if g:Tlist_File_Fold_Auto_Close
+        " Close all the folds
+        silent! %foldclose
+    endif
+
+    if !g:Tlist_Use_Horiz_Window && s:auto_width
+        exe 'vertical resize '.g:Tlist_WinWidth
+    endif
+
+    " Move the cursor to the top of the taglist window
+    normal! gg
+endfunction
+
+" Tlist_Post_Close_Cleanup()
+" Close the taglist window and adjust the Vim window width
+function! s:Tlist_Post_Close_Cleanup()
+    call s:Tlist_Log_Msg('Tlist_Post_Close_Cleanup()')
+    " Mark all the files as not visible
+    let i = 0
+    while i < s:tlist_file_count
+        let s:tlist_{i}_visible = 0
+        let i = i + 1
+    endwhile
+
+    " Remove the taglist autocommands
+    silent! autocmd! TagListAutoCmds
+
+    " Clear all the highlights
+    match none
+
+    silent! syntax clear TagListTitle
+    silent! syntax clear TagListComment
+    silent! syntax clear TagListTagScope
+
+    " Remove the left mouse click mapping if it was setup initially
+    if g:Tlist_Use_SingleClick
+        if hasmapto('<LeftMouse>')
+            nunmap <LeftMouse>
+        endif
+    endif
+
+    if s:tlist_app_name != "winmanager"
+    if g:Tlist_Use_Horiz_Window || g:Tlist_Inc_Winwidth == 0 ||
+                \ s:tlist_winsize_chgd != 1 ||
+                \ &columns < (80 + g:Tlist_WinWidth)
+        " No need to adjust window width if using horizontally split taglist
+        " window or if columns is less than 101 or if the user chose not to
+        " adjust the window width
+    else
+        " If the user didn't manually move the window, then restore the window
+        " position to the pre-taglist position
+        if s:tlist_pre_winx != -1 && s:tlist_pre_winy != -1 &&
+                    \ getwinposx() == s:tlist_winx &&
+                    \ getwinposy() == s:tlist_winy
+            exe 'winpos ' . s:tlist_pre_winx . ' ' . s:tlist_pre_winy
+        endif
+
+        " Adjust the Vim window width
+        let &columns= &columns - (g:Tlist_WinWidth + 1)
+    endif
+    endif
+
+    let s:tlist_winsize_chgd = -1
+
+    " Reset taglist state variables
+    if s:tlist_app_name == "winmanager"
+        let s:tlist_app_name = "none"
+    endif
+    let s:tlist_window_initialized = 0
+endfunction
+
+" Tlist_Window_Refresh_File()
+" List the tags defined in the specified file in a Vim window
+function! s:Tlist_Window_Refresh_File(filename, ftype)
+    call s:Tlist_Log_Msg('Tlist_Window_Refresh_File (' . a:filename . ')')
+    " First check whether the file already exists
+    let fidx = s:Tlist_Get_File_Index(a:filename)
+    if fidx != -1
+        let file_listed = 1
+    else
+        let file_listed = 0
+    endif
+
+    if !file_listed
+        " Check whether this file is removed based on user request
+        " If it is, then don't display the tags for this file
+        if s:Tlist_User_Removed_File(a:filename)
+            return
+        endif
+    endif
+
+    if file_listed && s:tlist_{fidx}_visible
+        " Check whether the file tags are currently valid
+        if s:tlist_{fidx}_valid
+            " Goto the first line in the file
+            exe s:tlist_{fidx}_start
+
+            " If the line is inside a fold, open the fold
+            if foldclosed('.') != -1
+                exe "silent! " . s:tlist_{fidx}_start . "," .
+                            \ s:tlist_{fidx}_end . "foldopen!"
+            endif
+            return
+        endif
+
+        " Discard and remove the tags for this file from display
+        call s:Tlist_Discard_TagInfo(fidx)
+        call s:Tlist_Window_Remove_File_From_Display(fidx)
+    endif
+
+    " Process and generate a list of tags defined in the file
+    if !file_listed || !s:tlist_{fidx}_valid
+        let ret_fidx = s:Tlist_Process_File(a:filename, a:ftype)
+        if ret_fidx == -1
+            return
+        endif
+        let fidx = ret_fidx
+    endif
+
+    " Set report option to a huge value to prevent informational messages
+    " while adding lines to the taglist window
+    let old_report = &report
+    set report=99999
+
+    if g:Tlist_Show_One_File
+        " Remove the previous file
+        if s:tlist_cur_file_idx != -1
+            call s:Tlist_Window_Remove_File_From_Display(s:tlist_cur_file_idx)
+            let s:tlist_{s:tlist_cur_file_idx}_visible = 0
+            let s:tlist_{s:tlist_cur_file_idx}_start = 0
+            let s:tlist_{s:tlist_cur_file_idx}_end = 0
+        endif
+        let s:tlist_cur_file_idx = fidx
+    endif
+
+    " Mark the buffer as modifiable
+    setlocal modifiable
+
+    " Add new files to the end of the window. For existing files, add them at
+    " the same line where they were previously present. If the file is not
+    " visible, then add it at the end
+    if s:tlist_{fidx}_start == 0 || !s:tlist_{fidx}_visible
+        if g:Tlist_Compact_Format
+            let s:tlist_{fidx}_start = line('$')
+        else
+            let s:tlist_{fidx}_start = line('$') + 1
+        endif
+    endif
+
+    let s:tlist_{fidx}_visible = 1
+
+    " Goto the line where this file should be placed
+    if g:Tlist_Compact_Format
+        exe s:tlist_{fidx}_start
+    else
+        exe s:tlist_{fidx}_start - 1
+    endif
+
+    let txt = fnamemodify(s:tlist_{fidx}_filename, ':t') . ' (' .
+                \ fnamemodify(s:tlist_{fidx}_filename, ':p:h') . ')'
+    if g:Tlist_Compact_Format == 0
+        silent! put =txt
+    else
+        silent! put! =txt
+        " Move to the next line
+        exe line('.') + 1
+    endif
+    let file_start = s:tlist_{fidx}_start
+
+    " Add the tag names grouped by tag type to the buffer with a title
+    let i = 1
+    let ttype_cnt = s:tlist_{a:ftype}_count
+    while i <= ttype_cnt
+        let ttype = s:tlist_{a:ftype}_{i}_name
+        " Add the tag type only if there are tags for that type
+        let fidx_ttype = 's:tlist_' . fidx . '_' . ttype
+        let ttype_txt = {fidx_ttype}
+        if ttype_txt != ''
+            let txt = '  ' . s:tlist_{a:ftype}_{i}_fullname
+            if g:Tlist_Compact_Format == 0
+                let ttype_start_lnum = line('.') + 1
+                silent! put =txt
+            else
+                let ttype_start_lnum = line('.')
+                silent! put! =txt
+            endif
+            silent! put =ttype_txt
+
+            let {fidx_ttype}_offset = ttype_start_lnum - file_start
+
+            " create a fold for this tag type
+            let fold_start = ttype_start_lnum
+            let fold_end = fold_start + {fidx_ttype}_count
+            exe fold_start . ',' . fold_end  . 'fold'
+
+            " Adjust the cursor position
+            if g:Tlist_Compact_Format == 0
+                exe ttype_start_lnum + {fidx_ttype}_count
+            else
+                exe ttype_start_lnum + {fidx_ttype}_count + 1
+            endif
+
+            if g:Tlist_Compact_Format == 0
+                " Separate the tag types by a empty line
+                silent! put =''
+            endif
+        endif
+        let i = i + 1
+    endwhile
+
+    if s:tlist_{fidx}_tag_count == 0
+        if g:Tlist_Compact_Format == 0
+            silent! put =''
+        endif
+    endif
+
+    let s:tlist_{fidx}_end = line('.') - 1
+
+    " Create a fold for the entire file
+    exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'fold'
+    exe 'silent! ' . s:tlist_{fidx}_start . ',' .
+                \ s:tlist_{fidx}_end . 'foldopen!'
+
+    " Goto the starting line for this file,
+    exe s:tlist_{fidx}_start
+
+    if s:tlist_app_name == "winmanager"
+        " To handle a bug in the winmanager plugin, add a space at the
+        " last line
+        call setline('$', ' ')
+    endif
+
+    " Mark the buffer as not modifiable
+    setlocal nomodifiable
+
+    " Restore the report option
+    let &report = old_report
+
+    " Update the start and end line numbers for all the files following this
+    " file
+    let start = s:tlist_{fidx}_start
+    " include the empty line after the last line
+    if g:Tlist_Compact_Format
+        let end = s:tlist_{fidx}_end
+    else
+        let end = s:tlist_{fidx}_end + 1
+    endif
+    call s:Tlist_Window_Update_Line_Offsets(fidx + 1, 1, end - start + 1)
+
+    if !g:Tlist_Use_Horiz_Window && s:auto_width
+        exe 'vertical resize '.g:Tlist_WinWidth
+    endif
+
+    " Now that we have updated the taglist window, update the tags
+    " menu (if present)
+    if g:Tlist_Show_Menu
+        call s:Tlist_Menu_Update_File(1)
+    endif
+endfunction
+
+" Tlist_Init_File
+" Initialize the variables for a new file
+function! s:Tlist_Init_File(filename, ftype)
+    call s:Tlist_Log_Msg('Tlist_Init_File (' . a:filename . ')')
+    " Add new files at the end of the list
+    let fidx = s:tlist_file_count
+    let s:tlist_file_count = s:tlist_file_count + 1
+    " Add the new file name to the taglist list of file names
+    let s:tlist_file_names = s:tlist_file_names . a:filename . "\n"
+
+    " Initialize the file variables
+    let s:tlist_{fidx}_filename = a:filename
+    let s:tlist_{fidx}_sort_type = g:Tlist_Sort_Type
+    let s:tlist_{fidx}_filetype = a:ftype
+    let s:tlist_{fidx}_mtime = -1
+    let s:tlist_{fidx}_start = 0
+    let s:tlist_{fidx}_end = 0
+    let s:tlist_{fidx}_valid = 0
+    let s:tlist_{fidx}_visible = 0
+    let s:tlist_{fidx}_tag_count = 0
+    let s:tlist_{fidx}_menu_cmd = ''
+
+    " Initialize the tag type variables
+    let i = 1
+    while i <= s:tlist_{a:ftype}_count
+        let ttype = s:tlist_{a:ftype}_{i}_name
+        let s:tlist_{fidx}_{ttype} = ''
+        let s:tlist_{fidx}_{ttype}_offset = 0
+        let s:tlist_{fidx}_{ttype}_count = 0
+        let i = i + 1
+    endwhile
+
+    return fidx
+endfunction
+
+" Tlist_Get_Tag_Type_By_Tag
+" Return the tag type for the specified tag index
+function! s:Tlist_Get_Tag_Type_By_Tag(fidx, tidx)
+    let ttype_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_type'
+
+    " Already parsed and have the tag name
+    if exists(ttype_var)
+        return {ttype_var}
+    endif
+
+    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
+    let {ttype_var} = s:Tlist_Extract_Tagtype(tag_line)
+
+    return {ttype_var}
+endfunction
+
+" Tlist_Get_Tag_Prototype
+function! s:Tlist_Get_Tag_Prototype(fidx, tidx)
+    let tproto_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_proto'
+
+    " Already parsed and have the tag prototype
+    if exists(tproto_var)
+        return {tproto_var}
+    endif
+
+    " Parse and extract the tag prototype
+    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
+    let start = stridx(tag_line, '/^') + 2
+    let end = stridx(tag_line, '/;"' . "\t")
+    if tag_line[end - 1] == '$'
+        let end = end -1
+    endif
+    let tag_proto = strpart(tag_line, start, end - start)
+    let {tproto_var} = substitute(tag_proto, '\s*', '', '')
+
+    return {tproto_var}
+endfunction
+
+" Tlist_Get_Tag_SearchPat
+function! s:Tlist_Get_Tag_SearchPat(fidx, tidx)
+    let tpat_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_searchpat'
+
+    " Already parsed and have the tag search pattern
+    if exists(tpat_var)
+        return {tpat_var}
+    endif
+
+    " Parse and extract the tag search pattern
+    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
+    let start = stridx(tag_line, '/^') + 2
+    let end = stridx(tag_line, '/;"' . "\t")
+    if tag_line[end - 1] == '$'
+        let end = end -1
+    endif
+    let {tpat_var} = '\V\^' . strpart(tag_line, start, end - start) .
+                        \ (tag_line[end] == '$' ? '\$' : '')
+
+    return {tpat_var}
+endfunction
+
+" Tlist_Get_Tag_Linenum
+" Return the tag line number, given the tag index
+function! s:Tlist_Get_Tag_Linenum(fidx, tidx)
+    let tline_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_linenum'
+
+    " Already parsed and have the tag line number
+    if exists(tline_var)
+        return {tline_var}
+    endif
+
+    " Parse and extract the tag line number
+    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
+    let start = match(tag_line, 'line\(no\)\?:')
+    let start = stridx(tag_line, ':', start) + 1
+    let end = stridx(tag_line, "\t", start)
+
+    if end < start
+        let {tline_var} = strpart(tag_line, start) + 0
+    else
+        let {tline_var} = strpart(tag_line, start, end - start) + 0
+    endif
+
+    return {tline_var}
+endfunction
+
+" Tlist_Parse_Tagline
+" Parse a tag line from the ctags output. Separate the tag output based on the
+" tag type and store it in the tag type variable.
+" The format of each line in the ctags output is:
+"
+"     tag_name<TAB>file_name<TAB>ex_cmd;"<TAB>extension_fields
+"
+function! s:Tlist_Parse_Tagline(tag_line,ftype)
+    if a:tag_line == ''
+        " Skip empty lines
+        return
+    endif
+
+    " Extract the tag type
+    let ttype = s:Tlist_Extract_Tagtype(a:tag_line)
+
+    " Make sure the tag type is a valid and supported one
+    if ttype == '' || stridx(s:ctags_flags, ttype) == -1
+        " Line is not in proper tags format or Tag type is not supported
+        return
+    endif
+
+    " Update the total tag count
+    let s:tidx = s:tidx + 1
+
+    " The following variables are used to optimize this code.  Vim is slow in
+    " using curly brace names. To reduce the amount of processing needed, the
+    " curly brace variables are pre-processed here
+    let fidx_tidx = 's:tlist_' . s:fidx . '_' . s:tidx
+    let fidx_ttype = 's:tlist_' . s:fidx . '_' . ttype
+
+    " Update the count of this tag type
+    let ttype_idx = {fidx_ttype}_count + 1
+    let {fidx_ttype}_count = ttype_idx
+
+    " Store the ctags output for this tag
+    let {fidx_tidx}_tag = a:tag_line
+
+    " Store the tag index and the tag type index (back pointers)
+    let {fidx_ttype}_{ttype_idx} = s:tidx
+    let {fidx_tidx}_ttype_idx = ttype_idx
+
+    " Extract the tag name
+    let tag_name = strpart(a:tag_line, 0, stridx(a:tag_line, "\t"))
+
+    " Extract the tag scope/prototype
+    if g:Tlist_Display_Prototype
+        let ttxt = '    ' . s:Tlist_Get_Tag_Prototype(s:fidx, s:tidx)
+    else
+        let ttxt = '    ' . tag_name
+
+        " Add the tag scope, if it is available and is configured. Tag
+        " scope is the last field after the 'line:<num>\t' field
+        if g:Tlist_Display_Tag_Scope
+            let ttxt .= s:Tlist_Get_Scope_String(a:tag_line, a:ftype)
+        endif
+    endif
+
+    if !g:Tlist_Use_Horiz_Window && s:auto_width
+        " Add 3 for the fold columns
+        let g:Tlist_WinWidth = max([g:Tlist_WinWidth, strlen(ttxt)+3])
+    endif
+
+    " Add this tag to the tag type variable
+    let {fidx_ttype} = {fidx_ttype} . ttxt . "\n"
+
+    " Save the tag name
+    let {fidx_tidx}_tag_name = tag_name
+endfunction
+
+function! s:Tlist_Get_Scope_String(tag_line, ftype)
+    let ttxt = ''
+    let tag_scopes = s:Tlist_Extract_Tag_Scope(a:tag_line)
+    for [extradata_name, extradata_content] in items(tag_scopes)
+        if !exists('g:Tlist_{a:ftype}_Hide_Extras') || match(g:Tlist_{a:ftype}_Hide_Extras, extradata_name) == -1
+            let ttxt = ttxt . ' [' . extradata_content . ']'
+        endif
+    endfor
+    return ttxt
+endfunction
+
+" Tlist_Process_File
+" Get the list of tags defined in the specified file and store them
+" in Vim variables. Returns the file index where the tags are stored.
+function! s:Tlist_Process_File(filename, ftype)
+    call s:Tlist_Log_Msg('Tlist_Process_File (' . a:filename . ', ' .
+                \ a:ftype . ')')
+    " Check whether this file is supported
+    if s:Tlist_Skip_File(a:filename, a:ftype)
+        return -1
+    endif
+
+    " If the tag types for this filetype are not yet created, then create
+    " them now
+    let var = 's:tlist_' . a:ftype . '_count'
+    if !exists(var)
+        if s:Tlist_FileType_Init(a:ftype) == 0
+            return -1
+        endif
+    endif
+
+    " If this file is already processed, then use the cached values
+    let fidx = s:Tlist_Get_File_Index(a:filename)
+    if fidx == -1
+        " First time, this file is loaded
+        let fidx = s:Tlist_Init_File(a:filename, a:ftype)
+    else
+        " File was previously processed. Discard the tag information
+        call s:Tlist_Discard_TagInfo(fidx)
+    endif
+
+    let s:tlist_{fidx}_valid = 1
+
+    " Exuberant ctags arguments to generate a tag list
+    let ctags_args = { '-f': ' -', '--format=': '2', '--excmd=': 'pattern', '--fields=': 'nks' }
+
+    " Form the ctags argument depending on the sort type
+    if s:tlist_{fidx}_sort_type == 'name'
+        let ctags_args['--sort'] = '=yes'
+    else
+        let ctags_args['--sort'] = '=no'
+    endif
+
+    " Add the filetype specific arguments
+    call extend(ctags_args, s:tlist_{a:ftype}_ctags_args)
+
+    " Ctags command to produce output with regexp for locating the tags
+    if exists('g:Tlist_{a:ftype}_Ctags_Cmd')
+        let ctags_cmd = g:Tlist_{a:ftype}_Ctags_Cmd
+        let ctags_args = filter(ctags_args, 'match(g:Tlist_javascript_Ctags_Allowed_Flags, "^".v:key."$") != -1')
+    else
+        let ctags_cmd = g:Tlist_Ctags_Cmd
+    endif
+    let ctags_cmd = ctags_cmd . ' ' . join(values(map(ctags_args, 'v:key . v:val')))
+    let ctags_cmd = ctags_cmd . ' "' . a:filename . '"'
+
+    if &shellxquote == '"'
+        " Double-quotes within double-quotes will not work in the
+        " command-line.If the 'shellxquote' option is set to double-quotes,
+        " then escape the double-quotes in the ctags command-line.
+        let ctags_cmd = escape(ctags_cmd, '"')
+    endif
+
+    " In Windows 95, if not using cygwin, disable the 'shellslash'
+    " option. Otherwise, this will cause problems when running the
+    " ctags command.
+    if has('win95') && !has('win32unix')
+        let old_shellslash = &shellslash
+        set noshellslash
+    endif
+
+    if has('win32') && !has('win32unix') && !has('win95')
+                \ && (&shell =~ 'cmd.exe')
+        " Windows does not correctly deal with commands that have more than 1
+        " set of double quotes.  It will strip them all resulting in:
+        " 'C:\Program' is not recognized as an internal or external command
+        " operable program or batch file.  To work around this, place the
+        " command inside a batch file and call the batch file.
+        " Do this only on Win2K, WinXP and above.
+        " Contributed by: David Fishburn.
+        let s:taglist_tempfile = fnamemodify(tempname(), ':h') .
+                    \ '\taglist.cmd'
+        exe 'redir! > ' . s:taglist_tempfile
+        silent echo ctags_cmd
+        redir END
+
+        call s:Tlist_Log_Msg('Cmd inside batch file: ' . ctags_cmd)
+        let ctags_cmd = '"' . s:taglist_tempfile . '"'
+    endif
+
+    call s:Tlist_Log_Msg('Cmd: ' . ctags_cmd)
+
+    " Run ctags and get the tag list
+    let cmd_output = system(ctags_cmd)
+
+    " Restore the value of the 'shellslash' option.
+    if has('win95') && !has('win32unix')
+        let &shellslash = old_shellslash
+    endif
+
+    if exists('s:taglist_tempfile')
+        " Delete the temporary cmd file created on MS-Windows
+        call delete(s:taglist_tempfile)
+    endif
+
+    " Handle errors
+    if v:shell_error
+        let msg = "Taglist: Failed to generate tags for " . a:filename
+        call s:Tlist_Warning_Msg(msg)
+        if cmd_output != ''
+            call s:Tlist_Warning_Msg(cmd_output)
+        endif
+        return fidx
+    endif
+
+    " Store the modification time for the file
+    let s:tlist_{fidx}_mtime = getftime(a:filename)
+
+    " No tags for current file
+    if cmd_output == ''
+        call s:Tlist_Log_Msg('No tags defined in ' . a:filename)
+        return fidx
+    endif
+
+    call s:Tlist_Log_Msg('Generated tags information for ' . a:filename)
+
+    if v:version > 601
+        " The following script local variables are used by the
+        " Tlist_Parse_Tagline() function.
+        let s:ctags_flags = s:tlist_{a:ftype}_ctags_flags
+        let s:fidx = fidx
+        let s:tidx = 0
+
+        " Tlist_Parse_Tagline will adjust this accordingly
+        if !g:Tlist_Use_Horiz_Window && s:auto_width
+            let g:Tlist_WinWidth = 0
+        endif
+
+        " Process the ctags output one line at a time.  The substitute()
+        " command is used to parse the tag lines instead of using the
+        " matchstr()/stridx()/strpart() functions for performance reason
+        call substitute(cmd_output, "\\([^\n]\\+\\)\n",
+                    \ '\=s:Tlist_Parse_Tagline(submatch(1),a:ftype)', 'g')
+
+        " Save the number of tags for this file
+        let s:tlist_{fidx}_tag_count = s:tidx
+
+        " The following script local variables are no longer needed
+        unlet! s:ctags_flags
+        unlet! s:tidx
+        unlet! s:fidx
+    else
+        " Due to a bug in Vim earlier than version 6.1,
+        " we cannot use substitute() to parse the ctags output.
+        " Instead the slow str*() functions are used
+        let ctags_flags = s:tlist_{a:ftype}_ctags_flags
+        let tidx = 0
+
+        while cmd_output != ''
+            " Extract one line at a time
+            let idx = stridx(cmd_output, "\n")
+            let one_line = strpart(cmd_output, 0, idx)
+            " Remove the line from the tags output
+            let cmd_output = strpart(cmd_output, idx + 1)
+
+            if one_line == ''
+                " Line is not in proper tags format
+                continue
+            endif
+
+            " Extract the tag type
+            let ttype = s:Tlist_Extract_Tagtype(one_line)
+
+            " Make sure the tag type is a valid and supported one
+            if ttype == '' || stridx(ctags_flags, ttype) == -1
+                " Line is not in proper tags format or Tag type is not
+                " supported
+                continue
+            endif
+
+            " Update the total tag count
+            let tidx = tidx + 1
+
+            " The following variables are used to optimize this code.  Vim is
+            " slow in using curly brace names. To reduce the amount of
+            " processing needed, the curly brace variables are pre-processed
+            " here
+            let fidx_tidx = 's:tlist_' . fidx . '_' . tidx
+            let fidx_ttype = 's:tlist_' . fidx . '_' . ttype
+
+            " Update the count of this tag type
+            let ttype_idx = {fidx_ttype}_count + 1
+            let {fidx_ttype}_count = ttype_idx
+
+            " Store the ctags output for this tag
+            let {fidx_tidx}_tag = one_line
+
+            " Store the tag index and the tag type index (back pointers)
+            let {fidx_ttype}_{ttype_idx} = tidx
+            let {fidx_tidx}_ttype_idx = ttype_idx
+
+            " Extract the tag name
+            let tag_name = strpart(one_line, 0, stridx(one_line, "\t"))
+
+            " Extract the tag scope/prototype
+            if g:Tlist_Display_Prototype
+                let ttxt = '    ' . s:Tlist_Get_Tag_Prototype(fidx, tidx)
+            else
+                let ttxt = '    ' . tag_name
+
+                " Add the tag scope, if it is available and is configured. Tag
+                " scope is the last field after the 'line:<num>\t' field
+                if g:Tlist_Display_Tag_Scope
+                    let ttxt .= s:Tlist_Get_Scope_String(a:tag_line, a:ftype)
+                endif
+            endif
+
+            " Add this tag to the tag type variable
+            let {fidx_ttype} = {fidx_ttype} . ttxt . "\n"
+
+            " Save the tag name
+            let {fidx_tidx}_tag_name = tag_name
+        endwhile
+
+        " Save the number of tags for this file
+        let s:tlist_{fidx}_tag_count = tidx
+    endif
+
+    call s:Tlist_Log_Msg('Processed ' . s:tlist_{fidx}_tag_count . 
+                \ ' tags in ' . a:filename)
+
+    return fidx
+endfunction
+
+" Tlist_Update_File
+" Update the tags for a file (if needed)
+function! Tlist_Update_File(filename, ftype)
+    call s:Tlist_Log_Msg('Tlist_Update_File (' . a:filename . ')')
+    " If the file doesn't support tag listing, skip it
+    if s:Tlist_Skip_File(a:filename, a:ftype)
+        return
+    endif
+
+    " Convert the file name to a full path
+    let fname = fnamemodify(a:filename, ':p')
+
+    " First check whether the file already exists
+    let fidx = s:Tlist_Get_File_Index(fname)
+
+    if fidx != -1 && s:tlist_{fidx}_valid
+        " File exists and the tags are valid
+        " Check whether the file was modified after the last tags update
+        " If it is modified, then update the tags
+        if s:tlist_{fidx}_mtime == getftime(fname)
+            return
+        endif
+    else
+        " If the tags were removed previously based on a user request,
+        " as we are going to update the tags (based on the user request),
+        " remove the filename from the deleted list
+        call s:Tlist_Update_Remove_List(fname, 0)
+    endif
+
+    " If the taglist window is opened, update it
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum == -1
+        " Taglist window is not present. Just update the taglist
+        " and return
+        call s:Tlist_Process_File(fname, a:ftype)
+    else
+        if g:Tlist_Show_One_File && s:tlist_cur_file_idx != -1
+            " If tags for only one file are displayed and we are not
+            " updating the tags for that file, then no need to
+            " refresh the taglist window. Otherwise, the taglist
+            " window should be updated.
+            if s:tlist_{s:tlist_cur_file_idx}_filename != fname
+                call s:Tlist_Process_File(fname, a:ftype)
+                return
+            endif
+        endif
+
+        " Save the current window number
+        let save_winnr = winnr()
+
+        " Goto the taglist window
+        call s:Tlist_Window_Goto_Window()
+
+        " Save the cursor position
+        let save_line = line('.')
+        let save_col = col('.')
+
+        " Update the taglist window
+        call s:Tlist_Window_Refresh_File(fname, a:ftype)
+
+        " Restore the cursor position
+        if v:version >= 601
+            call cursor(save_line, save_col)
+        else
+            exe save_line
+            exe 'normal! ' . save_col . '|'
+        endif
+
+        if winnr() != save_winnr
+            " Go back to the original window
+            call s:Tlist_Exe_Cmd_No_Acmds(save_winnr . 'wincmd w')
+        endif
+    endif
+
+    " Update the taglist menu
+    if g:Tlist_Show_Menu
+        call s:Tlist_Menu_Update_File(1)
+    endif
+endfunction
+
+" Tlist_Window_Close
+" Close the taglist window
+function! s:Tlist_Window_Close()
+    call s:Tlist_Log_Msg('Tlist_Window_Close()')
+    " Make sure the taglist window exists
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum == -1
+        call s:Tlist_Warning_Msg('Error: Taglist window is not open')
+        return
+    endif
+
+    if winnr() == winnum
+        " Already in the taglist window. Close it and return.
+        " Store the buffer that was selected prior to the taglist buffer
+        let prev_buf = bufnr('#')
+        if winbufnr(2) != -1
+            " If a window other than the taglist window is open,
+            " then only close the taglist window.
+            close
+            call s:Tlist_Exe_Cmd_No_Acmds(bufwinnr(prev_buf) . 'wincmd w')
+        endif
+    else
+        " Goto the taglist window, close it and then come back to the
+        " original window
+        let curbufnr = bufnr('%')
+        exe winnum . 'wincmd w'
+        close
+        " Need to jump back to the original window only if we are not
+        " already in that window
+        let winnum = bufwinnr(curbufnr)
+        if winnr() != winnum
+            exe winnum . 'wincmd w'
+        endif
+    endif
+endfunction
+
+" Tlist_Window_Mark_File_Window
+" Mark the current window as the file window to use when jumping to a tag.
+" Only if the current window is a non-plugin, non-preview and non-taglist
+" window
+function! s:Tlist_Window_Mark_File_Window()
+    if getbufvar('%', '&buftype') == '' && !&previewwindow
+        let w:tlist_file_window = "yes"
+    endif
+endfunction
+
+" Tlist_Window_Open
+" Open and refresh the taglist window
+function! s:Tlist_Window_Open()
+    call s:Tlist_Log_Msg('Tlist_Window_Open()')
+    " If the window is open, jump to it
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        " Jump to the existing window
+        if winnr() != winnum
+            exe winnum . 'wincmd w'
+        endif
+        return
+    endif
+
+    if s:tlist_app_name == "winmanager"
+        " Taglist plugin is no longer part of the winmanager app
+        let s:tlist_app_name = "none"
+    endif
+
+    " Get the filename and filetype for the specified buffer
+    let curbuf_name = fnamemodify(bufname('%'), ':p')
+    let curbuf_ftype = s:Tlist_Get_Buffer_Filetype('%')
+    let cur_lnum = line('.')
+
+    " Mark the current window as the desired window to open a file when a tag
+    " is selected.
+    call s:Tlist_Window_Mark_File_Window()
+
+    " Open the taglist window
+    call s:Tlist_Window_Create()
+
+    call s:Tlist_Window_Refresh()
+
+    if g:Tlist_Show_One_File
+        " Add only the current buffer and file
+        "
+        " If the file doesn't support tag listing, skip it
+        if !s:Tlist_Skip_File(curbuf_name, curbuf_ftype)
+            call s:Tlist_Window_Refresh_File(curbuf_name, curbuf_ftype)
+        endif
+    endif
+
+    if g:Tlist_File_Fold_Auto_Close
+        " Open the fold for the current file, as all the folds in
+        " the taglist window are closed
+        let fidx = s:Tlist_Get_File_Index(curbuf_name)
+        if fidx != -1
+            exe "silent! " . s:tlist_{fidx}_start . "," .
+                        \ s:tlist_{fidx}_end . "foldopen!"
+        endif
+    endif
+
+    " Highlight the current tag
+    call s:Tlist_Window_Highlight_Tag(curbuf_name, cur_lnum, 1, 1)
+endfunction
+
+" Tlist_Window_Toggle()
+" Open or close a taglist window
+function! s:Tlist_Window_Toggle()
+    call s:Tlist_Log_Msg('Tlist_Window_Toggle()')
+    " If taglist window is open then close it.
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        call s:Tlist_Window_Close()
+        return
+    endif
+
+    " Store the current buffer
+    let current_buf = winbufnr(0)
+    call s:Tlist_Window_Open()
+
+    " Go back to the original window, if Tlist_GainFocus_On_ToggleOpen is not
+    " set
+    if !g:Tlist_GainFocus_On_ToggleOpen
+        let prev_win = bufwinnr(current_buf)
+        call s:Tlist_Exe_Cmd_No_Acmds(prev_win . 'wincmd w')
+    endif
+
+    " Update the taglist menu
+    if g:Tlist_Show_Menu
+        call s:Tlist_Menu_Update_File(0)
+    endif
+endfunction
+
+" Tlist_Process_Filelist
+" Process multiple files. Each filename is separated by "\n"
+" Returns the number of processed files
+function! s:Tlist_Process_Filelist(file_names)
+    let flist = a:file_names
+
+    " Enable lazy screen updates
+    let old_lazyredraw = &lazyredraw
+    set lazyredraw
+
+    " Keep track of the number of processed files
+    let fcnt = 0
+
+    " Process one file at a time
+    while flist != ''
+        let nl_idx = stridx(flist, "\n")
+        let one_file = strpart(flist, 0, nl_idx)
+
+        " Remove the filename from the list
+        let flist = strpart(flist, nl_idx + 1)
+
+        if one_file == ''
+            continue
+        endif
+
+        " Skip directories
+        if isdirectory(one_file)
+            continue
+        endif
+
+        let ftype = s:Tlist_Detect_Filetype(one_file)
+
+        echon "\r                                                              "
+        echon "\rProcessing tags for " . fnamemodify(one_file, ':p:t')
+
+        let fcnt = fcnt + 1
+
+        call Tlist_Update_File(one_file, ftype)
+    endwhile
+
+    " Clear the displayed informational messages
+    echon "\r                                                            "
+
+    " Restore the previous state
+    let &lazyredraw = old_lazyredraw
+
+    return fcnt
+endfunction
+
+" Tlist_Process_Dir
+" Process the files in a directory matching the specified pattern
+function! s:Tlist_Process_Dir(dir_name, pat)
+    let flist = glob(a:dir_name . '/' . a:pat) . "\n"
+
+    let fcnt = s:Tlist_Process_Filelist(flist)
+
+    let len = strlen(a:dir_name)
+    if a:dir_name[len - 1] == '\' || a:dir_name[len - 1] == '/'
+        let glob_expr = a:dir_name . '*'
+    else
+        let glob_expr = a:dir_name . '/*'
+    endif
+    let all_files = glob(glob_expr) . "\n"
+
+    while all_files != ''
+        let nl_idx = stridx(all_files, "\n")
+        let one_file = strpart(all_files, 0, nl_idx)
+
+        let all_files = strpart(all_files, nl_idx + 1)
+        if one_file == ''
+            continue
+        endif
+
+        " Skip non-directory names
+        if !isdirectory(one_file)
+            continue
+        endif
+
+        echon "\r                                                              "
+        echon "\rProcessing files in directory " . fnamemodify(one_file, ':t')
+        let fcnt = fcnt + s:Tlist_Process_Dir(one_file, a:pat)
+    endwhile
+
+    return fcnt
+endfunction
+
+" Tlist_Add_Files_Recursive
+" Add files recursively from a directory
+function! s:Tlist_Add_Files_Recursive(dir, ...)
+    let dir_name = fnamemodify(a:dir, ':p')
+    if !isdirectory(dir_name)
+        call s:Tlist_Warning_Msg('Error: ' . dir_name . ' is not a directory')
+        return
+    endif
+
+    if a:0 == 1
+        " User specified file pattern
+        let pat = a:1
+    else
+        " Default file pattern
+        let pat = '*'
+    endif
+
+    echon "\r                                                              "
+    echon "\rProcessing files in directory " . fnamemodify(dir_name, ':t')
+    let fcnt = s:Tlist_Process_Dir(dir_name, pat)
+
+    echon "\rAdded " . fcnt . " files to the taglist"
+endfunction
+
+" Tlist_Add_Files
+" Add the specified list of files to the taglist
+function! s:Tlist_Add_Files(...)
+    let flist = ''
+    let i = 1
+
+    " Get all the files matching the file patterns supplied as argument
+    while i <= a:0
+        let flist = flist . glob(a:{i}) . "\n"
+        let i = i + 1
+    endwhile
+
+    if flist == ''
+        call s:Tlist_Warning_Msg('Error: No matching files are found')
+        return
+    endif
+
+    let fcnt = s:Tlist_Process_Filelist(flist)
+    echon "\rAdded " . fcnt . " files to the taglist"
+endfunction
+
+" Tlist_Extract_Tagtype
+" Extract the tag type from the tag text
+function! s:Tlist_Extract_Tagtype(tag_line)
+    " The tag type is after the tag prototype field. The prototype field
+    " ends with the /;"\t string. We add 4 at the end to skip the characters
+    " in this special string..
+    let start = strridx(a:tag_line, '/;"' . "\t") + 4
+    let end = match(a:tag_line,  'line\(no\)\?:') - 1
+    let ttype = strpart(a:tag_line, start, end - start)
+
+    return ttype
+endfunction
+
+" Tlist_Extract_Tag_Scope
+" Extract the tag scope from the tag text
+function! s:Tlist_Extract_Tag_Scope(tag_line)
+    let start = match(a:tag_line, 'line\(no\)\?:')
+    let end = stridx(a:tag_line, "\t", start)
+    if end <= start
+        return {}
+    endif
+
+    let tag_extras = {}
+
+    let tag_extra = strpart(a:tag_line, end + 1)
+    while tag_extra != ''
+        let tag_extra_separator_start = stridx(tag_extra, ':')
+        let tag_extra_content_start = tag_extra_separator_start + 1
+        let tag_extra_content_end = stridx(tag_extra, "\t")
+        if tag_extra_content_end == -1
+            let tag_extra_content_end = strlen(tag_extra)
+        endif
+        let tag_extra_name = strpart(tag_extra, 0, tag_extra_separator_start)
+        let tag_extra_content = strpart(tag_extra, tag_extra_content_start, tag_extra_content_end - tag_extra_content_start)
+        let tag_extras[tag_extra_name] = tag_extra_content
+        let tag_extra = strpart(tag_extra, tag_extra_content_end + 1)
+    endwhile
+
+    return tag_extras
+endfunction
+
+function! s:Tlist_Window_Toggle_Extra(ftype, extra_name)
+    if !exists('g:Tlist_{a:ftype}_Hide_Extras')
+        return
+    endif
+    let index = index(g:Tlist_{a:ftype}_Hide_Extras, a:extra_name)
+    if index == -1
+        call add(g:Tlist_{a:ftype}_Hide_Extras, a:extra_name)
+    else
+        unlet g:Tlist_{a:ftype}_Hide_Extras[index]
+    endif
+    if s:auto_width
+        let g:Tlist_WinWidth = 30
+    endif
+
+    let cur_lnum = line('.')
+    let cur_col = col('.')
+    call s:Tlist_Window_Update_File()
+    call s:Tlist_Window_Check_Width()
+    call cursor(cur_lnum, cur_col)
+endfunction
+
+" Tlist_Refresh()
+" Refresh the taglist
+function! s:Tlist_Refresh()
+    call s:Tlist_Log_Msg('Tlist_Refresh (Skip_Refresh = ' .
+                \ s:Tlist_Skip_Refresh . ', ' . bufname('%') . ')')
+    " If we are entering the buffer from one of the taglist functions, then
+    " no need to refresh the taglist window again.
+    if s:Tlist_Skip_Refresh
+        " We still need to update the taglist menu
+        if g:Tlist_Show_Menu
+            call s:Tlist_Menu_Update_File(0)
+        endif
+        return
+    endif
+
+    " If part of the winmanager plugin and not configured to process
+    " tags always and not configured to display the tags menu, then return
+    if (s:tlist_app_name == 'winmanager') && !g:Tlist_Process_File_Always
+                \ && !g:Tlist_Show_Menu
+        return
+    endif
+
+    " Skip buffers with 'buftype' set to nofile, nowrite, quickfix or help
+    if &buftype != ''
+        return
+    endif
+
+    let filename = fnamemodify(bufname('%'), ':p')
+    let ftype = s:Tlist_Get_Buffer_Filetype('%')
+
+    " If the file doesn't support tag listing, skip it
+    if s:Tlist_Skip_File(filename, ftype)
+        return
+    endif
+
+    let tlist_win = bufwinnr(g:TagList_title)
+
+    " If the taglist window is not opened and not configured to process
+    " tags always and not displaying the tags menu, then return
+    if tlist_win == -1 && !g:Tlist_Process_File_Always && !g:Tlist_Show_Menu
+        return
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(filename)
+    if fidx == -1
+        " Check whether this file is removed based on user request
+        " If it is, then don't display the tags for this file
+        if s:Tlist_User_Removed_File(filename)
+            return
+        endif
+
+        " If the taglist should not be auto updated, then return
+        if !g:Tlist_Auto_Update
+            return
+        endif
+    endif
+
+    let cur_lnum = line('.')
+
+    if fidx == -1
+        " Update the tags for the file
+        let fidx = s:Tlist_Process_File(filename, ftype)
+    else
+        let mtime = getftime(filename)
+        if s:tlist_{fidx}_mtime != mtime
+            " Invalidate the tags listed for this file
+            let s:tlist_{fidx}_valid = 0
+
+            " Update the taglist and the window
+            call Tlist_Update_File(filename, ftype)
+
+            " Store the new file modification time
+            let s:tlist_{fidx}_mtime = mtime
+        endif
+    endif
+
+    " Update the taglist window
+    if tlist_win != -1
+        " Disable screen updates
+        let old_lazyredraw = &lazyredraw
+        set nolazyredraw
+
+        " Save the current window number
+        let save_winnr = winnr()
+
+        " Goto the taglist window
+        call s:Tlist_Window_Goto_Window()
+
+        if !g:Tlist_Auto_Highlight_Tag || !g:Tlist_Highlight_Tag_On_BufEnter
+            " Save the cursor position
+            let save_line = line('.')
+            let save_col = col('.')
+        endif
+
+        " Update the taglist window
+        call s:Tlist_Window_Refresh_File(filename, ftype)
+
+        " Open the fold for the file
+        exe "silent! " . s:tlist_{fidx}_start . "," .
+                    \ s:tlist_{fidx}_end . "foldopen!"
+
+        if g:Tlist_Highlight_Tag_On_BufEnter && g:Tlist_Auto_Highlight_Tag
+            if g:Tlist_Show_One_File && s:tlist_cur_file_idx != fidx
+                " If displaying tags for only one file in the taglist
+                " window and about to display the tags for a new file,
+                " then center the current tag line for the new file
+                let center_tag_line = 1
+            else
+                let center_tag_line = 0
+            endif
+
+            " Highlight the current tag
+            call s:Tlist_Window_Highlight_Tag(filename, cur_lnum, 1, center_tag_line)
+        else
+            " Restore the cursor position
+            if v:version >= 601
+                call cursor(save_line, save_col)
+            else
+                exe save_line
+                exe 'normal! ' . save_col . '|'
+            endif
+        endif
+
+        " Jump back to the original window
+        if save_winnr != winnr()
+            call s:Tlist_Exe_Cmd_No_Acmds(save_winnr . 'wincmd w')
+        endif
+
+        " Restore screen updates
+        let &lazyredraw = old_lazyredraw
+    endif
+
+    " Update the taglist menu
+    if g:Tlist_Show_Menu
+        call s:Tlist_Menu_Update_File(0)
+    endif
+endfunction
+
+" Tlist_Change_Sort()
+" Change the sort order of the tag listing
+" caller == 'cmd', command used in the taglist window
+" caller == 'menu', taglist menu
+" action == 'toggle', toggle sort from name to order and vice versa
+" action == 'set', set the sort order to sort_type
+function! s:Tlist_Change_Sort(caller, action, sort_type)
+    call s:Tlist_Log_Msg('Tlist_Change_Sort (caller = ' . a:caller .
+            \ ', action = ' . a:action . ', sort_type = ' . a:sort_type . ')')
+    if a:caller == 'cmd'
+        let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
+        if fidx == -1
+            return
+        endif
+
+        " Remove the previous highlighting
+        match none
+    elseif a:caller == 'menu'
+        let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
+        if fidx == -1
+            return
+        endif
+    endif
+
+    if a:action == 'toggle'
+        let sort_type = s:tlist_{fidx}_sort_type
+
+        " Toggle the sort order from 'name' to 'order' and vice versa
+        if sort_type == 'name'
+            let s:tlist_{fidx}_sort_type = 'order'
+        else
+            let s:tlist_{fidx}_sort_type = 'name'
+        endif
+    else
+        let s:tlist_{fidx}_sort_type = a:sort_type
+    endif
+
+    " Invalidate the tags listed for this file
+    let s:tlist_{fidx}_valid = 0
+
+    if a:caller  == 'cmd'
+        " Save the current line for later restoration
+        let curline = '\V\^' . getline('.') . '\$'
+
+        call s:Tlist_Window_Refresh_File(s:tlist_{fidx}_filename,
+                    \   s:tlist_{fidx}_filetype)
+
+        exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'foldopen!'
+
+        " Go back to the cursor line before the tag list is sorted
+        call search(curline, 'w')
+
+        call s:Tlist_Menu_Update_File(1)
+    else
+        call s:Tlist_Menu_Remove_File()
+
+        call s:Tlist_Refresh()
+    endif
+endfunction
+
+" Tlist_Update_Current_File()
+" Update taglist for the current buffer by regenerating the tag list
+" Contributed by WEN Guopeng.
+function! s:Tlist_Update_Current_File()
+    call s:Tlist_Log_Msg('Tlist_Update_Current_File()')
+    if winnr() == bufwinnr(g:TagList_title)
+        " In the taglist window. Update the current file
+        call s:Tlist_Window_Update_File()
+    else
+        " Not in the taglist window. Update the current buffer
+        let filename = fnamemodify(bufname('%'), ':p')
+        let fidx = s:Tlist_Get_File_Index(filename)
+        if fidx != -1
+            let s:tlist_{fidx}_valid = 0
+        endif
+        let ft = s:Tlist_Get_Buffer_Filetype('%')
+        call Tlist_Update_File(filename, ft)
+    endif
+endfunction
+
+" Tlist_Window_Update_File()
+" Update the tags displayed in the taglist window
+function! s:Tlist_Window_Update_File()
+    call s:Tlist_Log_Msg('Tlist_Window_Update_File()')
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
+    if fidx == -1
+        return
+    endif
+
+    " Remove the previous highlighting
+    match none
+
+    " Save the current line for later restoration
+    let curline = '\V\^' . getline('.') . '\$'
+
+    let s:tlist_{fidx}_valid = 0
+
+    " Update the taglist window
+    call s:Tlist_Window_Refresh_File(s:tlist_{fidx}_filename,
+                \ s:tlist_{fidx}_filetype)
+
+    exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'foldopen!'
+
+    " Go back to the tag line before the list is updated
+    call search(curline, 'w')
+endfunction
+
+" Tlist_Window_Get_Tag_Type_By_Linenum()
+" Return the tag type index for the specified line in the taglist window
+function! s:Tlist_Window_Get_Tag_Type_By_Linenum(fidx, lnum)
+    let ftype = s:tlist_{a:fidx}_filetype
+
+    " Determine to which tag type the current line number belongs to using the
+    " tag type start line number and the number of tags in a tag type
+    let i = 1
+    while i <= s:tlist_{ftype}_count
+        let ttype = s:tlist_{ftype}_{i}_name
+        let start_lnum =
+                    \ s:tlist_{a:fidx}_start + s:tlist_{a:fidx}_{ttype}_offset
+        let end =  start_lnum + s:tlist_{a:fidx}_{ttype}_count
+        if a:lnum >= start_lnum && a:lnum <= end
+            break
+        endif
+        let i = i + 1
+    endwhile
+
+    " Current line doesn't belong to any of the displayed tag types
+    if i > s:tlist_{ftype}_count
+        return ''
+    endif
+
+    return ttype
+endfunction
+
+" Tlist_Window_Get_Tag_Index()
+" Return the tag index for the specified line in the taglist window
+function! s:Tlist_Window_Get_Tag_Index(fidx, lnum)
+    let ttype = s:Tlist_Window_Get_Tag_Type_By_Linenum(a:fidx, a:lnum)
+
+    " Current line doesn't belong to any of the displayed tag types
+    if ttype == ''
+        return 0
+    endif
+
+    " Compute the index into the displayed tags for the tag type
+    let ttype_lnum = s:tlist_{a:fidx}_start + s:tlist_{a:fidx}_{ttype}_offset
+    let tidx = a:lnum - ttype_lnum
+    if tidx == 0
+        return 0
+    endif
+
+    " Get the corresponding tag line and return it
+    return s:tlist_{a:fidx}_{ttype}_{tidx}
+endfunction
+
+" Tlist_Window_Highlight_Line
+" Highlight the current line
+function! s:Tlist_Window_Highlight_Line()
+    " Clear previously selected name
+    match none
+
+    " Highlight the current line
+    if g:Tlist_Display_Prototype == 0
+        let pat = '/\%' . line('.') . 'l\s\+\zs.*/'
+    else
+        let pat = '/\%' . line('.') . 'l.*/'
+    endif
+
+    exe 'match TagListTagName ' . pat
+endfunction
+
+" Tlist_Window_Open_File
+" Open the specified file in either a new window or an existing window
+" and place the cursor at the specified tag pattern
+function! s:Tlist_Window_Open_File(win_ctrl, filename, tagpat)
+    call s:Tlist_Log_Msg('Tlist_Window_Open_File (' . a:filename . ',' .
+                \ a:win_ctrl . ')')
+    let prev_Tlist_Skip_Refresh = s:Tlist_Skip_Refresh
+    let s:Tlist_Skip_Refresh = 1
+
+    if s:tlist_app_name == "winmanager"
+        " Let the winmanager edit the file
+        call WinManagerFileEdit(a:filename, a:win_ctrl == 'newwin')
+    else
+
+    if a:win_ctrl == 'newtab'
+        " Create a new tab
+        exe 'tabnew ' . escape(a:filename, ' ')
+        " Open the taglist window in the new tab
+        call s:Tlist_Window_Open()
+    endif
+
+    if a:win_ctrl == 'checktab'
+        " Check whether the file is present in any of the tabs.
+        " If the file is present in the current tab, then use the
+        " current tab.
+        if bufwinnr(a:filename) != -1
+            let file_present_in_tab = 1
+            let i = tabpagenr()
+        else
+            let i = 1
+            let bnum = bufnr(a:filename)
+            let file_present_in_tab = 0
+            while i <= tabpagenr('$')
+                if index(tabpagebuflist(i), bnum) != -1
+                    let file_present_in_tab = 1
+                    break
+                endif
+                let i += 1
+            endwhile
+        endif
+
+        if file_present_in_tab
+            " Goto the tab containing the file
+            exe 'tabnext ' . i
+        else
+            " Open a new tab
+            exe 'tabnew ' . escape(a:filename, ' ')
+
+            " Open the taglist window
+            call s:Tlist_Window_Open()
+        endif
+    endif
+
+    let winnum = -1
+    if a:win_ctrl == 'prevwin'
+        " Open the file in the previous window, if it is usable
+        let cur_win = winnr()
+        wincmd p
+        if &buftype == '' && !&previewwindow
+            exe "edit " . escape(a:filename, ' ')
+            let winnum = winnr()
+        else
+            " Previous window is not usable
+            exe cur_win . 'wincmd w'
+        endif
+    endif
+
+    " Goto the window containing the file.  If the window is not there, open a
+    " new window
+    if winnum == -1
+        let winnum = bufwinnr(a:filename)
+    endif
+
+    if winnum == -1
+        " Locate the previously used window for opening a file
+        let fwin_num = 0
+        let first_usable_win = 0
+
+        let i = 1
+        let bnum = winbufnr(i)
+        while bnum != -1
+            if getwinvar(i, 'tlist_file_window') == 'yes'
+                let fwin_num = i
+                break
+            endif
+            if first_usable_win == 0 &&
+                        \ getbufvar(bnum, '&buftype') == '' &&
+                        \ !getwinvar(i, '&previewwindow')
+                " First non-taglist, non-plugin and non-preview window
+                let first_usable_win = i
+            endif
+            let i = i + 1
+            let bnum = winbufnr(i)
+        endwhile
+
+        " If a previously used window is not found, then use the first
+        " non-taglist window
+        if fwin_num == 0
+            let fwin_num = first_usable_win
+        endif
+
+        if fwin_num != 0
+            " Jump to the file window
+            exe fwin_num . "wincmd w"
+
+            " If the user asked to jump to the tag in a new window, then split
+            " the existing window into two.
+            if a:win_ctrl == 'newwin'
+                split
+            endif
+            exe "edit " . escape(a:filename, ' ')
+        else
+            " Open a new window
+            if g:Tlist_Use_Horiz_Window
+                exe 'leftabove split ' . escape(a:filename, ' ')
+            else
+                if winbufnr(2) == -1
+                    " Only the taglist window is present
+                    if g:Tlist_Use_Right_Window
+                        exe 'leftabove vertical split ' .
+                                    \ escape(a:filename, ' ')
+                    else
+                        exe 'rightbelow vertical split ' .
+                                    \ escape(a:filename, ' ')
+                    endif
+
+                    " Go to the taglist window to change the window size to
+                    " the user configured value
+                    call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
+                    if g:Tlist_Use_Horiz_Window
+                        exe 'resize ' . g:Tlist_WinHeight
+                    else
+                        exe 'vertical resize ' . g:Tlist_WinWidth
+                    endif
+                    " Go back to the file window
+                    call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
+                else
+                    " A plugin or help window is also present
+                    wincmd w
+                    exe 'leftabove split ' . escape(a:filename, ' ')
+                endif
+            endif
+        endif
+        " Mark the window, so that it can be reused.
+        call s:Tlist_Window_Mark_File_Window()
+    else
+        if v:version >= 700
+            " If the file is opened in more than one window, then check
+            " whether the last accessed window has the selected file.
+            " If it does, then use that window.
+            let lastwin_bufnum = winbufnr(winnr('#'))
+            if bufnr(a:filename) == lastwin_bufnum
+                let winnum = winnr('#')
+            endif
+        endif
+        exe winnum . 'wincmd w'
+
+        " If the user asked to jump to the tag in a new window, then split the
+        " existing window into two.
+        if a:win_ctrl == 'newwin'
+            split
+        endif
+    endif
+    endif
+
+    " Jump to the tag
+    if a:tagpat != ''
+        " Add the current cursor position to the jump list, so that user can
+        " jump back using the ' and ` marks.
+        mark '
+        silent call search(a:tagpat, 'w')
+
+        " Bring the line to the middle of the window
+        normal! z.
+
+        " If the line is inside a fold, open the fold
+        if foldclosed('.') != -1
+            .foldopen
+        endif
+    endif
+
+    " If the user selects to preview the tag then jump back to the
+    " taglist window
+    if a:win_ctrl == 'preview'
+        " Go back to the taglist window
+        let winnum = bufwinnr(g:TagList_title)
+        exe winnum . 'wincmd w'
+    else
+        " If the user has selected to close the taglist window, when a
+        " tag is selected, close the taglist  window
+        if g:Tlist_Close_On_Select
+            call s:Tlist_Window_Goto_Window()
+            close
+
+            " Go back to the window displaying the selected file
+            let wnum = bufwinnr(a:filename)
+            if wnum != -1 && wnum != winnr()
+                call s:Tlist_Exe_Cmd_No_Acmds(wnum . 'wincmd w')
+            endif
+        endif
+    endif
+
+    let s:Tlist_Skip_Refresh = prev_Tlist_Skip_Refresh
+endfunction
+
+" Tlist_Window_Jump_To_Tag()
+" Jump to the location of the current tag
+" win_ctrl == useopen - Reuse the existing file window
+" win_ctrl == newwin - Open a new window
+" win_ctrl == preview - Preview the tag
+" win_ctrl == prevwin - Open in previous window
+" win_ctrl == newtab - Open in new tab
+function! s:Tlist_Window_Jump_To_Tag(win_ctrl)
+    call s:Tlist_Log_Msg('Tlist_Window_Jump_To_Tag(' . a:win_ctrl . ')')
+    " Do not process comment lines and empty lines
+    let curline = getline('.')
+    if curline =~ '^\s*$' || curline[0] == '"'
+        return
+    endif
+
+    " If inside a closed fold, then use the first line of the fold
+    " and jump to the file.
+    let lnum = foldclosed('.')
+    if lnum == -1
+        " Jump to the selected tag or file
+        let lnum = line('.')
+    else
+        " Open the closed fold
+        .foldopen!
+    endif
+
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
+    if fidx == -1
+        return
+    endif
+
+    " Get the tag output for the current tag
+    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, lnum)
+    if tidx != 0
+        let tagpat = s:Tlist_Get_Tag_SearchPat(fidx, tidx)
+
+        " Highlight the tagline
+        call s:Tlist_Window_Highlight_Line()
+    else
+        " Selected a line which is not a tag name. Just edit the file
+        let tagpat = ''
+    endif
+
+    call s:Tlist_Window_Open_File(a:win_ctrl, s:tlist_{fidx}_filename, tagpat)
+endfunction
+
+" Tlist_Window_Show_Info()
+" Display information about the entry under the cursor
+function! s:Tlist_Window_Show_Info()
+    call s:Tlist_Log_Msg('Tlist_Window_Show_Info()')
+
+    " Clear the previously displayed line
+    echo
+
+    " Do not process comment lines and empty lines
+    let curline = getline('.')
+    if curline =~ '^\s*$' || curline[0] == '"'
+        return
+    endif
+
+    " If inside a fold, then don't display the prototype
+    if foldclosed('.') != -1
+        return
+    endif
+
+    let lnum = line('.')
+
+    " Get the file index
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
+    if fidx == -1
+        return
+    endif
+
+    if lnum == s:tlist_{fidx}_start
+        " Cursor is on a file name
+        let fname = s:tlist_{fidx}_filename
+        if strlen(fname) > 50
+            let fname = fnamemodify(fname, ':t')
+        endif
+        echo fname . ', Filetype=' . s:tlist_{fidx}_filetype .
+                    \  ', Tag count=' . s:tlist_{fidx}_tag_count
+        return
+    endif
+
+    " Get the tag output line for the current tag
+    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, lnum)
+    if tidx == 0
+        " Cursor is on a tag type
+        let ttype = s:Tlist_Window_Get_Tag_Type_By_Linenum(fidx, lnum)
+        if ttype == ''
+            return
+        endif
+
+        let ttype_name = ''
+
+        let ftype = s:tlist_{fidx}_filetype
+        let i = 1
+        while i <= s:tlist_{ftype}_count
+            if ttype == s:tlist_{ftype}_{i}_name
+                let ttype_name = s:tlist_{ftype}_{i}_fullname
+                break
+            endif
+            let i = i + 1
+        endwhile
+
+        echo 'Tag type=' . ttype_name .
+                    \ ', Tag count=' . s:tlist_{fidx}_{ttype}_count
+        return
+    endif
+
+    " Get the tag search pattern and display it
+    echo s:Tlist_Get_Tag_Prototype(fidx, tidx)
+endfunction
+
+" Tlist_Find_Nearest_Tag_Idx
+" Find the tag idx nearest to the supplied line number
+" Returns -1, if a tag couldn't be found for the specified line number
+function! s:Tlist_Find_Nearest_Tag_Idx(fidx, linenum)
+    let sort_type = s:tlist_{a:fidx}_sort_type
+
+    let left = 1
+    let right = s:tlist_{a:fidx}_tag_count
+
+    if sort_type == 'order'
+        " Tags sorted by order, use a binary search.
+        " The idea behind this function is taken from the ctags.vim script (by
+        " Alexey Marinichev) available at the Vim online website.
+
+        " If the current line is the less than the first tag, then no need to
+        " search
+        let first_lnum = s:Tlist_Get_Tag_Linenum(a:fidx, 1)
+
+        if a:linenum < first_lnum
+            return -1
+        endif
+
+        while left < right
+            let middle = (right + left + 1) / 2
+            let middle_lnum = s:Tlist_Get_Tag_Linenum(a:fidx, middle)
+
+            if middle_lnum == a:linenum
+                let left = middle
+                break
+            endif
+
+            if middle_lnum > a:linenum
+                let right = middle - 1
+            else
+                let left = middle
+            endif
+        endwhile
+    else
+        " Tags sorted by name, use a linear search. (contributed by Dave
+        " Eggum).
+        " Look for a tag with a line number less than or equal to the supplied
+        " line number. If multiple tags are found, then use the tag with the
+        " line number closest to the supplied line number. IOW, use the tag
+        " with the highest line number.
+        let closest_lnum = 0
+        let final_left = 0
+        while left <= right
+            let lnum = s:Tlist_Get_Tag_Linenum(a:fidx, left)
+
+            if lnum < a:linenum && lnum > closest_lnum
+                let closest_lnum = lnum
+                let final_left = left
+            elseif lnum == a:linenum
+                let closest_lnum = lnum
+                let final_left = left
+                break
+            else
+                let left = left + 1
+            endif
+        endwhile
+        if closest_lnum == 0
+            return -1
+        endif
+        if left >= right
+            let left = final_left
+        endif
+    endif
+
+    return left
+endfunction
+
+" Tlist_Window_Highlight_Tag()
+" Highlight the current tag
+" cntx == 1, Called by the taglist plugin itself
+" cntx == 2, Forced by the user through the TlistHighlightTag command
+" center = 1, move the tag line to the center of the taglist window
+function! s:Tlist_Window_Highlight_Tag(filename, cur_lnum, cntx, center)
+    " Highlight the current tag only if the user configured the
+    " taglist plugin to do so or if the user explictly invoked the
+    " command to highlight the current tag.
+    if !g:Tlist_Auto_Highlight_Tag && a:cntx == 1
+        return
+    endif
+
+    if a:filename == ''
+        return
+    endif
+
+    " Make sure the taglist window is present
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum == -1
+        call s:Tlist_Warning_Msg('Error: Taglist window is not open')
+        return
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(a:filename)
+    if fidx == -1
+        return
+    endif
+
+    " If the file is currently not displayed in the taglist window, then retrn
+    if !s:tlist_{fidx}_visible
+        return
+    endif
+
+    " If there are no tags for this file, then no need to proceed further
+    if s:tlist_{fidx}_tag_count == 0
+        return
+    endif
+
+    " Ignore all autocommands
+    let old_ei = &eventignore
+    set eventignore=all
+
+    " Save the original window number
+    let org_winnr = winnr()
+
+    if org_winnr == winnum
+        let in_taglist_window = 1
+    else
+        let in_taglist_window = 0
+    endif
+
+    " Go to the taglist window
+    if !in_taglist_window
+        exe winnum . 'wincmd w'
+    endif
+
+    " Clear previously selected name
+    match none
+
+    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, a:cur_lnum)
+    if tidx == -1
+        " Make sure the current tag line is visible in the taglist window.
+        " Calling the winline() function makes the line visible.  Don't know
+        " of a better way to achieve this.
+        let lnum = line('.')
+
+        if lnum < s:tlist_{fidx}_start || lnum > s:tlist_{fidx}_end
+            " Move the cursor to the beginning of the file
+            exe s:tlist_{fidx}_start
+        endif
+
+        if foldclosed('.') != -1
+            .foldopen
+        endif
+
+        call winline()
+
+        if !in_taglist_window
+            exe org_winnr . 'wincmd w'
+        endif
+
+        " Restore the autocommands
+        let &eventignore = old_ei
+        return
+    endif
+
+    " Extract the tag type
+    let ttype = s:Tlist_Get_Tag_Type_By_Tag(fidx, tidx)
+
+    " Compute the line number
+    " Start of file + Start of tag type + offset
+    let lnum = s:tlist_{fidx}_start + s:tlist_{fidx}_{ttype}_offset +
+                \ s:tlist_{fidx}_{tidx}_ttype_idx
+
+    " Goto the line containing the tag
+    exe lnum
+
+    " Open the fold
+    if foldclosed('.') != -1
+        .foldopen
+    endif
+
+    if a:center
+        " Move the tag line to the center of the taglist window
+        normal! z.
+    else
+        " Make sure the current tag line is visible in the taglist window.
+        " Calling the winline() function makes the line visible.  Don't know
+        " of a better way to achieve this.
+        call winline()
+    endif
+
+    " Highlight the tag name
+    call s:Tlist_Window_Highlight_Line()
+
+    " Go back to the original window
+    if !in_taglist_window
+        exe org_winnr . 'wincmd w'
+    endif
+
+    " Restore the autocommands
+    let &eventignore = old_ei
+    return
+endfunction
+
+" Tlist_Get_Tag_Prototype_By_Line
+" Get the prototype for the tag on or before the specified line number in the
+" current buffer
+function! Tlist_Get_Tag_Prototype_By_Line(...)
+    if a:0 == 0
+        " Arguments are not supplied. Use the current buffer name
+        " and line number
+        let filename = bufname('%')
+        let linenr = line('.')
+    elseif a:0 == 2
+        " Filename and line number are specified
+        let filename = a:1
+        let linenr = a:2
+        if linenr !~ '\d\+'
+            " Invalid line number
+            return ""
+        endif
+    else
+        " Sufficient arguments are not supplied
+        let msg =  'Usage: Tlist_Get_Tag_Prototype_By_Line <filename> ' .
+                                \ '<line_number>'
+        call s:Tlist_Warning_Msg(msg)
+        return ""
+    endif
+
+    " Expand the file to a fully qualified name
+    let filename = fnamemodify(filename, ':p')
+    if filename == ''
+        return ""
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(filename)
+    if fidx == -1
+        return ""
+    endif
+
+    " If there are no tags for this file, then no need to proceed further
+    if s:tlist_{fidx}_tag_count == 0
+        return ""
+    endif
+
+    " Get the tag text using the line number
+    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, linenr)
+    if tidx == -1
+        return ""
+    endif
+
+    return s:Tlist_Get_Tag_Prototype(fidx, tidx)
+endfunction
+
+" Tlist_Get_Tagname_By_Line
+" Get the tag name on or before the specified line number in the
+" current buffer
+function! Tlist_Get_Tagname_By_Line(...)
+    if a:0 == 0
+        " Arguments are not supplied. Use the current buffer name
+        " and line number
+        let filename = bufname('%')
+        let linenr = line('.')
+    elseif a:0 == 2
+        " Filename and line number are specified
+        let filename = a:1
+        let linenr = a:2
+        if linenr !~ '\d\+'
+            " Invalid line number
+            return ""
+        endif
+    else
+        " Sufficient arguments are not supplied
+        let msg =  'Usage: Tlist_Get_Tagname_By_Line <filename> <line_number>'
+        call s:Tlist_Warning_Msg(msg)
+        return ""
+    endif
+
+    " Make sure the current file has a name
+    let filename = fnamemodify(filename, ':p')
+    if filename == ''
+        return ""
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(filename)
+    if fidx == -1
+        return ""
+    endif
+
+    " If there are no tags for this file, then no need to proceed further
+    if s:tlist_{fidx}_tag_count == 0
+        return ""
+    endif
+
+    " Get the tag name using the line number
+    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, linenr)
+    if tidx == -1
+        return ""
+    endif
+
+    return s:tlist_{fidx}_{tidx}_tag_name
+endfunction
+
+" Tlist_Window_Move_To_File
+" Move the cursor to the beginning of the current file or the next file
+" or the previous file in the taglist window
+" dir == -1, move to start of current or previous function
+" dir == 1, move to start of next function
+function! s:Tlist_Window_Move_To_File(dir)
+    if foldlevel('.') == 0
+        " Cursor is on a non-folded line (it is not in any of the files)
+        " Move it to a folded line
+        if a:dir == -1
+            normal! zk
+        else
+            " While moving down to the start of the next fold,
+            " no need to do go to the start of the next file.
+            normal! zj
+            return
+        endif
+    endif
+
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
+    if fidx == -1
+        return
+    endif
+
+    let cur_lnum = line('.')
+
+    if a:dir == -1
+        if cur_lnum > s:tlist_{fidx}_start
+            " Move to the beginning of the current file
+            exe s:tlist_{fidx}_start
+            return
+        endif
+
+        if fidx != 0
+            " Move to the beginning of the previous file
+            let fidx = fidx - 1
+        else
+            " Cursor is at the first file, wrap around to the last file
+            let fidx = s:tlist_file_count - 1
+        endif
+
+        exe s:tlist_{fidx}_start
+        return
+    else
+        " Move to the beginning of the next file
+        let fidx = fidx + 1
+
+        if fidx >= s:tlist_file_count
+            " Cursor is at the last file, wrap around to the first file
+            let fidx = 0
+        endif
+
+        if s:tlist_{fidx}_start != 0
+            exe s:tlist_{fidx}_start
+        endif
+        return
+    endif
+endfunction
+
+" Tlist_Session_Load
+" Load a taglist session (information about all the displayed files
+" and the tags) from the specified file
+function! s:Tlist_Session_Load(...)
+    if a:0 == 0 || a:1 == ''
+        call s:Tlist_Warning_Msg('Usage: TlistSessionLoad <filename>')
+        return
+    endif
+
+    let sessionfile = a:1
+
+    if !filereadable(sessionfile)
+        let msg = 'Taglist: Error - Unable to open file ' . sessionfile
+        call s:Tlist_Warning_Msg(msg)
+        return
+    endif
+
+    " Mark the current window as the file window
+    call s:Tlist_Window_Mark_File_Window()
+
+    " Source the session file
+    exe 'source ' . sessionfile
+
+    let new_file_count = g:tlist_file_count
+    unlet! g:tlist_file_count
+
+    let i = 0
+    while i < new_file_count
+        let ftype = g:tlist_{i}_filetype
+        unlet! g:tlist_{i}_filetype
+
+        if !exists('s:tlist_' . ftype . '_count')
+            if s:Tlist_FileType_Init(ftype) == 0
+                let i = i + 1
+                continue
+            endif
+        endif
+
+        let fname = g:tlist_{i}_filename
+        unlet! g:tlist_{i}_filename
+
+        let fidx = s:Tlist_Get_File_Index(fname)
+        if fidx != -1
+            let s:tlist_{fidx}_visible = 0
+            let i = i + 1
+            continue
+        else
+            " As we are loading the tags from the session file, if this
+            " file was previously deleted by the user, now we need to
+            " add it back. So remove the file from the deleted list.
+            call s:Tlist_Update_Remove_List(fname, 0)
+        endif
+
+        let fidx = s:Tlist_Init_File(fname, ftype)
+
+        let s:tlist_{fidx}_filename = fname
+
+        let s:tlist_{fidx}_sort_type = g:tlist_{i}_sort_type
+        unlet! g:tlist_{i}_sort_type
+
+        let s:tlist_{fidx}_filetype = ftype
+        let s:tlist_{fidx}_mtime = getftime(fname)
+
+        let s:tlist_{fidx}_start = 0
+        let s:tlist_{fidx}_end = 0
+
+        let s:tlist_{fidx}_valid = 1
+
+        let s:tlist_{fidx}_tag_count = g:tlist_{i}_tag_count
+        unlet! g:tlist_{i}_tag_count
+
+        let j = 1
+        while j <= s:tlist_{fidx}_tag_count
+            let s:tlist_{fidx}_{j}_tag = g:tlist_{i}_{j}_tag
+            let s:tlist_{fidx}_{j}_tag_name = g:tlist_{i}_{j}_tag_name
+            let s:tlist_{fidx}_{j}_ttype_idx = g:tlist_{i}_{j}_ttype_idx
+            unlet! g:tlist_{i}_{j}_tag
+            unlet! g:tlist_{i}_{j}_tag_name
+            unlet! g:tlist_{i}_{j}_ttype_idx
+            let j = j + 1
+        endwhile
+
+        let j = 1
+        while j <= s:tlist_{ftype}_count
+            let ttype = s:tlist_{ftype}_{j}_name
+
+            if exists('g:tlist_' . i . '_' . ttype)
+                let s:tlist_{fidx}_{ttype} = g:tlist_{i}_{ttype}
+                unlet! g:tlist_{i}_{ttype}
+                let s:tlist_{fidx}_{ttype}_offset = 0
+                let s:tlist_{fidx}_{ttype}_count = g:tlist_{i}_{ttype}_count
+                unlet! g:tlist_{i}_{ttype}_count
+
+                let k = 1
+                while k <= s:tlist_{fidx}_{ttype}_count
+                    let s:tlist_{fidx}_{ttype}_{k} = g:tlist_{i}_{ttype}_{k}
+                    unlet! g:tlist_{i}_{ttype}_{k}
+                    let k = k + 1
+                endwhile
+            else
+                let s:tlist_{fidx}_{ttype} = ''
+                let s:tlist_{fidx}_{ttype}_offset = 0
+                let s:tlist_{fidx}_{ttype}_count = 0
+            endif
+
+            let j = j + 1
+        endwhile
+
+        let i = i + 1
+    endwhile
+
+    " If the taglist window is open, then update it
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        let save_winnr = winnr()
+
+        " Goto the taglist window
+        call s:Tlist_Window_Goto_Window()
+
+        " Refresh the taglist window
+        call s:Tlist_Window_Refresh()
+
+        " Go back to the original window
+        if save_winnr != winnr()
+            call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
+        endif
+    endif
+endfunction
+
+" Tlist_Session_Save
+" Save a taglist session (information about all the displayed files
+" and the tags) into the specified file
+function! s:Tlist_Session_Save(...)
+    if a:0 == 0 || a:1 == ''
+        call s:Tlist_Warning_Msg('Usage: TlistSessionSave <filename>')
+        return
+    endif
+
+    let sessionfile = a:1
+
+    if s:tlist_file_count == 0
+        " There is nothing to save
+        call s:Tlist_Warning_Msg('Warning: Taglist is empty. Nothing to save.')
+        return
+    endif
+
+    if filereadable(sessionfile)
+        let ans = input('Do you want to overwrite ' . sessionfile . ' (Y/N)?')
+        if ans !=? 'y'
+            return
+        endif
+
+        echo "\n"
+    endif
+
+    let old_verbose = &verbose
+    set verbose&vim
+
+    exe 'redir! > ' . sessionfile
+
+    silent! echo '" Taglist session file. This file is auto-generated.'
+    silent! echo '" File information'
+    silent! echo 'let tlist_file_count = ' . s:tlist_file_count
+
+    let i = 0
+
+    while i < s:tlist_file_count
+        " Store information about the file
+        silent! echo 'let tlist_' . i . "_filename = '" .
+                                            \ s:tlist_{i}_filename . "'"
+        silent! echo 'let tlist_' . i . '_sort_type = "' .
+                                                \ s:tlist_{i}_sort_type . '"'
+        silent! echo 'let tlist_' . i . '_filetype = "' .
+                                            \ s:tlist_{i}_filetype . '"'
+        silent! echo 'let tlist_' . i . '_tag_count = ' .
+                                                        \ s:tlist_{i}_tag_count
+        " Store information about all the tags
+        let j = 1
+        while j <= s:tlist_{i}_tag_count
+            let txt = escape(s:tlist_{i}_{j}_tag, '"\\')
+            silent! echo 'let tlist_' . i . '_' . j . '_tag = "' . txt . '"'
+            silent! echo 'let tlist_' . i . '_' . j . '_tag_name = "' .
+                        \ s:tlist_{i}_{j}_tag_name . '"'
+            silent! echo 'let tlist_' . i . '_' . j . '_ttype_idx' . ' = ' .
+                        \ s:tlist_{i}_{j}_ttype_idx
+            let j = j + 1
+        endwhile
+
+        " Store information about all the tags grouped by their type
+        let ftype = s:tlist_{i}_filetype
+        let j = 1
+        while j <= s:tlist_{ftype}_count
+            let ttype = s:tlist_{ftype}_{j}_name
+            if s:tlist_{i}_{ttype}_count != 0
+                let txt = escape(s:tlist_{i}_{ttype}, '"\')
+                let txt = substitute(txt, "\n", "\\\\n", 'g')
+                silent! echo 'let tlist_' . i . '_' . ttype . ' = "' .
+                                                \ txt . '"'
+                silent! echo 'let tlist_' . i . '_' . ttype . '_count = ' .
+                                                     \ s:tlist_{i}_{ttype}_count
+                let k = 1
+                while k <= s:tlist_{i}_{ttype}_count
+                    silent! echo 'let tlist_' . i . '_' . ttype . '_' . k .
+                                \ ' = ' . s:tlist_{i}_{ttype}_{k}
+                    let k = k + 1
+                endwhile
+            endif
+            let j = j + 1
+        endwhile
+
+        silent! echo
+
+        let i = i + 1
+    endwhile
+
+    redir END
+
+    let &verbose = old_verbose
+endfunction
+
+" Tlist_Buffer_Removed
+" A buffer is removed from the Vim buffer list. Remove the tags defined
+" for that file
+function! s:Tlist_Buffer_Removed(filename)
+    call s:Tlist_Log_Msg('Tlist_Buffer_Removed (' . a:filename .  ')')
+
+    " Make sure a valid filename is supplied
+    if a:filename == ''
+        return
+    endif
+
+    " Get tag list index of the specified file
+    let fidx = s:Tlist_Get_File_Index(a:filename)
+    if fidx == -1
+        " File not present in the taglist
+        return
+    endif
+
+    " Remove the file from the list
+    call s:Tlist_Remove_File(fidx, 0)
+endfunction
+
+" When a buffer is deleted, remove the file from the taglist
+autocmd BufDelete * silent call s:Tlist_Buffer_Removed(expand('<afile>:p'))
+
+" Tlist_Window_Open_File_Fold
+" Open the fold for the specified file and close the fold for all the
+" other files
+function! s:Tlist_Window_Open_File_Fold(acmd_bufnr)
+    call s:Tlist_Log_Msg('Tlist_Window_Open_File_Fold (' . a:acmd_bufnr . ')')
+
+    " Make sure the taglist window is present
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum == -1
+        call s:Tlist_Warning_Msg('Taglist: Error - Taglist window is not open')
+        return
+    endif
+
+    " Save the original window number
+    let org_winnr = winnr()
+    if org_winnr == winnum
+        let in_taglist_window = 1
+    else
+        let in_taglist_window = 0
+    endif
+
+    if in_taglist_window
+        " When entering the taglist window, no need to update the folds
+        return
+    endif
+
+    " Go to the taglist window
+    if !in_taglist_window
+        call s:Tlist_Exe_Cmd_No_Acmds(winnum . 'wincmd w')
+    endif
+
+    " Close all the folds
+    silent! %foldclose
+
+    " Get tag list index of the specified file
+    let fname = fnamemodify(bufname(a:acmd_bufnr + 0), ':p')
+    if filereadable(fname)
+        let fidx = s:Tlist_Get_File_Index(fname)
+        if fidx != -1
+            " Open the fold for the file
+            exe "silent! " . s:tlist_{fidx}_start . "," .
+                        \ s:tlist_{fidx}_end . "foldopen"
+        endif
+    endif
+
+    " Go back to the original window
+    if !in_taglist_window
+        call s:Tlist_Exe_Cmd_No_Acmds(org_winnr . 'wincmd w')
+    endif
+endfunction
+
+" Tlist_Window_Check_Auto_Open
+" Open the taglist window automatically on Vim startup.
+" Open the window only when files present in any of the Vim windows support
+" tags.
+function! s:Tlist_Window_Check_Auto_Open()
+    let open_window = 0
+
+    let i = 1
+    let buf_num = winbufnr(i)
+    while buf_num != -1
+        let filename = fnamemodify(bufname(buf_num), ':p')
+        let ft = s:Tlist_Get_Buffer_Filetype(buf_num)
+        if !s:Tlist_Skip_File(filename, ft)
+            let open_window = 1
+            break
+        endif
+        let i = i + 1
+        let buf_num = winbufnr(i)
+    endwhile
+
+    if open_window
+        call s:Tlist_Window_Toggle()
+    endif
+endfunction
+
+" Tlist_Refresh_Folds
+" Remove and create the folds for all the files displayed in the taglist
+" window. Used after entering a tab. If this is not done, then the folds
+" are not properly created for taglist windows displayed in multiple tabs.
+function! s:Tlist_Refresh_Folds()
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum == -1
+        return
+    endif
+
+    let save_wnum = winnr()
+    exe winnum . 'wincmd w'
+
+    " First remove all the existing folds
+    normal! zE
+
+    " Create the folds for each in the tag list
+    let fidx = 0
+    while fidx < s:tlist_file_count
+        let ftype = s:tlist_{fidx}_filetype
+
+        " Create the folds for each tag type in a file
+        let j = 1
+        while j <= s:tlist_{ftype}_count
+            let ttype = s:tlist_{ftype}_{j}_name
+            if s:tlist_{fidx}_{ttype}_count
+                let s = s:tlist_{fidx}_start + s:tlist_{fidx}_{ttype}_offset
+                let e = s + s:tlist_{fidx}_{ttype}_count
+                exe s . ',' . e . 'fold'
+            endif
+            let j = j + 1
+        endwhile
+
+        exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'fold'
+        exe 'silent! ' . s:tlist_{fidx}_start . ',' .
+                    \ s:tlist_{fidx}_end . 'foldopen!'
+        let fidx = fidx + 1
+    endwhile
+
+    exe save_wnum . 'wincmd w'
+endfunction
+
+function! s:Tlist_Menu_Add_Base_Menu()
+    call s:Tlist_Log_Msg('Adding the base menu')
+
+    " Add the menu
+    anoremenu <silent> T&ags.Refresh\ menu :call <SID>Tlist_Menu_Refresh()<CR>
+    anoremenu <silent> T&ags.Sort\ menu\ by.Name
+                    \ :call <SID>Tlist_Change_Sort('menu', 'set', 'name')<CR>
+    anoremenu <silent> T&ags.Sort\ menu\ by.Order
+                    \ :call <SID>Tlist_Change_Sort('menu', 'set', 'order')<CR>
+    anoremenu T&ags.-SEP1-           :
+
+    if &mousemodel =~ 'popup'
+        anoremenu <silent> PopUp.T&ags.Refresh\ menu
+                    \ :call <SID>Tlist_Menu_Refresh()<CR>
+        anoremenu <silent> PopUp.T&ags.Sort\ menu\ by.Name
+                  \ :call <SID>Tlist_Change_Sort('menu', 'set', 'name')<CR>
+        anoremenu <silent> PopUp.T&ags.Sort\ menu\ by.Order
+                  \ :call <SID>Tlist_Change_Sort('menu', 'set', 'order')<CR>
+        anoremenu PopUp.T&ags.-SEP1-           :
+    endif
+endfunction
+
+let s:menu_char_prefix =
+            \ '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
+
+" Tlist_Menu_Get_Tag_Type_Cmd
+" Get the menu command for the specified tag type
+" fidx - File type index
+" ftype - File Type
+" add_ttype_name - To add or not to add the tag type name to the menu entries
+" ttype_idx - Tag type index
+function! s:Tlist_Menu_Get_Tag_Type_Cmd(fidx, ftype, add_ttype_name, ttype_idx)
+    " Curly brace variable name optimization
+    let ftype_ttype_idx = a:ftype . '_' . a:ttype_idx
+
+    let ttype = s:tlist_{ftype_ttype_idx}_name
+    if a:add_ttype_name
+        " If the tag type name contains space characters, escape it. This
+        " will be used to create the menu entries.
+        let ttype_fullname = escape(s:tlist_{ftype_ttype_idx}_fullname, ' ')
+    endif
+
+    " Curly brace variable name optimization
+    let fidx_ttype = a:fidx . '_' . ttype
+
+    " Number of tag entries for this tag type
+    let tcnt = s:tlist_{fidx_ttype}_count
+    if tcnt == 0 " No entries for this tag type
+        return ''
+    endif
+
+    let mcmd = ''
+
+    " Create the menu items for the tags.
+    " Depending on the number of tags of this type, split the menu into
+    " multiple sub-menus, if needed.
+    if tcnt > g:Tlist_Max_Submenu_Items
+        let j = 1
+        while j <= tcnt
+            let final_index = j + g:Tlist_Max_Submenu_Items - 1
+            if final_index > tcnt
+                let final_index = tcnt
+            endif
+
+            " Extract the first and last tag name and form the
+            " sub-menu name
+            let tidx = s:tlist_{fidx_ttype}_{j}
+            let first_tag = s:tlist_{a:fidx}_{tidx}_tag_name
+
+            let tidx = s:tlist_{fidx_ttype}_{final_index}
+            let last_tag = s:tlist_{a:fidx}_{tidx}_tag_name
+
+            " Truncate the names, if they are greater than the
+            " max length
+            let first_tag = strpart(first_tag, 0, g:Tlist_Max_Tag_Length)
+            let last_tag = strpart(last_tag, 0, g:Tlist_Max_Tag_Length)
+
+            " Form the menu command prefix
+            let m_prefix = 'anoremenu <silent> T\&ags.'
+            if a:add_ttype_name
+                let m_prefix = m_prefix . ttype_fullname . '.'
+            endif
+            let m_prefix = m_prefix . first_tag . '\.\.\.' . last_tag . '.'
+
+            " Character prefix used to number the menu items (hotkey)
+            let m_prefix_idx = 0
+
+            while j <= final_index
+                let tidx = s:tlist_{fidx_ttype}_{j}
+
+                let tname = s:tlist_{a:fidx}_{tidx}_tag_name
+
+                let mcmd = mcmd . m_prefix . '\&' .
+                            \ s:menu_char_prefix[m_prefix_idx] . '\.' .
+                            \ tname . ' :call <SID>Tlist_Menu_Jump_To_Tag(' .
+                            \ tidx . ')<CR>|'
+
+                let m_prefix_idx = m_prefix_idx + 1
+                let j = j + 1
+            endwhile
+        endwhile
+    else
+        " Character prefix used to number the menu items (hotkey)
+        let m_prefix_idx = 0
+
+        let m_prefix = 'anoremenu <silent> T\&ags.'
+        if a:add_ttype_name
+            let m_prefix = m_prefix . ttype_fullname . '.'
+        endif
+        let j = 1
+        while j <= tcnt
+            let tidx = s:tlist_{fidx_ttype}_{j}
+
+            let tname = s:tlist_{a:fidx}_{tidx}_tag_name
+
+            let mcmd = mcmd . m_prefix . '\&' .
+                        \ s:menu_char_prefix[m_prefix_idx] . '\.' .
+                        \ tname . ' :call <SID>Tlist_Menu_Jump_To_Tag(' . tidx
+                        \ . ')<CR>|'
+
+            let m_prefix_idx = m_prefix_idx + 1
+            let j = j + 1
+        endwhile
+    endif
+
+    return mcmd
+endfunction
+
+" Update the taglist menu with the tags for the specified file
+function! s:Tlist_Menu_File_Refresh(fidx)
+    call s:Tlist_Log_Msg('Refreshing the tag menu for ' . s:tlist_{a:fidx}_filename)
+    " The 'B' flag is needed in the 'cpoptions' option
+    let old_cpoptions = &cpoptions
+    set cpoptions&vim
+
+    exe s:tlist_{a:fidx}_menu_cmd
+
+    " Update the popup menu (if enabled)
+    if &mousemodel =~ 'popup'
+        let cmd = substitute(s:tlist_{a:fidx}_menu_cmd, ' T\\&ags\.',
+                                        \ ' PopUp.T\\\&ags.', "g")
+        exe cmd
+    endif
+
+    " The taglist menu is not empty now
+    let s:tlist_menu_empty = 0
+
+    " Restore the 'cpoptions' settings
+    let &cpoptions = old_cpoptions
+endfunction
+
+" Tlist_Menu_Update_File
+" Add the taglist menu
+function! s:Tlist_Menu_Update_File(clear_menu)
+    if !has('gui_running')
+        " Not running in GUI mode
+        return
+    endif
+
+    call s:Tlist_Log_Msg('Updating the tag menu, clear_menu = ' . a:clear_menu)
+
+    " Remove the tags menu
+    if a:clear_menu
+        call s:Tlist_Menu_Remove_File()
+
+    endif
+
+    " Skip buffers with 'buftype' set to nofile, nowrite, quickfix or help
+    if &buftype != ''
+        return
+    endif
+
+    let filename = fnamemodify(bufname('%'), ':p')
+    let ftype = s:Tlist_Get_Buffer_Filetype('%')
+
+    " If the file doesn't support tag listing, skip it
+    if s:Tlist_Skip_File(filename, ftype)
+        return
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(filename)
+    if fidx == -1 || !s:tlist_{fidx}_valid
+        " Check whether this file is removed based on user request
+        " If it is, then don't display the tags for this file
+        if s:Tlist_User_Removed_File(filename)
+            return
+        endif
+
+        " Process the tags for the file
+        let fidx = s:Tlist_Process_File(filename, ftype)
+        if fidx == -1
+            return
+        endif
+    endif
+
+    let fname = escape(fnamemodify(bufname('%'), ':t'), '.')
+    if fname != ''
+        exe 'anoremenu T&ags.' .  fname . ' <Nop>'
+        anoremenu T&ags.-SEP2-           :
+    endif
+
+    if !s:tlist_{fidx}_tag_count
+        return
+    endif
+
+    if s:tlist_{fidx}_menu_cmd != ''
+        " Update the menu with the cached command
+        call s:Tlist_Menu_File_Refresh(fidx)
+
+        return
+    endif
+
+    " We are going to add entries to the tags menu, so the menu won't be
+    " empty
+    let s:tlist_menu_empty = 0
+
+    let cmd = ''
+
+    " Determine whether the tag type name needs to be added to the menu
+    " If more than one tag type is present in the taglisting for a file,
+    " then the tag type name needs to be present
+    let add_ttype_name = -1
+    let i = 1
+    while i <= s:tlist_{ftype}_count && add_ttype_name < 1
+        let ttype = s:tlist_{ftype}_{i}_name
+        if s:tlist_{fidx}_{ttype}_count
+            let add_ttype_name = add_ttype_name + 1
+        endif
+        let i = i + 1
+    endwhile
+
+    " Process the tags by the tag type and get the menu command
+    let i = 1
+    while i <= s:tlist_{ftype}_count
+        let mcmd = s:Tlist_Menu_Get_Tag_Type_Cmd(fidx, ftype, add_ttype_name, i)
+        if mcmd != ''
+            let cmd = cmd . mcmd
+        endif
+
+        let i = i + 1
+    endwhile
+
+    " Cache the menu command for reuse
+    let s:tlist_{fidx}_menu_cmd = cmd
+
+    " Update the menu
+    call s:Tlist_Menu_File_Refresh(fidx)
+endfunction
+
+" Tlist_Menu_Remove_File
+" Remove the tags displayed in the tags menu
+function! s:Tlist_Menu_Remove_File()
+    if !has('gui_running') || s:tlist_menu_empty
+        return
+    endif
+
+    call s:Tlist_Log_Msg('Removing the tags menu for a file')
+
+    " Cleanup the Tags menu
+    silent! unmenu T&ags
+    if &mousemodel =~ 'popup'
+        silent! unmenu PopUp.T&ags
+    endif
+
+    " Add a dummy menu item to retain teared off menu
+    noremenu T&ags.Dummy l
+
+    silent! unmenu! T&ags
+    if &mousemodel =~ 'popup'
+        silent! unmenu! PopUp.T&ags
+    endif
+
+    call s:Tlist_Menu_Add_Base_Menu()
+
+    " Remove the dummy menu item
+    unmenu T&ags.Dummy
+
+    let s:tlist_menu_empty = 1
+endfunction
+
+" Tlist_Menu_Refresh
+" Refresh the taglist menu
+function! s:Tlist_Menu_Refresh()
+    call s:Tlist_Log_Msg('Refreshing the tags menu')
+    let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
+    if fidx != -1
+        " Invalidate the cached menu command
+        let s:tlist_{fidx}_menu_cmd = ''
+    endif
+
+    " Update the taglist, menu and window
+    call s:Tlist_Update_Current_File()
+endfunction
+
+" Tlist_Menu_Jump_To_Tag
+" Jump to the selected tag
+function! s:Tlist_Menu_Jump_To_Tag(tidx)
+    let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
+    if fidx == -1
+        return
+    endif
+
+    let tagpat = s:Tlist_Get_Tag_SearchPat(fidx, a:tidx)
+    if tagpat == ''
+        return
+    endif
+
+    " Add the current cursor position to the jump list, so that user can
+    " jump back using the ' and ` marks.
+    mark '
+
+    silent call search(tagpat, 'w')
+
+    " Bring the line to the middle of the window
+    normal! z.
+
+    " If the line is inside a fold, open the fold
+    if foldclosed('.') != -1
+        .foldopen
+    endif
+endfunction
+
+" Tlist_Menu_Init
+" Initialize the taglist menu
+function! s:Tlist_Menu_Init()
+    call s:Tlist_Menu_Add_Base_Menu()
+
+    " Automatically add the tags defined in the current file to the menu
+    augroup TagListMenuCmds
+        autocmd!
+
+        if !g:Tlist_Process_File_Always
+            autocmd BufEnter * call s:Tlist_Refresh()
+        endif
+        autocmd BufLeave * call s:Tlist_Menu_Remove_File()
+    augroup end
+
+    call s:Tlist_Menu_Update_File(0)
+endfunction
+
+" Tlist_Vim_Session_Load
+" Initialize the taglist window/buffer, which is created when loading
+" a Vim session file.
+function! s:Tlist_Vim_Session_Load()
+    call s:Tlist_Log_Msg('Tlist_Vim_Session_Load')
+
+    " Initialize the taglist window
+    call s:Tlist_Window_Init()
+
+    " Refresh the taglist window
+    call s:Tlist_Window_Refresh()
+endfunction
+
+" Tlist_Set_App
+" Set the name of the external plugin/application to which taglist
+" belongs.
+" Taglist plugin is part of another plugin like cream or winmanager.
+function! Tlist_Set_App(name)
+    if a:name == ""
+        return
+    endif
+
+    let s:tlist_app_name = a:name
+endfunction
+
+" Winmanager integration
+
+" Initialization required for integration with winmanager
+function! TagList_Start()
+    " If current buffer is not taglist buffer, then don't proceed
+    if bufname('%') != '__Tag_List__'
+        return
+    endif
+
+    call Tlist_Set_App('winmanager')
+
+    " Get the current filename from the winmanager plugin
+    let bufnum = WinManagerGetLastEditedFile()
+    if bufnum != -1
+        let filename = fnamemodify(bufname(bufnum), ':p')
+        let ftype = s:Tlist_Get_Buffer_Filetype(bufnum)
+    endif
+
+    " Initialize the taglist window, if it is not already initialized
+    if !exists('s:tlist_window_initialized') || !s:tlist_window_initialized
+        call s:Tlist_Window_Init()
+        call s:Tlist_Window_Refresh()
+        let s:tlist_window_initialized = 1
+    endif
+
+    " Update the taglist window
+    if bufnum != -1
+        if !s:Tlist_Skip_File(filename, ftype) && g:Tlist_Auto_Update
+            call s:Tlist_Window_Refresh_File(filename, ftype)
+        endif
+    endif
+endfunction
+
+function! TagList_IsValid()
+    return 0
+endfunction
+
+function! TagList_WrapUp()
+    return 0
+endfunction
+
+" restore 'cpo'
+let &cpo = s:cpo_save
+unlet s:cpo_save
+
diff --git a/vimrc/.vim/plugin/taglist.vim b/vimrc/.vim/plugin/taglist.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/taglist.vim
@@ -0,0 +1,4546 @@
+" File: taglist.vim
+" Author: Yegappan Lakshmanan (yegappan AT yahoo DOT com)
+" Version: 4.5
+" Last Modified: September 21, 2007
+" Copyright: Copyright (C) 2002-2007 Yegappan Lakshmanan
+"            Permission is hereby granted to use and distribute this code,
+"            with or without modifications, provided that this copyright
+"            notice is copied with it. Like anything else that's free,
+"            taglist.vim is provided *as is* and comes with no warranty of any
+"            kind, either expressed or implied. In no event will the copyright
+"            holder be liable for any damamges resulting from the use of this
+"            software.
+"
+" The "Tag List" plugin is a source code browser plugin for Vim and provides
+" an overview of the structure of the programming language files and allows
+" you to efficiently browse through source code files for different
+" programming languages.  You can visit the taglist plugin home page for more
+" information:
+"
+"       http://vim-taglist.sourceforge.net
+"
+" You can subscribe to the taglist mailing list to post your questions
+" or suggestions for improvement or to report bugs. Visit the following
+" page for subscribing to the mailing list:
+"
+"       http://groups.yahoo.com/group/taglist/
+"
+" For more information about using this plugin, after installing the
+" taglist plugin, use the ":help taglist" command.
+"
+" Installation
+" ------------
+" 1. Download the taglist.zip file and unzip the files to the $HOME/.vim
+"    or the $HOME/vimfiles or the $VIM/vimfiles directory. This should
+"    unzip the following two files (the directory structure should be
+"    preserved):
+"
+"       plugin/taglist.vim - main taglist plugin file
+"       doc/taglist.txt    - documentation (help) file
+"
+"    Refer to the 'add-plugin', 'add-global-plugin' and 'runtimepath'
+"    Vim help pages for more details about installing Vim plugins.
+" 2. Change to the $HOME/.vim/doc or $HOME/vimfiles/doc or
+"    $VIM/vimfiles/doc directory, start Vim and run the ":helptags ."
+"    command to process the taglist help file.
+" 3. If the exuberant ctags utility is not present in your PATH, then set the
+"    Tlist_Ctags_Cmd variable to point to the location of the exuberant ctags
+"    utility (not to the directory) in the .vimrc file.
+" 4. If you are running a terminal/console version of Vim and the
+"    terminal doesn't support changing the window width then set the
+"    'Tlist_Inc_Winwidth' variable to 0 in the .vimrc file.
+" 5. Restart Vim.
+" 6. You can now use the ":TlistToggle" command to open/close the taglist
+"    window. You can use the ":help taglist" command to get more
+"    information about using the taglist plugin.
+"
+" ****************** Do not modify after this line ************************
+
+" Line continuation used here
+let s:cpo_save = &cpo
+set cpo&vim
+
+if !exists('loaded_taglist')
+    " First time loading the taglist plugin
+    "
+    " To speed up the loading of Vim, the taglist plugin uses autoload
+    " mechanism to load the taglist functions.
+    " Only define the configuration variables, user commands and some
+    " auto-commands and finish sourcing the file
+
+    " The taglist plugin requires the built-in Vim system() function. If this
+    " function is not available, then don't load the plugin.
+    if !exists('*system')
+        echomsg 'Taglist: Vim system() built-in function is not available. ' .
+                    \ 'Plugin is not loaded.'
+        let loaded_taglist = 'no'
+        let &cpo = s:cpo_save
+        finish
+    endif
+
+    " Location of the exuberant ctags tool
+    if !exists('Tlist_Ctags_Cmd')
+        if executable('exuberant-ctags')
+            " On Debian Linux, exuberant ctags is installed
+            " as exuberant-ctags
+            let Tlist_Ctags_Cmd = 'exuberant-ctags'
+        elseif executable('exctags')
+            " On Free-BSD, exuberant ctags is installed as exctags
+            let Tlist_Ctags_Cmd = 'exctags'
+        elseif executable('ctags')
+            let Tlist_Ctags_Cmd = 'ctags'
+        elseif executable('ctags.exe')
+            let Tlist_Ctags_Cmd = 'ctags.exe'
+        elseif executable('tags')
+            let Tlist_Ctags_Cmd = 'tags'
+        else
+            echomsg 'Taglist: Exuberant ctags (http://ctags.sf.net) ' .
+                        \ 'not found in PATH. Plugin is not loaded.'
+            " Skip loading the plugin
+            let loaded_taglist = 'no'
+            let &cpo = s:cpo_save
+            finish
+        endif
+    endif
+
+
+    " Automatically open the taglist window on Vim startup
+    if !exists('Tlist_Auto_Open')
+        let Tlist_Auto_Open = 0
+    endif
+
+    " When the taglist window is toggle opened, move the cursor to the
+    " taglist window
+    if !exists('Tlist_GainFocus_On_ToggleOpen')
+        let Tlist_GainFocus_On_ToggleOpen = 0
+    endif
+
+    " Process files even when the taglist window is not open
+    if !exists('Tlist_Process_File_Always')
+        let Tlist_Process_File_Always = 0
+    endif
+
+    if !exists('Tlist_Show_Menu')
+        let Tlist_Show_Menu = 0
+    endif
+
+    " Tag listing sort type - 'name' or 'order'
+    if !exists('Tlist_Sort_Type')
+        let Tlist_Sort_Type = 'order'
+    endif
+
+    " Tag listing window split (horizontal/vertical) control
+    if !exists('Tlist_Use_Horiz_Window')
+        let Tlist_Use_Horiz_Window = 0
+    endif
+
+    " Open the vertically split taglist window on the left or on the right
+    " side.  This setting is relevant only if Tlist_Use_Horiz_Window is set to
+    " zero (i.e.  only for vertically split windows)
+    if !exists('Tlist_Use_Right_Window')
+        let Tlist_Use_Right_Window = 0
+    endif
+
+    " Increase Vim window width to display vertically split taglist window.
+    " For MS-Windows version of Vim running in a MS-DOS window, this must be
+    " set to 0 otherwise the system may hang due to a Vim limitation.
+    if !exists('Tlist_Inc_Winwidth')
+        if (has('win16') || has('win95')) && !has('gui_running')
+            let Tlist_Inc_Winwidth = 0
+        else
+            let Tlist_Inc_Winwidth = 1
+        endif
+    endif
+
+    " Vertically split taglist window width setting
+    if !exists('Tlist_WinWidth')
+        let Tlist_WinWidth = 30
+    endif
+
+    " Horizontally split taglist window height setting
+    if !exists('Tlist_WinHeight')
+        let Tlist_WinHeight = 10
+    endif
+
+    " Display tag prototypes or tag names in the taglist window
+    if !exists('Tlist_Display_Prototype')
+        let Tlist_Display_Prototype = 0
+    endif
+
+    " Display tag scopes in the taglist window
+    if !exists('Tlist_Display_Tag_Scope')
+        let Tlist_Display_Tag_Scope = 1
+    endif
+
+    " Use single left mouse click to jump to a tag. By default this is disabled.
+    " Only double click using the mouse will be processed.
+    if !exists('Tlist_Use_SingleClick')
+        let Tlist_Use_SingleClick = 0
+    endif
+
+    " Control whether additional help is displayed as part of the taglist or
+    " not.  Also, controls whether empty lines are used to separate the tag
+    " tree.
+    if !exists('Tlist_Compact_Format')
+        let Tlist_Compact_Format = 0
+    endif
+
+    " Exit Vim if only the taglist window is currently open. By default, this is
+    " set to zero.
+    if !exists('Tlist_Exit_OnlyWindow')
+        let Tlist_Exit_OnlyWindow = 0
+    endif
+
+    " Automatically close the folds for the non-active files in the taglist
+    " window
+    if !exists('Tlist_File_Fold_Auto_Close')
+        let Tlist_File_Fold_Auto_Close = 0
+    endif
+
+    " Close the taglist window when a tag is selected
+    if !exists('Tlist_Close_On_Select')
+        let Tlist_Close_On_Select = 0
+    endif
+
+    " Automatically update the taglist window to display tags for newly
+    " edited files
+    if !exists('Tlist_Auto_Update')
+        let Tlist_Auto_Update = 1
+    endif
+
+    " Automatically highlight the current tag
+    if !exists('Tlist_Auto_Highlight_Tag')
+        let Tlist_Auto_Highlight_Tag = 1
+    endif
+    
+    " Automatically highlight the current tag on entering a buffer
+    if !exists('Tlist_Highlight_Tag_On_BufEnter')
+        let Tlist_Highlight_Tag_On_BufEnter = 1
+    endif
+
+    " Enable fold column to display the folding for the tag tree
+    if !exists('Tlist_Enable_Fold_Column')
+        let Tlist_Enable_Fold_Column = 1
+    endif
+
+    " Display the tags for only one file in the taglist window
+    if !exists('Tlist_Show_One_File')
+        let Tlist_Show_One_File = 0
+    endif
+
+    if !exists('Tlist_Max_Submenu_Items')
+        let Tlist_Max_Submenu_Items = 20
+    endif
+
+    if !exists('Tlist_Max_Tag_Length')
+        let Tlist_Max_Tag_Length = 10
+    endif
+
+    " Do not change the name of the taglist title variable. The winmanager
+    " plugin relies on this name to determine the title for the taglist
+    " plugin.
+    let TagList_title = "__Tag_List__"
+
+    " Taglist debug messages
+    let s:tlist_msg = ''
+
+    " Define the taglist autocommand to automatically open the taglist window
+    " on Vim startup
+    if g:Tlist_Auto_Open
+        autocmd VimEnter * nested call s:Tlist_Window_Check_Auto_Open()
+    endif
+
+    " Refresh the taglist
+    if g:Tlist_Process_File_Always
+        autocmd BufEnter * call s:Tlist_Refresh()
+    endif
+
+    if g:Tlist_Show_Menu
+        autocmd GUIEnter * call s:Tlist_Menu_Init()
+    endif
+
+    " When the taglist buffer is created when loading a Vim session file,
+    " the taglist buffer needs to be initialized. The BufFilePost event
+    " is used to handle this case.
+    autocmd BufFilePost __Tag_List__ call s:Tlist_Vim_Session_Load()
+
+    " Define the user commands to manage the taglist window
+    command! -nargs=0 -bar TlistToggle call s:Tlist_Window_Toggle()
+    command! -nargs=0 -bar TlistOpen call s:Tlist_Window_Open()
+    " For backwards compatiblity define the Tlist command
+    command! -nargs=0 -bar Tlist TlistToggle
+    command! -nargs=+ -complete=file TlistAddFiles
+                \  call s:Tlist_Add_Files(<f-args>)
+    command! -nargs=+ -complete=dir TlistAddFilesRecursive
+                \ call s:Tlist_Add_Files_Recursive(<f-args>)
+    command! -nargs=0 -bar TlistClose call s:Tlist_Window_Close()
+    command! -nargs=0 -bar TlistUpdate call s:Tlist_Update_Current_File()
+    command! -nargs=0 -bar TlistHighlightTag call s:Tlist_Window_Highlight_Tag(
+                        \ fnamemodify(bufname('%'), ':p'), line('.'), 2, 1)
+    " For backwards compatiblity define the TlistSync command
+    command! -nargs=0 -bar TlistSync TlistHighlightTag
+    command! -nargs=* -complete=buffer TlistShowPrototype
+                \ echo Tlist_Get_Tag_Prototype_By_Line(<f-args>)
+    command! -nargs=* -complete=buffer TlistShowTag
+                \ echo Tlist_Get_Tagname_By_Line(<f-args>)
+    command! -nargs=* -complete=file TlistSessionLoad
+                \ call s:Tlist_Session_Load(<q-args>)
+    command! -nargs=* -complete=file TlistSessionSave
+                \ call s:Tlist_Session_Save(<q-args>)
+    command! -bar TlistLock let Tlist_Auto_Update=0
+    command! -bar TlistUnlock let Tlist_Auto_Update=1
+
+    " Commands for enabling/disabling debug and to display debug messages
+    command! -nargs=? -complete=file -bar TlistDebug
+                \ call s:Tlist_Debug_Enable(<q-args>)
+    command! -nargs=0 -bar TlistUndebug  call s:Tlist_Debug_Disable()
+    command! -nargs=0 -bar TlistMessages call s:Tlist_Debug_Show()
+
+    " Define autocommands to autoload the taglist plugin when needed.
+
+    " Trick to get the current script ID
+    map <SID>xx <SID>xx
+    let s:tlist_sid = substitute(maparg('<SID>xx'), '<SNR>\(\d\+_\)xx$',
+                                \ '\1', '')
+    unmap <SID>xx
+
+    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_Window_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_Menu_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+    exe 'autocmd FuncUndefined Tlist_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+    exe 'autocmd FuncUndefined TagList_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+
+    let loaded_taglist = 'fast_load_done'
+
+    if g:Tlist_Show_Menu && has('gui_running')
+        call s:Tlist_Menu_Init()
+    endif
+
+    " restore 'cpo'
+    let &cpo = s:cpo_save
+    finish
+endif
+
+if !exists('s:tlist_sid')
+    " Two or more versions of taglist plugin are installed. Don't
+    " load this version of the plugin.
+    finish
+endif
+
+unlet! s:tlist_sid
+
+if loaded_taglist != 'fast_load_done'
+    " restore 'cpo'
+    let &cpo = s:cpo_save
+    finish
+endif
+
+" Taglist plugin functionality is available
+let loaded_taglist = 'available'
+
+"------------------- end of user configurable options --------------------
+
+" Default language specific settings for supported file types and tag types
+"
+" Variable name format:
+"
+"       s:tlist_def_{vim_ftype}_settings
+" 
+" vim_ftype - Filetype detected by Vim
+"
+" Value format:
+"
+"       <ctags_ftype>;<flag>:<name>;<flag>:<name>;...
+"
+" ctags_ftype - File type supported by exuberant ctags
+" flag        - Flag supported by exuberant ctags to generate a tag type
+" name        - Name of the tag type used in the taglist window to display the
+"               tags of this type
+"
+
+" assembly language
+let s:tlist_def_asm_settings = 'asm;d:define;l:label;m:macro;t:type'
+
+" aspperl language
+let s:tlist_def_aspperl_settings = 'asp;f:function;s:sub;v:variable'
+
+" aspvbs language
+let s:tlist_def_aspvbs_settings = 'asp;f:function;s:sub;v:variable'
+
+" awk language
+let s:tlist_def_awk_settings = 'awk;f:function'
+
+" beta language
+let s:tlist_def_beta_settings = 'beta;f:fragment;s:slot;v:pattern'
+
+" c language
+let s:tlist_def_c_settings = 'c;d:macro;g:enum;s:struct;u:union;t:typedef;' .
+                           \ 'v:variable;f:function'
+
+" c++ language
+let s:tlist_def_cpp_settings = 'c++;n:namespace;v:variable;d:macro;t:typedef;' .
+                             \ 'c:class;g:enum;s:struct;u:union;f:function'
+
+" c# language
+let s:tlist_def_cs_settings = 'c#;d:macro;t:typedef;n:namespace;c:class;' .
+                             \ 'E:event;g:enum;s:struct;i:interface;' .
+                             \ 'p:properties;m:method'
+
+" cobol language
+let s:tlist_def_cobol_settings = 'cobol;d:data;f:file;g:group;p:paragraph;' .
+                               \ 'P:program;s:section'
+
+" eiffel language
+let s:tlist_def_eiffel_settings = 'eiffel;c:class;f:feature'
+
+" erlang language
+let s:tlist_def_erlang_settings = 'erlang;d:macro;r:record;m:module;f:function'
+
+" expect (same as tcl) language
+let s:tlist_def_expect_settings = 'tcl;c:class;f:method;p:procedure'
+
+" fortran language
+let s:tlist_def_fortran_settings = 'fortran;p:program;b:block data;' .
+                    \ 'c:common;e:entry;i:interface;k:type;l:label;m:module;' .
+                    \ 'n:namelist;t:derived;v:variable;f:function;s:subroutine'
+
+" HTML language
+let s:tlist_def_html_settings = 'html;a:anchor;f:javascript function'
+
+" java language
+let s:tlist_def_java_settings = 'java;p:package;c:class;i:interface;' .
+                              \ 'f:field;m:method'
+
+" javascript language
+let s:tlist_def_javascript_settings = 'javascript;f:function'
+
+" lisp language
+let s:tlist_def_lisp_settings = 'lisp;f:function'
+
+" lua language
+let s:tlist_def_lua_settings = 'lua;f:function'
+
+" makefiles
+let s:tlist_def_make_settings = 'make;m:macro'
+
+" pascal language
+let s:tlist_def_pascal_settings = 'pascal;f:function;p:procedure'
+
+" perl language
+let s:tlist_def_perl_settings = 'perl;c:constant;l:label;p:package;s:subroutine'
+
+" php language
+let s:tlist_def_php_settings = 'php;c:class;d:constant;v:variable;f:function'
+
+" python language
+let s:tlist_def_python_settings = 'python;c:class;m:member;f:function'
+
+" rexx language
+let s:tlist_def_rexx_settings = 'rexx;s:subroutine'
+
+" ruby language
+let s:tlist_def_ruby_settings = 'ruby;c:class;f:method;F:function;' .
+                              \ 'm:singleton method'
+
+" scheme language
+let s:tlist_def_scheme_settings = 'scheme;s:set;f:function'
+
+" shell language
+let s:tlist_def_sh_settings = 'sh;f:function'
+
+" C shell language
+let s:tlist_def_csh_settings = 'sh;f:function'
+
+" Z shell language
+let s:tlist_def_zsh_settings = 'sh;f:function'
+
+" slang language
+let s:tlist_def_slang_settings = 'slang;n:namespace;f:function'
+
+" sml language
+let s:tlist_def_sml_settings = 'sml;e:exception;c:functor;s:signature;' .
+                             \ 'r:structure;t:type;v:value;f:function'
+
+" sql language
+let s:tlist_def_sql_settings = 'sql;c:cursor;F:field;P:package;r:record;' .
+            \ 's:subtype;t:table;T:trigger;v:variable;f:function;p:procedure'
+
+" tcl language
+let s:tlist_def_tcl_settings = 'tcl;c:class;f:method;m:method;p:procedure'
+
+" vera language
+let s:tlist_def_vera_settings = 'vera;c:class;d:macro;e:enumerator;' .
+                                \ 'f:function;g:enum;m:member;p:program;' .
+                                \ 'P:prototype;t:task;T:typedef;v:variable;' .
+                                \ 'x:externvar'
+
+"verilog language
+let s:tlist_def_verilog_settings = 'verilog;m:module;c:constant;P:parameter;' .
+            \ 'e:event;r:register;t:task;w:write;p:port;v:variable;f:function'
+
+" vim language
+let s:tlist_def_vim_settings = 'vim;a:autocmds;v:variable;f:function'
+
+" yacc language
+let s:tlist_def_yacc_settings = 'yacc;l:label'
+
+"------------------- end of language specific options --------------------
+
+" Vim window size is changed by the taglist plugin or not
+let s:tlist_winsize_chgd = -1
+" Taglist window is maximized or not
+let s:tlist_win_maximized = 0
+" Name of files in the taglist
+let s:tlist_file_names=''
+" Number of files in the taglist
+let s:tlist_file_count = 0
+" Number of filetypes supported by taglist
+let s:tlist_ftype_count = 0
+" Is taglist part of other plugins like winmanager or cream?
+let s:tlist_app_name = "none"
+" Are we displaying brief help text
+let s:tlist_brief_help = 1
+" List of files removed on user request
+let s:tlist_removed_flist = ""
+" Index of current file displayed in the taglist window
+let s:tlist_cur_file_idx = -1
+" Taglist menu is empty or not
+let s:tlist_menu_empty = 1
+
+" An autocommand is used to refresh the taglist window when entering any
+" buffer. We don't want to refresh the taglist window if we are entering the
+" file window from one of the taglist functions. The 'Tlist_Skip_Refresh'
+" variable is used to skip the refresh of the taglist window and is set
+" and cleared appropriately.
+let s:Tlist_Skip_Refresh = 0
+
+" Tlist_Window_Display_Help()
+function! s:Tlist_Window_Display_Help()
+    if s:tlist_app_name == "winmanager"
+        " To handle a bug in the winmanager plugin, add a space at the
+        " last line
+        call setline('$', ' ')
+    endif
+
+    if s:tlist_brief_help
+        " Add the brief help
+        call append(0, '" Press <F1> to display help text')
+    else
+        " Add the extensive help
+        call append(0, '" <enter> : Jump to tag definition')
+        call append(1, '" o : Jump to tag definition in new window')
+        call append(2, '" p : Preview the tag definition')
+        call append(3, '" <space> : Display tag prototype')
+        call append(4, '" u : Update tag list')
+        call append(5, '" s : Select sort field')
+        call append(6, '" d : Remove file from taglist')
+        call append(7, '" x : Zoom-out/Zoom-in taglist window')
+        call append(8, '" + : Open a fold')
+        call append(9, '" - : Close a fold')
+        call append(10, '" * : Open all folds')
+        call append(11, '" = : Close all folds')
+        call append(12, '" [[ : Move to the start of previous file')
+        call append(13, '" ]] : Move to the start of next file')
+        call append(14, '" q : Close the taglist window')
+        call append(15, '" <F1> : Remove help text')
+    endif
+endfunction
+
+" Tlist_Window_Toggle_Help_Text()
+" Toggle taglist plugin help text between the full version and the brief
+" version
+function! s:Tlist_Window_Toggle_Help_Text()
+    if g:Tlist_Compact_Format
+        " In compact display mode, do not display help
+        return
+    endif
+
+    " Include the empty line displayed after the help text
+    let brief_help_size = 1
+    let full_help_size = 16
+
+    setlocal modifiable
+
+    " Set report option to a huge value to prevent informational messages
+    " while deleting the lines
+    let old_report = &report
+    set report=99999
+
+    " Remove the currently highlighted tag. Otherwise, the help text
+    " might be highlighted by mistake
+    match none
+
+    " Toggle between brief and full help text
+    if s:tlist_brief_help
+        let s:tlist_brief_help = 0
+
+        " Remove the previous help
+        exe '1,' . brief_help_size . ' delete _'
+
+        " Adjust the start/end line numbers for the files
+        call s:Tlist_Window_Update_Line_Offsets(0, 1, full_help_size - brief_help_size)
+    else
+        let s:tlist_brief_help = 1
+
+        " Remove the previous help
+        exe '1,' . full_help_size . ' delete _'
+
+        " Adjust the start/end line numbers for the files
+        call s:Tlist_Window_Update_Line_Offsets(0, 0, full_help_size - brief_help_size)
+    endif
+
+    call s:Tlist_Window_Display_Help()
+
+    " Restore the report option
+    let &report = old_report
+
+    setlocal nomodifiable
+endfunction
+
+" Taglist debug support
+let s:tlist_debug = 0
+
+" File for storing the debug messages
+let s:tlist_debug_file = ''
+
+" Tlist_Debug_Enable
+" Enable logging of taglist debug messages.
+function! s:Tlist_Debug_Enable(...)
+    let s:tlist_debug = 1
+
+    " Check whether a valid file name is supplied.
+    if a:1 != ''
+        let s:tlist_debug_file = fnamemodify(a:1, ':p')
+
+        " Empty the log file
+        exe 'redir! > ' . s:tlist_debug_file
+        redir END
+
+        " Check whether the log file is present/created
+        if !filewritable(s:tlist_debug_file)
+            call s:Tlist_Warning_Msg('Taglist: Unable to create log file '
+                        \ . s:tlist_debug_file)
+            let s:tlist_debug_file = ''
+        endif
+    endif
+endfunction
+
+" Tlist_Debug_Disable
+" Disable logging of taglist debug messages.
+function! s:Tlist_Debug_Disable(...)
+    let s:tlist_debug = 0
+    let s:tlist_debug_file = ''
+endfunction
+
+" Tlist_Debug_Show
+" Display the taglist debug messages in a new window
+function! s:Tlist_Debug_Show()
+    if s:tlist_msg == ''
+        call s:Tlist_Warning_Msg('Taglist: No debug messages')
+        return
+    endif
+
+    " Open a new window to display the taglist debug messages
+    new taglist_debug.txt
+    " Delete all the lines (if the buffer already exists)
+    silent! %delete _
+    " Add the messages
+    silent! put =s:tlist_msg
+    " Move the cursor to the first line
+    normal! gg
+endfunction
+
+" Tlist_Log_Msg
+" Log the supplied debug message along with the time
+function! s:Tlist_Log_Msg(msg)
+    if s:tlist_debug
+        if s:tlist_debug_file != ''
+            exe 'redir >> ' . s:tlist_debug_file
+            silent echon strftime('%H:%M:%S') . ': ' . a:msg . "\n"
+            redir END
+        else
+            " Log the message into a variable
+            " Retain only the last 3000 characters
+            let len = strlen(s:tlist_msg)
+            if len > 3000
+                let s:tlist_msg = strpart(s:tlist_msg, len - 3000)
+            endif
+            let s:tlist_msg = s:tlist_msg . strftime('%H:%M:%S') . ': ' . 
+                        \ a:msg . "\n"
+        endif
+    endif
+endfunction
+
+" Tlist_Warning_Msg()
+" Display a message using WarningMsg highlight group
+function! s:Tlist_Warning_Msg(msg)
+    echohl WarningMsg
+    echomsg a:msg
+    echohl None
+endfunction
+
+" Last returned file index for file name lookup.
+" Used to speed up file lookup
+let s:tlist_file_name_idx_cache = -1
+
+" Tlist_Get_File_Index()
+" Return the index of the specified filename
+function! s:Tlist_Get_File_Index(fname)
+    if s:tlist_file_count == 0 || a:fname == ''
+        return -1
+    endif
+
+    " If the new filename is same as the last accessed filename, then
+    " return that index
+    if s:tlist_file_name_idx_cache != -1 &&
+                \ s:tlist_file_name_idx_cache < s:tlist_file_count
+        if s:tlist_{s:tlist_file_name_idx_cache}_filename == a:fname
+            " Same as the last accessed file
+            return s:tlist_file_name_idx_cache
+        endif
+    endif
+
+    " First, check whether the filename is present
+    let s_fname = a:fname . "\n"
+    let i = stridx(s:tlist_file_names, s_fname)
+    if i == -1
+        let s:tlist_file_name_idx_cache = -1
+        return -1
+    endif
+
+    " Second, compute the file name index
+    let nl_txt = substitute(strpart(s:tlist_file_names, 0, i), "[^\n]", '', 'g')
+    let s:tlist_file_name_idx_cache = strlen(nl_txt)
+    return s:tlist_file_name_idx_cache
+endfunction
+
+" Last returned file index for line number lookup.
+" Used to speed up file lookup
+let s:tlist_file_lnum_idx_cache = -1
+
+" Tlist_Window_Get_File_Index_By_Linenum()
+" Return the index of the filename present in the specified line number
+" Line number refers to the line number in the taglist window
+function! s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
+    call s:Tlist_Log_Msg('Tlist_Window_Get_File_Index_By_Linenum (' . a:lnum . ')')
+
+    " First try to see whether the new line number is within the range
+    " of the last returned file
+    if s:tlist_file_lnum_idx_cache != -1 &&
+                \ s:tlist_file_lnum_idx_cache < s:tlist_file_count
+        if a:lnum >= s:tlist_{s:tlist_file_lnum_idx_cache}_start &&
+                    \ a:lnum <= s:tlist_{s:tlist_file_lnum_idx_cache}_end
+            return s:tlist_file_lnum_idx_cache
+        endif
+    endif
+
+    let fidx = -1
+
+    if g:Tlist_Show_One_File
+        " Displaying only one file in the taglist window. Check whether
+        " the line is within the tags displayed for that file
+        if s:tlist_cur_file_idx != -1
+            if a:lnum >= s:tlist_{s:tlist_cur_file_idx}_start
+                        \ && a:lnum <= s:tlist_{s:tlist_cur_file_idx}_end
+                let fidx = s:tlist_cur_file_idx
+            endif
+
+        endif
+    else
+        " Do a binary search in the taglist
+        let left = 0
+        let right = s:tlist_file_count - 1
+
+        while left < right
+            let mid = (left + right) / 2
+
+            if a:lnum >= s:tlist_{mid}_start && a:lnum <= s:tlist_{mid}_end
+                let s:tlist_file_lnum_idx_cache = mid
+                return mid
+            endif
+
+            if a:lnum < s:tlist_{mid}_start
+                let right = mid - 1
+            else
+                let left = mid + 1
+            endif
+        endwhile
+
+        if left >= 0 && left < s:tlist_file_count
+                    \ && a:lnum >= s:tlist_{left}_start
+                    \ && a:lnum <= s:tlist_{left}_end
+            let fidx = left
+        endif
+    endif
+
+    let s:tlist_file_lnum_idx_cache = fidx
+
+    return fidx
+endfunction
+
+" Tlist_Exe_Cmd_No_Acmds
+" Execute the specified Ex command after disabling autocommands
+function! s:Tlist_Exe_Cmd_No_Acmds(cmd)
+    let old_eventignore = &eventignore
+    set eventignore=all
+    exe a:cmd
+    let &eventignore = old_eventignore
+endfunction
+
+" Tlist_Skip_File()
+" Check whether tag listing is supported for the specified file
+function! s:Tlist_Skip_File(filename, ftype)
+    " Skip buffers with no names and buffers with filetype not set
+    if a:filename == '' || a:ftype == ''
+        return 1
+    endif
+
+    " Skip files which are not supported by exuberant ctags
+    " First check whether default settings for this filetype are available.
+    " If it is not available, then check whether user specified settings are
+    " available. If both are not available, then don't list the tags for this
+    " filetype
+    let var = 's:tlist_def_' . a:ftype . '_settings'
+    if !exists(var)
+        let var = 'g:tlist_' . a:ftype . '_settings'
+        if !exists(var)
+            return 1
+        endif
+    endif
+
+    " Skip files which are not readable or files which are not yet stored
+    " to the disk
+    if !filereadable(a:filename)
+        return 1
+    endif
+
+    return 0
+endfunction
+
+" Tlist_User_Removed_File
+" Returns 1 if a file is removed by a user from the taglist
+function! s:Tlist_User_Removed_File(filename)
+    return stridx(s:tlist_removed_flist, a:filename . "\n") != -1
+endfunction
+
+" Tlist_Update_Remove_List
+" Update the list of user removed files from the taglist
+" add == 1, add the file to the removed list
+" add == 0, delete the file from the removed list
+function! s:Tlist_Update_Remove_List(filename, add)
+    if a:add
+        let s:tlist_removed_flist = s:tlist_removed_flist . a:filename . "\n"
+    else
+        let idx = stridx(s:tlist_removed_flist, a:filename . "\n")
+        let text_before = strpart(s:tlist_removed_flist, 0, idx)
+        let rem_text = strpart(s:tlist_removed_flist, idx)
+        let next_idx = stridx(rem_text, "\n")
+        let text_after = strpart(rem_text, next_idx + 1)
+
+        let s:tlist_removed_flist = text_before . text_after
+    endif
+endfunction
+
+" Tlist_FileType_Init
+" Initialize the ctags arguments and tag variable for the specified
+" file type
+function! s:Tlist_FileType_Init(ftype)
+    call s:Tlist_Log_Msg('Tlist_FileType_Init (' . a:ftype . ')')
+    " If the user didn't specify any settings, then use the default
+    " ctags args. Otherwise, use the settings specified by the user
+    let var = 'g:tlist_' . a:ftype . '_settings'
+    if exists(var)
+        " User specified ctags arguments
+        let settings = {var} . ';'
+    else
+        " Default ctags arguments
+        let var = 's:tlist_def_' . a:ftype . '_settings'
+        if !exists(var)
+            " No default settings for this file type. This filetype is
+            " not supported
+            return 0
+        endif
+        let settings = s:tlist_def_{a:ftype}_settings . ';'
+    endif
+
+    let msg = 'Taglist: Invalid ctags option setting - ' . settings
+
+    " Format of the option that specifies the filetype and ctags arugments:
+    "
+    "       <language_name>;flag1:name1;flag2:name2;flag3:name3
+    "
+
+    " Extract the file type to pass to ctags. This may be different from the
+    " file type detected by Vim
+    let pos = stridx(settings, ';')
+    if pos == -1
+        call s:Tlist_Warning_Msg(msg)
+        return 0
+    endif
+    let ctags_ftype = strpart(settings, 0, pos)
+    if ctags_ftype == ''
+        call s:Tlist_Warning_Msg(msg)
+        return 0
+    endif
+    " Make sure a valid filetype is supplied. If the user didn't specify a
+    " valid filetype, then the ctags option settings may be treated as the
+    " filetype
+    if ctags_ftype =~ ':'
+        call s:Tlist_Warning_Msg(msg)
+        return 0
+    endif
+
+    " Remove the file type from settings
+    let settings = strpart(settings, pos + 1)
+    if settings == ''
+        call s:Tlist_Warning_Msg(msg)
+        return 0
+    endif
+
+    " Process all the specified ctags flags. The format is
+    " flag1:name1;flag2:name2;flag3:name3
+    let ctags_flags = ''
+    let cnt = 0
+    while settings != ''
+        " Extract the flag
+        let pos = stridx(settings, ':')
+        if pos == -1
+            call s:Tlist_Warning_Msg(msg)
+            return 0
+        endif
+        let flag = strpart(settings, 0, pos)
+        if flag == ''
+            call s:Tlist_Warning_Msg(msg)
+            return 0
+        endif
+        " Remove the flag from settings
+        let settings = strpart(settings, pos + 1)
+
+        " Extract the tag type name
+        let pos = stridx(settings, ';')
+        if pos == -1
+            call s:Tlist_Warning_Msg(msg)
+            return 0
+        endif
+        let name = strpart(settings, 0, pos)
+        if name == ''
+            call s:Tlist_Warning_Msg(msg)
+            return 0
+        endif
+        let settings = strpart(settings, pos + 1)
+
+        let cnt = cnt + 1
+
+        let s:tlist_{a:ftype}_{cnt}_name = flag
+        let s:tlist_{a:ftype}_{cnt}_fullname = name
+        let ctags_flags = ctags_flags . flag
+    endwhile
+
+    let s:tlist_{a:ftype}_ctags_args = '--language-force=' . ctags_ftype .
+                            \ ' --' . ctags_ftype . '-types=' . ctags_flags
+    let s:tlist_{a:ftype}_count = cnt
+    let s:tlist_{a:ftype}_ctags_flags = ctags_flags
+
+    " Save the filetype name
+    let s:tlist_ftype_{s:tlist_ftype_count}_name = a:ftype
+    let s:tlist_ftype_count = s:tlist_ftype_count + 1
+
+    return 1
+endfunction
+
+" Tlist_Detect_Filetype
+" Determine the filetype for the specified file using the filetypedetect
+" autocmd.
+function! s:Tlist_Detect_Filetype(fname)
+    " Ignore the filetype autocommands
+    let old_eventignore = &eventignore
+    set eventignore=FileType
+
+    " Save the 'filetype', as this will be changed temporarily
+    let old_filetype = &filetype
+
+    " Run the filetypedetect group of autocommands to determine
+    " the filetype
+    exe 'doautocmd filetypedetect BufRead ' . a:fname
+
+    " Save the detected filetype
+    let ftype = &filetype
+
+    " Restore the previous state
+    let &filetype = old_filetype
+    let &eventignore = old_eventignore
+
+    return ftype
+endfunction
+
+" Tlist_Get_Buffer_Filetype
+" Get the filetype for the specified buffer
+function! s:Tlist_Get_Buffer_Filetype(bnum)
+    let buf_ft = getbufvar(a:bnum, '&filetype')
+
+    if bufloaded(a:bnum)
+        " For loaded buffers, the 'filetype' is already determined
+        return buf_ft
+    endif
+
+    " For unloaded buffers, if the 'filetype' option is set, return it
+    if buf_ft != ''
+        return buf_ft
+    endif
+
+    " Skip non-existent buffers
+    if !bufexists(a:bnum)
+        return ''
+    endif
+
+    " For buffers whose filetype is not yet determined, try to determine
+    " the filetype
+    let bname = bufname(a:bnum)
+
+    return s:Tlist_Detect_Filetype(bname)
+endfunction
+
+" Tlist_Discard_TagInfo
+" Discard the stored tag information for a file
+function! s:Tlist_Discard_TagInfo(fidx)
+    call s:Tlist_Log_Msg('Tlist_Discard_TagInfo (' .
+                \ s:tlist_{a:fidx}_filename . ')')
+    let ftype = s:tlist_{a:fidx}_filetype
+
+    " Discard information about the tags defined in the file
+    let i = 1
+    while i <= s:tlist_{a:fidx}_tag_count
+        let fidx_i = 's:tlist_' . a:fidx . '_' . i
+        unlet! {fidx_i}_tag
+        unlet! {fidx_i}_tag_name
+        unlet! {fidx_i}_tag_type
+        unlet! {fidx_i}_ttype_idx
+        unlet! {fidx_i}_tag_proto
+        unlet! {fidx_i}_tag_searchpat
+        unlet! {fidx_i}_tag_linenum
+        let i = i + 1
+    endwhile
+
+    let s:tlist_{a:fidx}_tag_count = 0
+
+    " Discard information about tag type groups
+    let i = 1
+    while i <= s:tlist_{ftype}_count
+        let ttype = s:tlist_{ftype}_{i}_name
+        if s:tlist_{a:fidx}_{ttype} != ''
+            let fidx_ttype = 's:tlist_' . a:fidx . '_' . ttype
+            let {fidx_ttype} = ''
+            let {fidx_ttype}_offset = 0
+            let cnt = {fidx_ttype}_count
+            let {fidx_ttype}_count = 0
+            let j = 1
+            while j <= cnt
+                unlet! {fidx_ttype}_{j}
+                let j = j + 1
+            endwhile
+        endif
+        let i = i + 1
+    endwhile
+
+    " Discard the stored menu command also
+    let s:tlist_{a:fidx}_menu_cmd = ''
+endfunction
+
+" Tlist_Window_Update_Line_Offsets
+" Update the line offsets for tags for files starting from start_idx
+" and displayed in the taglist window by the specified offset
+function! s:Tlist_Window_Update_Line_Offsets(start_idx, increment, offset)
+    let i = a:start_idx
+
+    while i < s:tlist_file_count
+        if s:tlist_{i}_visible
+            " Update the start/end line number only if the file is visible
+            if a:increment
+                let s:tlist_{i}_start = s:tlist_{i}_start + a:offset
+                let s:tlist_{i}_end = s:tlist_{i}_end + a:offset
+            else
+                let s:tlist_{i}_start = s:tlist_{i}_start - a:offset
+                let s:tlist_{i}_end = s:tlist_{i}_end - a:offset
+            endif
+        endif
+        let i = i + 1
+    endwhile
+endfunction
+
+" Tlist_Discard_FileInfo
+" Discard the stored information for a file
+function! s:Tlist_Discard_FileInfo(fidx)
+    call s:Tlist_Log_Msg('Tlist_Discard_FileInfo (' .
+                \ s:tlist_{a:fidx}_filename . ')')
+    call s:Tlist_Discard_TagInfo(a:fidx)
+
+    let ftype = s:tlist_{a:fidx}_filetype
+
+    let i = 1
+    while i <= s:tlist_{ftype}_count
+        let ttype = s:tlist_{ftype}_{i}_name
+        unlet! s:tlist_{a:fidx}_{ttype}
+        unlet! s:tlist_{a:fidx}_{ttype}_offset
+        unlet! s:tlist_{a:fidx}_{ttype}_count
+        let i = i + 1
+    endwhile
+
+    unlet! s:tlist_{a:fidx}_filename
+    unlet! s:tlist_{a:fidx}_sort_type
+    unlet! s:tlist_{a:fidx}_filetype
+    unlet! s:tlist_{a:fidx}_mtime
+    unlet! s:tlist_{a:fidx}_start
+    unlet! s:tlist_{a:fidx}_end
+    unlet! s:tlist_{a:fidx}_valid
+    unlet! s:tlist_{a:fidx}_visible
+    unlet! s:tlist_{a:fidx}_tag_count
+    unlet! s:tlist_{a:fidx}_menu_cmd
+endfunction
+
+" Tlist_Window_Remove_File_From_Display
+" Remove the specified file from display
+function! s:Tlist_Window_Remove_File_From_Display(fidx)
+    call s:Tlist_Log_Msg('Tlist_Window_Remove_File_From_Display (' .
+                \ s:tlist_{a:fidx}_filename . ')')
+    " If the file is not visible then no need to remove it
+    if !s:tlist_{a:fidx}_visible
+        return
+    endif
+
+    " Remove the tags displayed for the specified file from the window
+    let start = s:tlist_{a:fidx}_start
+    " Include the empty line after the last line also
+    if g:Tlist_Compact_Format
+        let end = s:tlist_{a:fidx}_end
+    else
+        let end = s:tlist_{a:fidx}_end + 1
+    endif
+
+    setlocal modifiable
+    exe 'silent! ' . start . ',' . end . 'delete _'
+    setlocal nomodifiable
+
+    " Correct the start and end line offsets for all the files following
+    " this file, as the tags for this file are removed
+    call s:Tlist_Window_Update_Line_Offsets(a:fidx + 1, 0, end - start + 1)
+endfunction
+
+" Tlist_Remove_File
+" Remove the file under the cursor or the specified file index
+" user_request - User requested to remove the file from taglist
+function! s:Tlist_Remove_File(file_idx, user_request)
+    let fidx = a:file_idx
+
+    if fidx == -1
+        let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
+        if fidx == -1
+            return
+        endif
+    endif
+    call s:Tlist_Log_Msg('Tlist_Remove_File (' .
+                \ s:tlist_{fidx}_filename . ', ' . a:user_request . ')')
+
+    let save_winnr = winnr()
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        " Taglist window is open, remove the file from display
+
+        if save_winnr != winnum
+            let old_eventignore = &eventignore
+            set eventignore=all
+            exe winnum . 'wincmd w'
+        endif
+
+        call s:Tlist_Window_Remove_File_From_Display(fidx)
+
+        if save_winnr != winnum
+            exe save_winnr . 'wincmd w'
+            let &eventignore = old_eventignore
+        endif
+    endif
+
+    let fname = s:tlist_{fidx}_filename
+
+    if a:user_request
+        " As the user requested to remove the file from taglist,
+        " add it to the removed list
+        call s:Tlist_Update_Remove_List(fname, 1)
+    endif
+
+    " Remove the file name from the taglist list of filenames
+    let idx = stridx(s:tlist_file_names, fname . "\n")
+    let text_before = strpart(s:tlist_file_names, 0, idx)
+    let rem_text = strpart(s:tlist_file_names, idx)
+    let next_idx = stridx(rem_text, "\n")
+    let text_after = strpart(rem_text, next_idx + 1)
+    let s:tlist_file_names = text_before . text_after
+
+    call s:Tlist_Discard_FileInfo(fidx)
+
+    " Shift all the file variables by one index
+    let i = fidx + 1
+
+    while i < s:tlist_file_count
+        let j = i - 1
+
+        let s:tlist_{j}_filename = s:tlist_{i}_filename
+        let s:tlist_{j}_sort_type = s:tlist_{i}_sort_type
+        let s:tlist_{j}_filetype = s:tlist_{i}_filetype
+        let s:tlist_{j}_mtime = s:tlist_{i}_mtime
+        let s:tlist_{j}_start = s:tlist_{i}_start
+        let s:tlist_{j}_end = s:tlist_{i}_end
+        let s:tlist_{j}_valid = s:tlist_{i}_valid
+        let s:tlist_{j}_visible = s:tlist_{i}_visible
+        let s:tlist_{j}_tag_count = s:tlist_{i}_tag_count
+        let s:tlist_{j}_menu_cmd = s:tlist_{i}_menu_cmd
+
+        let k = 1
+        while k <= s:tlist_{j}_tag_count
+            let s:tlist_{j}_{k}_tag = s:tlist_{i}_{k}_tag
+            let s:tlist_{j}_{k}_tag_name = s:tlist_{i}_{k}_tag_name
+            let s:tlist_{j}_{k}_tag_type = s:Tlist_Get_Tag_Type_By_Tag(i, k)
+            let s:tlist_{j}_{k}_ttype_idx = s:tlist_{i}_{k}_ttype_idx
+            let s:tlist_{j}_{k}_tag_proto = s:Tlist_Get_Tag_Prototype(i, k)
+            let s:tlist_{j}_{k}_tag_searchpat = s:Tlist_Get_Tag_SearchPat(i, k)
+            let s:tlist_{j}_{k}_tag_linenum = s:Tlist_Get_Tag_Linenum(i, k)
+            let k = k + 1
+        endwhile
+
+        let ftype = s:tlist_{i}_filetype
+
+        let k = 1
+        while k <= s:tlist_{ftype}_count
+            let ttype = s:tlist_{ftype}_{k}_name
+            let s:tlist_{j}_{ttype} = s:tlist_{i}_{ttype}
+            let s:tlist_{j}_{ttype}_offset = s:tlist_{i}_{ttype}_offset
+            let s:tlist_{j}_{ttype}_count = s:tlist_{i}_{ttype}_count
+            if s:tlist_{j}_{ttype} != ''
+                let l = 1
+                while l <= s:tlist_{j}_{ttype}_count
+                    let s:tlist_{j}_{ttype}_{l} = s:tlist_{i}_{ttype}_{l}
+                    let l = l + 1
+                endwhile
+            endif
+            let k = k + 1
+        endwhile
+
+        " As the file and tag information is copied to the new index,
+        " discard the previous information
+        call s:Tlist_Discard_FileInfo(i)
+
+        let i = i + 1
+    endwhile
+
+    " Reduce the number of files displayed
+    let s:tlist_file_count = s:tlist_file_count - 1
+
+    if g:Tlist_Show_One_File
+        " If the tags for only one file is displayed and if we just
+        " now removed that file, then invalidate the current file idx
+        if s:tlist_cur_file_idx == fidx
+            let s:tlist_cur_file_idx = -1
+        endif
+    endif
+endfunction
+
+" Tlist_Window_Goto_Window
+" Goto the taglist window
+function! s:Tlist_Window_Goto_Window()
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        if winnr() != winnum
+            call s:Tlist_Exe_Cmd_No_Acmds(winnum . 'wincmd w')
+        endif
+    endif
+endfunction
+
+" Tlist_Window_Create
+" Create a new taglist window. If it is already open, jump to it
+function! s:Tlist_Window_Create()
+    call s:Tlist_Log_Msg('Tlist_Window_Create()')
+    " If the window is open, jump to it
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        " Jump to the existing window
+        if winnr() != winnum
+            exe winnum . 'wincmd w'
+        endif
+        return
+    endif
+
+    " If used with winmanager don't open windows. Winmanager will handle
+    " the window/buffer management
+    if s:tlist_app_name == "winmanager"
+        return
+    endif
+
+    " Create a new window. If user prefers a horizontal window, then open
+    " a horizontally split window. Otherwise open a vertically split
+    " window
+    if g:Tlist_Use_Horiz_Window
+        " Open a horizontally split window
+        let win_dir = 'botright'
+        " Horizontal window height
+        let win_size = g:Tlist_WinHeight
+    else
+        if s:tlist_winsize_chgd == -1
+            " Open a vertically split window. Increase the window size, if
+            " needed, to accomodate the new window
+            if g:Tlist_Inc_Winwidth &&
+                        \ &columns < (80 + g:Tlist_WinWidth)
+                " Save the original window position
+                let s:tlist_pre_winx = getwinposx()
+                let s:tlist_pre_winy = getwinposy()
+
+                " one extra column is needed to include the vertical split
+                let &columns= &columns + g:Tlist_WinWidth + 1
+
+                let s:tlist_winsize_chgd = 1
+            else
+                let s:tlist_winsize_chgd = 0
+            endif
+        endif
+
+        if g:Tlist_Use_Right_Window
+            " Open the window at the rightmost place
+            let win_dir = 'botright vertical'
+        else
+            " Open the window at the leftmost place
+            let win_dir = 'topleft vertical'
+        endif
+        let win_size = g:Tlist_WinWidth
+    endif
+
+    " If the tag listing temporary buffer already exists, then reuse it.
+    " Otherwise create a new buffer
+    let bufnum = bufnr(g:TagList_title)
+    if bufnum == -1
+        " Create a new buffer
+        let wcmd = g:TagList_title
+    else
+        " Edit the existing buffer
+        let wcmd = '+buffer' . bufnum
+    endif
+
+    " Create the taglist window
+    exe 'silent! ' . win_dir . ' ' . win_size . 'split ' . wcmd
+
+    " Save the new window position
+    let s:tlist_winx = getwinposx()
+    let s:tlist_winy = getwinposy()
+
+    " Initialize the taglist window
+    call s:Tlist_Window_Init()
+endfunction
+
+" Tlist_Window_Zoom
+" Zoom (maximize/minimize) the taglist window
+function! s:Tlist_Window_Zoom()
+    if s:tlist_win_maximized
+        " Restore the window back to the previous size
+        if g:Tlist_Use_Horiz_Window
+            exe 'resize ' . g:Tlist_WinHeight
+        else
+            exe 'vert resize ' . g:Tlist_WinWidth
+        endif
+        let s:tlist_win_maximized = 0
+    else
+        " Set the window size to the maximum possible without closing other
+        " windows
+        if g:Tlist_Use_Horiz_Window
+            resize
+        else
+            vert resize
+        endif
+        let s:tlist_win_maximized = 1
+    endif
+endfunction
+
+" Tlist_Ballon_Expr
+" When the mouse cursor is over a tag in the taglist window, display the
+" tag prototype (balloon)
+function! Tlist_Ballon_Expr()
+    " Get the file index
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(v:beval_lnum)
+    if fidx == -1
+        return ''
+    endif
+
+    " Get the tag output line for the current tag
+    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, v:beval_lnum)
+    if tidx == 0
+        return ''
+    endif
+
+    " Get the tag search pattern and display it
+    return s:Tlist_Get_Tag_Prototype(fidx, tidx)
+endfunction
+
+" Tlist_Window_Check_Width
+" Check the width of the taglist window. For horizontally split windows, the
+" 'winfixheight' option is used to fix the height of the window. For
+" vertically split windows, Vim doesn't support the 'winfixwidth' option. So
+" need to handle window width changes from this function.
+function! s:Tlist_Window_Check_Width()
+    let tlist_winnr = bufwinnr(g:TagList_title)
+    if tlist_winnr == -1
+        return
+    endif
+
+    let width = winwidth(tlist_winnr)
+    if width != g:Tlist_WinWidth
+        call s:Tlist_Log_Msg("Tlist_Window_Check_Width: Changing window " .
+                    \ "width from " . width . " to " . g:Tlist_WinWidth)
+        let save_winnr = winnr()
+        if save_winnr != tlist_winnr
+            call s:Tlist_Exe_Cmd_No_Acmds(tlist_winnr . 'wincmd w')
+        endif
+        exe 'vert resize ' . g:Tlist_WinWidth
+        if save_winnr != tlist_winnr
+            call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
+        endif
+    endif
+endfunction
+
+" Tlist_Window_Exit_Only_Window
+" If the 'Tlist_Exit_OnlyWindow' option is set, then exit Vim if only the
+" taglist window is present.
+function! s:Tlist_Window_Exit_Only_Window()
+    " Before quitting Vim, delete the taglist buffer so that
+    " the '0 mark is correctly set to the previous buffer.
+    if v:version < 700
+	if winbufnr(2) == -1
+	    bdelete
+	    quit
+	endif
+    else
+	if winbufnr(2) == -1
+	    if tabpagenr('$') == 1
+		" Only one tag page is present
+		bdelete
+		quit
+	    else
+		" More than one tab page is present. Close only the current
+		" tab page
+		close
+	    endif
+	endif
+    endif
+endfunction
+
+" Tlist_Window_Init
+" Set the default options for the taglist window
+function! s:Tlist_Window_Init()
+    call s:Tlist_Log_Msg('Tlist_Window_Init()')
+
+    " The 'readonly' option should not be set for the taglist buffer.
+    " If Vim is started as "view/gview" or if the ":view" command is
+    " used, then the 'readonly' option is set for all the buffers.
+    " Unset it for the taglist buffer
+    setlocal noreadonly
+
+    " Set the taglist buffer filetype to taglist
+    setlocal filetype=taglist
+
+    " Define taglist window element highlighting
+    syntax match TagListComment '^" .*'
+    syntax match TagListFileName '^[^" ].*$'
+    syntax match TagListTitle '^  \S.*$'
+    syntax match TagListTagScope  '\s\[.\{-\}\]$'
+
+    " Define the highlighting only if colors are supported
+    if has('gui_running') || &t_Co > 2
+        " Colors to highlight various taglist window elements
+        " If user defined highlighting group exists, then use them.
+        " Otherwise, use default highlight groups.
+        if hlexists('MyTagListTagName')
+            highlight link TagListTagName MyTagListTagName
+        else
+            highlight default link TagListTagName Search
+        endif
+        " Colors to highlight comments and titles
+        if hlexists('MyTagListComment')
+            highlight link TagListComment MyTagListComment
+        else
+            highlight clear TagListComment
+            highlight default link TagListComment Comment
+        endif
+        if hlexists('MyTagListTitle')
+            highlight link TagListTitle MyTagListTitle
+        else
+            highlight clear TagListTitle
+            highlight default link TagListTitle Title
+        endif
+        if hlexists('MyTagListFileName')
+            highlight link TagListFileName MyTagListFileName
+        else
+            highlight clear TagListFileName
+            highlight default TagListFileName guibg=Grey ctermbg=darkgray
+                        \ guifg=white ctermfg=white
+        endif
+        if hlexists('MyTagListTagScope')
+            highlight link TagListTagScope MyTagListTagScope
+        else
+            highlight clear TagListTagScope
+            highlight default link TagListTagScope Identifier
+        endif
+    else
+        highlight default TagListTagName term=reverse cterm=reverse
+    endif
+
+    " Folding related settings
+    setlocal foldenable
+    setlocal foldminlines=0
+    setlocal foldmethod=manual
+    setlocal foldlevel=9999
+    if g:Tlist_Enable_Fold_Column
+        setlocal foldcolumn=3
+    else
+        setlocal foldcolumn=0
+    endif
+    setlocal foldtext=v:folddashes.getline(v:foldstart)
+
+    if s:tlist_app_name != "winmanager"
+        " Mark buffer as scratch
+        silent! setlocal buftype=nofile
+        if s:tlist_app_name == "none"
+            silent! setlocal bufhidden=delete
+        endif
+        silent! setlocal noswapfile
+        " Due to a bug in Vim 6.0, the winbufnr() function fails for unlisted
+        " buffers. So if the taglist buffer is unlisted, multiple taglist
+        " windows will be opened. This bug is fixed in Vim 6.1 and above
+        if v:version >= 601
+            silent! setlocal nobuflisted
+        endif
+    endif
+
+    silent! setlocal nowrap
+
+    " If the 'number' option is set in the source window, it will affect the
+    " taglist window. So forcefully disable 'number' option for the taglist
+    " window
+    silent! setlocal nonumber
+
+    " Use fixed height when horizontally split window is used
+    if g:Tlist_Use_Horiz_Window
+        if v:version >= 602
+            set winfixheight
+        endif
+    endif
+    if !g:Tlist_Use_Horiz_Window && v:version >= 700
+        set winfixwidth
+    endif
+
+    " Setup balloon evaluation to display tag prototype
+    if v:version >= 700 && has('balloon_eval')
+        setlocal balloonexpr=Tlist_Ballon_Expr()
+        set ballooneval
+    endif
+
+    " Setup the cpoptions properly for the maps to work
+    let old_cpoptions = &cpoptions
+    set cpoptions&vim
+
+    " Create buffer local mappings for jumping to the tags and sorting the list
+    nnoremap <buffer> <silent> <CR>
+                \ :call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    nnoremap <buffer> <silent> o
+                \ :call <SID>Tlist_Window_Jump_To_Tag('newwin')<CR>
+    nnoremap <buffer> <silent> p
+                \ :call <SID>Tlist_Window_Jump_To_Tag('preview')<CR>
+    nnoremap <buffer> <silent> P
+                \ :call <SID>Tlist_Window_Jump_To_Tag('prevwin')<CR>
+    if v:version >= 700
+    nnoremap <buffer> <silent> t
+                \ :call <SID>Tlist_Window_Jump_To_Tag('checktab')<CR>
+    nnoremap <buffer> <silent> <C-t>
+                \ :call <SID>Tlist_Window_Jump_To_Tag('newtab')<CR>
+    endif
+    nnoremap <buffer> <silent> <2-LeftMouse>
+                \ :call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    nnoremap <buffer> <silent> s
+                \ :call <SID>Tlist_Change_Sort('cmd', 'toggle', '')<CR>
+    nnoremap <buffer> <silent> + :silent! foldopen<CR>
+    nnoremap <buffer> <silent> - :silent! foldclose<CR>
+    nnoremap <buffer> <silent> * :silent! %foldopen!<CR>
+    nnoremap <buffer> <silent> = :silent! %foldclose<CR>
+    nnoremap <buffer> <silent> <kPlus> :silent! foldopen<CR>
+    nnoremap <buffer> <silent> <kMinus> :silent! foldclose<CR>
+    nnoremap <buffer> <silent> <kMultiply> :silent! %foldopen!<CR>
+    nnoremap <buffer> <silent> <Space> :call <SID>Tlist_Window_Show_Info()<CR>
+    nnoremap <buffer> <silent> u :call <SID>Tlist_Window_Update_File()<CR>
+    nnoremap <buffer> <silent> d :call <SID>Tlist_Remove_File(-1, 1)<CR>
+    nnoremap <buffer> <silent> x :call <SID>Tlist_Window_Zoom()<CR>
+    nnoremap <buffer> <silent> [[ :call <SID>Tlist_Window_Move_To_File(-1)<CR>
+    nnoremap <buffer> <silent> <BS> :call <SID>Tlist_Window_Move_To_File(-1)<CR>
+    nnoremap <buffer> <silent> ]] :call <SID>Tlist_Window_Move_To_File(1)<CR>
+    nnoremap <buffer> <silent> <Tab> :call <SID>Tlist_Window_Move_To_File(1)<CR>
+    nnoremap <buffer> <silent> <F1> :call <SID>Tlist_Window_Toggle_Help_Text()<CR>
+    nnoremap <buffer> <silent> q :close<CR>
+
+    " Insert mode mappings
+    inoremap <buffer> <silent> <CR>
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    " Windows needs return
+    inoremap <buffer> <silent> <Return>
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    inoremap <buffer> <silent> o
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('newwin')<CR>
+    inoremap <buffer> <silent> p
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('preview')<CR>
+    inoremap <buffer> <silent> P
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('prevwin')<CR>
+    if v:version >= 700
+    inoremap <buffer> <silent> t
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('checktab')<CR>
+    inoremap <buffer> <silent> <C-t>
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('newtab')<CR>
+    endif
+    inoremap <buffer> <silent> <2-LeftMouse>
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    inoremap <buffer> <silent> s
+                \ <C-o>:call <SID>Tlist_Change_Sort('cmd', 'toggle', '')<CR>
+    inoremap <buffer> <silent> +             <C-o>:silent! foldopen<CR>
+    inoremap <buffer> <silent> -             <C-o>:silent! foldclose<CR>
+    inoremap <buffer> <silent> *             <C-o>:silent! %foldopen!<CR>
+    inoremap <buffer> <silent> =             <C-o>:silent! %foldclose<CR>
+    inoremap <buffer> <silent> <kPlus>       <C-o>:silent! foldopen<CR>
+    inoremap <buffer> <silent> <kMinus>      <C-o>:silent! foldclose<CR>
+    inoremap <buffer> <silent> <kMultiply>   <C-o>:silent! %foldopen!<CR>
+    inoremap <buffer> <silent> <Space>       <C-o>:call
+                                    \ <SID>Tlist_Window_Show_Info()<CR>
+    inoremap <buffer> <silent> u
+                            \ <C-o>:call <SID>Tlist_Window_Update_File()<CR>
+    inoremap <buffer> <silent> d    <C-o>:call <SID>Tlist_Remove_File(-1, 1)<CR>
+    inoremap <buffer> <silent> x    <C-o>:call <SID>Tlist_Window_Zoom()<CR>
+    inoremap <buffer> <silent> [[   <C-o>:call <SID>Tlist_Window_Move_To_File(-1)<CR>
+    inoremap <buffer> <silent> <BS> <C-o>:call <SID>Tlist_Window_Move_To_File(-1)<CR>
+    inoremap <buffer> <silent> ]]   <C-o>:call <SID>Tlist_Window_Move_To_File(1)<CR>
+    inoremap <buffer> <silent> <Tab> <C-o>:call <SID>Tlist_Window_Move_To_File(1)<CR>
+    inoremap <buffer> <silent> <F1>  <C-o>:call <SID>Tlist_Window_Toggle_Help_Text()<CR>
+    inoremap <buffer> <silent> q    <C-o>:close<CR>
+
+    " Map single left mouse click if the user wants this functionality
+    if g:Tlist_Use_SingleClick == 1
+        " Contributed by Bindu Wavell
+        " attempt to perform single click mapping, it would be much
+        " nicer if we could nnoremap <buffer> ... however vim does
+        " not fire the <buffer> <leftmouse> when you use the mouse
+        " to enter a buffer.
+        let clickmap = ':if bufname("%") =~ "__Tag_List__" <bar> ' .
+                    \ 'call <SID>Tlist_Window_Jump_To_Tag("useopen") ' .
+                    \ '<bar> endif <CR>'
+        if maparg('<leftmouse>', 'n') == ''
+            " no mapping for leftmouse
+            exe ':nnoremap <silent> <leftmouse> <leftmouse>' . clickmap
+        else
+            " we have a mapping
+            let mapcmd = ':nnoremap <silent> <leftmouse> <leftmouse>'
+            let mapcmd = mapcmd . substitute(substitute(
+                        \ maparg('<leftmouse>', 'n'), '|', '<bar>', 'g'),
+                        \ '\c^<leftmouse>', '', '')
+            let mapcmd = mapcmd . clickmap
+            exe mapcmd
+        endif
+    endif
+
+    " Define the taglist autocommands
+    augroup TagListAutoCmds
+        autocmd!
+        " Display the tag prototype for the tag under the cursor.
+        autocmd CursorHold __Tag_List__ call s:Tlist_Window_Show_Info()
+        " Highlight the current tag periodically
+        autocmd CursorHold * silent call s:Tlist_Window_Highlight_Tag(
+                            \ fnamemodify(bufname('%'), ':p'), line('.'), 1, 0)
+
+        " Adjust the Vim window width when taglist window is closed
+        autocmd BufUnload __Tag_List__ call s:Tlist_Post_Close_Cleanup()
+        " Close the fold for this buffer when leaving the buffer
+        if g:Tlist_File_Fold_Auto_Close
+            autocmd BufEnter * silent
+                \ call s:Tlist_Window_Open_File_Fold(expand('<abuf>'))
+        endif
+        " Exit Vim itself if only the taglist window is present (optional)
+        if g:Tlist_Exit_OnlyWindow
+	    autocmd BufEnter __Tag_List__ nested
+			\ call s:Tlist_Window_Exit_Only_Window()
+        endif
+        if s:tlist_app_name != "winmanager" &&
+                    \ !g:Tlist_Process_File_Always &&
+                    \ (!has('gui_running') || !g:Tlist_Show_Menu)
+            " Auto refresh the taglist window
+            autocmd BufEnter * call s:Tlist_Refresh()
+        endif
+
+        if !g:Tlist_Use_Horiz_Window
+            if v:version < 700
+                autocmd WinEnter * call s:Tlist_Window_Check_Width()
+            endif
+        endif
+        if v:version >= 700
+            autocmd TabEnter * silent call s:Tlist_Refresh_Folds()
+        endif
+    augroup end
+
+    " Restore the previous cpoptions settings
+    let &cpoptions = old_cpoptions
+endfunction
+
+" Tlist_Window_Refresh
+" Display the tags for all the files in the taglist window
+function! s:Tlist_Window_Refresh()
+    call s:Tlist_Log_Msg('Tlist_Window_Refresh()')
+    " Set report option to a huge value to prevent informational messages
+    " while deleting the lines
+    let old_report = &report
+    set report=99999
+
+    " Mark the buffer as modifiable
+    setlocal modifiable
+
+    " Delete the contents of the buffer to the black-hole register
+    silent! %delete _
+
+    " As we have cleared the taglist window, mark all the files
+    " as not visible
+    let i = 0
+    while i < s:tlist_file_count
+        let s:tlist_{i}_visible = 0
+        let i = i + 1
+    endwhile
+
+    if g:Tlist_Compact_Format == 0
+        " Display help in non-compact mode
+        call s:Tlist_Window_Display_Help()
+    endif
+
+    " Mark the buffer as not modifiable
+    setlocal nomodifiable
+
+    " Restore the report option
+    let &report = old_report
+
+    " If the tags for only one file should be displayed in the taglist
+    " window, then no need to add the tags here. The bufenter autocommand
+    " will add the tags for that file.
+    if g:Tlist_Show_One_File
+        return
+    endif
+
+    " List all the tags for the previously processed files
+    " Do this only if taglist is configured to display tags for more than
+    " one file. Otherwise, when Tlist_Show_One_File is configured,
+    " tags for the wrong file will be displayed.
+    let i = 0
+    while i < s:tlist_file_count
+        call s:Tlist_Window_Refresh_File(s:tlist_{i}_filename,
+                    \ s:tlist_{i}_filetype)
+        let i = i + 1
+    endwhile
+
+    if g:Tlist_Auto_Update
+        " Add and list the tags for all buffers in the Vim buffer list
+        let i = 1
+        let last_bufnum = bufnr('$')
+        while i <= last_bufnum
+            if buflisted(i)
+                let fname = fnamemodify(bufname(i), ':p')
+                let ftype = s:Tlist_Get_Buffer_Filetype(i)
+                " If the file doesn't support tag listing, skip it
+                if !s:Tlist_Skip_File(fname, ftype)
+                    call s:Tlist_Window_Refresh_File(fname, ftype)
+                endif
+            endif
+            let i = i + 1
+        endwhile
+    endif
+
+    " If Tlist_File_Fold_Auto_Close option is set, then close all the folds
+    if g:Tlist_File_Fold_Auto_Close
+        " Close all the folds
+        silent! %foldclose
+    endif
+
+    " Move the cursor to the top of the taglist window
+    normal! gg
+endfunction
+
+" Tlist_Post_Close_Cleanup()
+" Close the taglist window and adjust the Vim window width
+function! s:Tlist_Post_Close_Cleanup()
+    call s:Tlist_Log_Msg('Tlist_Post_Close_Cleanup()')
+    " Mark all the files as not visible
+    let i = 0
+    while i < s:tlist_file_count
+        let s:tlist_{i}_visible = 0
+        let i = i + 1
+    endwhile
+
+    " Remove the taglist autocommands
+    silent! autocmd! TagListAutoCmds
+
+    " Clear all the highlights
+    match none
+
+    silent! syntax clear TagListTitle
+    silent! syntax clear TagListComment
+    silent! syntax clear TagListTagScope
+
+    " Remove the left mouse click mapping if it was setup initially
+    if g:Tlist_Use_SingleClick
+        if hasmapto('<LeftMouse>')
+            nunmap <LeftMouse>
+        endif
+    endif
+
+    if s:tlist_app_name != "winmanager"
+    if g:Tlist_Use_Horiz_Window || g:Tlist_Inc_Winwidth == 0 ||
+                \ s:tlist_winsize_chgd != 1 ||
+                \ &columns < (80 + g:Tlist_WinWidth)
+        " No need to adjust window width if using horizontally split taglist
+        " window or if columns is less than 101 or if the user chose not to
+        " adjust the window width
+    else
+        " If the user didn't manually move the window, then restore the window
+        " position to the pre-taglist position
+        if s:tlist_pre_winx != -1 && s:tlist_pre_winy != -1 &&
+                    \ getwinposx() == s:tlist_winx &&
+                    \ getwinposy() == s:tlist_winy
+            exe 'winpos ' . s:tlist_pre_winx . ' ' . s:tlist_pre_winy
+        endif
+
+        " Adjust the Vim window width
+        let &columns= &columns - (g:Tlist_WinWidth + 1)
+    endif
+    endif
+
+    let s:tlist_winsize_chgd = -1
+
+    " Reset taglist state variables
+    if s:tlist_app_name == "winmanager"
+        let s:tlist_app_name = "none"
+    endif
+    let s:tlist_window_initialized = 0
+endfunction
+
+" Tlist_Window_Refresh_File()
+" List the tags defined in the specified file in a Vim window
+function! s:Tlist_Window_Refresh_File(filename, ftype)
+    call s:Tlist_Log_Msg('Tlist_Window_Refresh_File (' . a:filename . ')')
+    " First check whether the file already exists
+    let fidx = s:Tlist_Get_File_Index(a:filename)
+    if fidx != -1
+        let file_listed = 1
+    else
+        let file_listed = 0
+    endif
+
+    if !file_listed
+        " Check whether this file is removed based on user request
+        " If it is, then don't display the tags for this file
+        if s:Tlist_User_Removed_File(a:filename)
+            return
+        endif
+    endif
+
+    if file_listed && s:tlist_{fidx}_visible
+        " Check whether the file tags are currently valid
+        if s:tlist_{fidx}_valid
+            " Goto the first line in the file
+            exe s:tlist_{fidx}_start
+
+            " If the line is inside a fold, open the fold
+            if foldclosed('.') != -1
+                exe "silent! " . s:tlist_{fidx}_start . "," .
+                            \ s:tlist_{fidx}_end . "foldopen!"
+            endif
+            return
+        endif
+
+        " Discard and remove the tags for this file from display
+        call s:Tlist_Discard_TagInfo(fidx)
+        call s:Tlist_Window_Remove_File_From_Display(fidx)
+    endif
+
+    " Process and generate a list of tags defined in the file
+    if !file_listed || !s:tlist_{fidx}_valid
+        let ret_fidx = s:Tlist_Process_File(a:filename, a:ftype)
+        if ret_fidx == -1
+            return
+        endif
+        let fidx = ret_fidx
+    endif
+
+    " Set report option to a huge value to prevent informational messages
+    " while adding lines to the taglist window
+    let old_report = &report
+    set report=99999
+
+    if g:Tlist_Show_One_File
+        " Remove the previous file
+        if s:tlist_cur_file_idx != -1
+            call s:Tlist_Window_Remove_File_From_Display(s:tlist_cur_file_idx)
+            let s:tlist_{s:tlist_cur_file_idx}_visible = 0
+            let s:tlist_{s:tlist_cur_file_idx}_start = 0
+            let s:tlist_{s:tlist_cur_file_idx}_end = 0
+        endif
+        let s:tlist_cur_file_idx = fidx
+    endif
+
+    " Mark the buffer as modifiable
+    setlocal modifiable
+
+    " Add new files to the end of the window. For existing files, add them at
+    " the same line where they were previously present. If the file is not
+    " visible, then add it at the end
+    if s:tlist_{fidx}_start == 0 || !s:tlist_{fidx}_visible
+        if g:Tlist_Compact_Format
+            let s:tlist_{fidx}_start = line('$')
+        else
+            let s:tlist_{fidx}_start = line('$') + 1
+        endif
+    endif
+
+    let s:tlist_{fidx}_visible = 1
+
+    " Goto the line where this file should be placed
+    if g:Tlist_Compact_Format
+        exe s:tlist_{fidx}_start
+    else
+        exe s:tlist_{fidx}_start - 1
+    endif
+
+    let txt = fnamemodify(s:tlist_{fidx}_filename, ':t') . ' (' .
+                \ fnamemodify(s:tlist_{fidx}_filename, ':p:h') . ')'
+    if g:Tlist_Compact_Format == 0
+        silent! put =txt
+    else
+        silent! put! =txt
+        " Move to the next line
+        exe line('.') + 1
+    endif
+    let file_start = s:tlist_{fidx}_start
+
+    " Add the tag names grouped by tag type to the buffer with a title
+    let i = 1
+    let ttype_cnt = s:tlist_{a:ftype}_count
+    while i <= ttype_cnt
+        let ttype = s:tlist_{a:ftype}_{i}_name
+        " Add the tag type only if there are tags for that type
+        let fidx_ttype = 's:tlist_' . fidx . '_' . ttype
+        let ttype_txt = {fidx_ttype}
+        if ttype_txt != ''
+            let txt = '  ' . s:tlist_{a:ftype}_{i}_fullname
+            if g:Tlist_Compact_Format == 0
+                let ttype_start_lnum = line('.') + 1
+                silent! put =txt
+            else
+                let ttype_start_lnum = line('.')
+                silent! put! =txt
+            endif
+            silent! put =ttype_txt
+
+            let {fidx_ttype}_offset = ttype_start_lnum - file_start
+
+            " create a fold for this tag type
+            let fold_start = ttype_start_lnum
+            let fold_end = fold_start + {fidx_ttype}_count
+            exe fold_start . ',' . fold_end  . 'fold'
+
+            " Adjust the cursor position
+            if g:Tlist_Compact_Format == 0
+                exe ttype_start_lnum + {fidx_ttype}_count
+            else
+                exe ttype_start_lnum + {fidx_ttype}_count + 1
+            endif
+
+            if g:Tlist_Compact_Format == 0
+                " Separate the tag types by a empty line
+                silent! put =''
+            endif
+        endif
+        let i = i + 1
+    endwhile
+
+    if s:tlist_{fidx}_tag_count == 0
+        if g:Tlist_Compact_Format == 0
+            silent! put =''
+        endif
+    endif
+
+    let s:tlist_{fidx}_end = line('.') - 1
+
+    " Create a fold for the entire file
+    exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'fold'
+    exe 'silent! ' . s:tlist_{fidx}_start . ',' .
+                \ s:tlist_{fidx}_end . 'foldopen!'
+
+    " Goto the starting line for this file,
+    exe s:tlist_{fidx}_start
+
+    if s:tlist_app_name == "winmanager"
+        " To handle a bug in the winmanager plugin, add a space at the
+        " last line
+        call setline('$', ' ')
+    endif
+
+    " Mark the buffer as not modifiable
+    setlocal nomodifiable
+
+    " Restore the report option
+    let &report = old_report
+
+    " Update the start and end line numbers for all the files following this
+    " file
+    let start = s:tlist_{fidx}_start
+    " include the empty line after the last line
+    if g:Tlist_Compact_Format
+        let end = s:tlist_{fidx}_end
+    else
+        let end = s:tlist_{fidx}_end + 1
+    endif
+    call s:Tlist_Window_Update_Line_Offsets(fidx + 1, 1, end - start + 1)
+
+    " Now that we have updated the taglist window, update the tags
+    " menu (if present)
+    if g:Tlist_Show_Menu
+        call s:Tlist_Menu_Update_File(1)
+    endif
+endfunction
+
+" Tlist_Init_File
+" Initialize the variables for a new file
+function! s:Tlist_Init_File(filename, ftype)
+    call s:Tlist_Log_Msg('Tlist_Init_File (' . a:filename . ')')
+    " Add new files at the end of the list
+    let fidx = s:tlist_file_count
+    let s:tlist_file_count = s:tlist_file_count + 1
+    " Add the new file name to the taglist list of file names
+    let s:tlist_file_names = s:tlist_file_names . a:filename . "\n"
+
+    " Initialize the file variables
+    let s:tlist_{fidx}_filename = a:filename
+    let s:tlist_{fidx}_sort_type = g:Tlist_Sort_Type
+    let s:tlist_{fidx}_filetype = a:ftype
+    let s:tlist_{fidx}_mtime = -1
+    let s:tlist_{fidx}_start = 0
+    let s:tlist_{fidx}_end = 0
+    let s:tlist_{fidx}_valid = 0
+    let s:tlist_{fidx}_visible = 0
+    let s:tlist_{fidx}_tag_count = 0
+    let s:tlist_{fidx}_menu_cmd = ''
+
+    " Initialize the tag type variables
+    let i = 1
+    while i <= s:tlist_{a:ftype}_count
+        let ttype = s:tlist_{a:ftype}_{i}_name
+        let s:tlist_{fidx}_{ttype} = ''
+        let s:tlist_{fidx}_{ttype}_offset = 0
+        let s:tlist_{fidx}_{ttype}_count = 0
+        let i = i + 1
+    endwhile
+
+    return fidx
+endfunction
+
+" Tlist_Get_Tag_Type_By_Tag
+" Return the tag type for the specified tag index
+function! s:Tlist_Get_Tag_Type_By_Tag(fidx, tidx)
+    let ttype_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_type'
+
+    " Already parsed and have the tag name
+    if exists(ttype_var)
+        return {ttype_var}
+    endif
+
+    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
+    let {ttype_var} = s:Tlist_Extract_Tagtype(tag_line)
+
+    return {ttype_var}
+endfunction
+
+" Tlist_Get_Tag_Prototype
+function! s:Tlist_Get_Tag_Prototype(fidx, tidx)
+    let tproto_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_proto'
+
+    " Already parsed and have the tag prototype
+    if exists(tproto_var)
+        return {tproto_var}
+    endif
+
+    " Parse and extract the tag prototype
+    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
+    let start = stridx(tag_line, '/^') + 2
+    let end = stridx(tag_line, '/;"' . "\t")
+    if tag_line[end - 1] == '$'
+        let end = end -1
+    endif
+    let tag_proto = strpart(tag_line, start, end - start)
+    let {tproto_var} = substitute(tag_proto, '\s*', '', '')
+
+    return {tproto_var}
+endfunction
+
+" Tlist_Get_Tag_SearchPat
+function! s:Tlist_Get_Tag_SearchPat(fidx, tidx)
+    let tpat_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_searchpat'
+
+    " Already parsed and have the tag search pattern
+    if exists(tpat_var)
+        return {tpat_var}
+    endif
+
+    " Parse and extract the tag search pattern
+    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
+    let start = stridx(tag_line, '/^') + 2
+    let end = stridx(tag_line, '/;"' . "\t")
+    if tag_line[end - 1] == '$'
+        let end = end -1
+    endif
+    let {tpat_var} = '\V\^' . strpart(tag_line, start, end - start) .
+                        \ (tag_line[end] == '$' ? '\$' : '')
+
+    return {tpat_var}
+endfunction
+
+" Tlist_Get_Tag_Linenum
+" Return the tag line number, given the tag index
+function! s:Tlist_Get_Tag_Linenum(fidx, tidx)
+    let tline_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_linenum'
+
+    " Already parsed and have the tag line number
+    if exists(tline_var)
+        return {tline_var}
+    endif
+
+    " Parse and extract the tag line number
+    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
+    let start = strridx(tag_line, 'line:') + 5
+    let end = strridx(tag_line, "\t")
+    if end < start
+        let {tline_var} = strpart(tag_line, start) + 0
+    else
+        let {tline_var} = strpart(tag_line, start, end - start) + 0
+    endif
+
+    return {tline_var}
+endfunction
+
+" Tlist_Parse_Tagline
+" Parse a tag line from the ctags output. Separate the tag output based on the
+" tag type and store it in the tag type variable.
+" The format of each line in the ctags output is:
+"
+"     tag_name<TAB>file_name<TAB>ex_cmd;"<TAB>extension_fields
+"
+function! s:Tlist_Parse_Tagline(tag_line)
+    if a:tag_line == ''
+        " Skip empty lines
+        return
+    endif
+
+    " Extract the tag type
+    let ttype = s:Tlist_Extract_Tagtype(a:tag_line)
+
+    " Make sure the tag type is a valid and supported one
+    if ttype == '' || stridx(s:ctags_flags, ttype) == -1
+        " Line is not in proper tags format or Tag type is not supported
+        return
+    endif
+
+    " Update the total tag count
+    let s:tidx = s:tidx + 1
+
+    " The following variables are used to optimize this code.  Vim is slow in
+    " using curly brace names. To reduce the amount of processing needed, the
+    " curly brace variables are pre-processed here
+    let fidx_tidx = 's:tlist_' . s:fidx . '_' . s:tidx
+    let fidx_ttype = 's:tlist_' . s:fidx . '_' . ttype
+
+    " Update the count of this tag type
+    let ttype_idx = {fidx_ttype}_count + 1
+    let {fidx_ttype}_count = ttype_idx
+
+    " Store the ctags output for this tag
+    let {fidx_tidx}_tag = a:tag_line
+
+    " Store the tag index and the tag type index (back pointers)
+    let {fidx_ttype}_{ttype_idx} = s:tidx
+    let {fidx_tidx}_ttype_idx = ttype_idx
+
+    " Extract the tag name
+    let tag_name = strpart(a:tag_line, 0, stridx(a:tag_line, "\t"))
+
+    " Extract the tag scope/prototype
+    if g:Tlist_Display_Prototype
+        let ttxt = '    ' . s:Tlist_Get_Tag_Prototype(s:fidx, s:tidx)
+    else
+        let ttxt = '    ' . tag_name
+
+        " Add the tag scope, if it is available and is configured. Tag
+        " scope is the last field after the 'line:<num>\t' field
+        if g:Tlist_Display_Tag_Scope
+            let tag_scope = s:Tlist_Extract_Tag_Scope(a:tag_line)
+            if tag_scope != ''
+                let ttxt = ttxt . ' [' . tag_scope . ']'
+            endif
+        endif
+    endif
+
+    " Add this tag to the tag type variable
+    let {fidx_ttype} = {fidx_ttype} . ttxt . "\n"
+
+    " Save the tag name
+    let {fidx_tidx}_tag_name = tag_name
+endfunction
+
+" Tlist_Process_File
+" Get the list of tags defined in the specified file and store them
+" in Vim variables. Returns the file index where the tags are stored.
+function! s:Tlist_Process_File(filename, ftype)
+    call s:Tlist_Log_Msg('Tlist_Process_File (' . a:filename . ', ' .
+                \ a:ftype . ')')
+    " Check whether this file is supported
+    if s:Tlist_Skip_File(a:filename, a:ftype)
+        return -1
+    endif
+
+    " If the tag types for this filetype are not yet created, then create
+    " them now
+    let var = 's:tlist_' . a:ftype . '_count'
+    if !exists(var)
+        if s:Tlist_FileType_Init(a:ftype) == 0
+            return -1
+        endif
+    endif
+
+    " If this file is already processed, then use the cached values
+    let fidx = s:Tlist_Get_File_Index(a:filename)
+    if fidx == -1
+        " First time, this file is loaded
+        let fidx = s:Tlist_Init_File(a:filename, a:ftype)
+    else
+        " File was previously processed. Discard the tag information
+        call s:Tlist_Discard_TagInfo(fidx)
+    endif
+
+    let s:tlist_{fidx}_valid = 1
+
+    " Exuberant ctags arguments to generate a tag list
+    let ctags_args = ' -f - --format=2 --excmd=pattern --fields=nks '
+
+    " Form the ctags argument depending on the sort type
+    if s:tlist_{fidx}_sort_type == 'name'
+        let ctags_args = ctags_args . '--sort=yes'
+    else
+        let ctags_args = ctags_args . '--sort=no'
+    endif
+
+    " Add the filetype specific arguments
+    let ctags_args = ctags_args . ' ' . s:tlist_{a:ftype}_ctags_args
+
+    " Ctags command to produce output with regexp for locating the tags
+    let ctags_cmd = g:Tlist_Ctags_Cmd . ctags_args
+    let ctags_cmd = ctags_cmd . ' "' . a:filename . '"'
+
+    if &shellxquote == '"'
+        " Double-quotes within double-quotes will not work in the
+        " command-line.If the 'shellxquote' option is set to double-quotes,
+        " then escape the double-quotes in the ctags command-line.
+        let ctags_cmd = escape(ctags_cmd, '"')
+    endif
+
+    " In Windows 95, if not using cygwin, disable the 'shellslash'
+    " option. Otherwise, this will cause problems when running the
+    " ctags command.
+    if has('win95') && !has('win32unix')
+        let old_shellslash = &shellslash
+        set noshellslash
+    endif
+
+    if has('win32') && !has('win32unix') && !has('win95')
+                \ && (&shell =~ 'cmd.exe')
+        " Windows does not correctly deal with commands that have more than 1
+        " set of double quotes.  It will strip them all resulting in:
+        " 'C:\Program' is not recognized as an internal or external command
+        " operable program or batch file.  To work around this, place the
+        " command inside a batch file and call the batch file.
+        " Do this only on Win2K, WinXP and above.
+        " Contributed by: David Fishburn.
+        let s:taglist_tempfile = fnamemodify(tempname(), ':h') .
+                    \ '\taglist.cmd'
+        exe 'redir! > ' . s:taglist_tempfile
+        silent echo ctags_cmd
+        redir END
+
+        call s:Tlist_Log_Msg('Cmd inside batch file: ' . ctags_cmd)
+        let ctags_cmd = '"' . s:taglist_tempfile . '"'
+    endif
+
+    call s:Tlist_Log_Msg('Cmd: ' . ctags_cmd)
+
+    " Run ctags and get the tag list
+    let cmd_output = system(ctags_cmd)
+
+    " Restore the value of the 'shellslash' option.
+    if has('win95') && !has('win32unix')
+        let &shellslash = old_shellslash
+    endif
+
+    if exists('s:taglist_tempfile')
+        " Delete the temporary cmd file created on MS-Windows
+        call delete(s:taglist_tempfile)
+    endif
+
+    " Handle errors
+    if v:shell_error
+        let msg = "Taglist: Failed to generate tags for " . a:filename
+        call s:Tlist_Warning_Msg(msg)
+        if cmd_output != ''
+            call s:Tlist_Warning_Msg(cmd_output)
+        endif
+        return fidx
+    endif
+
+    " Store the modification time for the file
+    let s:tlist_{fidx}_mtime = getftime(a:filename)
+
+    " No tags for current file
+    if cmd_output == ''
+        call s:Tlist_Log_Msg('No tags defined in ' . a:filename)
+        return fidx
+    endif
+
+    call s:Tlist_Log_Msg('Generated tags information for ' . a:filename)
+
+    if v:version > 601
+        " The following script local variables are used by the
+        " Tlist_Parse_Tagline() function.
+        let s:ctags_flags = s:tlist_{a:ftype}_ctags_flags
+        let s:fidx = fidx
+        let s:tidx = 0
+
+        " Process the ctags output one line at a time.  The substitute()
+        " command is used to parse the tag lines instead of using the
+        " matchstr()/stridx()/strpart() functions for performance reason
+        call substitute(cmd_output, "\\([^\n]\\+\\)\n",
+                    \ '\=s:Tlist_Parse_Tagline(submatch(1))', 'g')
+
+        " Save the number of tags for this file
+        let s:tlist_{fidx}_tag_count = s:tidx
+
+        " The following script local variables are no longer needed
+        unlet! s:ctags_flags
+        unlet! s:tidx
+        unlet! s:fidx
+    else
+        " Due to a bug in Vim earlier than version 6.1,
+        " we cannot use substitute() to parse the ctags output.
+        " Instead the slow str*() functions are used
+        let ctags_flags = s:tlist_{a:ftype}_ctags_flags
+        let tidx = 0
+
+        while cmd_output != ''
+            " Extract one line at a time
+            let idx = stridx(cmd_output, "\n")
+            let one_line = strpart(cmd_output, 0, idx)
+            " Remove the line from the tags output
+            let cmd_output = strpart(cmd_output, idx + 1)
+
+            if one_line == ''
+                " Line is not in proper tags format
+                continue
+            endif
+
+            " Extract the tag type
+            let ttype = s:Tlist_Extract_Tagtype(one_line)
+
+            " Make sure the tag type is a valid and supported one
+            if ttype == '' || stridx(ctags_flags, ttype) == -1
+                " Line is not in proper tags format or Tag type is not
+                " supported
+                continue
+            endif
+
+            " Update the total tag count
+            let tidx = tidx + 1
+
+            " The following variables are used to optimize this code.  Vim is
+            " slow in using curly brace names. To reduce the amount of
+            " processing needed, the curly brace variables are pre-processed
+            " here
+            let fidx_tidx = 's:tlist_' . fidx . '_' . tidx
+            let fidx_ttype = 's:tlist_' . fidx . '_' . ttype
+
+            " Update the count of this tag type
+            let ttype_idx = {fidx_ttype}_count + 1
+            let {fidx_ttype}_count = ttype_idx
+
+            " Store the ctags output for this tag
+            let {fidx_tidx}_tag = one_line
+
+            " Store the tag index and the tag type index (back pointers)
+            let {fidx_ttype}_{ttype_idx} = tidx
+            let {fidx_tidx}_ttype_idx = ttype_idx
+
+            " Extract the tag name
+            let tag_name = strpart(one_line, 0, stridx(one_line, "\t"))
+
+            " Extract the tag scope/prototype
+            if g:Tlist_Display_Prototype
+                let ttxt = '    ' . s:Tlist_Get_Tag_Prototype(fidx, tidx)
+            else
+                let ttxt = '    ' . tag_name
+
+                " Add the tag scope, if it is available and is configured. Tag
+                " scope is the last field after the 'line:<num>\t' field
+                if g:Tlist_Display_Tag_Scope
+                    let tag_scope = s:Tlist_Extract_Tag_Scope(one_line)
+                    if tag_scope != ''
+                        let ttxt = ttxt . ' [' . tag_scope . ']'
+                    endif
+                endif
+            endif
+
+            " Add this tag to the tag type variable
+            let {fidx_ttype} = {fidx_ttype} . ttxt . "\n"
+
+            " Save the tag name
+            let {fidx_tidx}_tag_name = tag_name
+        endwhile
+
+        " Save the number of tags for this file
+        let s:tlist_{fidx}_tag_count = tidx
+    endif
+
+    call s:Tlist_Log_Msg('Processed ' . s:tlist_{fidx}_tag_count . 
+                \ ' tags in ' . a:filename)
+
+    return fidx
+endfunction
+
+" Tlist_Update_File
+" Update the tags for a file (if needed)
+function! Tlist_Update_File(filename, ftype)
+    call s:Tlist_Log_Msg('Tlist_Update_File (' . a:filename . ')')
+    " If the file doesn't support tag listing, skip it
+    if s:Tlist_Skip_File(a:filename, a:ftype)
+        return
+    endif
+
+    " Convert the file name to a full path
+    let fname = fnamemodify(a:filename, ':p')
+
+    " First check whether the file already exists
+    let fidx = s:Tlist_Get_File_Index(fname)
+
+    if fidx != -1 && s:tlist_{fidx}_valid
+        " File exists and the tags are valid
+        " Check whether the file was modified after the last tags update
+        " If it is modified, then update the tags
+        if s:tlist_{fidx}_mtime == getftime(fname)
+            return
+        endif
+    else
+        " If the tags were removed previously based on a user request,
+        " as we are going to update the tags (based on the user request),
+        " remove the filename from the deleted list
+        call s:Tlist_Update_Remove_List(fname, 0)
+    endif
+
+    " If the taglist window is opened, update it
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum == -1
+        " Taglist window is not present. Just update the taglist
+        " and return
+        call s:Tlist_Process_File(fname, a:ftype)
+    else
+        if g:Tlist_Show_One_File && s:tlist_cur_file_idx != -1
+            " If tags for only one file are displayed and we are not
+            " updating the tags for that file, then no need to
+            " refresh the taglist window. Otherwise, the taglist
+            " window should be updated.
+            if s:tlist_{s:tlist_cur_file_idx}_filename != fname
+                call s:Tlist_Process_File(fname, a:ftype)
+                return
+            endif
+        endif
+
+        " Save the current window number
+        let save_winnr = winnr()
+
+        " Goto the taglist window
+        call s:Tlist_Window_Goto_Window()
+
+        " Save the cursor position
+        let save_line = line('.')
+        let save_col = col('.')
+
+        " Update the taglist window
+        call s:Tlist_Window_Refresh_File(fname, a:ftype)
+
+        " Restore the cursor position
+        if v:version >= 601
+            call cursor(save_line, save_col)
+        else
+            exe save_line
+            exe 'normal! ' . save_col . '|'
+        endif
+
+        if winnr() != save_winnr
+            " Go back to the original window
+            call s:Tlist_Exe_Cmd_No_Acmds(save_winnr . 'wincmd w')
+        endif
+    endif
+
+    " Update the taglist menu
+    if g:Tlist_Show_Menu
+        call s:Tlist_Menu_Update_File(1)
+    endif
+endfunction
+
+" Tlist_Window_Close
+" Close the taglist window
+function! s:Tlist_Window_Close()
+    call s:Tlist_Log_Msg('Tlist_Window_Close()')
+    " Make sure the taglist window exists
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum == -1
+        call s:Tlist_Warning_Msg('Error: Taglist window is not open')
+        return
+    endif
+
+    if winnr() == winnum
+        " Already in the taglist window. Close it and return
+        if winbufnr(2) != -1
+            " If a window other than the taglist window is open,
+            " then only close the taglist window.
+            close
+        endif
+    else
+        " Goto the taglist window, close it and then come back to the
+        " original window
+        let curbufnr = bufnr('%')
+        exe winnum . 'wincmd w'
+        close
+        " Need to jump back to the original window only if we are not
+        " already in that window
+        let winnum = bufwinnr(curbufnr)
+        if winnr() != winnum
+            exe winnum . 'wincmd w'
+        endif
+    endif
+endfunction
+
+" Tlist_Window_Mark_File_Window
+" Mark the current window as the file window to use when jumping to a tag.
+" Only if the current window is a non-plugin, non-preview and non-taglist
+" window
+function! s:Tlist_Window_Mark_File_Window()
+    if getbufvar('%', '&buftype') == '' && !&previewwindow
+        let w:tlist_file_window = "yes"
+    endif
+endfunction
+
+" Tlist_Window_Open
+" Open and refresh the taglist window
+function! s:Tlist_Window_Open()
+    call s:Tlist_Log_Msg('Tlist_Window_Open()')
+    " If the window is open, jump to it
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        " Jump to the existing window
+        if winnr() != winnum
+            exe winnum . 'wincmd w'
+        endif
+        return
+    endif
+
+    if s:tlist_app_name == "winmanager"
+        " Taglist plugin is no longer part of the winmanager app
+        let s:tlist_app_name = "none"
+    endif
+
+    " Get the filename and filetype for the specified buffer
+    let curbuf_name = fnamemodify(bufname('%'), ':p')
+    let curbuf_ftype = s:Tlist_Get_Buffer_Filetype('%')
+    let cur_lnum = line('.')
+
+    " Mark the current window as the desired window to open a file when a tag
+    " is selected.
+    call s:Tlist_Window_Mark_File_Window()
+
+    " Open the taglist window
+    call s:Tlist_Window_Create()
+
+    call s:Tlist_Window_Refresh()
+
+    if g:Tlist_Show_One_File
+        " Add only the current buffer and file
+        "
+        " If the file doesn't support tag listing, skip it
+        if !s:Tlist_Skip_File(curbuf_name, curbuf_ftype)
+            call s:Tlist_Window_Refresh_File(curbuf_name, curbuf_ftype)
+        endif
+    endif
+
+    if g:Tlist_File_Fold_Auto_Close
+        " Open the fold for the current file, as all the folds in
+        " the taglist window are closed
+        let fidx = s:Tlist_Get_File_Index(curbuf_name)
+        if fidx != -1
+            exe "silent! " . s:tlist_{fidx}_start . "," .
+                        \ s:tlist_{fidx}_end . "foldopen!"
+        endif
+    endif
+
+    " Highlight the current tag
+    call s:Tlist_Window_Highlight_Tag(curbuf_name, cur_lnum, 1, 1)
+endfunction
+
+" Tlist_Window_Toggle()
+" Open or close a taglist window
+function! s:Tlist_Window_Toggle()
+    call s:Tlist_Log_Msg('Tlist_Window_Toggle()')
+    " If taglist window is open then close it.
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        call s:Tlist_Window_Close()
+        return
+    endif
+
+    call s:Tlist_Window_Open()
+
+    " Go back to the original window, if Tlist_GainFocus_On_ToggleOpen is not
+    " set
+    if !g:Tlist_GainFocus_On_ToggleOpen
+        call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
+    endif
+
+    " Update the taglist menu
+    if g:Tlist_Show_Menu
+        call s:Tlist_Menu_Update_File(0)
+    endif
+endfunction
+
+" Tlist_Process_Filelist
+" Process multiple files. Each filename is separated by "\n"
+" Returns the number of processed files
+function! s:Tlist_Process_Filelist(file_names)
+    let flist = a:file_names
+
+    " Enable lazy screen updates
+    let old_lazyredraw = &lazyredraw
+    set lazyredraw
+
+    " Keep track of the number of processed files
+    let fcnt = 0
+
+    " Process one file at a time
+    while flist != ''
+        let nl_idx = stridx(flist, "\n")
+        let one_file = strpart(flist, 0, nl_idx)
+
+        " Remove the filename from the list
+        let flist = strpart(flist, nl_idx + 1)
+
+        if one_file == ''
+            continue
+        endif
+
+        " Skip directories
+        if isdirectory(one_file)
+            continue
+        endif
+
+        let ftype = s:Tlist_Detect_Filetype(one_file)
+
+        echon "\r                                                              "
+        echon "\rProcessing tags for " . fnamemodify(one_file, ':p:t')
+
+        let fcnt = fcnt + 1
+
+        call Tlist_Update_File(one_file, ftype)
+    endwhile
+
+    " Clear the displayed informational messages
+    echon "\r                                                            "
+
+    " Restore the previous state
+    let &lazyredraw = old_lazyredraw
+
+    return fcnt
+endfunction
+
+" Tlist_Process_Dir
+" Process the files in a directory matching the specified pattern
+function! s:Tlist_Process_Dir(dir_name, pat)
+    let flist = glob(a:dir_name . '/' . a:pat) . "\n"
+
+    let fcnt = s:Tlist_Process_Filelist(flist)
+
+    let len = strlen(a:dir_name)
+    if a:dir_name[len - 1] == '\' || a:dir_name[len - 1] == '/'
+        let glob_expr = a:dir_name . '*'
+    else
+        let glob_expr = a:dir_name . '/*'
+    endif
+    let all_files = glob(glob_expr) . "\n"
+
+    while all_files != ''
+        let nl_idx = stridx(all_files, "\n")
+        let one_file = strpart(all_files, 0, nl_idx)
+
+        let all_files = strpart(all_files, nl_idx + 1)
+        if one_file == ''
+            continue
+        endif
+
+        " Skip non-directory names
+        if !isdirectory(one_file)
+            continue
+        endif
+
+        echon "\r                                                              "
+        echon "\rProcessing files in directory " . fnamemodify(one_file, ':t')
+        let fcnt = fcnt + s:Tlist_Process_Dir(one_file, a:pat)
+    endwhile
+
+    return fcnt
+endfunction
+
+" Tlist_Add_Files_Recursive
+" Add files recursively from a directory
+function! s:Tlist_Add_Files_Recursive(dir, ...)
+    let dir_name = fnamemodify(a:dir, ':p')
+    if !isdirectory(dir_name)
+        call s:Tlist_Warning_Msg('Error: ' . dir_name . ' is not a directory')
+        return
+    endif
+
+    if a:0 == 1
+        " User specified file pattern
+        let pat = a:1
+    else
+        " Default file pattern
+        let pat = '*'
+    endif
+
+    echon "\r                                                              "
+    echon "\rProcessing files in directory " . fnamemodify(dir_name, ':t')
+    let fcnt = s:Tlist_Process_Dir(dir_name, pat)
+
+    echon "\rAdded " . fcnt . " files to the taglist"
+endfunction
+
+" Tlist_Add_Files
+" Add the specified list of files to the taglist
+function! s:Tlist_Add_Files(...)
+    let flist = ''
+    let i = 1
+
+    " Get all the files matching the file patterns supplied as argument
+    while i <= a:0
+        let flist = flist . glob(a:{i}) . "\n"
+        let i = i + 1
+    endwhile
+
+    if flist == ''
+        call s:Tlist_Warning_Msg('Error: No matching files are found')
+        return
+    endif
+
+    let fcnt = s:Tlist_Process_Filelist(flist)
+    echon "\rAdded " . fcnt . " files to the taglist"
+endfunction
+
+" Tlist_Extract_Tagtype
+" Extract the tag type from the tag text
+function! s:Tlist_Extract_Tagtype(tag_line)
+    " The tag type is after the tag prototype field. The prototype field
+    " ends with the /;"\t string. We add 4 at the end to skip the characters
+    " in this special string..
+    let start = strridx(a:tag_line, '/;"' . "\t") + 4
+    let end = strridx(a:tag_line, 'line:') - 1
+    let ttype = strpart(a:tag_line, start, end - start)
+
+    return ttype
+endfunction
+
+" Tlist_Extract_Tag_Scope
+" Extract the tag scope from the tag text
+function! s:Tlist_Extract_Tag_Scope(tag_line)
+    let start = strridx(a:tag_line, 'line:')
+    let end = strridx(a:tag_line, "\t")
+    if end <= start
+        return ''
+    endif
+
+    let tag_scope = strpart(a:tag_line, end + 1)
+    let tag_scope = strpart(tag_scope, stridx(tag_scope, ':') + 1)
+
+    return tag_scope
+endfunction
+
+" Tlist_Refresh()
+" Refresh the taglist
+function! s:Tlist_Refresh()
+    call s:Tlist_Log_Msg('Tlist_Refresh (Skip_Refresh = ' .
+                \ s:Tlist_Skip_Refresh . ', ' . bufname('%') . ')')
+    " If we are entering the buffer from one of the taglist functions, then
+    " no need to refresh the taglist window again.
+    if s:Tlist_Skip_Refresh
+        " We still need to update the taglist menu
+        if g:Tlist_Show_Menu
+            call s:Tlist_Menu_Update_File(0)
+        endif
+        return
+    endif
+
+    " If part of the winmanager plugin and not configured to process
+    " tags always and not configured to display the tags menu, then return
+    if (s:tlist_app_name == 'winmanager') && !g:Tlist_Process_File_Always
+                \ && !g:Tlist_Show_Menu
+        return
+    endif
+
+    " Skip buffers with 'buftype' set to nofile, nowrite, quickfix or help
+    if &buftype != ''
+        return
+    endif
+
+    let filename = fnamemodify(bufname('%'), ':p')
+    let ftype = s:Tlist_Get_Buffer_Filetype('%')
+
+    " If the file doesn't support tag listing, skip it
+    if s:Tlist_Skip_File(filename, ftype)
+        return
+    endif
+
+    let tlist_win = bufwinnr(g:TagList_title)
+
+    " If the taglist window is not opened and not configured to process
+    " tags always and not displaying the tags menu, then return
+    if tlist_win == -1 && !g:Tlist_Process_File_Always && !g:Tlist_Show_Menu
+        return
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(filename)
+    if fidx == -1
+        " Check whether this file is removed based on user request
+        " If it is, then don't display the tags for this file
+        if s:Tlist_User_Removed_File(filename)
+            return
+        endif
+
+        " If the taglist should not be auto updated, then return
+        if !g:Tlist_Auto_Update
+            return
+        endif
+    endif
+
+    let cur_lnum = line('.')
+
+    if fidx == -1
+        " Update the tags for the file
+        let fidx = s:Tlist_Process_File(filename, ftype)
+    else
+        let mtime = getftime(filename)
+        if s:tlist_{fidx}_mtime != mtime
+            " Invalidate the tags listed for this file
+            let s:tlist_{fidx}_valid = 0
+
+            " Update the taglist and the window
+            call Tlist_Update_File(filename, ftype)
+
+            " Store the new file modification time
+            let s:tlist_{fidx}_mtime = mtime
+        endif
+    endif
+
+    " Update the taglist window
+    if tlist_win != -1
+        " Disable screen updates
+        let old_lazyredraw = &lazyredraw
+        set nolazyredraw
+
+        " Save the current window number
+        let save_winnr = winnr()
+
+        " Goto the taglist window
+        call s:Tlist_Window_Goto_Window()
+
+        if !g:Tlist_Auto_Highlight_Tag || !g:Tlist_Highlight_Tag_On_BufEnter
+            " Save the cursor position
+            let save_line = line('.')
+            let save_col = col('.')
+        endif
+
+        " Update the taglist window
+        call s:Tlist_Window_Refresh_File(filename, ftype)
+
+        " Open the fold for the file
+        exe "silent! " . s:tlist_{fidx}_start . "," .
+                    \ s:tlist_{fidx}_end . "foldopen!"
+
+        if g:Tlist_Highlight_Tag_On_BufEnter && g:Tlist_Auto_Highlight_Tag
+            if g:Tlist_Show_One_File && s:tlist_cur_file_idx != fidx
+                " If displaying tags for only one file in the taglist
+                " window and about to display the tags for a new file,
+                " then center the current tag line for the new file
+                let center_tag_line = 1
+            else
+                let center_tag_line = 0
+            endif
+
+            " Highlight the current tag
+            call s:Tlist_Window_Highlight_Tag(filename, cur_lnum, 1, center_tag_line)
+        else
+            " Restore the cursor position
+            if v:version >= 601
+                call cursor(save_line, save_col)
+            else
+                exe save_line
+                exe 'normal! ' . save_col . '|'
+            endif
+        endif
+
+        " Jump back to the original window
+        if save_winnr != winnr()
+            call s:Tlist_Exe_Cmd_No_Acmds(save_winnr . 'wincmd w')
+        endif
+
+        " Restore screen updates
+        let &lazyredraw = old_lazyredraw
+    endif
+
+    " Update the taglist menu
+    if g:Tlist_Show_Menu
+        call s:Tlist_Menu_Update_File(0)
+    endif
+endfunction
+
+" Tlist_Change_Sort()
+" Change the sort order of the tag listing
+" caller == 'cmd', command used in the taglist window
+" caller == 'menu', taglist menu
+" action == 'toggle', toggle sort from name to order and vice versa
+" action == 'set', set the sort order to sort_type
+function! s:Tlist_Change_Sort(caller, action, sort_type)
+    call s:Tlist_Log_Msg('Tlist_Change_Sort (caller = ' . a:caller .
+            \ ', action = ' . a:action . ', sort_type = ' . a:sort_type . ')')
+    if a:caller == 'cmd'
+        let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
+        if fidx == -1
+            return
+        endif
+
+        " Remove the previous highlighting
+        match none
+    elseif a:caller == 'menu'
+        let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
+        if fidx == -1
+            return
+        endif
+    endif
+
+    if a:action == 'toggle'
+        let sort_type = s:tlist_{fidx}_sort_type
+
+        " Toggle the sort order from 'name' to 'order' and vice versa
+        if sort_type == 'name'
+            let s:tlist_{fidx}_sort_type = 'order'
+        else
+            let s:tlist_{fidx}_sort_type = 'name'
+        endif
+    else
+        let s:tlist_{fidx}_sort_type = a:sort_type
+    endif
+
+    " Invalidate the tags listed for this file
+    let s:tlist_{fidx}_valid = 0
+
+    if a:caller  == 'cmd'
+        " Save the current line for later restoration
+        let curline = '\V\^' . getline('.') . '\$'
+
+        call s:Tlist_Window_Refresh_File(s:tlist_{fidx}_filename,
+                    \   s:tlist_{fidx}_filetype)
+
+        exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'foldopen!'
+
+        " Go back to the cursor line before the tag list is sorted
+        call search(curline, 'w')
+
+        call s:Tlist_Menu_Update_File(1)
+    else
+        call s:Tlist_Menu_Remove_File()
+
+        call s:Tlist_Refresh()
+    endif
+endfunction
+
+" Tlist_Update_Current_File()
+" Update taglist for the current buffer by regenerating the tag list
+" Contributed by WEN Guopeng.
+function! s:Tlist_Update_Current_File()
+    call s:Tlist_Log_Msg('Tlist_Update_Current_File()')
+    if winnr() == bufwinnr(g:TagList_title)
+        " In the taglist window. Update the current file
+        call s:Tlist_Window_Update_File()
+    else
+        " Not in the taglist window. Update the current buffer
+        let filename = fnamemodify(bufname('%'), ':p')
+        let fidx = s:Tlist_Get_File_Index(filename)
+        if fidx != -1
+            let s:tlist_{fidx}_valid = 0
+        endif
+        let ft = s:Tlist_Get_Buffer_Filetype('%')
+        call Tlist_Update_File(filename, ft)
+    endif
+endfunction
+
+" Tlist_Window_Update_File()
+" Update the tags displayed in the taglist window
+function! s:Tlist_Window_Update_File()
+    call s:Tlist_Log_Msg('Tlist_Window_Update_File()')
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
+    if fidx == -1
+        return
+    endif
+
+    " Remove the previous highlighting
+    match none
+
+    " Save the current line for later restoration
+    let curline = '\V\^' . getline('.') . '\$'
+
+    let s:tlist_{fidx}_valid = 0
+
+    " Update the taglist window
+    call s:Tlist_Window_Refresh_File(s:tlist_{fidx}_filename,
+                \ s:tlist_{fidx}_filetype)
+
+    exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'foldopen!'
+
+    " Go back to the tag line before the list is updated
+    call search(curline, 'w')
+endfunction
+
+" Tlist_Window_Get_Tag_Type_By_Linenum()
+" Return the tag type index for the specified line in the taglist window
+function! s:Tlist_Window_Get_Tag_Type_By_Linenum(fidx, lnum)
+    let ftype = s:tlist_{a:fidx}_filetype
+
+    " Determine to which tag type the current line number belongs to using the
+    " tag type start line number and the number of tags in a tag type
+    let i = 1
+    while i <= s:tlist_{ftype}_count
+        let ttype = s:tlist_{ftype}_{i}_name
+        let start_lnum =
+                    \ s:tlist_{a:fidx}_start + s:tlist_{a:fidx}_{ttype}_offset
+        let end =  start_lnum + s:tlist_{a:fidx}_{ttype}_count
+        if a:lnum >= start_lnum && a:lnum <= end
+            break
+        endif
+        let i = i + 1
+    endwhile
+
+    " Current line doesn't belong to any of the displayed tag types
+    if i > s:tlist_{ftype}_count
+        return ''
+    endif
+
+    return ttype
+endfunction
+
+" Tlist_Window_Get_Tag_Index()
+" Return the tag index for the specified line in the taglist window
+function! s:Tlist_Window_Get_Tag_Index(fidx, lnum)
+    let ttype = s:Tlist_Window_Get_Tag_Type_By_Linenum(a:fidx, a:lnum)
+
+    " Current line doesn't belong to any of the displayed tag types
+    if ttype == ''
+        return 0
+    endif
+
+    " Compute the index into the displayed tags for the tag type
+    let ttype_lnum = s:tlist_{a:fidx}_start + s:tlist_{a:fidx}_{ttype}_offset
+    let tidx = a:lnum - ttype_lnum
+    if tidx == 0
+        return 0
+    endif
+
+    " Get the corresponding tag line and return it
+    return s:tlist_{a:fidx}_{ttype}_{tidx}
+endfunction
+
+" Tlist_Window_Highlight_Line
+" Highlight the current line
+function! s:Tlist_Window_Highlight_Line()
+    " Clear previously selected name
+    match none
+
+    " Highlight the current line
+    if g:Tlist_Display_Prototype == 0
+        let pat = '/\%' . line('.') . 'l\s\+\zs.*/'
+    else
+        let pat = '/\%' . line('.') . 'l.*/'
+    endif
+
+    exe 'match TagListTagName ' . pat
+endfunction
+
+" Tlist_Window_Open_File
+" Open the specified file in either a new window or an existing window
+" and place the cursor at the specified tag pattern
+function! s:Tlist_Window_Open_File(win_ctrl, filename, tagpat)
+    call s:Tlist_Log_Msg('Tlist_Window_Open_File (' . a:filename . ',' .
+                \ a:win_ctrl . ')')
+    let prev_Tlist_Skip_Refresh = s:Tlist_Skip_Refresh
+    let s:Tlist_Skip_Refresh = 1
+
+    if s:tlist_app_name == "winmanager"
+        " Let the winmanager edit the file
+        call WinManagerFileEdit(a:filename, a:win_ctrl == 'newwin')
+    else
+
+    if a:win_ctrl == 'newtab'
+        " Create a new tab
+        exe 'tabnew ' . escape(a:filename, ' ')
+        " Open the taglist window in the new tab
+        call s:Tlist_Window_Open()
+    endif
+
+    if a:win_ctrl == 'checktab'
+        " Check whether the file is present in any of the tabs.
+        " If the file is present in the current tab, then use the
+        " current tab.
+        if bufwinnr(a:filename) != -1
+            let file_present_in_tab = 1
+            let i = tabpagenr()
+        else
+            let i = 1
+            let bnum = bufnr(a:filename)
+            let file_present_in_tab = 0
+            while i <= tabpagenr('$')
+                if index(tabpagebuflist(i), bnum) != -1
+                    let file_present_in_tab = 1
+                    break
+                endif
+                let i += 1
+            endwhile
+        endif
+
+        if file_present_in_tab
+            " Goto the tab containing the file
+            exe 'tabnext ' . i
+        else
+            " Open a new tab
+            exe 'tabnew ' . escape(a:filename, ' ')
+
+            " Open the taglist window
+            call s:Tlist_Window_Open()
+        endif
+    endif
+
+    let winnum = -1
+    if a:win_ctrl == 'prevwin'
+        " Open the file in the previous window, if it is usable
+        let cur_win = winnr()
+        wincmd p
+        if &buftype == '' && !&previewwindow
+            exe "edit " . escape(a:filename, ' ')
+            let winnum = winnr()
+        else
+            " Previous window is not usable
+            exe cur_win . 'wincmd w'
+        endif
+    endif
+
+    " Goto the window containing the file.  If the window is not there, open a
+    " new window
+    if winnum == -1
+        let winnum = bufwinnr(a:filename)
+    endif
+
+    if winnum == -1
+        " Locate the previously used window for opening a file
+        let fwin_num = 0
+        let first_usable_win = 0
+
+        let i = 1
+        let bnum = winbufnr(i)
+        while bnum != -1
+            if getwinvar(i, 'tlist_file_window') == 'yes'
+                let fwin_num = i
+                break
+            endif
+            if first_usable_win == 0 &&
+                        \ getbufvar(bnum, '&buftype') == '' &&
+                        \ !getwinvar(i, '&previewwindow')
+                " First non-taglist, non-plugin and non-preview window
+                let first_usable_win = i
+            endif
+            let i = i + 1
+            let bnum = winbufnr(i)
+        endwhile
+
+        " If a previously used window is not found, then use the first
+        " non-taglist window
+        if fwin_num == 0
+            let fwin_num = first_usable_win
+        endif
+
+        if fwin_num != 0
+            " Jump to the file window
+            exe fwin_num . "wincmd w"
+
+            " If the user asked to jump to the tag in a new window, then split
+            " the existing window into two.
+            if a:win_ctrl == 'newwin'
+                split
+            endif
+            exe "edit " . escape(a:filename, ' ')
+        else
+            " Open a new window
+            if g:Tlist_Use_Horiz_Window
+                exe 'leftabove split ' . escape(a:filename, ' ')
+            else
+                if winbufnr(2) == -1
+                    " Only the taglist window is present
+                    if g:Tlist_Use_Right_Window
+                        exe 'leftabove vertical split ' .
+                                    \ escape(a:filename, ' ')
+                    else
+                        exe 'rightbelow vertical split ' .
+                                    \ escape(a:filename, ' ')
+                    endif
+
+                    " Go to the taglist window to change the window size to
+                    " the user configured value
+                    call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
+                    if g:Tlist_Use_Horiz_Window
+                        exe 'resize ' . g:Tlist_WinHeight
+                    else
+                        exe 'vertical resize ' . g:Tlist_WinWidth
+                    endif
+                    " Go back to the file window
+                    call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
+                else
+                    " A plugin or help window is also present
+                    wincmd w
+                    exe 'leftabove split ' . escape(a:filename, ' ')
+                endif
+            endif
+        endif
+        " Mark the window, so that it can be reused.
+        call s:Tlist_Window_Mark_File_Window()
+    else
+        if v:version >= 700
+            " If the file is opened in more than one window, then check
+            " whether the last accessed window has the selected file.
+            " If it does, then use that window.
+            let lastwin_bufnum = winbufnr(winnr('#'))
+            if bufnr(a:filename) == lastwin_bufnum
+                let winnum = winnr('#')
+            endif
+        endif
+        exe winnum . 'wincmd w'
+
+        " If the user asked to jump to the tag in a new window, then split the
+        " existing window into two.
+        if a:win_ctrl == 'newwin'
+            split
+        endif
+    endif
+    endif
+
+    " Jump to the tag
+    if a:tagpat != ''
+        " Add the current cursor position to the jump list, so that user can
+        " jump back using the ' and ` marks.
+        mark '
+        silent call search(a:tagpat, 'w')
+
+        " Bring the line to the middle of the window
+        normal! z.
+
+        " If the line is inside a fold, open the fold
+        if foldclosed('.') != -1
+            .foldopen
+        endif
+    endif
+
+    " If the user selects to preview the tag then jump back to the
+    " taglist window
+    if a:win_ctrl == 'preview'
+        " Go back to the taglist window
+        let winnum = bufwinnr(g:TagList_title)
+        exe winnum . 'wincmd w'
+    else
+        " If the user has selected to close the taglist window, when a
+        " tag is selected, close the taglist  window
+        if g:Tlist_Close_On_Select
+            call s:Tlist_Window_Goto_Window()
+            close
+
+            " Go back to the window displaying the selected file
+            let wnum = bufwinnr(a:filename)
+            if wnum != -1 && wnum != winnr()
+                call s:Tlist_Exe_Cmd_No_Acmds(wnum . 'wincmd w')
+            endif
+        endif
+    endif
+
+    let s:Tlist_Skip_Refresh = prev_Tlist_Skip_Refresh
+endfunction
+
+" Tlist_Window_Jump_To_Tag()
+" Jump to the location of the current tag
+" win_ctrl == useopen - Reuse the existing file window
+" win_ctrl == newwin - Open a new window
+" win_ctrl == preview - Preview the tag
+" win_ctrl == prevwin - Open in previous window
+" win_ctrl == newtab - Open in new tab
+function! s:Tlist_Window_Jump_To_Tag(win_ctrl)
+    call s:Tlist_Log_Msg('Tlist_Window_Jump_To_Tag(' . a:win_ctrl . ')')
+    " Do not process comment lines and empty lines
+    let curline = getline('.')
+    if curline =~ '^\s*$' || curline[0] == '"'
+        return
+    endif
+
+    " If inside a closed fold, then use the first line of the fold
+    " and jump to the file.
+    let lnum = foldclosed('.')
+    if lnum == -1
+        " Jump to the selected tag or file
+        let lnum = line('.')
+    else
+        " Open the closed fold
+        .foldopen!
+    endif
+
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
+    if fidx == -1
+        return
+    endif
+
+    " Get the tag output for the current tag
+    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, lnum)
+    if tidx != 0
+        let tagpat = s:Tlist_Get_Tag_SearchPat(fidx, tidx)
+
+        " Highlight the tagline
+        call s:Tlist_Window_Highlight_Line()
+    else
+        " Selected a line which is not a tag name. Just edit the file
+        let tagpat = ''
+    endif
+
+    call s:Tlist_Window_Open_File(a:win_ctrl, s:tlist_{fidx}_filename, tagpat)
+endfunction
+
+" Tlist_Window_Show_Info()
+" Display information about the entry under the cursor
+function! s:Tlist_Window_Show_Info()
+    call s:Tlist_Log_Msg('Tlist_Window_Show_Info()')
+
+    " Clear the previously displayed line
+    echo
+
+    " Do not process comment lines and empty lines
+    let curline = getline('.')
+    if curline =~ '^\s*$' || curline[0] == '"'
+        return
+    endif
+
+    " If inside a fold, then don't display the prototype
+    if foldclosed('.') != -1
+        return
+    endif
+
+    let lnum = line('.')
+
+    " Get the file index
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
+    if fidx == -1
+        return
+    endif
+
+    if lnum == s:tlist_{fidx}_start
+        " Cursor is on a file name
+        let fname = s:tlist_{fidx}_filename
+        if strlen(fname) > 50
+            let fname = fnamemodify(fname, ':t')
+        endif
+        echo fname . ', Filetype=' . s:tlist_{fidx}_filetype .
+                    \  ', Tag count=' . s:tlist_{fidx}_tag_count
+        return
+    endif
+
+    " Get the tag output line for the current tag
+    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, lnum)
+    if tidx == 0
+        " Cursor is on a tag type
+        let ttype = s:Tlist_Window_Get_Tag_Type_By_Linenum(fidx, lnum)
+        if ttype == ''
+            return
+        endif
+
+        let ttype_name = ''
+
+        let ftype = s:tlist_{fidx}_filetype
+        let i = 1
+        while i <= s:tlist_{ftype}_count
+            if ttype == s:tlist_{ftype}_{i}_name
+                let ttype_name = s:tlist_{ftype}_{i}_fullname
+                break
+            endif
+            let i = i + 1
+        endwhile
+
+        echo 'Tag type=' . ttype_name .
+                    \ ', Tag count=' . s:tlist_{fidx}_{ttype}_count
+        return
+    endif
+
+    " Get the tag search pattern and display it
+    echo s:Tlist_Get_Tag_Prototype(fidx, tidx)
+endfunction
+
+" Tlist_Find_Nearest_Tag_Idx
+" Find the tag idx nearest to the supplied line number
+" Returns -1, if a tag couldn't be found for the specified line number
+function! s:Tlist_Find_Nearest_Tag_Idx(fidx, linenum)
+    let sort_type = s:tlist_{a:fidx}_sort_type
+
+    let left = 1
+    let right = s:tlist_{a:fidx}_tag_count
+
+    if sort_type == 'order'
+        " Tags sorted by order, use a binary search.
+        " The idea behind this function is taken from the ctags.vim script (by
+        " Alexey Marinichev) available at the Vim online website.
+
+        " If the current line is the less than the first tag, then no need to
+        " search
+        let first_lnum = s:Tlist_Get_Tag_Linenum(a:fidx, 1)
+
+        if a:linenum < first_lnum
+            return -1
+        endif
+
+        while left < right
+            let middle = (right + left + 1) / 2
+            let middle_lnum = s:Tlist_Get_Tag_Linenum(a:fidx, middle)
+
+            if middle_lnum == a:linenum
+                let left = middle
+                break
+            endif
+
+            if middle_lnum > a:linenum
+                let right = middle - 1
+            else
+                let left = middle
+            endif
+        endwhile
+    else
+        " Tags sorted by name, use a linear search. (contributed by Dave
+        " Eggum).
+        " Look for a tag with a line number less than or equal to the supplied
+        " line number. If multiple tags are found, then use the tag with the
+        " line number closest to the supplied line number. IOW, use the tag
+        " with the highest line number.
+        let closest_lnum = 0
+        let final_left = 0
+        while left <= right
+            let lnum = s:Tlist_Get_Tag_Linenum(a:fidx, left)
+
+            if lnum < a:linenum && lnum > closest_lnum
+                let closest_lnum = lnum
+                let final_left = left
+            elseif lnum == a:linenum
+                let closest_lnum = lnum
+                let final_left = left
+                break
+            else
+                let left = left + 1
+            endif
+        endwhile
+        if closest_lnum == 0
+            return -1
+        endif
+        if left >= right
+            let left = final_left
+        endif
+    endif
+
+    return left
+endfunction
+
+" Tlist_Window_Highlight_Tag()
+" Highlight the current tag
+" cntx == 1, Called by the taglist plugin itself
+" cntx == 2, Forced by the user through the TlistHighlightTag command
+" center = 1, move the tag line to the center of the taglist window
+function! s:Tlist_Window_Highlight_Tag(filename, cur_lnum, cntx, center)
+    " Highlight the current tag only if the user configured the
+    " taglist plugin to do so or if the user explictly invoked the
+    " command to highlight the current tag.
+    if !g:Tlist_Auto_Highlight_Tag && a:cntx == 1
+        return
+    endif
+
+    if a:filename == ''
+        return
+    endif
+
+    " Make sure the taglist window is present
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum == -1
+        call s:Tlist_Warning_Msg('Error: Taglist window is not open')
+        return
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(a:filename)
+    if fidx == -1
+        return
+    endif
+
+    " If the file is currently not displayed in the taglist window, then retrn
+    if !s:tlist_{fidx}_visible
+        return
+    endif
+
+    " If there are no tags for this file, then no need to proceed further
+    if s:tlist_{fidx}_tag_count == 0
+        return
+    endif
+
+    " Ignore all autocommands
+    let old_ei = &eventignore
+    set eventignore=all
+
+    " Save the original window number
+    let org_winnr = winnr()
+
+    if org_winnr == winnum
+        let in_taglist_window = 1
+    else
+        let in_taglist_window = 0
+    endif
+
+    " Go to the taglist window
+    if !in_taglist_window
+        exe winnum . 'wincmd w'
+    endif
+
+    " Clear previously selected name
+    match none
+
+    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, a:cur_lnum)
+    if tidx == -1
+        " Make sure the current tag line is visible in the taglist window.
+        " Calling the winline() function makes the line visible.  Don't know
+        " of a better way to achieve this.
+        let lnum = line('.')
+
+        if lnum < s:tlist_{fidx}_start || lnum > s:tlist_{fidx}_end
+            " Move the cursor to the beginning of the file
+            exe s:tlist_{fidx}_start
+        endif
+
+        if foldclosed('.') != -1
+            .foldopen
+        endif
+
+        call winline()
+
+        if !in_taglist_window
+            exe org_winnr . 'wincmd w'
+        endif
+
+        " Restore the autocommands
+        let &eventignore = old_ei
+        return
+    endif
+
+    " Extract the tag type
+    let ttype = s:Tlist_Get_Tag_Type_By_Tag(fidx, tidx)
+
+    " Compute the line number
+    " Start of file + Start of tag type + offset
+    let lnum = s:tlist_{fidx}_start + s:tlist_{fidx}_{ttype}_offset +
+                \ s:tlist_{fidx}_{tidx}_ttype_idx
+
+    " Goto the line containing the tag
+    exe lnum
+
+    " Open the fold
+    if foldclosed('.') != -1
+        .foldopen
+    endif
+
+    if a:center
+        " Move the tag line to the center of the taglist window
+        normal! z.
+    else
+        " Make sure the current tag line is visible in the taglist window.
+        " Calling the winline() function makes the line visible.  Don't know
+        " of a better way to achieve this.
+        call winline()
+    endif
+
+    " Highlight the tag name
+    call s:Tlist_Window_Highlight_Line()
+
+    " Go back to the original window
+    if !in_taglist_window
+        exe org_winnr . 'wincmd w'
+    endif
+
+    " Restore the autocommands
+    let &eventignore = old_ei
+    return
+endfunction
+
+" Tlist_Get_Tag_Prototype_By_Line
+" Get the prototype for the tag on or before the specified line number in the
+" current buffer
+function! Tlist_Get_Tag_Prototype_By_Line(...)
+    if a:0 == 0
+        " Arguments are not supplied. Use the current buffer name
+        " and line number
+        let filename = bufname('%')
+        let linenr = line('.')
+    elseif a:0 == 2
+        " Filename and line number are specified
+        let filename = a:1
+        let linenr = a:2
+        if linenr !~ '\d\+'
+            " Invalid line number
+            return ""
+        endif
+    else
+        " Sufficient arguments are not supplied
+        let msg =  'Usage: Tlist_Get_Tag_Prototype_By_Line <filename> ' .
+                                \ '<line_number>'
+        call s:Tlist_Warning_Msg(msg)
+        return ""
+    endif
+
+    " Expand the file to a fully qualified name
+    let filename = fnamemodify(filename, ':p')
+    if filename == ''
+        return ""
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(filename)
+    if fidx == -1
+        return ""
+    endif
+
+    " If there are no tags for this file, then no need to proceed further
+    if s:tlist_{fidx}_tag_count == 0
+        return ""
+    endif
+
+    " Get the tag text using the line number
+    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, linenr)
+    if tidx == -1
+        return ""
+    endif
+
+    return s:Tlist_Get_Tag_Prototype(fidx, tidx)
+endfunction
+
+" Tlist_Get_Tagname_By_Line
+" Get the tag name on or before the specified line number in the
+" current buffer
+function! Tlist_Get_Tagname_By_Line(...)
+    if a:0 == 0
+        " Arguments are not supplied. Use the current buffer name
+        " and line number
+        let filename = bufname('%')
+        let linenr = line('.')
+    elseif a:0 == 2
+        " Filename and line number are specified
+        let filename = a:1
+        let linenr = a:2
+        if linenr !~ '\d\+'
+            " Invalid line number
+            return ""
+        endif
+    else
+        " Sufficient arguments are not supplied
+        let msg =  'Usage: Tlist_Get_Tagname_By_Line <filename> <line_number>'
+        call s:Tlist_Warning_Msg(msg)
+        return ""
+    endif
+
+    " Make sure the current file has a name
+    let filename = fnamemodify(filename, ':p')
+    if filename == ''
+        return ""
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(filename)
+    if fidx == -1
+        return ""
+    endif
+
+    " If there are no tags for this file, then no need to proceed further
+    if s:tlist_{fidx}_tag_count == 0
+        return ""
+    endif
+
+    " Get the tag name using the line number
+    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, linenr)
+    if tidx == -1
+        return ""
+    endif
+
+    return s:tlist_{fidx}_{tidx}_tag_name
+endfunction
+
+" Tlist_Window_Move_To_File
+" Move the cursor to the beginning of the current file or the next file
+" or the previous file in the taglist window
+" dir == -1, move to start of current or previous function
+" dir == 1, move to start of next function
+function! s:Tlist_Window_Move_To_File(dir)
+    if foldlevel('.') == 0
+        " Cursor is on a non-folded line (it is not in any of the files)
+        " Move it to a folded line
+        if a:dir == -1
+            normal! zk
+        else
+            " While moving down to the start of the next fold,
+            " no need to do go to the start of the next file.
+            normal! zj
+            return
+        endif
+    endif
+
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
+    if fidx == -1
+        return
+    endif
+
+    let cur_lnum = line('.')
+
+    if a:dir == -1
+        if cur_lnum > s:tlist_{fidx}_start
+            " Move to the beginning of the current file
+            exe s:tlist_{fidx}_start
+            return
+        endif
+
+        if fidx != 0
+            " Move to the beginning of the previous file
+            let fidx = fidx - 1
+        else
+            " Cursor is at the first file, wrap around to the last file
+            let fidx = s:tlist_file_count - 1
+        endif
+
+        exe s:tlist_{fidx}_start
+        return
+    else
+        " Move to the beginning of the next file
+        let fidx = fidx + 1
+
+        if fidx >= s:tlist_file_count
+            " Cursor is at the last file, wrap around to the first file
+            let fidx = 0
+        endif
+
+        if s:tlist_{fidx}_start != 0
+            exe s:tlist_{fidx}_start
+        endif
+        return
+    endif
+endfunction
+
+" Tlist_Session_Load
+" Load a taglist session (information about all the displayed files
+" and the tags) from the specified file
+function! s:Tlist_Session_Load(...)
+    if a:0 == 0 || a:1 == ''
+        call s:Tlist_Warning_Msg('Usage: TlistSessionLoad <filename>')
+        return
+    endif
+
+    let sessionfile = a:1
+
+    if !filereadable(sessionfile)
+        let msg = 'Taglist: Error - Unable to open file ' . sessionfile
+        call s:Tlist_Warning_Msg(msg)
+        return
+    endif
+
+    " Mark the current window as the file window
+    call s:Tlist_Window_Mark_File_Window()
+
+    " Source the session file
+    exe 'source ' . sessionfile
+
+    let new_file_count = g:tlist_file_count
+    unlet! g:tlist_file_count
+
+    let i = 0
+    while i < new_file_count
+        let ftype = g:tlist_{i}_filetype
+        unlet! g:tlist_{i}_filetype
+
+        if !exists('s:tlist_' . ftype . '_count')
+            if s:Tlist_FileType_Init(ftype) == 0
+                let i = i + 1
+                continue
+            endif
+        endif
+
+        let fname = g:tlist_{i}_filename
+        unlet! g:tlist_{i}_filename
+
+        let fidx = s:Tlist_Get_File_Index(fname)
+        if fidx != -1
+            let s:tlist_{fidx}_visible = 0
+            let i = i + 1
+            continue
+        else
+            " As we are loading the tags from the session file, if this
+            " file was previously deleted by the user, now we need to
+            " add it back. So remove the file from the deleted list.
+            call s:Tlist_Update_Remove_List(fname, 0)
+        endif
+
+        let fidx = s:Tlist_Init_File(fname, ftype)
+
+        let s:tlist_{fidx}_filename = fname
+
+        let s:tlist_{fidx}_sort_type = g:tlist_{i}_sort_type
+        unlet! g:tlist_{i}_sort_type
+
+        let s:tlist_{fidx}_filetype = ftype
+        let s:tlist_{fidx}_mtime = getftime(fname)
+
+        let s:tlist_{fidx}_start = 0
+        let s:tlist_{fidx}_end = 0
+
+        let s:tlist_{fidx}_valid = 1
+
+        let s:tlist_{fidx}_tag_count = g:tlist_{i}_tag_count
+        unlet! g:tlist_{i}_tag_count
+
+        let j = 1
+        while j <= s:tlist_{fidx}_tag_count
+            let s:tlist_{fidx}_{j}_tag = g:tlist_{i}_{j}_tag
+            let s:tlist_{fidx}_{j}_tag_name = g:tlist_{i}_{j}_tag_name
+            let s:tlist_{fidx}_{j}_ttype_idx = g:tlist_{i}_{j}_ttype_idx
+            unlet! g:tlist_{i}_{j}_tag
+            unlet! g:tlist_{i}_{j}_tag_name
+            unlet! g:tlist_{i}_{j}_ttype_idx
+            let j = j + 1
+        endwhile
+
+        let j = 1
+        while j <= s:tlist_{ftype}_count
+            let ttype = s:tlist_{ftype}_{j}_name
+
+            if exists('g:tlist_' . i . '_' . ttype)
+                let s:tlist_{fidx}_{ttype} = g:tlist_{i}_{ttype}
+                unlet! g:tlist_{i}_{ttype}
+                let s:tlist_{fidx}_{ttype}_offset = 0
+                let s:tlist_{fidx}_{ttype}_count = g:tlist_{i}_{ttype}_count
+                unlet! g:tlist_{i}_{ttype}_count
+
+                let k = 1
+                while k <= s:tlist_{fidx}_{ttype}_count
+                    let s:tlist_{fidx}_{ttype}_{k} = g:tlist_{i}_{ttype}_{k}
+                    unlet! g:tlist_{i}_{ttype}_{k}
+                    let k = k + 1
+                endwhile
+            else
+                let s:tlist_{fidx}_{ttype} = ''
+                let s:tlist_{fidx}_{ttype}_offset = 0
+                let s:tlist_{fidx}_{ttype}_count = 0
+            endif
+
+            let j = j + 1
+        endwhile
+
+        let i = i + 1
+    endwhile
+
+    " If the taglist window is open, then update it
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        let save_winnr = winnr()
+
+        " Goto the taglist window
+        call s:Tlist_Window_Goto_Window()
+
+        " Refresh the taglist window
+        call s:Tlist_Window_Refresh()
+
+        " Go back to the original window
+        if save_winnr != winnr()
+            call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
+        endif
+    endif
+endfunction
+
+" Tlist_Session_Save
+" Save a taglist session (information about all the displayed files
+" and the tags) into the specified file
+function! s:Tlist_Session_Save(...)
+    if a:0 == 0 || a:1 == ''
+        call s:Tlist_Warning_Msg('Usage: TlistSessionSave <filename>')
+        return
+    endif
+
+    let sessionfile = a:1
+
+    if s:tlist_file_count == 0
+        " There is nothing to save
+        call s:Tlist_Warning_Msg('Warning: Taglist is empty. Nothing to save.')
+        return
+    endif
+
+    if filereadable(sessionfile)
+        let ans = input('Do you want to overwrite ' . sessionfile . ' (Y/N)?')
+        if ans !=? 'y'
+            return
+        endif
+
+        echo "\n"
+    endif
+
+    let old_verbose = &verbose
+    set verbose&vim
+
+    exe 'redir! > ' . sessionfile
+
+    silent! echo '" Taglist session file. This file is auto-generated.'
+    silent! echo '" File information'
+    silent! echo 'let tlist_file_count = ' . s:tlist_file_count
+
+    let i = 0
+
+    while i < s:tlist_file_count
+        " Store information about the file
+        silent! echo 'let tlist_' . i . "_filename = '" .
+                                            \ s:tlist_{i}_filename . "'"
+        silent! echo 'let tlist_' . i . '_sort_type = "' .
+                                                \ s:tlist_{i}_sort_type . '"'
+        silent! echo 'let tlist_' . i . '_filetype = "' .
+                                            \ s:tlist_{i}_filetype . '"'
+        silent! echo 'let tlist_' . i . '_tag_count = ' .
+                                                        \ s:tlist_{i}_tag_count
+        " Store information about all the tags
+        let j = 1
+        while j <= s:tlist_{i}_tag_count
+            let txt = escape(s:tlist_{i}_{j}_tag, '"\\')
+            silent! echo 'let tlist_' . i . '_' . j . '_tag = "' . txt . '"'
+            silent! echo 'let tlist_' . i . '_' . j . '_tag_name = "' .
+                        \ s:tlist_{i}_{j}_tag_name . '"'
+            silent! echo 'let tlist_' . i . '_' . j . '_ttype_idx' . ' = ' .
+                        \ s:tlist_{i}_{j}_ttype_idx
+            let j = j + 1
+        endwhile
+
+        " Store information about all the tags grouped by their type
+        let ftype = s:tlist_{i}_filetype
+        let j = 1
+        while j <= s:tlist_{ftype}_count
+            let ttype = s:tlist_{ftype}_{j}_name
+            if s:tlist_{i}_{ttype}_count != 0
+                let txt = escape(s:tlist_{i}_{ttype}, '"\')
+                let txt = substitute(txt, "\n", "\\\\n", 'g')
+                silent! echo 'let tlist_' . i . '_' . ttype . ' = "' .
+                                                \ txt . '"'
+                silent! echo 'let tlist_' . i . '_' . ttype . '_count = ' .
+                                                     \ s:tlist_{i}_{ttype}_count
+                let k = 1
+                while k <= s:tlist_{i}_{ttype}_count
+                    silent! echo 'let tlist_' . i . '_' . ttype . '_' . k .
+                                \ ' = ' . s:tlist_{i}_{ttype}_{k}
+                    let k = k + 1
+                endwhile
+            endif
+            let j = j + 1
+        endwhile
+
+        silent! echo
+
+        let i = i + 1
+    endwhile
+
+    redir END
+
+    let &verbose = old_verbose
+endfunction
+
+" Tlist_Buffer_Removed
+" A buffer is removed from the Vim buffer list. Remove the tags defined
+" for that file
+function! s:Tlist_Buffer_Removed(filename)
+    call s:Tlist_Log_Msg('Tlist_Buffer_Removed (' . a:filename .  ')')
+
+    " Make sure a valid filename is supplied
+    if a:filename == ''
+        return
+    endif
+
+    " Get tag list index of the specified file
+    let fidx = s:Tlist_Get_File_Index(a:filename)
+    if fidx == -1
+        " File not present in the taglist
+        return
+    endif
+
+    " Remove the file from the list
+    call s:Tlist_Remove_File(fidx, 0)
+endfunction
+
+" When a buffer is deleted, remove the file from the taglist
+autocmd BufDelete * silent call s:Tlist_Buffer_Removed(expand('<afile>:p'))
+
+" Tlist_Window_Open_File_Fold
+" Open the fold for the specified file and close the fold for all the
+" other files
+function! s:Tlist_Window_Open_File_Fold(acmd_bufnr)
+    call s:Tlist_Log_Msg('Tlist_Window_Open_File_Fold (' . a:acmd_bufnr . ')')
+
+    " Make sure the taglist window is present
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum == -1
+        call s:Tlist_Warning_Msg('Taglist: Error - Taglist window is not open')
+        return
+    endif
+
+    " Save the original window number
+    let org_winnr = winnr()
+    if org_winnr == winnum
+        let in_taglist_window = 1
+    else
+        let in_taglist_window = 0
+    endif
+
+    if in_taglist_window
+        " When entering the taglist window, no need to update the folds
+        return
+    endif
+
+    " Go to the taglist window
+    if !in_taglist_window
+        call s:Tlist_Exe_Cmd_No_Acmds(winnum . 'wincmd w')
+    endif
+
+    " Close all the folds
+    silent! %foldclose
+
+    " Get tag list index of the specified file
+    let fname = fnamemodify(bufname(a:acmd_bufnr + 0), ':p')
+    if filereadable(fname)
+        let fidx = s:Tlist_Get_File_Index(fname)
+        if fidx != -1
+            " Open the fold for the file
+            exe "silent! " . s:tlist_{fidx}_start . "," .
+                        \ s:tlist_{fidx}_end . "foldopen"
+        endif
+    endif
+
+    " Go back to the original window
+    if !in_taglist_window
+        call s:Tlist_Exe_Cmd_No_Acmds(org_winnr . 'wincmd w')
+    endif
+endfunction
+
+" Tlist_Window_Check_Auto_Open
+" Open the taglist window automatically on Vim startup.
+" Open the window only when files present in any of the Vim windows support
+" tags.
+function! s:Tlist_Window_Check_Auto_Open()
+    let open_window = 0
+
+    let i = 1
+    let buf_num = winbufnr(i)
+    while buf_num != -1
+        let filename = fnamemodify(bufname(buf_num), ':p')
+        let ft = s:Tlist_Get_Buffer_Filetype(buf_num)
+        if !s:Tlist_Skip_File(filename, ft)
+            let open_window = 1
+            break
+        endif
+        let i = i + 1
+        let buf_num = winbufnr(i)
+    endwhile
+
+    if open_window
+        call s:Tlist_Window_Toggle()
+    endif
+endfunction
+
+" Tlist_Refresh_Folds
+" Remove and create the folds for all the files displayed in the taglist
+" window. Used after entering a tab. If this is not done, then the folds
+" are not properly created for taglist windows displayed in multiple tabs.
+function! s:Tlist_Refresh_Folds()
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum == -1
+        return
+    endif
+
+    let save_wnum = winnr()
+    exe winnum . 'wincmd w'
+
+    " First remove all the existing folds
+    normal! zE
+
+    " Create the folds for each in the tag list
+    let fidx = 0
+    while fidx < s:tlist_file_count
+        let ftype = s:tlist_{fidx}_filetype
+
+        " Create the folds for each tag type in a file
+        let j = 1
+        while j <= s:tlist_{ftype}_count
+            let ttype = s:tlist_{ftype}_{j}_name
+            if s:tlist_{fidx}_{ttype}_count
+                let s = s:tlist_{fidx}_start + s:tlist_{fidx}_{ttype}_offset
+                let e = s + s:tlist_{fidx}_{ttype}_count
+                exe s . ',' . e . 'fold'
+            endif
+            let j = j + 1
+        endwhile
+
+        exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'fold'
+        exe 'silent! ' . s:tlist_{fidx}_start . ',' .
+                    \ s:tlist_{fidx}_end . 'foldopen!'
+        let fidx = fidx + 1
+    endwhile
+
+    exe save_wnum . 'wincmd w'
+endfunction
+
+function! s:Tlist_Menu_Add_Base_Menu()
+    call s:Tlist_Log_Msg('Adding the base menu')
+
+    " Add the menu
+    anoremenu <silent> T&ags.Refresh\ menu :call <SID>Tlist_Menu_Refresh()<CR>
+    anoremenu <silent> T&ags.Sort\ menu\ by.Name
+                    \ :call <SID>Tlist_Change_Sort('menu', 'set', 'name')<CR>
+    anoremenu <silent> T&ags.Sort\ menu\ by.Order
+                    \ :call <SID>Tlist_Change_Sort('menu', 'set', 'order')<CR>
+    anoremenu T&ags.-SEP1-           :
+
+    if &mousemodel =~ 'popup'
+        anoremenu <silent> PopUp.T&ags.Refresh\ menu
+                    \ :call <SID>Tlist_Menu_Refresh()<CR>
+        anoremenu <silent> PopUp.T&ags.Sort\ menu\ by.Name
+                  \ :call <SID>Tlist_Change_Sort('menu', 'set', 'name')<CR>
+        anoremenu <silent> PopUp.T&ags.Sort\ menu\ by.Order
+                  \ :call <SID>Tlist_Change_Sort('menu', 'set', 'order')<CR>
+        anoremenu PopUp.T&ags.-SEP1-           :
+    endif
+endfunction
+
+let s:menu_char_prefix =
+            \ '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
+
+" Tlist_Menu_Get_Tag_Type_Cmd
+" Get the menu command for the specified tag type
+" fidx - File type index
+" ftype - File Type
+" add_ttype_name - To add or not to add the tag type name to the menu entries
+" ttype_idx - Tag type index
+function! s:Tlist_Menu_Get_Tag_Type_Cmd(fidx, ftype, add_ttype_name, ttype_idx)
+    " Curly brace variable name optimization
+    let ftype_ttype_idx = a:ftype . '_' . a:ttype_idx
+
+    let ttype = s:tlist_{ftype_ttype_idx}_name
+    if a:add_ttype_name
+        " If the tag type name contains space characters, escape it. This
+        " will be used to create the menu entries.
+        let ttype_fullname = escape(s:tlist_{ftype_ttype_idx}_fullname, ' ')
+    endif
+
+    " Curly brace variable name optimization
+    let fidx_ttype = a:fidx . '_' . ttype
+
+    " Number of tag entries for this tag type
+    let tcnt = s:tlist_{fidx_ttype}_count
+    if tcnt == 0 " No entries for this tag type
+        return ''
+    endif
+
+    let mcmd = ''
+
+    " Create the menu items for the tags.
+    " Depending on the number of tags of this type, split the menu into
+    " multiple sub-menus, if needed.
+    if tcnt > g:Tlist_Max_Submenu_Items
+        let j = 1
+        while j <= tcnt
+            let final_index = j + g:Tlist_Max_Submenu_Items - 1
+            if final_index > tcnt
+                let final_index = tcnt
+            endif
+
+            " Extract the first and last tag name and form the
+            " sub-menu name
+            let tidx = s:tlist_{fidx_ttype}_{j}
+            let first_tag = s:tlist_{a:fidx}_{tidx}_tag_name
+
+            let tidx = s:tlist_{fidx_ttype}_{final_index}
+            let last_tag = s:tlist_{a:fidx}_{tidx}_tag_name
+
+            " Truncate the names, if they are greater than the
+            " max length
+            let first_tag = strpart(first_tag, 0, g:Tlist_Max_Tag_Length)
+            let last_tag = strpart(last_tag, 0, g:Tlist_Max_Tag_Length)
+
+            " Form the menu command prefix
+            let m_prefix = 'anoremenu <silent> T\&ags.'
+            if a:add_ttype_name
+                let m_prefix = m_prefix . ttype_fullname . '.'
+            endif
+            let m_prefix = m_prefix . first_tag . '\.\.\.' . last_tag . '.'
+
+            " Character prefix used to number the menu items (hotkey)
+            let m_prefix_idx = 0
+
+            while j <= final_index
+                let tidx = s:tlist_{fidx_ttype}_{j}
+
+                let tname = s:tlist_{a:fidx}_{tidx}_tag_name
+
+                let mcmd = mcmd . m_prefix . '\&' .
+                            \ s:menu_char_prefix[m_prefix_idx] . '\.' .
+                            \ tname . ' :call <SID>Tlist_Menu_Jump_To_Tag(' .
+                            \ tidx . ')<CR>|'
+
+                let m_prefix_idx = m_prefix_idx + 1
+                let j = j + 1
+            endwhile
+        endwhile
+    else
+        " Character prefix used to number the menu items (hotkey)
+        let m_prefix_idx = 0
+
+        let m_prefix = 'anoremenu <silent> T\&ags.'
+        if a:add_ttype_name
+            let m_prefix = m_prefix . ttype_fullname . '.'
+        endif
+        let j = 1
+        while j <= tcnt
+            let tidx = s:tlist_{fidx_ttype}_{j}
+
+            let tname = s:tlist_{a:fidx}_{tidx}_tag_name
+
+            let mcmd = mcmd . m_prefix . '\&' .
+                        \ s:menu_char_prefix[m_prefix_idx] . '\.' .
+                        \ tname . ' :call <SID>Tlist_Menu_Jump_To_Tag(' . tidx
+                        \ . ')<CR>|'
+
+            let m_prefix_idx = m_prefix_idx + 1
+            let j = j + 1
+        endwhile
+    endif
+
+    return mcmd
+endfunction
+
+" Update the taglist menu with the tags for the specified file
+function! s:Tlist_Menu_File_Refresh(fidx)
+    call s:Tlist_Log_Msg('Refreshing the tag menu for ' . s:tlist_{a:fidx}_filename)
+    " The 'B' flag is needed in the 'cpoptions' option
+    let old_cpoptions = &cpoptions
+    set cpoptions&vim
+
+    exe s:tlist_{a:fidx}_menu_cmd
+
+    " Update the popup menu (if enabled)
+    if &mousemodel =~ 'popup'
+        let cmd = substitute(s:tlist_{a:fidx}_menu_cmd, ' T\\&ags\.',
+                                        \ ' PopUp.T\\\&ags.', "g")
+        exe cmd
+    endif
+
+    " The taglist menu is not empty now
+    let s:tlist_menu_empty = 0
+
+    " Restore the 'cpoptions' settings
+    let &cpoptions = old_cpoptions
+endfunction
+
+" Tlist_Menu_Update_File
+" Add the taglist menu
+function! s:Tlist_Menu_Update_File(clear_menu)
+    if !has('gui_running')
+        " Not running in GUI mode
+        return
+    endif
+
+    call s:Tlist_Log_Msg('Updating the tag menu, clear_menu = ' . a:clear_menu)
+
+    " Remove the tags menu
+    if a:clear_menu
+        call s:Tlist_Menu_Remove_File()
+
+    endif
+
+    " Skip buffers with 'buftype' set to nofile, nowrite, quickfix or help
+    if &buftype != ''
+        return
+    endif
+
+    let filename = fnamemodify(bufname('%'), ':p')
+    let ftype = s:Tlist_Get_Buffer_Filetype('%')
+
+    " If the file doesn't support tag listing, skip it
+    if s:Tlist_Skip_File(filename, ftype)
+        return
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(filename)
+    if fidx == -1 || !s:tlist_{fidx}_valid
+        " Check whether this file is removed based on user request
+        " If it is, then don't display the tags for this file
+        if s:Tlist_User_Removed_File(filename)
+            return
+        endif
+
+        " Process the tags for the file
+        let fidx = s:Tlist_Process_File(filename, ftype)
+        if fidx == -1
+            return
+        endif
+    endif
+
+    let fname = escape(fnamemodify(bufname('%'), ':t'), '.')
+    if fname != ''
+        exe 'anoremenu T&ags.' .  fname . ' <Nop>'
+        anoremenu T&ags.-SEP2-           :
+    endif
+
+    if !s:tlist_{fidx}_tag_count
+        return
+    endif
+
+    if s:tlist_{fidx}_menu_cmd != ''
+        " Update the menu with the cached command
+        call s:Tlist_Menu_File_Refresh(fidx)
+
+        return
+    endif
+
+    " We are going to add entries to the tags menu, so the menu won't be
+    " empty
+    let s:tlist_menu_empty = 0
+
+    let cmd = ''
+
+    " Determine whether the tag type name needs to be added to the menu
+    " If more than one tag type is present in the taglisting for a file,
+    " then the tag type name needs to be present
+    let add_ttype_name = -1
+    let i = 1
+    while i <= s:tlist_{ftype}_count && add_ttype_name < 1
+        let ttype = s:tlist_{ftype}_{i}_name
+        if s:tlist_{fidx}_{ttype}_count
+            let add_ttype_name = add_ttype_name + 1
+        endif
+        let i = i + 1
+    endwhile
+
+    " Process the tags by the tag type and get the menu command
+    let i = 1
+    while i <= s:tlist_{ftype}_count
+        let mcmd = s:Tlist_Menu_Get_Tag_Type_Cmd(fidx, ftype, add_ttype_name, i)
+        if mcmd != ''
+            let cmd = cmd . mcmd
+        endif
+
+        let i = i + 1
+    endwhile
+
+    " Cache the menu command for reuse
+    let s:tlist_{fidx}_menu_cmd = cmd
+
+    " Update the menu
+    call s:Tlist_Menu_File_Refresh(fidx)
+endfunction
+
+" Tlist_Menu_Remove_File
+" Remove the tags displayed in the tags menu
+function! s:Tlist_Menu_Remove_File()
+    if !has('gui_running') || s:tlist_menu_empty
+        return
+    endif
+
+    call s:Tlist_Log_Msg('Removing the tags menu for a file')
+
+    " Cleanup the Tags menu
+    silent! unmenu T&ags
+    if &mousemodel =~ 'popup'
+        silent! unmenu PopUp.T&ags
+    endif
+
+    " Add a dummy menu item to retain teared off menu
+    noremenu T&ags.Dummy l
+
+    silent! unmenu! T&ags
+    if &mousemodel =~ 'popup'
+        silent! unmenu! PopUp.T&ags
+    endif
+
+    call s:Tlist_Menu_Add_Base_Menu()
+
+    " Remove the dummy menu item
+    unmenu T&ags.Dummy
+
+    let s:tlist_menu_empty = 1
+endfunction
+
+" Tlist_Menu_Refresh
+" Refresh the taglist menu
+function! s:Tlist_Menu_Refresh()
+    call s:Tlist_Log_Msg('Refreshing the tags menu')
+    let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
+    if fidx != -1
+        " Invalidate the cached menu command
+        let s:tlist_{fidx}_menu_cmd = ''
+    endif
+
+    " Update the taglist, menu and window
+    call s:Tlist_Update_Current_File()
+endfunction
+
+" Tlist_Menu_Jump_To_Tag
+" Jump to the selected tag
+function! s:Tlist_Menu_Jump_To_Tag(tidx)
+    let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
+    if fidx == -1
+        return
+    endif
+
+    let tagpat = s:Tlist_Get_Tag_SearchPat(fidx, a:tidx)
+    if tagpat == ''
+        return
+    endif
+
+    " Add the current cursor position to the jump list, so that user can
+    " jump back using the ' and ` marks.
+    mark '
+
+    silent call search(tagpat, 'w')
+
+    " Bring the line to the middle of the window
+    normal! z.
+
+    " If the line is inside a fold, open the fold
+    if foldclosed('.') != -1
+        .foldopen
+    endif
+endfunction
+
+" Tlist_Menu_Init
+" Initialize the taglist menu
+function! s:Tlist_Menu_Init()
+    call s:Tlist_Menu_Add_Base_Menu()
+
+    " Automatically add the tags defined in the current file to the menu
+    augroup TagListMenuCmds
+        autocmd!
+
+        if !g:Tlist_Process_File_Always
+            autocmd BufEnter * call s:Tlist_Refresh()
+        endif
+        autocmd BufLeave * call s:Tlist_Menu_Remove_File()
+    augroup end
+
+    call s:Tlist_Menu_Update_File(0)
+endfunction
+
+" Tlist_Vim_Session_Load
+" Initialize the taglist window/buffer, which is created when loading
+" a Vim session file.
+function! s:Tlist_Vim_Session_Load()
+    call s:Tlist_Log_Msg('Tlist_Vim_Session_Load')
+
+    " Initialize the taglist window
+    call s:Tlist_Window_Init()
+
+    " Refresh the taglist window
+    call s:Tlist_Window_Refresh()
+endfunction
+
+" Tlist_Set_App
+" Set the name of the external plugin/application to which taglist
+" belongs.
+" Taglist plugin is part of another plugin like cream or winmanager.
+function! Tlist_Set_App(name)
+    if a:name == ""
+        return
+    endif
+
+    let s:tlist_app_name = a:name
+endfunction
+
+" Winmanager integration
+
+" Initialization required for integration with winmanager
+function! TagList_Start()
+    " If current buffer is not taglist buffer, then don't proceed
+    if bufname('%') != '__Tag_List__'
+        return
+    endif
+
+    call Tlist_Set_App('winmanager')
+
+    " Get the current filename from the winmanager plugin
+    let bufnum = WinManagerGetLastEditedFile()
+    if bufnum != -1
+        let filename = fnamemodify(bufname(bufnum), ':p')
+        let ftype = s:Tlist_Get_Buffer_Filetype(bufnum)
+    endif
+
+    " Initialize the taglist window, if it is not already initialized
+    if !exists('s:tlist_window_initialized') || !s:tlist_window_initialized
+        call s:Tlist_Window_Init()
+        call s:Tlist_Window_Refresh()
+        let s:tlist_window_initialized = 1
+    endif
+
+    " Update the taglist window
+    if bufnum != -1
+        if !s:Tlist_Skip_File(filename, ftype) && g:Tlist_Auto_Update
+            call s:Tlist_Window_Refresh_File(filename, ftype)
+        endif
+    endif
+endfunction
+
+function! TagList_IsValid()
+    return 0
+endfunction
+
+function! TagList_WrapUp()
+    return 0
+endfunction
+
+" restore 'cpo'
+let &cpo = s:cpo_save
+unlet s:cpo_save
+
diff --git a/vimrc/.vim/plugin/view.vim b/vimrc/.vim/plugin/view.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/view.vim
@@ -0,0 +1,41 @@
+" set statusline=[%n]\ %f%m%r%h\ \|\ \ pwd:\ %{CurDir()}\ \ \|%=\|\ %l,%c\ %p%%\ \|\ ascii=%b,hex=%b%{((&fenc==\"\")?\"\":\"\ \|\ \".&fenc)}\ \|\ %{$USER}\ @\ %{hostname()}\
+"set statusline=[%n]\%f%m%r%h
+set statusline=%r%h
+set statusline +=\ %.55F            "full path
+set statusline +=\ %{WordCount()}\ words,
+set statusline +=%=        " Switch to the right side
+set statusline +=\ %{strftime('%m/%d/%y\ %H:%M:%S',getftime(expand('%')))} " file last modified time
+set statusline +=\ %l             "current line
+set statusline +=/%L               "total lines
+set statusline +=\ %v             "virtual column number
+set statusline +=\ %f
+set statusline +=\ %m                "modified flag
+"set statusline +=%1*\ %n\ %*            "buffer number
+"set statusline +=%5*%{&ff}%*            "file format
+"set statusline +=%3*%y%*                "file type
+"set statusline +=%2*0x%04B\ %*          "character under cursor
+" Split previously opened file ('#') in a split window
+set laststatus=2 "black status line at bottom of window
+if has("win32")
+    set statusline+=\ %<%f%h%m%r%=%{strftime(\"%I:%M:%S\ \%p,\ %a\ %b\ %d,\ %Y\")}\ %{&ff}\ %l,%c%V\ %P
+else
+    set statusline+=\%{strftime(\"%m/%d/%y\ %H:%M:%S\")}
+endif
+syn match ipaddr /\(\(25\_[0-5]\|2\_[0-4]\_[0-9]\|\_[01]\?\_[0-9]\_[0-9]\?\)\.\)\{3\}\(25\_[0-5]\|2\_[0-4]\_[0-9]\|\_[01]\?\_[0-9]\_[0-9]\?\)/
+hi link ipaddr Identifier
+set completeopt-=preview
+syntax enable
+set background=dark
+set cursorline
+"highlight cursorline cterm=NONE ctermbg=darkred ctermfg=NONE
+"set cursorcolumn
+"highlight cursorcolumn cterm=NONE ctermbg=darkred ctermfg=white
+
+if &diff
+    set winwidth=1
+else
+    set winwidth=999999
+endif
+
+set wrap
+"set iskeyword-=_
diff --git a/vimrc/.vim/plugin/vsearch.vim b/vimrc/.vim/plugin/vsearch.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/vsearch.vim
@@ -0,0 +1,38 @@
+" Search for selected text.
+" http://vim.wikia.com/wiki/VimTip171
+let s:save_cpo = &cpo | set cpo&vim
+if !exists('g:VeryLiteral')
+  let g:VeryLiteral = 0
+endif
+
+function! s:VSetSearch(cmd)
+  let old_reg = getreg('"')
+  let old_regtype = getregtype('"')
+  normal! gvy
+  if @@ =~? '^[0-9a-z,_]*$' || @@ =~? '^[0-9a-z ,_]*$' && g:VeryLiteral
+    let @/ = @@
+  else
+    let pat = escape(@@, a:cmd . '\')
+    if g:VeryLiteral
+      let pat = substitute(pat, '\n', '\\n', 'g')
+    else
+      let pat = substitute(pat, '^\_s\+', '\\s\\+', '')
+      let pat = substitute(pat, '\_s\+$', '\\s\\*', '')
+      let pat = substitute(pat, '\_s\+', '\\_s\\+', 'g')
+    endif
+    let @/ = '\V' . pat
+  endif
+  normal! gV
+  call setreg('"', old_reg, old_regtype)
+endfunction
+
+vnoremap <silent> * :<C-U>call <SID>VSetSearch('/')<CR>
+vnoremap <silent> # :<C-U>call <SID>VSetSearch('?')<CR>
+vmap <kMultiply> *
+
+nmap <silent> <Plug>VLToggle :let g:VeryLiteral = !g:VeryLiteral
+  \\| echo "VeryLiteral " . (g:VeryLiteral ? "On" : "Off")<CR>
+if !hasmapto("<Plug>VLToggle")
+  nmap <unique> <Leader>vl <Plug>VLToggle
+endif
+let &cpo = s:save_cpo | unlet s:save_cpo
diff --git a/vimrc/.vim/plugin/windo.vim b/vimrc/.vim/plugin/windo.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/plugin/windo.vim
@@ -0,0 +1,18 @@
+" Just like windo, but restore the current window when done.
+function! WinDo(command)
+  let currwin=winnr()
+  execute 'windo ' . a:command
+  execute currwin . 'wincmd w'
+endfunction
+com! -nargs=+ -complete=command Windo call WinDo(<q-args>)
+
+" Just like Windo, but disable all autocommands for super fast processing.
+com! -nargs=+ -complete=command Windofast noautocmd call WinDo(<q-args>)
+
+" Just like bufdo, but restore the current buffer when done.
+function! BufDo(command)
+  let currBuff=bufnr("%")
+  execute 'bufdo ' . a:command
+  execute 'buffer ' . currBuff
+endfunction
+com! -nargs=+ -complete=command Bufdo call BufDo(<q-args>)
diff --git a/vimrc/.vim/plugin/work.vim b/vimrc/.vim/plugin/work.vim
new file mode 100644
diff --git a/vimrc/.vim/spell/en.utf-8.add b/vimrc/.vim/spell/en.utf-8.add
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/spell/en.utf-8.add
@@ -0,0 +1,39 @@
+Rovi
+dev
+ASD
+adaptee
+jdk
+opossed
+Adpatee
+PHP
+subclassed
+USCIS
+H1B
+F1
+CPT
+pdf
+nonimmigrant
+JDBC
+mysql
+API
+ReusablePool
+ConcreteMediator
+ConcreteColleague
+multidirectional
+BST
+TutorGroup
+trackpad
+refactor
+SVC
+BJ
+mediaroom
+vim
+IDE
+equiped
+virtualized
+techie
+etc
+Hainan
+Haikou
+Nginx
+json
diff --git a/vimrc/.vim/syntax/cql.vim b/vimrc/.vim/syntax/cql.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/syntax/cql.vim
@@ -0,0 +1,130 @@
+" Vim syntax file
+" Language:     cql
+" Maintainer:   Eric Lubow <eric@lubow.org
+" Filenames:    *.cql
+" URL:          https://github.com/elubow/cql-vim
+" Note:
+
+if version < 600
+  syntax clear
+elseif exists("b:current_syntax")
+  finish
+endif
+
+" Always ignore case
+syn case ignore
+
+" General keywords which don't fall into other categories
+syn keyword cqlKeyword         apply and batch
+syn keyword cqlKeyword         column columnfamily create delete drop
+syn keyword cqlKeyword         family first from
+syn keyword cqlKeyword         in index insert into
+syn keyword cqlKeyword         limit key keyspace
+syn keyword cqlKeyword         on or primary reversed
+syn keyword cqlKeyword         select set truncate
+syn keyword cqlKeyword         where with update use using values
+syn keyword cqlKeyword         asc desc
+
+" CQL 3 additions
+syn keyword cqlKeyword         table order by type if exists not frozen
+
+
+" Column family/table options
+syn keyword cqlKeyword          comparator key_cache_size row_cache_size read_repair_chance
+syn keyword cqlKeyword          gc_grace_seconds default_validation min_compaction_threshold
+syn keyword cqlKeyword          max_compaction_threshold row_cache_save_period_in_seconds
+syn keyword cqlKeyword          key_cache_save_period_in_seconds memtable_flush_after_mins
+syn keyword cqlKeyword          memtable_throughput_in_mb memtable_operations_in_millions replication_on_write
+syn keyword cqlKeyword          replication_on_write default_validation_class key_validation_class
+syn keyword cqlKeyword          rows_cached row_cache_save_period row_cache_keys_to_save keys_cached
+syn keyword cqlKeyword          column_type key_cache_save_period gc_grace replicate_on_write
+syn keyword cqlKeyword          row_cache_provider compaction_strategy column_metadata
+syn keyword cqlKeyword          column_name validation_class subcomparator replication
+syn keyword cqlKeyword          index_name index_type caching dclocal_read_repair_chance
+syn keyword cqlKeyword          bloom_filter_fp_chance populate_io_cache_on_flush compaction
+syn keyword cqlKeyword          compression class sstable_compression
+
+" CQL 3 additions
+syn keyword cqlKeyword          clustering
+
+" Keyspace options
+syn keyword cqlKeyword          placement_strategy strategy_options durable_writes replication_factor
+syn keyword cqlKeyword          strategy_class
+
+" Hadoop keywords
+syn keyword cqlKeyword          currentJobTracker
+
+
+" TODO Fix to use regions properly
+syn keyword cqlColType          standard super
+syn region cqlColumnType        start="column_type\W" end="\"'" contains=cqlColType
+
+" TODO Fix to use regions properly
+syn keyword cqlPStrategy        simplestrategy localstrategy networktopologystrategy
+syn region cqlPlacementStrategy start="placement_strategy\W" end="\"'" contains=cqlPlaceStrategy
+
+" Comments highlight the word as a keyword and comment as blue
+syn region cqlKeyword start=/comment\s*=\s*'/ end=/'/ contains=cqlComment
+syn region cqlKeyword start=/comment\s*=\s*"/ end=/"/ contains=cqlComment
+syn region cqlComment start="/\*" end="\*/" contains=cqlComment
+syn match cqlComment /'\zs\%(\\.\|[^\\']\)*\ze'/ contained
+syn match cqlComment /"\zs\%(\\.\|[^\\"]\)*\ze"/ contained
+syn match cqlComment "--.*$" contains=cqlComment
+syn match cqlComment "//.*$" contains=cqlComment
+syn match cqlComment "/\*\*/"
+
+" Special values
+syn keyword cqlSpecial         false null true
+
+" TODO Add ability to include entire Java class name for compaction strategies
+syn keyword cqlType            SizeTieredCompactionStrategy LeveledCompactionStrategy
+
+" Variable Types
+syn keyword cqlType     bytea ascii text varchar uuid inet varint int bigint tinyint smallint
+syn keyword cqlType     bytestype utf8type timeuuidtype timeuuid timestamp date time duration
+syn keyword cqlType     blob boolean counter decimal double float
+syn keyword cqlType     serializingcacheprovider
+syn keyword cqlType     set list map tuple
+
+" Consistency Levels
+syn region cqlType      start="consistency" end="zero"
+syn region cqlType      start="consistency" end="one"
+syn region cqlType      start="consistency" end="quorum"
+syn region cqlType      start="consistency" end="all"
+syn region cqlType      start="consistency" end="local_quorum"
+syn region cqlType      start="consistency" end="each_quorum"
+
+" Numbers and hexidecimal values
+syn match cqlNumber            "-\=\<[0-9]*\>"
+syn match cqlNumber            "-\=\<[0-9]*\.[0-9]*\>"
+syn match cqlNumber            "-\=\<[0-9][0-9]*e[+-]\=[0-9]*\>"
+syn match cqlNumber            "-\=\<[0-9]*\.[0-9]*e[+-]\=[0-9]*\>"
+syn match cqlNumber            "\<0x[abcdefABCDEF0-9]*\>"
+
+" Define the default highlighting.
+" For version 5.7 and earlier: only when not done already
+" For version 5.8 and later: only when an item doesn't have highlighting yet
+if version >= 508 || !exists("did_cql_syn_inits")
+  if version < 508
+    let did_cql_syn_inits = 1
+    command -nargs=+ HiLink hi link <args>
+  else
+    command -nargs=+ HiLink hi def link <args>
+  endif
+
+  HiLink cqlKeyword            Statement
+  HiLink cqlSpecial            Special
+  HiLink cqlString             String
+  HiLink cqlNumber             Number
+  HiLink cqlVariable           Identifier
+  HiLink cqlComment            Comment
+  HiLink cqlType               Type
+  HiLink cqlOperator           Statement
+  HiLink cqlConsistency        Statement
+  HiLink cqlColType            Type
+  HiLink cqlPStrategy          Type
+
+  delcommand HiLink
+endif
+
+let b:current_syntax = "cql"
diff --git a/vimrc/.vim/syntax/json.vim b/vimrc/.vim/syntax/json.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/syntax/json.vim
@@ -0,0 +1,133 @@
+" Vim syntax file
+" Language:	JSON
+" Maintainer:	Eli Parra <eli@elzr.com> https://github.com/elzr/vim-json
+" Last Change:	2014-08-24 HiLink to hi def link
+
+if !exists("main_syntax")
+  if version < 600
+    syntax clear
+  elseif exists("b:current_syntax")
+    finish
+  endif
+  let main_syntax = 'json'
+endif
+
+syntax match   jsonNoise           /\%(:\|,\)/
+
+" NOTE that for the concealing to work your conceallevel should be set to 2
+
+" Syntax: Strings
+" Separated into a match and region because a region by itself is always greedy
+syn match  jsonStringMatch /"\([^"]\|\\\"\)\+"\ze[[:blank:]\r\n]*[,}\]]/ contains=jsonString
+if has('conceal')
+	syn region  jsonString oneline matchgroup=jsonQuote start=/"/  skip=/\\\\\|\\"/  end=/"/ concealends contains=jsonEscape contained
+else
+	syn region  jsonString oneline matchgroup=jsonQuote start=/"/  skip=/\\\\\|\\"/  end=/"/ contains=jsonEscape contained
+endif
+
+" Syntax: JSON does not allow strings with single quotes, unlike JavaScript.
+syn region  jsonStringSQError oneline  start=+'+  skip=+\\\\\|\\"+  end=+'+
+
+" Syntax: JSON Keywords
+" Separated into a match and region because a region by itself is always greedy
+syn match  jsonKeywordMatch /"\([^"]\|\\\"\)\+"[[:blank:]\r\n]*\:/ contains=jsonKeyword
+if has('conceal')
+   syn region  jsonKeyword matchgroup=jsonQuote start=/"/  end=/"\ze[[:blank:]\r\n]*\:/ concealends contained
+else
+   syn region  jsonKeyword matchgroup=jsonQuote start=/"/  end=/"\ze[[:blank:]\r\n]*\:/ contained
+endif
+
+" Syntax: Escape sequences
+syn match   jsonEscape    "\\["\\/bfnrt]" contained
+syn match   jsonEscape    "\\u\x\{4}" contained
+
+" Syntax: Numbers
+syn match   jsonNumber    "-\=\<\%(0\|[1-9]\d*\)\%(\.\d\+\)\=\%([eE][-+]\=\d\+\)\=\>\ze[[:blank:]\r\n]*[,}\]]"
+
+" ERROR WARNINGS **********************************************
+if (!exists("g:vim_json_warnings") || g:vim_json_warnings==1)
+	" Syntax: Strings should always be enclosed with quotes.
+	syn match   jsonNoQuotesError  "\<[[:alpha:]][[:alnum:]]*\>"
+	syn match   jsonTripleQuotesError  /"""/
+
+	" Syntax: An integer part of 0 followed by other digits is not allowed.
+	syn match   jsonNumError  "-\=\<0\d\.\d*\>"
+
+	" Syntax: Decimals smaller than one should begin with 0 (so .1 should be 0.1).
+	syn match   jsonNumError  "\:\@<=[[:blank:]\r\n]*\zs\.\d\+"
+
+	" Syntax: No comments in JSON, see http://stackoverflow.com/questions/244777/can-i-comment-a-json-file
+	syn match   jsonCommentError  "//.*"
+	syn match   jsonCommentError  "\(/\*\)\|\(\*/\)"
+
+	" Syntax: No semicolons in JSON
+	syn match   jsonSemicolonError  ";"
+
+	" Syntax: No trailing comma after the last element of arrays or objects
+	syn match   jsonTrailingCommaError  ",\_s*[}\]]"
+
+	" Syntax: Watch out for missing commas between elements
+	syn match   jsonMissingCommaError /\("\|\]\|\d\)\zs\_s\+\ze"/
+	syn match   jsonMissingCommaError /\(\]\|\}\)\_s\+\ze"/ "arrays/objects as values
+	syn match   jsonMissingCommaError /}\_s\+\ze{/ "objects as elements in an array
+	syn match   jsonMissingCommaError /\(true\|false\)\_s\+\ze"/ "true/false as value
+endif
+
+" ********************************************** END OF ERROR WARNINGS
+" Allowances for JSONP: function call at the beginning of the file,
+" parenthesis and semicolon at the end.
+" Function name validation based on
+" http://stackoverflow.com/questions/2008279/validate-a-javascript-function-name/2008444#2008444
+syn match  jsonPadding "\%^[[:blank:]\r\n]*[_$[:alpha:]][_$[:alnum:]]*[[:blank:]\r\n]*("
+syn match  jsonPadding ");[[:blank:]\r\n]*\%$"
+
+" Syntax: Boolean
+syn match  jsonBoolean /\(true\|false\)\(\_s\+\ze"\)\@!/
+
+" Syntax: Null
+syn keyword  jsonNull      null
+
+" Syntax: Braces
+syn region  jsonFold matchgroup=jsonBraces start="{" end=/}\(\_s\+\ze\("\|{\)\)\@!/ transparent fold
+syn region  jsonFold matchgroup=jsonBraces start="\[" end=/]\(\_s\+\ze"\)\@!/ transparent fold
+
+" Define the default highlighting.
+if version >= 508 || !exists("did_json_syn_inits")
+  hi def link jsonPadding		Operator
+  hi def link jsonString		String
+  hi def link jsonTest			Label
+  hi def link jsonEscape		Special
+  hi def link jsonNumber		Number
+  hi def link jsonBraces		Delimiter
+  hi def link jsonNull			Function
+  hi def link jsonBoolean		Boolean
+  hi def link jsonKeyword		Label
+
+	if (!exists("g:vim_json_warnings") || g:vim_json_warnings==1)
+		hi def link jsonNumError					Error
+		hi def link jsonCommentError				Error
+		hi def link jsonSemicolonError			Error
+		hi def link jsonTrailingCommaError		Error
+		hi def link jsonMissingCommaError		Error
+		hi def link jsonStringSQError				Error
+		hi def link jsonNoQuotesError				Error
+		hi def link jsonTripleQuotesError		Error
+  endif
+  hi def link jsonQuote			Quote
+  hi def link jsonNoise			Noise
+endif
+
+let b:current_syntax = "json"
+if main_syntax == 'json'
+  unlet main_syntax
+endif
+
+" Vim settings
+" vim: ts=8 fdm=marker
+
+" MIT License
+" Copyright (c) 2013, Jeroen Ruigrok van der Werven, Eli Parra
+"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+"THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+"See https://twitter.com/elzr/status/294964017926119424
diff --git a/vimrc/.vim/taglist-plus.vim b/vimrc/.vim/taglist-plus.vim
new file mode 100644
--- /dev/null
+++ ./vimrc/.vim/taglist-plus.vim
@@ -0,0 +1,4620 @@
+" File: taglist-plus.vim
+" Authors: Jezreel Ng (jezreel AT gmail DOT com)
+"          Yegappan Lakshmanan (yegappan AT yahoo DOT com)
+" Version: 1.0
+ "Last Modified: March 16, 2011
+ "Copyright: Copyright (C) 2011 Jezeel Ng
+"            Copyright (C) 2002-2007 Yegappan Lakshmanan
+"            Permission is hereby granted to use and distribute this code,
+"            with or without modifications, provided that this copyright
+"            notice is copied with it. Like anything else that's free,
+"            taglist.vim is provided *as is* and comes with no warranty of any
+"            kind, either expressed or implied. In no event will the copyright
+"            holder be liable for any damamges resulting from the use of this
+"            software.
+"
+" For more information about using this plugin, after installing the
+" taglist plugin, use the ":help taglist" command.
+"
+" Installation
+" ------------
+" 1. Download the taglist.zip file and unzip the files to the $HOME/.vim
+"    or the $HOME/vimfiles or the $VIM/vimfiles directory. This should
+"    unzip the following two files (the directory structure should be
+"    preserved):
+"
+"       plugin/taglist-plus.vim - main taglist plugin file
+"       doc/taglist-plus.txt    - documentation (help) file
+"
+"    Refer to the 'add-plugin', 'add-global-plugin' and 'runtimepath'
+"    Vim help pages for more details about installing Vim plugins.
+" 2. Change to the $HOME/.vim/doc or $HOME/vimfiles/doc or
+"    $VIM/vimfiles/doc directory, start Vim and run the ":helptags ."
+"    command to process the taglist help file.
+" 3. If the exuberant ctags utility is not present in your PATH, then set the
+"    Tlist_Ctags_Cmd variable to point to the location of the exuberant ctags
+"    utility (not to the directory) in the .vimrc file.
+" 4. If you are running a terminal/console version of Vim and the
+"    terminal doesn't support changing the window width then set the
+"    'Tlist_Inc_Winwidth' variable to 0 in the .vimrc file.
+" 5. Restart Vim.
+" 6. You can now use the ":TlistToggle" command to open/close the taglist
+"    window. You can use the ":help taglist" command to get more
+"    information about using the taglist plugin.
+"
+" ****************** Do not modify after this line ************************
+
+" Line continuation used here
+let s:cpo_save = &cpo
+set cpo&vim
+
+if !exists('loaded_taglist')
+    " First time loading the taglist plugin
+    "
+    " To speed up the loading of Vim, the taglist plugin uses autoload
+    " mechanism to load the taglist functions.
+    " Only define the configuration variables, user commands and some
+    " auto-commands and finish sourcing the file
+
+    " The taglist plugin requires the built-in Vim system() function. If this
+    " function is not available, then don't load the plugin.
+    if !exists('*system')
+        echomsg 'Taglist: Vim system() built-in function is not available. ' .
+                    \ 'Plugin is not loaded.'
+        let loaded_taglist = 'no'
+        let &cpo = s:cpo_save
+        finish
+    endif
+
+    " Location of the exuberant ctags tool
+    if !exists('Tlist_Ctags_Cmd')
+        if executable('exuberant-ctags')
+            " On Debian Linux, exuberant ctags is installed
+            " as exuberant-ctags
+            let Tlist_Ctags_Cmd = 'exuberant-ctags'
+        elseif executable('exctags')
+            " On Free-BSD, exuberant ctags is installed as exctags
+            let Tlist_Ctags_Cmd = 'exctags'
+        elseif executable('ctags')
+            let Tlist_Ctags_Cmd = 'ctags'
+        elseif executable('ctags.exe')
+            let Tlist_Ctags_Cmd = 'ctags.exe'
+        elseif executable('tags')
+            let Tlist_Ctags_Cmd = 'tags'
+        else
+            echomsg 'Taglist: Exuberant ctags (http://ctags.sf.net) ' .
+                        \ 'not found in PATH. Plugin is not loaded.'
+            " Skip loading the plugin
+            let loaded_taglist = 'no'
+            let &cpo = s:cpo_save
+            finish
+        endif
+    endif
+
+
+    " Automatically open the taglist window on Vim startup
+    if !exists('Tlist_Auto_Open')
+        let Tlist_Auto_Open = 0
+    endif
+
+    " When the taglist window is toggle opened, move the cursor to the
+    " taglist window
+    if !exists('Tlist_GainFocus_On_ToggleOpen')
+        let Tlist_GainFocus_On_ToggleOpen = 0
+    endif
+
+    " Process files even when the taglist window is not open
+    if !exists('Tlist_Process_File_Always')
+        let Tlist_Process_File_Always = 0
+    endif
+
+    if !exists('Tlist_Show_Menu')
+        let Tlist_Show_Menu = 0
+    endif
+
+    " Tag listing sort type - 'name' or 'order'
+    if !exists('Tlist_Sort_Type')
+        let Tlist_Sort_Type = 'order'
+    endif
+
+    " Tag listing window split (horizontal/vertical) control
+    if !exists('Tlist_Use_Horiz_Window')
+        let Tlist_Use_Horiz_Window = 0
+    endif
+
+    " Open the vertically split taglist window on the left or on the right
+    " side.  This setting is relevant only if Tlist_Use_Horiz_Window is set to
+    " zero (i.e.  only for vertically split windows)
+    if !exists('Tlist_Use_Right_Window')
+        let Tlist_Use_Right_Window = 0
+    endif
+
+    " Increase Vim window width to display vertically split taglist window.
+    " For MS-Windows version of Vim running in a MS-DOS window, this must be
+    " set to 0 otherwise the system may hang due to a Vim limitation.
+    if !exists('Tlist_Inc_Winwidth')
+        if (has('win16') || has('win95')) && !has('gui_running')
+            let Tlist_Inc_Winwidth = 0
+        else
+            let Tlist_Inc_Winwidth = 1
+        endif
+    endif
+
+    " Vertically split taglist window width setting
+    if !exists('Tlist_WinWidth')
+        let Tlist_WinWidth = 30
+        let s:auto_width = 0
+    elseif Tlist_WinWidth == 'auto'
+        let Tlist_WinWidth = 30
+        let s:auto_width = 1
+    endif
+
+    " Horizontally split taglist window height setting
+    if !exists('Tlist_WinHeight')
+        let Tlist_WinHeight = 10
+    endif
+
+    " Display tag prototypes or tag names in the taglist window
+    if !exists('Tlist_Display_Prototype')
+        let Tlist_Display_Prototype = 0
+    endif
+
+    " Display tag scopes in the taglist window
+    if !exists('Tlist_Display_Tag_Scope')
+        let Tlist_Display_Tag_Scope = 1
+    endif
+
+    " Use single left mouse click to jump to a tag. By default this is disabled.
+    " Only double click using the mouse will be processed.
+    if !exists('Tlist_Use_SingleClick')
+        let Tlist_Use_SingleClick = 0
+    endif
+
+    " Control whether additional help is displayed as part of the taglist or
+    " not.  Also, controls whether empty lines are used to separate the tag
+    " tree.
+    if !exists('Tlist_Compact_Format')
+        let Tlist_Compact_Format = 0
+    endif
+
+    " Exit Vim if only the taglist window is currently open. By default, this is
+    " set to zero.
+    if !exists('Tlist_Exit_OnlyWindow')
+        let Tlist_Exit_OnlyWindow = 0
+    endif
+
+    " Automatically close the folds for the non-active files in the taglist
+    " window
+    if !exists('Tlist_File_Fold_Auto_Close')
+        let Tlist_File_Fold_Auto_Close = 0
+    endif
+
+    " Close the taglist window when a tag is selected
+    if !exists('Tlist_Close_On_Select')
+        let Tlist_Close_On_Select = 0
+    endif
+
+    " Automatically update the taglist window to display tags for newly
+    " edited files
+    if !exists('Tlist_Auto_Update')
+        let Tlist_Auto_Update = 1
+    endif
+
+    " Automatically highlight the current tag
+    if !exists('Tlist_Auto_Highlight_Tag')
+        let Tlist_Auto_Highlight_Tag = 1
+    endif
+    
+    " Automatically highlight the current tag on entering a buffer
+    if !exists('Tlist_Highlight_Tag_On_BufEnter')
+        let Tlist_Highlight_Tag_On_BufEnter = 1
+    endif
+
+    " Enable fold column to display the folding for the tag tree
+    if !exists('Tlist_Enable_Fold_Column')
+        let Tlist_Enable_Fold_Column = 1
+    endif
+
+    " Display the tags for only one file in the taglist window
+    if !exists('Tlist_Show_One_File')
+        let Tlist_Show_One_File = 0
+    endif
+
+    if !exists('Tlist_Max_Submenu_Items')
+        let Tlist_Max_Submenu_Items = 20
+    endif
+
+    if !exists('Tlist_Max_Tag_Length')
+        let Tlist_Max_Tag_Length = 10
+    endif
+
+    " Do not change the name of the taglist title variable. The winmanager
+    " plugin relies on this name to determine the title for the taglist
+    " plugin.
+    let TagList_title = "__Tag_List__"
+
+    " Taglist debug messages
+    let s:tlist_msg = ''
+
+    " Define the taglist autocommand to automatically open the taglist window
+    " on Vim startup
+    if g:Tlist_Auto_Open
+        autocmd VimEnter * nested call s:Tlist_Window_Check_Auto_Open()
+    endif
+
+    " Refresh the taglist
+    if g:Tlist_Process_File_Always
+        autocmd BufEnter * call s:Tlist_Refresh()
+    endif
+
+    if g:Tlist_Show_Menu
+        autocmd GUIEnter * call s:Tlist_Menu_Init()
+    endif
+
+    " When the taglist buffer is created when loading a Vim session file,
+    " the taglist buffer needs to be initialized. The BufFilePost event
+    " is used to handle this case.
+    autocmd BufFilePost __Tag_List__ call s:Tlist_Vim_Session_Load()
+
+    " Define the user commands to manage the taglist window
+    command! -nargs=0 -bar TlistToggle call s:Tlist_Window_Toggle()
+    command! -nargs=0 -bar TlistOpen call s:Tlist_Window_Open()
+    " For backwards compatiblity define the Tlist command
+    command! -nargs=0 -bar Tlist TlistToggle
+    command! -nargs=+ -complete=file TlistAddFiles
+                \  call s:Tlist_Add_Files(<f-args>)
+    command! -nargs=+ -complete=dir TlistAddFilesRecursive
+                \ call s:Tlist_Add_Files_Recursive(<f-args>)
+    command! -nargs=0 -bar TlistClose call s:Tlist_Window_Close()
+    command! -nargs=0 -bar TlistUpdate call s:Tlist_Update_Current_File()
+    command! -nargs=0 -bar TlistHighlightTag call s:Tlist_Window_Highlight_Tag(
+                        \ fnamemodify(bufname('%'), ':p'), line('.'), 2, 1)
+    " For backwards compatiblity define the TlistSync command
+    command! -nargs=0 -bar TlistSync TlistHighlightTag
+    command! -nargs=* -complete=buffer TlistShowPrototype
+                \ echo Tlist_Get_Tag_Prototype_By_Line(<f-args>)
+    command! -nargs=* -complete=buffer TlistShowTag
+                \ echo Tlist_Get_Tagname_By_Line(<f-args>)
+    command! -nargs=* -complete=file TlistSessionLoad
+                \ call s:Tlist_Session_Load(<q-args>)
+    command! -nargs=* -complete=file TlistSessionSave
+                \ call s:Tlist_Session_Save(<q-args>)
+    command! -bar TlistLock let Tlist_Auto_Update=0
+    command! -bar TlistUnlock let Tlist_Auto_Update=1
+
+    " Commands for enabling/disabling debug and to display debug messages
+    command! -nargs=? -complete=file -bar TlistDebug
+                \ call s:Tlist_Debug_Enable(<q-args>)
+    command! -nargs=0 -bar TlistUndebug  call s:Tlist_Debug_Disable()
+    command! -nargs=0 -bar TlistMessages call s:Tlist_Debug_Show()
+
+    " Define autocommands to autoload the taglist plugin when needed.
+
+    " Trick to get the current script ID
+    map <SID>xx <SID>xx
+    let s:tlist_sid = substitute(maparg('<SID>xx'), '<SNR>\(\d\+_\)xx$',
+                                \ '\1', '')
+    unmap <SID>xx
+
+    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_Window_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_Menu_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+    exe 'autocmd FuncUndefined Tlist_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+    exe 'autocmd FuncUndefined TagList_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+
+    let loaded_taglist = 'fast_load_done'
+
+    if g:Tlist_Show_Menu && has('gui_running')
+        call s:Tlist_Menu_Init()
+    endif
+
+    " restore 'cpo'
+    let &cpo = s:cpo_save
+    finish
+endif
+
+if !exists('s:tlist_sid')
+    " Two or more versions of taglist plugin are installed. Don't
+    " load this version of the plugin.
+    finish
+endif
+
+unlet! s:tlist_sid
+
+if loaded_taglist != 'fast_load_done'
+    " restore 'cpo'
+    let &cpo = s:cpo_save
+    finish
+endif
+
+" Taglist plugin functionality is available
+let loaded_taglist = 'available'
+
+"------------------- end of user configurable options --------------------
+
+" Default language specific settings for supported file types and tag types
+"
+" Variable name format:
+"
+"       s:tlist_def_{vim_ftype}_settings
+" 
+" vim_ftype - Filetype detected by Vim
+"
+" Value format:
+"
+"       <ctags_ftype>;<flag>:<name>;<flag>:<name>;...
+"
+" ctags_ftype - File type supported by exuberant ctags
+" flag        - Flag supported by exuberant ctags to generate a tag type
+" name        - Name of the tag type used in the taglist window to display the
+"               tags of this type
+"
+
+" assembly language
+let s:tlist_def_asm_settings = 'asm;d:define;l:label;m:macro;t:type'
+
+" aspperl language
+let s:tlist_def_aspperl_settings = 'asp;f:function;s:sub;v:variable'
+
+" aspvbs language
+let s:tlist_def_aspvbs_settings = 'asp;f:function;s:sub;v:variable'
+
+" awk language
+let s:tlist_def_awk_settings = 'awk;f:function'
+
+" beta language
+let s:tlist_def_beta_settings = 'beta;f:fragment;s:slot;v:pattern'
+
+" c language
+let s:tlist_def_c_settings = 'c;d:macro;g:enum;s:struct;u:union;t:typedef;' .
+                           \ 'v:variable;f:function'
+
+" c++ language
+let s:tlist_def_cpp_settings = 'c++;n:namespace;v:variable;d:macro;t:typedef;' .
+                             \ 'c:class;g:enum;s:struct;u:union;f:function'
+
+" c# language
+let s:tlist_def_cs_settings = 'c#;d:macro;t:typedef;n:namespace;c:class;' .
+                             \ 'E:event;g:enum;s:struct;i:interface;' .
+                             \ 'p:properties;m:method'
+
+" cobol language
+let s:tlist_def_cobol_settings = 'cobol;d:data;f:file;g:group;p:paragraph;' .
+                               \ 'P:program;s:section'
+
+" eiffel language
+let s:tlist_def_eiffel_settings = 'eiffel;c:class;f:feature'
+
+" erlang language
+let s:tlist_def_erlang_settings = 'erlang;d:macro;r:record;m:module;f:function'
+
+" expect (same as tcl) language
+let s:tlist_def_expect_settings = 'tcl;c:class;f:method;p:procedure'
+
+" fortran language
+let s:tlist_def_fortran_settings = 'fortran;p:program;b:block data;' .
+                    \ 'c:common;e:entry;i:interface;k:type;l:label;m:module;' .
+                    \ 'n:namelist;t:derived;v:variable;f:function;s:subroutine'
+
+" HTML language
+let s:tlist_def_html_settings = 'html;a:anchor;f:javascript function'
+
+" java language
+let s:tlist_def_java_settings = 'java;p:package;c:class;i:interface;' .
+                              \ 'f:field;m:method'
+
+" javascript language
+let s:tlist_def_javascript_settings = 'javascript;f:function;v:variable'
+if !exists('Tlist_javascript_Ctags_Cmd') && executable('jsctags')
+    let Tlist_javascript_Ctags_Cmd = 'jsctags'
+endif
+let Tlist_javascript_Ctags_Allowed_Flags = ['-f', '--sort']
+
+" lisp language
+let s:tlist_def_lisp_settings = 'lisp;f:function'
+
+" lua language
+let s:tlist_def_lua_settings = 'lua;f:function'
+
+" makefiles
+let s:tlist_def_make_settings = 'make;m:macro'
+
+" pascal language
+let s:tlist_def_pascal_settings = 'pascal;f:function;p:procedure'
+
+" perl language
+let s:tlist_def_perl_settings = 'perl;c:constant;l:label;p:package;s:subroutine'
+
+" php language
+let s:tlist_def_php_settings = 'php;c:class;d:constant;v:variable;f:function'
+
+" python language
+let s:tlist_def_python_settings = 'python;c:class;m:member;f:function'
+
+" rexx language
+let s:tlist_def_rexx_settings = 'rexx;s:subroutine'
+
+" ruby language
+let s:tlist_def_ruby_settings = 'ruby;c:class;f:method;F:function;' .
+                              \ 'm:singleton method'
+
+" scheme language
+let s:tlist_def_scheme_settings = 'scheme;s:set;f:function'
+
+" shell language
+let s:tlist_def_sh_settings = 'sh;f:function'
+
+" C shell language
+let s:tlist_def_csh_settings = 'sh;f:function'
+
+" Z shell language
+let s:tlist_def_zsh_settings = 'sh;f:function'
+
+" slang language
+let s:tlist_def_slang_settings = 'slang;n:namespace;f:function'
+
+" sml language
+let s:tlist_def_sml_settings = 'sml;e:exception;c:functor;s:signature;' .
+                             \ 'r:structure;t:type;v:value;f:function'
+
+" sql language
+let s:tlist_def_sql_settings = 'sql;c:cursor;F:field;P:package;r:record;' .
+            \ 's:subtype;t:table;T:trigger;v:variable;f:function;p:procedure'
+
+" tcl language
+let s:tlist_def_tcl_settings = 'tcl;c:class;f:method;m:method;p:procedure'
+
+" vera language
+let s:tlist_def_vera_settings = 'vera;c:class;d:macro;e:enumerator;' .
+                                \ 'f:function;g:enum;m:member;p:program;' .
+                                \ 'P:prototype;t:task;T:typedef;v:variable;' .
+                                \ 'x:externvar'
+
+"verilog language
+let s:tlist_def_verilog_settings = 'verilog;m:module;c:constant;P:parameter;' .
+            \ 'e:event;r:register;t:task;w:write;p:port;v:variable;f:function'
+
+" vim language
+let s:tlist_def_vim_settings = 'vim;a:autocmds;v:variable;f:function'
+
+" yacc language
+let s:tlist_def_yacc_settings = 'yacc;l:label'
+
+"------------------- end of language specific options --------------------
+
+" Vim window size is changed by the taglist plugin or not
+let s:tlist_winsize_chgd = -1
+" Taglist window is maximized or not
+let s:tlist_win_maximized = 0
+" Name of files in the taglist
+let s:tlist_file_names=''
+" Number of files in the taglist
+let s:tlist_file_count = 0
+" Number of filetypes supported by taglist
+let s:tlist_ftype_count = 0
+" Is taglist part of other plugins like winmanager or cream?
+let s:tlist_app_name = "none"
+" Are we displaying brief help text
+let s:tlist_brief_help = 1
+" List of files removed on user request
+let s:tlist_removed_flist = ""
+" Index of current file displayed in the taglist window
+let s:tlist_cur_file_idx = -1
+" Taglist menu is empty or not
+let s:tlist_menu_empty = 1
+
+" An autocommand is used to refresh the taglist window when entering any
+" buffer. We don't want to refresh the taglist window if we are entering the
+" file window from one of the taglist functions. The 'Tlist_Skip_Refresh'
+" variable is used to skip the refresh of the taglist window and is set
+" and cleared appropriately.
+let s:Tlist_Skip_Refresh = 0
+
+" Tlist_Window_Display_Help()
+function! s:Tlist_Window_Display_Help()
+    if s:tlist_app_name == "winmanager"
+        " To handle a bug in the winmanager plugin, add a space at the
+        " last line
+        call setline('$', ' ')
+    endif
+
+    if s:tlist_brief_help
+        " Add the brief help
+        call append(0, '" Press <F1> to display help text')
+    else
+        " Add the extensive help
+        call append(0, '" <enter> : Jump to tag definition')
+        call append(1, '" o : Jump to tag definition in new window')
+        call append(2, '" p : Preview the tag definition')
+        call append(3, '" <space> : Display tag prototype')
+        call append(4, '" u : Update tag list')
+        call append(5, '" s : Select sort field')
+        call append(6, '" d : Remove file from taglist')
+        call append(7, '" x : Zoom-out/Zoom-in taglist window')
+        call append(8, '" m : Toggle display of more tag info')
+        call append(9, '" + : Open a fold')
+        call append(10, '" - : Close a fold')
+        call append(11, '" * : Open all folds')
+        call append(12, '" = : Close all folds')
+        call append(13, '" [[ : Move to the start of previous file')
+        call append(14, '" ]] : Move to the start of next file')
+        call append(15, '" q : Close the taglist window')
+        call append(16, '" <F1> : Remove help text')
+    endif
+endfunction
+
+" Tlist_Window_Toggle_Help_Text()
+" Toggle taglist plugin help text between the full version and the brief
+" version
+function! s:Tlist_Window_Toggle_Help_Text()
+    if g:Tlist_Compact_Format
+        " In compact display mode, do not display help
+        return
+    endif
+
+    " Include the empty line displayed after the help text
+    let brief_help_size = 1
+    let full_help_size = 16
+
+    setlocal modifiable
+
+    " Set report option to a huge value to prevent informational messages
+    " while deleting the lines
+    let old_report = &report
+    set report=99999
+
+    " Remove the currently highlighted tag. Otherwise, the help text
+    " might be highlighted by mistake
+    match none
+
+    " Toggle between brief and full help text
+    if s:tlist_brief_help
+        let s:tlist_brief_help = 0
+
+        " Remove the previous help
+        exe '1,' . brief_help_size . ' delete _'
+
+        " Adjust the start/end line numbers for the files
+        call s:Tlist_Window_Update_Line_Offsets(0, 1, full_help_size - brief_help_size)
+    else
+        let s:tlist_brief_help = 1
+
+        " Remove the previous help
+        exe '1,' . full_help_size . ' delete _'
+
+        " Adjust the start/end line numbers for the files
+        call s:Tlist_Window_Update_Line_Offsets(0, 0, full_help_size - brief_help_size)
+    endif
+
+    call s:Tlist_Window_Display_Help()
+
+    " Restore the report option
+    let &report = old_report
+
+    setlocal nomodifiable
+endfunction
+
+" Taglist debug support
+let s:tlist_debug = 0
+
+" File for storing the debug messages
+let s:tlist_debug_file = ''
+
+" Tlist_Debug_Enable
+" Enable logging of taglist debug messages.
+function! s:Tlist_Debug_Enable(...)
+    let s:tlist_debug = 1
+
+    " Check whether a valid file name is supplied.
+    if a:1 != ''
+        let s:tlist_debug_file = fnamemodify(a:1, ':p')
+
+        " Empty the log file
+        exe 'redir! > ' . s:tlist_debug_file
+        redir END
+
+        " Check whether the log file is present/created
+        if !filewritable(s:tlist_debug_file)
+            call s:Tlist_Warning_Msg('Taglist: Unable to create log file '
+                        \ . s:tlist_debug_file)
+            let s:tlist_debug_file = ''
+        endif
+    endif
+endfunction
+
+" Tlist_Debug_Disable
+" Disable logging of taglist debug messages.
+function! s:Tlist_Debug_Disable(...)
+    let s:tlist_debug = 0
+    let s:tlist_debug_file = ''
+endfunction
+
+" Tlist_Debug_Show
+" Display the taglist debug messages in a new window
+function! s:Tlist_Debug_Show()
+    if s:tlist_msg == ''
+        call s:Tlist_Warning_Msg('Taglist: No debug messages')
+        return
+    endif
+
+    " Open a new window to display the taglist debug messages
+    new taglist_debug.txt
+    " Delete all the lines (if the buffer already exists)
+    silent! %delete _
+    " Add the messages
+    silent! put =s:tlist_msg
+    " Move the cursor to the first line
+    normal! gg
+endfunction
+
+" Tlist_Log_Msg
+" Log the supplied debug message along with the time
+function! s:Tlist_Log_Msg(msg)
+    if s:tlist_debug
+        if s:tlist_debug_file != ''
+            exe 'redir >> ' . s:tlist_debug_file
+            silent echon strftime('%H:%M:%S') . ': ' . a:msg . "\n"
+            redir END
+        else
+            " Log the message into a variable
+            " Retain only the last 3000 characters
+            let len = strlen(s:tlist_msg)
+            if len > 3000
+                let s:tlist_msg = strpart(s:tlist_msg, len - 3000)
+            endif
+            let s:tlist_msg = s:tlist_msg . strftime('%H:%M:%S') . ': ' . 
+                        \ a:msg . "\n"
+        endif
+    endif
+endfunction
+
+" Tlist_Warning_Msg()
+" Display a message using WarningMsg highlight group
+function! s:Tlist_Warning_Msg(msg)
+    echohl WarningMsg
+    echomsg a:msg
+    echohl None
+endfunction
+
+" Last returned file index for file name lookup.
+" Used to speed up file lookup
+let s:tlist_file_name_idx_cache = -1
+
+" Tlist_Get_File_Index()
+" Return the index of the specified filename
+function! s:Tlist_Get_File_Index(fname)
+    if s:tlist_file_count == 0 || a:fname == ''
+        return -1
+    endif
+
+    " If the new filename is same as the last accessed filename, then
+    " return that index
+    if s:tlist_file_name_idx_cache != -1 &&
+                \ s:tlist_file_name_idx_cache < s:tlist_file_count
+        if s:tlist_{s:tlist_file_name_idx_cache}_filename == a:fname
+            " Same as the last accessed file
+            return s:tlist_file_name_idx_cache
+        endif
+    endif
+
+    " First, check whether the filename is present
+    let s_fname = a:fname . "\n"
+    let i = stridx(s:tlist_file_names, s_fname)
+    if i == -1
+        let s:tlist_file_name_idx_cache = -1
+        return -1
+    endif
+
+    " Second, compute the file name index
+    let nl_txt = substitute(strpart(s:tlist_file_names, 0, i), "[^\n]", '', 'g')
+    let s:tlist_file_name_idx_cache = strlen(nl_txt)
+    return s:tlist_file_name_idx_cache
+endfunction
+
+" Last returned file index for line number lookup.
+" Used to speed up file lookup
+let s:tlist_file_lnum_idx_cache = -1
+
+" Tlist_Window_Get_File_Index_By_Linenum()
+" Return the index of the filename present in the specified line number
+" Line number refers to the line number in the taglist window
+function! s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
+    call s:Tlist_Log_Msg('Tlist_Window_Get_File_Index_By_Linenum (' . a:lnum . ')')
+
+    " First try to see whether the new line number is within the range
+    " of the last returned file
+    if s:tlist_file_lnum_idx_cache != -1 &&
+                \ s:tlist_file_lnum_idx_cache < s:tlist_file_count
+        if a:lnum >= s:tlist_{s:tlist_file_lnum_idx_cache}_start &&
+                    \ a:lnum <= s:tlist_{s:tlist_file_lnum_idx_cache}_end
+            return s:tlist_file_lnum_idx_cache
+        endif
+    endif
+
+    let fidx = -1
+
+    if g:Tlist_Show_One_File
+        " Displaying only one file in the taglist window. Check whether
+        " the line is within the tags displayed for that file
+        if s:tlist_cur_file_idx != -1
+            if a:lnum >= s:tlist_{s:tlist_cur_file_idx}_start
+                        \ && a:lnum <= s:tlist_{s:tlist_cur_file_idx}_end
+                let fidx = s:tlist_cur_file_idx
+            endif
+
+        endif
+    else
+        " Do a binary search in the taglist
+        let left = 0
+        let right = s:tlist_file_count - 1
+
+        while left < right
+            let mid = (left + right) / 2
+
+            if a:lnum >= s:tlist_{mid}_start && a:lnum <= s:tlist_{mid}_end
+                let s:tlist_file_lnum_idx_cache = mid
+                return mid
+            endif
+
+            if a:lnum < s:tlist_{mid}_start
+                let right = mid - 1
+            else
+                let left = mid + 1
+            endif
+        endwhile
+
+        if left >= 0 && left < s:tlist_file_count
+                    \ && a:lnum >= s:tlist_{left}_start
+                    \ && a:lnum <= s:tlist_{left}_end
+            let fidx = left
+        endif
+    endif
+
+    let s:tlist_file_lnum_idx_cache = fidx
+
+    return fidx
+endfunction
+
+" Tlist_Exe_Cmd_No_Acmds
+" Execute the specified Ex command after disabling autocommands
+function! s:Tlist_Exe_Cmd_No_Acmds(cmd)
+    let old_eventignore = &eventignore
+    set eventignore=all
+    exe a:cmd
+    let &eventignore = old_eventignore
+endfunction
+
+" Tlist_Skip_File()
+" Check whether tag listing is supported for the specified file
+function! s:Tlist_Skip_File(filename, ftype)
+    " Skip buffers with no names and buffers with filetype not set
+    if a:filename == '' || a:ftype == ''
+        return 1
+    endif
+
+    " Skip files which are not supported by exuberant ctags
+    " First check whether default settings for this filetype are available.
+    " If it is not available, then check whether user specified settings are
+    " available. If both are not available, then don't list the tags for this
+    " filetype
+    let var = 's:tlist_def_' . a:ftype . '_settings'
+    if !exists(var)
+        let var = 'g:tlist_' . a:ftype . '_settings'
+        if !exists(var)
+            return 1
+        endif
+    endif
+
+    " Skip files which are not readable or files which are not yet stored
+    " to the disk
+    if !filereadable(a:filename)
+        return 1
+    endif
+
+    return 0
+endfunction
+
+" Tlist_User_Removed_File
+" Returns 1 if a file is removed by a user from the taglist
+function! s:Tlist_User_Removed_File(filename)
+    return stridx(s:tlist_removed_flist, a:filename . "\n") != -1
+endfunction
+
+" Tlist_Update_Remove_List
+" Update the list of user removed files from the taglist
+" add == 1, add the file to the removed list
+" add == 0, delete the file from the removed list
+function! s:Tlist_Update_Remove_List(filename, add)
+    if a:add
+        let s:tlist_removed_flist = s:tlist_removed_flist . a:filename . "\n"
+    else
+        let idx = stridx(s:tlist_removed_flist, a:filename . "\n")
+        let text_before = strpart(s:tlist_removed_flist, 0, idx)
+        let rem_text = strpart(s:tlist_removed_flist, idx)
+        let next_idx = stridx(rem_text, "\n")
+        let text_after = strpart(rem_text, next_idx + 1)
+
+        let s:tlist_removed_flist = text_before . text_after
+    endif
+endfunction
+
+" Tlist_FileType_Init
+" Initialize the ctags arguments and tag variable for the specified
+" file type
+function! s:Tlist_FileType_Init(ftype)
+    call s:Tlist_Log_Msg('Tlist_FileType_Init (' . a:ftype . ')')
+    " If the user didn't specify any settings, then use the default
+    " ctags args. Otherwise, use the settings specified by the user
+    let var = 'g:tlist_' . a:ftype . '_settings'
+    if exists(var)
+        " User specified ctags arguments
+        let settings = {var} . ';'
+    else
+        " Default ctags arguments
+        let var = 's:tlist_def_' . a:ftype . '_settings'
+        if !exists(var)
+            " No default settings for this file type. This filetype is
+            " not supported
+            return 0
+        endif
+        let settings = s:tlist_def_{a:ftype}_settings . ';'
+    endif
+
+    let msg = 'Taglist: Invalid ctags option setting - ' . settings
+
+    " Format of the option that specifies the filetype and ctags arugments:
+    "
+    "       <language_name>;flag1:name1;flag2:name2;flag3:name3
+    "
+
+    " Extract the file type to pass to ctags. This may be different from the
+    " file type detected by Vim
+    let pos = stridx(settings, ';')
+    if pos == -1
+        call s:Tlist_Warning_Msg(msg)
+        return 0
+    endif
+    let ctags_ftype = strpart(settings, 0, pos)
+    if ctags_ftype == ''
+        call s:Tlist_Warning_Msg(msg)
+        return 0
+    endif
+    " Make sure a valid filetype is supplied. If the user didn't specify a
+    " valid filetype, then the ctags option settings may be treated as the
+    " filetype
+    if ctags_ftype =~ ':'
+        call s:Tlist_Warning_Msg(msg)
+        return 0
+    endif
+
+    " Remove the file type from settings
+    let settings = strpart(settings, pos + 1)
+    if settings == ''
+        call s:Tlist_Warning_Msg(msg)
+        return 0
+    endif
+
+    " Process all the specified ctags flags. The format is
+    " flag1:name1;flag2:name2;flag3:name3
+    let ctags_flags = ''
+    let cnt = 0
+    while settings != ''
+        " Extract the flag
+        let pos = stridx(settings, ':')
+        if pos == -1
+            call s:Tlist_Warning_Msg(msg)
+            return 0
+        endif
+        let flag = strpart(settings, 0, pos)
+        if flag == ''
+            call s:Tlist_Warning_Msg(msg)
+            return 0
+        endif
+        " Remove the flag from settings
+        let settings = strpart(settings, pos + 1)
+
+        " Extract the tag type name
+        let pos = stridx(settings, ';')
+        if pos == -1
+            call s:Tlist_Warning_Msg(msg)
+            return 0
+        endif
+        let name = strpart(settings, 0, pos)
+        if name == ''
+            call s:Tlist_Warning_Msg(msg)
+            return 0
+        endif
+        let settings = strpart(settings, pos + 1)
+
+        let cnt = cnt + 1
+
+        let s:tlist_{a:ftype}_{cnt}_name = flag
+        let s:tlist_{a:ftype}_{cnt}_fullname = name
+        let ctags_flags = ctags_flags . flag
+    endwhile
+
+    let s:tlist_{a:ftype}_ctags_args = { '--language-force=': ctags_ftype,
+                            \ '--'.ctags_ftype.'-types=': ctags_flags }
+    let s:tlist_{a:ftype}_count = cnt
+    let s:tlist_{a:ftype}_ctags_flags = ctags_flags
+
+    " Save the filetype name
+    let s:tlist_ftype_{s:tlist_ftype_count}_name = a:ftype
+    let s:tlist_ftype_count = s:tlist_ftype_count + 1
+
+    return 1
+endfunction
+
+" Tlist_Detect_Filetype
+" Determine the filetype for the specified file using the filetypedetect
+" autocmd.
+function! s:Tlist_Detect_Filetype(fname)
+    " Ignore the filetype autocommands
+    let old_eventignore = &eventignore
+    set eventignore=FileType
+
+    " Save the 'filetype', as this will be changed temporarily
+    let old_filetype = &filetype
+
+    " Run the filetypedetect group of autocommands to determine
+    " the filetype
+    exe 'doautocmd filetypedetect BufRead ' . a:fname
+
+    " Save the detected filetype
+    let ftype = &filetype
+
+    " Restore the previous state
+    let &filetype = old_filetype
+    let &eventignore = old_eventignore
+
+    return ftype
+endfunction
+
+" Tlist_Get_Buffer_Filetype
+" Get the filetype for the specified buffer
+function! s:Tlist_Get_Buffer_Filetype(bnum)
+    let buf_ft = getbufvar(a:bnum, '&filetype')
+
+    if bufloaded(a:bnum)
+        " For loaded buffers, the 'filetype' is already determined
+        return buf_ft
+    endif
+
+    " For unloaded buffers, if the 'filetype' option is set, return it
+    if buf_ft != ''
+        return buf_ft
+    endif
+
+    " Skip non-existent buffers
+    if !bufexists(a:bnum)
+        return ''
+    endif
+
+    " For buffers whose filetype is not yet determined, try to determine
+    " the filetype
+    let bname = bufname(a:bnum)
+
+    return s:Tlist_Detect_Filetype(bname)
+endfunction
+
+" Tlist_Discard_TagInfo
+" Discard the stored tag information for a file
+function! s:Tlist_Discard_TagInfo(fidx)
+    call s:Tlist_Log_Msg('Tlist_Discard_TagInfo (' .
+                \ s:tlist_{a:fidx}_filename . ')')
+    let ftype = s:tlist_{a:fidx}_filetype
+
+    " Discard information about the tags defined in the file
+    let i = 1
+    while i <= s:tlist_{a:fidx}_tag_count
+        let fidx_i = 's:tlist_' . a:fidx . '_' . i
+        unlet! {fidx_i}_tag
+        unlet! {fidx_i}_tag_name
+        unlet! {fidx_i}_tag_type
+        unlet! {fidx_i}_ttype_idx
+        unlet! {fidx_i}_tag_proto
+        unlet! {fidx_i}_tag_searchpat
+        unlet! {fidx_i}_tag_linenum
+        let i = i + 1
+    endwhile
+
+    let s:tlist_{a:fidx}_tag_count = 0
+
+    " Discard information about tag type groups
+    let i = 1
+    while i <= s:tlist_{ftype}_count
+        let ttype = s:tlist_{ftype}_{i}_name
+        if s:tlist_{a:fidx}_{ttype} != ''
+            let fidx_ttype = 's:tlist_' . a:fidx . '_' . ttype
+            let {fidx_ttype} = ''
+            let {fidx_ttype}_offset = 0
+            let cnt = {fidx_ttype}_count
+            let {fidx_ttype}_count = 0
+            let j = 1
+            while j <= cnt
+                unlet! {fidx_ttype}_{j}
+                let j = j + 1
+            endwhile
+        endif
+        let i = i + 1
+    endwhile
+
+    " Discard the stored menu command also
+    let s:tlist_{a:fidx}_menu_cmd = ''
+endfunction
+
+" Tlist_Window_Update_Line_Offsets
+" Update the line offsets for tags for files starting from start_idx
+" and displayed in the taglist window by the specified offset
+function! s:Tlist_Window_Update_Line_Offsets(start_idx, increment, offset)
+    let i = a:start_idx
+
+    while i < s:tlist_file_count
+        if s:tlist_{i}_visible
+            " Update the start/end line number only if the file is visible
+            if a:increment
+                let s:tlist_{i}_start = s:tlist_{i}_start + a:offset
+                let s:tlist_{i}_end = s:tlist_{i}_end + a:offset
+            else
+                let s:tlist_{i}_start = s:tlist_{i}_start - a:offset
+                let s:tlist_{i}_end = s:tlist_{i}_end - a:offset
+            endif
+        endif
+        let i = i + 1
+    endwhile
+endfunction
+
+" Tlist_Discard_FileInfo
+" Discard the stored information for a file
+function! s:Tlist_Discard_FileInfo(fidx)
+    call s:Tlist_Log_Msg('Tlist_Discard_FileInfo (' .
+                \ s:tlist_{a:fidx}_filename . ')')
+    call s:Tlist_Discard_TagInfo(a:fidx)
+
+    let ftype = s:tlist_{a:fidx}_filetype
+
+    let i = 1
+    while i <= s:tlist_{ftype}_count
+        let ttype = s:tlist_{ftype}_{i}_name
+        unlet! s:tlist_{a:fidx}_{ttype}
+        unlet! s:tlist_{a:fidx}_{ttype}_offset
+        unlet! s:tlist_{a:fidx}_{ttype}_count
+        let i = i + 1
+    endwhile
+
+    unlet! s:tlist_{a:fidx}_filename
+    unlet! s:tlist_{a:fidx}_sort_type
+    unlet! s:tlist_{a:fidx}_filetype
+    unlet! s:tlist_{a:fidx}_mtime
+    unlet! s:tlist_{a:fidx}_start
+    unlet! s:tlist_{a:fidx}_end
+    unlet! s:tlist_{a:fidx}_valid
+    unlet! s:tlist_{a:fidx}_visible
+    unlet! s:tlist_{a:fidx}_tag_count
+    unlet! s:tlist_{a:fidx}_menu_cmd
+endfunction
+
+" Tlist_Window_Remove_File_From_Display
+" Remove the specified file from display
+function! s:Tlist_Window_Remove_File_From_Display(fidx)
+    call s:Tlist_Log_Msg('Tlist_Window_Remove_File_From_Display (' .
+                \ s:tlist_{a:fidx}_filename . ')')
+    " If the file is not visible then no need to remove it
+    if !s:tlist_{a:fidx}_visible
+        return
+    endif
+
+    " Remove the tags displayed for the specified file from the window
+    let start = s:tlist_{a:fidx}_start
+    " Include the empty line after the last line also
+    if g:Tlist_Compact_Format
+        let end = s:tlist_{a:fidx}_end
+    else
+        let end = s:tlist_{a:fidx}_end + 1
+    endif
+
+    setlocal modifiable
+    exe 'silent! ' . start . ',' . end . 'delete _'
+    setlocal nomodifiable
+
+    " Correct the start and end line offsets for all the files following
+    " this file, as the tags for this file are removed
+    call s:Tlist_Window_Update_Line_Offsets(a:fidx + 1, 0, end - start + 1)
+endfunction
+
+" Tlist_Remove_File
+" Remove the file under the cursor or the specified file index
+" user_request - User requested to remove the file from taglist
+function! s:Tlist_Remove_File(file_idx, user_request)
+    let fidx = a:file_idx
+
+    if fidx == -1
+        let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
+        if fidx == -1
+            return
+        endif
+    endif
+    call s:Tlist_Log_Msg('Tlist_Remove_File (' .
+                \ s:tlist_{fidx}_filename . ', ' . a:user_request . ')')
+
+    let save_winnr = winnr()
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        " Taglist window is open, remove the file from display
+
+        if save_winnr != winnum
+            let old_eventignore = &eventignore
+            set eventignore=all
+            exe winnum . 'wincmd w'
+        endif
+
+        call s:Tlist_Window_Remove_File_From_Display(fidx)
+
+        if save_winnr != winnum
+            exe save_winnr . 'wincmd w'
+            let &eventignore = old_eventignore
+        endif
+    endif
+
+    let fname = s:tlist_{fidx}_filename
+
+    if a:user_request
+        " As the user requested to remove the file from taglist,
+        " add it to the removed list
+        call s:Tlist_Update_Remove_List(fname, 1)
+    endif
+
+    " Remove the file name from the taglist list of filenames
+    let idx = stridx(s:tlist_file_names, fname . "\n")
+    let text_before = strpart(s:tlist_file_names, 0, idx)
+    let rem_text = strpart(s:tlist_file_names, idx)
+    let next_idx = stridx(rem_text, "\n")
+    let text_after = strpart(rem_text, next_idx + 1)
+    let s:tlist_file_names = text_before . text_after
+
+    call s:Tlist_Discard_FileInfo(fidx)
+
+    " Shift all the file variables by one index
+    let i = fidx + 1
+
+    while i < s:tlist_file_count
+        let j = i - 1
+
+        let s:tlist_{j}_filename = s:tlist_{i}_filename
+        let s:tlist_{j}_sort_type = s:tlist_{i}_sort_type
+        let s:tlist_{j}_filetype = s:tlist_{i}_filetype
+        let s:tlist_{j}_mtime = s:tlist_{i}_mtime
+        let s:tlist_{j}_start = s:tlist_{i}_start
+        let s:tlist_{j}_end = s:tlist_{i}_end
+        let s:tlist_{j}_valid = s:tlist_{i}_valid
+        let s:tlist_{j}_visible = s:tlist_{i}_visible
+        let s:tlist_{j}_tag_count = s:tlist_{i}_tag_count
+        let s:tlist_{j}_menu_cmd = s:tlist_{i}_menu_cmd
+
+        let k = 1
+        while k <= s:tlist_{j}_tag_count
+            let s:tlist_{j}_{k}_tag = s:tlist_{i}_{k}_tag
+            let s:tlist_{j}_{k}_tag_name = s:tlist_{i}_{k}_tag_name
+            let s:tlist_{j}_{k}_tag_type = s:Tlist_Get_Tag_Type_By_Tag(i, k)
+            let s:tlist_{j}_{k}_ttype_idx = s:tlist_{i}_{k}_ttype_idx
+            let s:tlist_{j}_{k}_tag_proto = s:Tlist_Get_Tag_Prototype(i, k)
+            let s:tlist_{j}_{k}_tag_searchpat = s:Tlist_Get_Tag_SearchPat(i, k)
+            let s:tlist_{j}_{k}_tag_linenum = s:Tlist_Get_Tag_Linenum(i, k)
+            let k = k + 1
+        endwhile
+
+        let ftype = s:tlist_{i}_filetype
+
+        let k = 1
+        while k <= s:tlist_{ftype}_count
+            let ttype = s:tlist_{ftype}_{k}_name
+            let s:tlist_{j}_{ttype} = s:tlist_{i}_{ttype}
+            let s:tlist_{j}_{ttype}_offset = s:tlist_{i}_{ttype}_offset
+            let s:tlist_{j}_{ttype}_count = s:tlist_{i}_{ttype}_count
+            if s:tlist_{j}_{ttype} != ''
+                let l = 1
+                while l <= s:tlist_{j}_{ttype}_count
+                    let s:tlist_{j}_{ttype}_{l} = s:tlist_{i}_{ttype}_{l}
+                    let l = l + 1
+                endwhile
+            endif
+            let k = k + 1
+        endwhile
+
+        " As the file and tag information is copied to the new index,
+        " discard the previous information
+        call s:Tlist_Discard_FileInfo(i)
+
+        let i = i + 1
+    endwhile
+
+    " Reduce the number of files displayed
+    let s:tlist_file_count = s:tlist_file_count - 1
+
+    if g:Tlist_Show_One_File
+        " If the tags for only one file is displayed and if we just
+        " now removed that file, then invalidate the current file idx
+        if s:tlist_cur_file_idx == fidx
+            let s:tlist_cur_file_idx = -1
+        endif
+    endif
+endfunction
+
+" Tlist_Window_Goto_Window
+" Goto the taglist window
+function! s:Tlist_Window_Goto_Window()
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        if winnr() != winnum
+            call s:Tlist_Exe_Cmd_No_Acmds(winnum . 'wincmd w')
+        endif
+    endif
+endfunction
+
+" Tlist_Window_Create
+" Create a new taglist window. If it is already open, jump to it
+function! s:Tlist_Window_Create()
+    call s:Tlist_Log_Msg('Tlist_Window_Create()')
+    " If the window is open, jump to it
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        " Jump to the existing window
+        if winnr() != winnum
+            exe winnum . 'wincmd w'
+        endif
+        return
+    endif
+
+    " If used with winmanager don't open windows. Winmanager will handle
+    " the window/buffer management
+    if s:tlist_app_name == "winmanager"
+        return
+    endif
+
+    " Create a new window. If user prefers a horizontal window, then open
+    " a horizontally split window. Otherwise open a vertically split
+    " window
+    if g:Tlist_Use_Horiz_Window
+        " Open a horizontally split window
+        let win_dir = 'botright'
+        " Horizontal window height
+        let win_size = g:Tlist_WinHeight
+    else
+        if s:tlist_winsize_chgd == -1
+            " Open a vertically split window. Increase the window size, if
+            " needed, to accomodate the new window
+            if g:Tlist_Inc_Winwidth &&
+                        \ &columns < (80 + g:Tlist_WinWidth)
+                " Save the original window position
+                let s:tlist_pre_winx = getwinposx()
+                let s:tlist_pre_winy = getwinposy()
+
+                " one extra column is needed to include the vertical split
+                let &columns= &columns + g:Tlist_WinWidth + 1
+
+                let s:tlist_winsize_chgd = 1
+            else
+                let s:tlist_winsize_chgd = 0
+            endif
+        endif
+
+        if g:Tlist_Use_Right_Window
+            " Open the window at the rightmost place
+            let win_dir = 'botright vertical'
+        else
+            " Open the window at the leftmost place
+            let win_dir = 'topleft vertical'
+        endif
+        let win_size = g:Tlist_WinWidth
+    endif
+
+    " If the tag listing temporary buffer already exists, then reuse it.
+    " Otherwise create a new buffer
+    let bufnum = bufnr(g:TagList_title)
+    if bufnum == -1
+        " Create a new buffer
+        let wcmd = g:TagList_title
+    else
+        " Edit the existing buffer
+        let wcmd = '+buffer' . bufnum
+    endif
+
+    " Create the taglist window
+    exe 'silent! ' . win_dir . ' ' . win_size . 'split ' . wcmd
+
+    " Save the new window position
+    let s:tlist_winx = getwinposx()
+    let s:tlist_winy = getwinposy()
+
+    " Initialize the taglist window
+    call s:Tlist_Window_Init()
+endfunction
+
+" Tlist_Window_Zoom
+" Zoom (maximize/minimize) the taglist window
+function! s:Tlist_Window_Zoom()
+    if s:tlist_win_maximized
+        " Restore the window back to the previous size
+        if g:Tlist_Use_Horiz_Window
+            exe 'resize ' . g:Tlist_WinHeight
+        else
+            exe 'vert resize ' . g:Tlist_WinWidth
+        endif
+        let s:tlist_win_maximized = 0
+    else
+        " Set the window size to the maximum possible without closing other
+        " windows
+        if g:Tlist_Use_Horiz_Window
+            resize
+        else
+            vert resize
+        endif
+        let s:tlist_win_maximized = 1
+    endif
+endfunction
+
+" Tlist_Ballon_Expr
+" When the mouse cursor is over a tag in the taglist window, display the
+" tag prototype (balloon)
+function! Tlist_Ballon_Expr()
+    " Get the file index
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(v:beval_lnum)
+    if fidx == -1
+        return ''
+    endif
+
+    " Get the tag output line for the current tag
+    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, v:beval_lnum)
+    if tidx == 0
+        return ''
+    endif
+
+    " Get the tag search pattern and display it
+    return s:Tlist_Get_Tag_Prototype(fidx, tidx)
+endfunction
+
+" Tlist_Window_Check_Width
+" Check the width of the taglist window. For horizontally split windows, the
+" 'winfixheight' option is used to fix the height of the window. For
+" vertically split windows, Vim doesn't support the 'winfixwidth' option. So
+" need to handle window width changes from this function.
+function! s:Tlist_Window_Check_Width()
+    let tlist_winnr = bufwinnr(g:TagList_title)
+    if tlist_winnr == -1
+        return
+    endif
+
+    let width = winwidth(tlist_winnr)
+    if width != g:Tlist_WinWidth
+        call s:Tlist_Log_Msg("Tlist_Window_Check_Width: Changing window " .
+                    \ "width from " . width . " to " . g:Tlist_WinWidth)
+        let save_winnr = winnr()
+        if save_winnr != tlist_winnr
+            call s:Tlist_Exe_Cmd_No_Acmds(tlist_winnr . 'wincmd w')
+        endif
+        exe 'vert resize ' . g:Tlist_WinWidth
+        if save_winnr != tlist_winnr
+            call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
+        endif
+    endif
+endfunction
+
+" Tlist_Window_Exit_Only_Window
+" If the 'Tlist_Exit_OnlyWindow' option is set, then exit Vim if only the
+" taglist window is present.
+function! s:Tlist_Window_Exit_Only_Window()
+    " Before quitting Vim, delete the taglist buffer so that
+    " the '0 mark is correctly set to the previous buffer.
+    if v:version < 700
+	if winbufnr(2) == -1
+	    bdelete
+	    quit
+	endif
+    else
+	if winbufnr(2) == -1
+	    if tabpagenr('$') == 1
+		" Only one tag page is present
+		bdelete
+		quit
+	    else
+		" More than one tab page is present. Close only the current
+		" tab page
+		close
+	    endif
+	endif
+    endif
+endfunction
+
+" Tlist_Window_Init
+" Set the default options for the taglist window
+function! s:Tlist_Window_Init()
+    call s:Tlist_Log_Msg('Tlist_Window_Init()')
+
+    " The 'readonly' option should not be set for the taglist buffer.
+    " If Vim is started as "view/gview" or if the ":view" command is
+    " used, then the 'readonly' option is set for all the buffers.
+    " Unset it for the taglist buffer
+    setlocal noreadonly
+
+    " Set the taglist buffer filetype to taglist
+    setlocal filetype=taglist
+
+    " Define taglist window element highlighting
+    syntax match TagListComment '^" .*'
+    syntax match TagListFileName '^[^" ].*$'
+    syntax match TagListTitle '^  \S.*$'
+    syntax region TagListTagScope1  start='\[' end='\]' contains=TagListTagScope1 nextgroup=TagListTagScope2 skipwhite
+    syntax region TagListTagScope2 start='\[' end='\]' contained contains=TaglistTagScope2
+
+    " Define the highlighting only if colors are supported
+    if has('gui_running') || &t_Co > 2
+        " Colors to highlight various taglist window elements
+        " If user defined highlighting group exists, then use them.
+        " Otherwise, use default highlight groups.
+        if hlexists('MyTagListTagName')
+            highlight link TagListTagName MyTagListTagName
+        else
+            highlight default link TagListTagName Search
+        endif
+        " Colors to highlight comments and titles
+        if hlexists('MyTagListComment')
+            highlight link TagListComment MyTagListComment
+        else
+            highlight clear TagListComment
+            highlight default link TagListComment Comment
+        endif
+        if hlexists('MyTagListTitle')
+            highlight link TagListTitle MyTagListTitle
+        else
+            highlight clear TagListTitle
+            highlight default link TagListTitle Title
+        endif
+        if hlexists('MyTagListFileName')
+            highlight link TagListFileName MyTagListFileName
+        else
+            highlight clear TagListFileName
+            highlight default TagListFileName guibg=Grey ctermbg=darkgray
+                        \ guifg=white ctermfg=white
+        endif
+        if hlexists('MyTagListTagScope')
+            highlight link TagListTagScope1 MyTagListTagScope
+        else
+            highlight clear TagListTagScope1
+            highlight clear TagListTagScope2
+            highlight default link TagListTagScope1 Identifier
+            highlight default link TagListTagScope2 Keyword
+        endif
+    else
+        highlight default TagListTagName term=reverse cterm=reverse
+    endif
+
+    " Folding related settings
+    setlocal foldenable
+    setlocal foldminlines=0
+    setlocal foldmethod=manual
+    setlocal foldlevel=9999
+    if g:Tlist_Enable_Fold_Column
+        setlocal foldcolumn=3
+    else
+        setlocal foldcolumn=0
+    endif
+    setlocal foldtext=v:folddashes.getline(v:foldstart)
+
+    if s:tlist_app_name != "winmanager"
+        " Mark buffer as scratch
+        silent! setlocal buftype=nofile
+        if s:tlist_app_name == "none"
+            silent! setlocal bufhidden=delete
+        endif
+        silent! setlocal noswapfile
+        " Due to a bug in Vim 6.0, the winbufnr() function fails for unlisted
+        " buffers. So if the taglist buffer is unlisted, multiple taglist
+        " windows will be opened. This bug is fixed in Vim 6.1 and above
+        if v:version >= 601
+            silent! setlocal nobuflisted
+        endif
+    endif
+
+    silent! setlocal nowrap
+
+    " If the 'number' option is set in the source window, it will affect the
+    " taglist window. So forcefully disable 'number' option for the taglist
+    " window
+    silent! setlocal nonumber
+
+    " Use fixed height when horizontally split window is used
+    if g:Tlist_Use_Horiz_Window
+        if v:version >= 602
+            set winfixheight
+        endif
+    endif
+    if !g:Tlist_Use_Horiz_Window && v:version >= 700
+        set winfixwidth
+    endif
+
+    " Setup balloon evaluation to display tag prototype
+    if v:version >= 700 && has('balloon_eval')
+        setlocal balloonexpr=Tlist_Ballon_Expr()
+        set ballooneval
+    endif
+
+    " Setup the cpoptions properly for the maps to work
+    let old_cpoptions = &cpoptions
+    set cpoptions&vim
+
+    " Create buffer local mappings for jumping to the tags and sorting the list
+    nnoremap <buffer> <silent> <CR>
+                \ :call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    " If more languages are required, generate this from a list of options
+    nnoremap <buffer> <silent> m
+                \ :call <SID>Tlist_Window_Toggle_Extra('javascript', 'type')<CR>
+    nnoremap <buffer> <silent> o
+                \ :call <SID>Tlist_Window_Jump_To_Tag('newwin')<CR>
+    nnoremap <buffer> <silent> p
+                \ :call <SID>Tlist_Window_Jump_To_Tag('preview')<CR>
+    nnoremap <buffer> <silent> P
+                \ :call <SID>Tlist_Window_Jump_To_Tag('prevwin')<CR>
+    if v:version >= 700
+    nnoremap <buffer> <silent> t
+                \ :call <SID>Tlist_Window_Jump_To_Tag('checktab')<CR>
+    nnoremap <buffer> <silent> <C-t>
+                \ :call <SID>Tlist_Window_Jump_To_Tag('newtab')<CR>
+    endif
+    nnoremap <buffer> <silent> <2-LeftMouse>
+                \ :call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    nnoremap <buffer> <silent> s
+                \ :call <SID>Tlist_Change_Sort('cmd', 'toggle', '')<CR>
+    nnoremap <buffer> <silent> + :silent! foldopen<CR>
+    nnoremap <buffer> <silent> - :silent! foldclose<CR>
+    nnoremap <buffer> <silent> * :silent! %foldopen!<CR>
+    nnoremap <buffer> <silent> = :silent! %foldclose<CR>
+    nnoremap <buffer> <silent> <kPlus> :silent! foldopen<CR>
+    nnoremap <buffer> <silent> <kMinus> :silent! foldclose<CR>
+    nnoremap <buffer> <silent> <kMultiply> :silent! %foldopen!<CR>
+    nnoremap <buffer> <silent> <Space> :call <SID>Tlist_Window_Show_Info()<CR>
+    nnoremap <buffer> <silent> u :call <SID>Tlist_Window_Update_File()<CR>
+    nnoremap <buffer> <silent> d :call <SID>Tlist_Remove_File(-1, 1)<CR>
+    nnoremap <buffer> <silent> x :call <SID>Tlist_Window_Zoom()<CR>
+    nnoremap <buffer> <silent> [[ :call <SID>Tlist_Window_Move_To_File(-1)<CR>
+    nnoremap <buffer> <silent> <BS> :call <SID>Tlist_Window_Move_To_File(-1)<CR>
+    nnoremap <buffer> <silent> ]] :call <SID>Tlist_Window_Move_To_File(1)<CR>
+    nnoremap <buffer> <silent> <Tab> :call <SID>Tlist_Window_Move_To_File(1)<CR>
+    nnoremap <buffer> <silent> <F1> :call <SID>Tlist_Window_Toggle_Help_Text()<CR>
+    nnoremap <buffer> <silent> q :close<CR>
+
+    " Insert mode mappings
+    inoremap <buffer> <silent> <CR>
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    " Windows needs return
+    inoremap <buffer> <silent> <Return>
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    inoremap <buffer> <silent> o
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('newwin')<CR>
+    inoremap <buffer> <silent> p
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('preview')<CR>
+    inoremap <buffer> <silent> P
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('prevwin')<CR>
+    if v:version >= 700
+    inoremap <buffer> <silent> t
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('checktab')<CR>
+    inoremap <buffer> <silent> <C-t>
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('newtab')<CR>
+    endif
+    inoremap <buffer> <silent> <2-LeftMouse>
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    inoremap <buffer> <silent> s
+                \ <C-o>:call <SID>Tlist_Change_Sort('cmd', 'toggle', '')<CR>
+    inoremap <buffer> <silent> +             <C-o>:silent! foldopen<CR>
+    inoremap <buffer> <silent> -             <C-o>:silent! foldclose<CR>
+    inoremap <buffer> <silent> *             <C-o>:silent! %foldopen!<CR>
+    inoremap <buffer> <silent> =             <C-o>:silent! %foldclose<CR>
+    inoremap <buffer> <silent> <kPlus>       <C-o>:silent! foldopen<CR>
+    inoremap <buffer> <silent> <kMinus>      <C-o>:silent! foldclose<CR>
+    inoremap <buffer> <silent> <kMultiply>   <C-o>:silent! %foldopen!<CR>
+    inoremap <buffer> <silent> <Space>       <C-o>:call
+                                    \ <SID>Tlist_Window_Show_Info()<CR>
+    inoremap <buffer> <silent> u
+                            \ <C-o>:call <SID>Tlist_Window_Update_File()<CR>
+    inoremap <buffer> <silent> d    <C-o>:call <SID>Tlist_Remove_File(-1, 1)<CR>
+    inoremap <buffer> <silent> x    <C-o>:call <SID>Tlist_Window_Zoom()<CR>
+    inoremap <buffer> <silent> [[   <C-o>:call <SID>Tlist_Window_Move_To_File(-1)<CR>
+    inoremap <buffer> <silent> <BS> <C-o>:call <SID>Tlist_Window_Move_To_File(-1)<CR>
+    inoremap <buffer> <silent> ]]   <C-o>:call <SID>Tlist_Window_Move_To_File(1)<CR>
+    inoremap <buffer> <silent> <Tab> <C-o>:call <SID>Tlist_Window_Move_To_File(1)<CR>
+    inoremap <buffer> <silent> <F1>  <C-o>:call <SID>Tlist_Window_Toggle_Help_Text()<CR>
+    inoremap <buffer> <silent> q    <C-o>:close<CR>
+
+    " Map single left mouse click if the user wants this functionality
+    if g:Tlist_Use_SingleClick == 1
+        " Contributed by Bindu Wavell
+        " attempt to perform single click mapping, it would be much
+        " nicer if we could nnoremap <buffer> ... however vim does
+        " not fire the <buffer> <leftmouse> when you use the mouse
+        " to enter a buffer.
+        let clickmap = ':if bufname("%") =~ "__Tag_List__" <bar> ' .
+                    \ 'call <SID>Tlist_Window_Jump_To_Tag("useopen") ' .
+                    \ '<bar> endif <CR>'
+        if maparg('<leftmouse>', 'n') == ''
+            " no mapping for leftmouse
+            exe ':nnoremap <silent> <leftmouse> <leftmouse>' . clickmap
+        else
+            " we have a mapping
+            let mapcmd = ':nnoremap <silent> <leftmouse> <leftmouse>'
+            let mapcmd = mapcmd . substitute(substitute(
+                        \ maparg('<leftmouse>', 'n'), '|', '<bar>', 'g'),
+                        \ '\c^<leftmouse>', '', '')
+            let mapcmd = mapcmd . clickmap
+            exe mapcmd
+        endif
+    endif
+
+    " Define the taglist autocommands
+    augroup TagListAutoCmds
+        autocmd!
+        " Display the tag prototype for the tag under the cursor.
+        autocmd CursorHold __Tag_List__ call s:Tlist_Window_Show_Info()
+        " Highlight the current tag periodically
+        autocmd CursorHold * silent call s:Tlist_Window_Highlight_Tag(
+                            \ fnamemodify(bufname('%'), ':p'), line('.'), 1, 0)
+
+        " Adjust the Vim window width when taglist window is closed
+        autocmd BufUnload __Tag_List__ call s:Tlist_Post_Close_Cleanup()
+        " Close the fold for this buffer when leaving the buffer
+        if g:Tlist_File_Fold_Auto_Close
+            autocmd BufEnter * silent
+                \ call s:Tlist_Window_Open_File_Fold(expand('<abuf>'))
+        endif
+        " Exit Vim itself if only the taglist window is present (optional)
+        if g:Tlist_Exit_OnlyWindow
+	    autocmd BufEnter __Tag_List__ nested
+			\ call s:Tlist_Window_Exit_Only_Window()
+        endif
+        if s:tlist_app_name != "winmanager" &&
+                    \ !g:Tlist_Process_File_Always &&
+                    \ (!has('gui_running') || !g:Tlist_Show_Menu)
+            " Auto refresh the taglist window
+            autocmd BufEnter * call s:Tlist_Refresh()
+        endif
+
+        if !g:Tlist_Use_Horiz_Window
+            if v:version < 700
+                autocmd WinEnter * call s:Tlist_Window_Check_Width()
+            endif
+        endif
+        if v:version >= 700
+            autocmd TabEnter * silent call s:Tlist_Refresh_Folds()
+        endif
+    augroup end
+
+    " Restore the previous cpoptions settings
+    let &cpoptions = old_cpoptions
+endfunction
+
+" Tlist_Window_Refresh
+" Display the tags for all the files in the taglist window
+function! s:Tlist_Window_Refresh()
+    call s:Tlist_Log_Msg('Tlist_Window_Refresh()')
+    " Set report option to a huge value to prevent informational messages
+    " while deleting the lines
+    let old_report = &report
+    set report=99999
+
+    " Mark the buffer as modifiable
+    setlocal modifiable
+
+    " Delete the contents of the buffer to the black-hole register
+    silent! %delete _
+
+    " As we have cleared the taglist window, mark all the files
+    " as not visible
+    let i = 0
+    while i < s:tlist_file_count
+        let s:tlist_{i}_visible = 0
+        let i = i + 1
+    endwhile
+
+    if g:Tlist_Compact_Format == 0
+        " Display help in non-compact mode
+        call s:Tlist_Window_Display_Help()
+    endif
+
+    " Mark the buffer as not modifiable
+    setlocal nomodifiable
+
+    " Restore the report option
+    let &report = old_report
+
+    " If the tags for only one file should be displayed in the taglist
+    " window, then no need to add the tags here. The bufenter autocommand
+    " will add the tags for that file.
+    if g:Tlist_Show_One_File
+        return
+    endif
+
+    " List all the tags for the previously processed files
+    " Do this only if taglist is configured to display tags for more than
+    " one file. Otherwise, when Tlist_Show_One_File is configured,
+    " tags for the wrong file will be displayed.
+    let i = 0
+    while i < s:tlist_file_count
+        call s:Tlist_Window_Refresh_File(s:tlist_{i}_filename,
+                    \ s:tlist_{i}_filetype)
+        let i = i + 1
+    endwhile
+
+    if g:Tlist_Auto_Update
+        " Add and list the tags for all buffers in the Vim buffer list
+        let i = 1
+        let last_bufnum = bufnr('$')
+        while i <= last_bufnum
+            if buflisted(i)
+                let fname = fnamemodify(bufname(i), ':p')
+                let ftype = s:Tlist_Get_Buffer_Filetype(i)
+                " If the file doesn't support tag listing, skip it
+                if !s:Tlist_Skip_File(fname, ftype)
+                    call s:Tlist_Window_Refresh_File(fname, ftype)
+                endif
+            endif
+            let i = i + 1
+        endwhile
+    endif
+
+    " If Tlist_File_Fold_Auto_Close option is set, then close all the folds
+    if g:Tlist_File_Fold_Auto_Close
+        " Close all the folds
+        silent! %foldclose
+    endif
+
+    if !g:Tlist_Use_Horiz_Window && s:auto_width
+        exe 'vertical resize '.g:Tlist_WinWidth
+    endif
+
+    " Move the cursor to the top of the taglist window
+    normal! gg
+endfunction
+
+" Tlist_Post_Close_Cleanup()
+" Close the taglist window and adjust the Vim window width
+function! s:Tlist_Post_Close_Cleanup()
+    call s:Tlist_Log_Msg('Tlist_Post_Close_Cleanup()')
+    " Mark all the files as not visible
+    let i = 0
+    while i < s:tlist_file_count
+        let s:tlist_{i}_visible = 0
+        let i = i + 1
+    endwhile
+
+    " Remove the taglist autocommands
+    silent! autocmd! TagListAutoCmds
+
+    " Clear all the highlights
+    match none
+
+    silent! syntax clear TagListTitle
+    silent! syntax clear TagListComment
+    silent! syntax clear TagListTagScope
+
+    " Remove the left mouse click mapping if it was setup initially
+    if g:Tlist_Use_SingleClick
+        if hasmapto('<LeftMouse>')
+            nunmap <LeftMouse>
+        endif
+    endif
+
+    if s:tlist_app_name != "winmanager"
+    if g:Tlist_Use_Horiz_Window || g:Tlist_Inc_Winwidth == 0 ||
+                \ s:tlist_winsize_chgd != 1 ||
+                \ &columns < (80 + g:Tlist_WinWidth)
+        " No need to adjust window width if using horizontally split taglist
+        " window or if columns is less than 101 or if the user chose not to
+        " adjust the window width
+    else
+        " If the user didn't manually move the window, then restore the window
+        " position to the pre-taglist position
+        if s:tlist_pre_winx != -1 && s:tlist_pre_winy != -1 &&
+                    \ getwinposx() == s:tlist_winx &&
+                    \ getwinposy() == s:tlist_winy
+            exe 'winpos ' . s:tlist_pre_winx . ' ' . s:tlist_pre_winy
+        endif
+
+        " Adjust the Vim window width
+        let &columns= &columns - (g:Tlist_WinWidth + 1)
+    endif
+    endif
+
+    let s:tlist_winsize_chgd = -1
+
+    " Reset taglist state variables
+    if s:tlist_app_name == "winmanager"
+        let s:tlist_app_name = "none"
+    endif
+    let s:tlist_window_initialized = 0
+endfunction
+
+" Tlist_Window_Refresh_File()
+" List the tags defined in the specified file in a Vim window
+function! s:Tlist_Window_Refresh_File(filename, ftype)
+    call s:Tlist_Log_Msg('Tlist_Window_Refresh_File (' . a:filename . ')')
+    " First check whether the file already exists
+    let fidx = s:Tlist_Get_File_Index(a:filename)
+    if fidx != -1
+        let file_listed = 1
+    else
+        let file_listed = 0
+    endif
+
+    if !file_listed
+        " Check whether this file is removed based on user request
+        " If it is, then don't display the tags for this file
+        if s:Tlist_User_Removed_File(a:filename)
+            return
+        endif
+    endif
+
+    if file_listed && s:tlist_{fidx}_visible
+        " Check whether the file tags are currently valid
+        if s:tlist_{fidx}_valid
+            " Goto the first line in the file
+            exe s:tlist_{fidx}_start
+
+            " If the line is inside a fold, open the fold
+            if foldclosed('.') != -1
+                exe "silent! " . s:tlist_{fidx}_start . "," .
+                            \ s:tlist_{fidx}_end . "foldopen!"
+            endif
+            return
+        endif
+
+        " Discard and remove the tags for this file from display
+        call s:Tlist_Discard_TagInfo(fidx)
+        call s:Tlist_Window_Remove_File_From_Display(fidx)
+    endif
+
+    " Process and generate a list of tags defined in the file
+    if !file_listed || !s:tlist_{fidx}_valid
+        let ret_fidx = s:Tlist_Process_File(a:filename, a:ftype)
+        if ret_fidx == -1
+            return
+        endif
+        let fidx = ret_fidx
+    endif
+
+    " Set report option to a huge value to prevent informational messages
+    " while adding lines to the taglist window
+    let old_report = &report
+    set report=99999
+
+    if g:Tlist_Show_One_File
+        " Remove the previous file
+        if s:tlist_cur_file_idx != -1
+            call s:Tlist_Window_Remove_File_From_Display(s:tlist_cur_file_idx)
+            let s:tlist_{s:tlist_cur_file_idx}_visible = 0
+            let s:tlist_{s:tlist_cur_file_idx}_start = 0
+            let s:tlist_{s:tlist_cur_file_idx}_end = 0
+        endif
+        let s:tlist_cur_file_idx = fidx
+    endif
+
+    " Mark the buffer as modifiable
+    setlocal modifiable
+
+    " Add new files to the end of the window. For existing files, add them at
+    " the same line where they were previously present. If the file is not
+    " visible, then add it at the end
+    if s:tlist_{fidx}_start == 0 || !s:tlist_{fidx}_visible
+        if g:Tlist_Compact_Format
+            let s:tlist_{fidx}_start = line('$')
+        else
+            let s:tlist_{fidx}_start = line('$') + 1
+        endif
+    endif
+
+    let s:tlist_{fidx}_visible = 1
+
+    " Goto the line where this file should be placed
+    if g:Tlist_Compact_Format
+        exe s:tlist_{fidx}_start
+    else
+        exe s:tlist_{fidx}_start - 1
+    endif
+
+    let txt = fnamemodify(s:tlist_{fidx}_filename, ':t') . ' (' .
+                \ fnamemodify(s:tlist_{fidx}_filename, ':p:h') . ')'
+    if g:Tlist_Compact_Format == 0
+        silent! put =txt
+    else
+        silent! put! =txt
+        " Move to the next line
+        exe line('.') + 1
+    endif
+    let file_start = s:tlist_{fidx}_start
+
+    " Add the tag names grouped by tag type to the buffer with a title
+    let i = 1
+    let ttype_cnt = s:tlist_{a:ftype}_count
+    while i <= ttype_cnt
+        let ttype = s:tlist_{a:ftype}_{i}_name
+        " Add the tag type only if there are tags for that type
+        let fidx_ttype = 's:tlist_' . fidx . '_' . ttype
+        let ttype_txt = {fidx_ttype}
+        if ttype_txt != ''
+            let txt = '  ' . s:tlist_{a:ftype}_{i}_fullname
+            if g:Tlist_Compact_Format == 0
+                let ttype_start_lnum = line('.') + 1
+                silent! put =txt
+            else
+                let ttype_start_lnum = line('.')
+                silent! put! =txt
+            endif
+            silent! put =ttype_txt
+
+            let {fidx_ttype}_offset = ttype_start_lnum - file_start
+
+            " create a fold for this tag type
+            let fold_start = ttype_start_lnum
+            let fold_end = fold_start + {fidx_ttype}_count
+            exe fold_start . ',' . fold_end  . 'fold'
+
+            " Adjust the cursor position
+            if g:Tlist_Compact_Format == 0
+                exe ttype_start_lnum + {fidx_ttype}_count
+            else
+                exe ttype_start_lnum + {fidx_ttype}_count + 1
+            endif
+
+            if g:Tlist_Compact_Format == 0
+                " Separate the tag types by a empty line
+                silent! put =''
+            endif
+        endif
+        let i = i + 1
+    endwhile
+
+    if s:tlist_{fidx}_tag_count == 0
+        if g:Tlist_Compact_Format == 0
+            silent! put =''
+        endif
+    endif
+
+    let s:tlist_{fidx}_end = line('.') - 1
+
+    " Create a fold for the entire file
+    exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'fold'
+    exe 'silent! ' . s:tlist_{fidx}_start . ',' .
+                \ s:tlist_{fidx}_end . 'foldopen!'
+
+    " Goto the starting line for this file,
+    exe s:tlist_{fidx}_start
+
+    if s:tlist_app_name == "winmanager"
+        " To handle a bug in the winmanager plugin, add a space at the
+        " last line
+        call setline('$', ' ')
+    endif
+
+    " Mark the buffer as not modifiable
+    setlocal nomodifiable
+
+    " Restore the report option
+    let &report = old_report
+
+    " Update the start and end line numbers for all the files following this
+    " file
+    let start = s:tlist_{fidx}_start
+    " include the empty line after the last line
+    if g:Tlist_Compact_Format
+        let end = s:tlist_{fidx}_end
+    else
+        let end = s:tlist_{fidx}_end + 1
+    endif
+    call s:Tlist_Window_Update_Line_Offsets(fidx + 1, 1, end - start + 1)
+
+    if !g:Tlist_Use_Horiz_Window && s:auto_width
+        exe 'vertical resize '.g:Tlist_WinWidth
+    endif
+
+    " Now that we have updated the taglist window, update the tags
+    " menu (if present)
+    if g:Tlist_Show_Menu
+        call s:Tlist_Menu_Update_File(1)
+    endif
+endfunction
+
+" Tlist_Init_File
+" Initialize the variables for a new file
+function! s:Tlist_Init_File(filename, ftype)
+    call s:Tlist_Log_Msg('Tlist_Init_File (' . a:filename . ')')
+    " Add new files at the end of the list
+    let fidx = s:tlist_file_count
+    let s:tlist_file_count = s:tlist_file_count + 1
+    " Add the new file name to the taglist list of file names
+    let s:tlist_file_names = s:tlist_file_names . a:filename . "\n"
+
+    " Initialize the file variables
+    let s:tlist_{fidx}_filename = a:filename
+    let s:tlist_{fidx}_sort_type = g:Tlist_Sort_Type
+    let s:tlist_{fidx}_filetype = a:ftype
+    let s:tlist_{fidx}_mtime = -1
+    let s:tlist_{fidx}_start = 0
+    let s:tlist_{fidx}_end = 0
+    let s:tlist_{fidx}_valid = 0
+    let s:tlist_{fidx}_visible = 0
+    let s:tlist_{fidx}_tag_count = 0
+    let s:tlist_{fidx}_menu_cmd = ''
+
+    " Initialize the tag type variables
+    let i = 1
+    while i <= s:tlist_{a:ftype}_count
+        let ttype = s:tlist_{a:ftype}_{i}_name
+        let s:tlist_{fidx}_{ttype} = ''
+        let s:tlist_{fidx}_{ttype}_offset = 0
+        let s:tlist_{fidx}_{ttype}_count = 0
+        let i = i + 1
+    endwhile
+
+    return fidx
+endfunction
+
+" Tlist_Get_Tag_Type_By_Tag
+" Return the tag type for the specified tag index
+function! s:Tlist_Get_Tag_Type_By_Tag(fidx, tidx)
+    let ttype_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_type'
+
+    " Already parsed and have the tag name
+    if exists(ttype_var)
+        return {ttype_var}
+    endif
+
+    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
+    let {ttype_var} = s:Tlist_Extract_Tagtype(tag_line)
+
+    return {ttype_var}
+endfunction
+
+" Tlist_Get_Tag_Prototype
+function! s:Tlist_Get_Tag_Prototype(fidx, tidx)
+    let tproto_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_proto'
+
+    " Already parsed and have the tag prototype
+    if exists(tproto_var)
+        return {tproto_var}
+    endif
+
+    " Parse and extract the tag prototype
+    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
+    let start = stridx(tag_line, '/^') + 2
+    let end = stridx(tag_line, '/;"' . "\t")
+    if tag_line[end - 1] == '$'
+        let end = end -1
+    endif
+    let tag_proto = strpart(tag_line, start, end - start)
+    let {tproto_var} = substitute(tag_proto, '\s*', '', '')
+
+    return {tproto_var}
+endfunction
+
+" Tlist_Get_Tag_SearchPat
+function! s:Tlist_Get_Tag_SearchPat(fidx, tidx)
+    let tpat_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_searchpat'
+
+    " Already parsed and have the tag search pattern
+    if exists(tpat_var)
+        return {tpat_var}
+    endif
+
+    " Parse and extract the tag search pattern
+    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
+    let start = stridx(tag_line, '/^') + 2
+    let end = stridx(tag_line, '/;"' . "\t")
+    if tag_line[end - 1] == '$'
+        let end = end -1
+    endif
+    let {tpat_var} = '\V\^' . strpart(tag_line, start, end - start) .
+                        \ (tag_line[end] == '$' ? '\$' : '')
+
+    return {tpat_var}
+endfunction
+
+" Tlist_Get_Tag_Linenum
+" Return the tag line number, given the tag index
+function! s:Tlist_Get_Tag_Linenum(fidx, tidx)
+    let tline_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_linenum'
+
+    " Already parsed and have the tag line number
+    if exists(tline_var)
+        return {tline_var}
+    endif
+
+    " Parse and extract the tag line number
+    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
+    let start = match(tag_line, 'line\(no\)\?:')
+    let start = stridx(tag_line, ':', start) + 1
+    let end = stridx(tag_line, "\t", start)
+
+    if end < start
+        let {tline_var} = strpart(tag_line, start) + 0
+    else
+        let {tline_var} = strpart(tag_line, start, end - start) + 0
+    endif
+
+    return {tline_var}
+endfunction
+
+" Tlist_Parse_Tagline
+" Parse a tag line from the ctags output. Separate the tag output based on the
+" tag type and store it in the tag type variable.
+" The format of each line in the ctags output is:
+"
+"     tag_name<TAB>file_name<TAB>ex_cmd;"<TAB>extension_fields
+"
+function! s:Tlist_Parse_Tagline(tag_line,ftype)
+    if a:tag_line == ''
+        " Skip empty lines
+        return
+    endif
+
+    " Extract the tag type
+    let ttype = s:Tlist_Extract_Tagtype(a:tag_line)
+
+    " Make sure the tag type is a valid and supported one
+    if ttype == '' || stridx(s:ctags_flags, ttype) == -1
+        " Line is not in proper tags format or Tag type is not supported
+        return
+    endif
+
+    " Update the total tag count
+    let s:tidx = s:tidx + 1
+
+    " The following variables are used to optimize this code.  Vim is slow in
+    " using curly brace names. To reduce the amount of processing needed, the
+    " curly brace variables are pre-processed here
+    let fidx_tidx = 's:tlist_' . s:fidx . '_' . s:tidx
+    let fidx_ttype = 's:tlist_' . s:fidx . '_' . ttype
+
+    " Update the count of this tag type
+    let ttype_idx = {fidx_ttype}_count + 1
+    let {fidx_ttype}_count = ttype_idx
+
+    " Store the ctags output for this tag
+    let {fidx_tidx}_tag = a:tag_line
+
+    " Store the tag index and the tag type index (back pointers)
+    let {fidx_ttype}_{ttype_idx} = s:tidx
+    let {fidx_tidx}_ttype_idx = ttype_idx
+
+    " Extract the tag name
+    let tag_name = strpart(a:tag_line, 0, stridx(a:tag_line, "\t"))
+
+    " Extract the tag scope/prototype
+    if g:Tlist_Display_Prototype
+        let ttxt = '    ' . s:Tlist_Get_Tag_Prototype(s:fidx, s:tidx)
+    else
+        let ttxt = '    ' . tag_name
+
+        " Add the tag scope, if it is available and is configured. Tag
+        " scope is the last field after the 'line:<num>\t' field
+        if g:Tlist_Display_Tag_Scope
+            let ttxt .= s:Tlist_Get_Scope_String(a:tag_line, a:ftype)
+        endif
+    endif
+
+    if !g:Tlist_Use_Horiz_Window && s:auto_width
+        " Add 3 for the fold columns
+        let g:Tlist_WinWidth = max([g:Tlist_WinWidth, strlen(ttxt)+3])
+    endif
+
+    " Add this tag to the tag type variable
+    let {fidx_ttype} = {fidx_ttype} . ttxt . "\n"
+
+    " Save the tag name
+    let {fidx_tidx}_tag_name = tag_name
+endfunction
+
+function! s:Tlist_Get_Scope_String(tag_line, ftype)
+    let ttxt = ''
+    let tag_scopes = s:Tlist_Extract_Tag_Scope(a:tag_line)
+    for [extradata_name, extradata_content] in items(tag_scopes)
+        if !exists('g:Tlist_{a:ftype}_Hide_Extras') || match(g:Tlist_{a:ftype}_Hide_Extras, extradata_name) == -1
+            let ttxt = ttxt . ' [' . extradata_content . ']'
+        endif
+    endfor
+    return ttxt
+endfunction
+
+" Tlist_Process_File
+" Get the list of tags defined in the specified file and store them
+" in Vim variables. Returns the file index where the tags are stored.
+function! s:Tlist_Process_File(filename, ftype)
+    call s:Tlist_Log_Msg('Tlist_Process_File (' . a:filename . ', ' .
+                \ a:ftype . ')')
+    " Check whether this file is supported
+    if s:Tlist_Skip_File(a:filename, a:ftype)
+        return -1
+    endif
+
+    " If the tag types for this filetype are not yet created, then create
+    " them now
+    let var = 's:tlist_' . a:ftype . '_count'
+    if !exists(var)
+        if s:Tlist_FileType_Init(a:ftype) == 0
+            return -1
+        endif
+    endif
+
+    " If this file is already processed, then use the cached values
+    let fidx = s:Tlist_Get_File_Index(a:filename)
+    if fidx == -1
+        " First time, this file is loaded
+        let fidx = s:Tlist_Init_File(a:filename, a:ftype)
+    else
+        " File was previously processed. Discard the tag information
+        call s:Tlist_Discard_TagInfo(fidx)
+    endif
+
+    let s:tlist_{fidx}_valid = 1
+
+    " Exuberant ctags arguments to generate a tag list
+    let ctags_args = { '-f': ' -', '--format=': '2', '--excmd=': 'pattern', '--fields=': 'nks' }
+
+    " Form the ctags argument depending on the sort type
+    if s:tlist_{fidx}_sort_type == 'name'
+        let ctags_args['--sort'] = '=yes'
+    else
+        let ctags_args['--sort'] = '=no'
+    endif
+
+    " Add the filetype specific arguments
+    call extend(ctags_args, s:tlist_{a:ftype}_ctags_args)
+
+    " Ctags command to produce output with regexp for locating the tags
+    if exists('g:Tlist_{a:ftype}_Ctags_Cmd')
+        let ctags_cmd = g:Tlist_{a:ftype}_Ctags_Cmd
+        let ctags_args = filter(ctags_args, 'match(g:Tlist_javascript_Ctags_Allowed_Flags, "^".v:key."$") != -1')
+    else
+        let ctags_cmd = g:Tlist_Ctags_Cmd
+    endif
+    let ctags_cmd = ctags_cmd . ' ' . join(values(map(ctags_args, 'v:key . v:val')))
+    let ctags_cmd = ctags_cmd . ' "' . a:filename . '"'
+
+    if &shellxquote == '"'
+        " Double-quotes within double-quotes will not work in the
+        " command-line.If the 'shellxquote' option is set to double-quotes,
+        " then escape the double-quotes in the ctags command-line.
+        let ctags_cmd = escape(ctags_cmd, '"')
+    endif
+
+    " In Windows 95, if not using cygwin, disable the 'shellslash'
+    " option. Otherwise, this will cause problems when running the
+    " ctags command.
+    if has('win95') && !has('win32unix')
+        let old_shellslash = &shellslash
+        set noshellslash
+    endif
+
+    if has('win32') && !has('win32unix') && !has('win95')
+                \ && (&shell =~ 'cmd.exe')
+        " Windows does not correctly deal with commands that have more than 1
+        " set of double quotes.  It will strip them all resulting in:
+        " 'C:\Program' is not recognized as an internal or external command
+        " operable program or batch file.  To work around this, place the
+        " command inside a batch file and call the batch file.
+        " Do this only on Win2K, WinXP and above.
+        " Contributed by: David Fishburn.
+        let s:taglist_tempfile = fnamemodify(tempname(), ':h') .
+                    \ '\taglist.cmd'
+        exe 'redir! > ' . s:taglist_tempfile
+        silent echo ctags_cmd
+        redir END
+
+        call s:Tlist_Log_Msg('Cmd inside batch file: ' . ctags_cmd)
+        let ctags_cmd = '"' . s:taglist_tempfile . '"'
+    endif
+
+    call s:Tlist_Log_Msg('Cmd: ' . ctags_cmd)
+
+    " Run ctags and get the tag list
+    let cmd_output = system(ctags_cmd)
+
+    " Restore the value of the 'shellslash' option.
+    if has('win95') && !has('win32unix')
+        let &shellslash = old_shellslash
+    endif
+
+    if exists('s:taglist_tempfile')
+        " Delete the temporary cmd file created on MS-Windows
+        call delete(s:taglist_tempfile)
+    endif
+
+    " Handle errors
+    if v:shell_error
+        let msg = "Taglist: Failed to generate tags for " . a:filename
+        call s:Tlist_Warning_Msg(msg)
+        if cmd_output != ''
+            call s:Tlist_Warning_Msg(cmd_output)
+        endif
+        return fidx
+    endif
+
+    " Store the modification time for the file
+    let s:tlist_{fidx}_mtime = getftime(a:filename)
+
+    " No tags for current file
+    if cmd_output == ''
+        call s:Tlist_Log_Msg('No tags defined in ' . a:filename)
+        return fidx
+    endif
+
+    call s:Tlist_Log_Msg('Generated tags information for ' . a:filename)
+
+    if v:version > 601
+        " The following script local variables are used by the
+        " Tlist_Parse_Tagline() function.
+        let s:ctags_flags = s:tlist_{a:ftype}_ctags_flags
+        let s:fidx = fidx
+        let s:tidx = 0
+
+        " Tlist_Parse_Tagline will adjust this accordingly
+        if !g:Tlist_Use_Horiz_Window && s:auto_width
+            let g:Tlist_WinWidth = 0
+        endif
+
+        " Process the ctags output one line at a time.  The substitute()
+        " command is used to parse the tag lines instead of using the
+        " matchstr()/stridx()/strpart() functions for performance reason
+        call substitute(cmd_output, "\\([^\n]\\+\\)\n",
+                    \ '\=s:Tlist_Parse_Tagline(submatch(1),a:ftype)', 'g')
+
+        " Save the number of tags for this file
+        let s:tlist_{fidx}_tag_count = s:tidx
+
+        " The following script local variables are no longer needed
+        unlet! s:ctags_flags
+        unlet! s:tidx
+        unlet! s:fidx
+    else
+        " Due to a bug in Vim earlier than version 6.1,
+        " we cannot use substitute() to parse the ctags output.
+        " Instead the slow str*() functions are used
+        let ctags_flags = s:tlist_{a:ftype}_ctags_flags
+        let tidx = 0
+
+        while cmd_output != ''
+            " Extract one line at a time
+            let idx = stridx(cmd_output, "\n")
+            let one_line = strpart(cmd_output, 0, idx)
+            " Remove the line from the tags output
+            let cmd_output = strpart(cmd_output, idx + 1)
+
+            if one_line == ''
+                " Line is not in proper tags format
+                continue
+            endif
+
+            " Extract the tag type
+            let ttype = s:Tlist_Extract_Tagtype(one_line)
+
+            " Make sure the tag type is a valid and supported one
+            if ttype == '' || stridx(ctags_flags, ttype) == -1
+                " Line is not in proper tags format or Tag type is not
+                " supported
+                continue
+            endif
+
+            " Update the total tag count
+            let tidx = tidx + 1
+
+            " The following variables are used to optimize this code.  Vim is
+            " slow in using curly brace names. To reduce the amount of
+            " processing needed, the curly brace variables are pre-processed
+            " here
+            let fidx_tidx = 's:tlist_' . fidx . '_' . tidx
+            let fidx_ttype = 's:tlist_' . fidx . '_' . ttype
+
+            " Update the count of this tag type
+            let ttype_idx = {fidx_ttype}_count + 1
+            let {fidx_ttype}_count = ttype_idx
+
+            " Store the ctags output for this tag
+            let {fidx_tidx}_tag = one_line
+
+            " Store the tag index and the tag type index (back pointers)
+            let {fidx_ttype}_{ttype_idx} = tidx
+            let {fidx_tidx}_ttype_idx = ttype_idx
+
+            " Extract the tag name
+            let tag_name = strpart(one_line, 0, stridx(one_line, "\t"))
+
+            " Extract the tag scope/prototype
+            if g:Tlist_Display_Prototype
+                let ttxt = '    ' . s:Tlist_Get_Tag_Prototype(fidx, tidx)
+            else
+                let ttxt = '    ' . tag_name
+
+                " Add the tag scope, if it is available and is configured. Tag
+                " scope is the last field after the 'line:<num>\t' field
+                if g:Tlist_Display_Tag_Scope
+                    let ttxt .= s:Tlist_Get_Scope_String(a:tag_line, a:ftype)
+                endif
+            endif
+
+            " Add this tag to the tag type variable
+            let {fidx_ttype} = {fidx_ttype} . ttxt . "\n"
+
+            " Save the tag name
+            let {fidx_tidx}_tag_name = tag_name
+        endwhile
+
+        " Save the number of tags for this file
+        let s:tlist_{fidx}_tag_count = tidx
+    endif
+
+    call s:Tlist_Log_Msg('Processed ' . s:tlist_{fidx}_tag_count . 
+                \ ' tags in ' . a:filename)
+
+    return fidx
+endfunction
+
+" Tlist_Update_File
+" Update the tags for a file (if needed)
+function! Tlist_Update_File(filename, ftype)
+    call s:Tlist_Log_Msg('Tlist_Update_File (' . a:filename . ')')
+    " If the file doesn't support tag listing, skip it
+    if s:Tlist_Skip_File(a:filename, a:ftype)
+        return
+    endif
+
+    " Convert the file name to a full path
+    let fname = fnamemodify(a:filename, ':p')
+
+    " First check whether the file already exists
+    let fidx = s:Tlist_Get_File_Index(fname)
+
+    if fidx != -1 && s:tlist_{fidx}_valid
+        " File exists and the tags are valid
+        " Check whether the file was modified after the last tags update
+        " If it is modified, then update the tags
+        if s:tlist_{fidx}_mtime == getftime(fname)
+            return
+        endif
+    else
+        " If the tags were removed previously based on a user request,
+        " as we are going to update the tags (based on the user request),
+        " remove the filename from the deleted list
+        call s:Tlist_Update_Remove_List(fname, 0)
+    endif
+
+    " If the taglist window is opened, update it
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum == -1
+        " Taglist window is not present. Just update the taglist
+        " and return
+        call s:Tlist_Process_File(fname, a:ftype)
+    else
+        if g:Tlist_Show_One_File && s:tlist_cur_file_idx != -1
+            " If tags for only one file are displayed and we are not
+            " updating the tags for that file, then no need to
+            " refresh the taglist window. Otherwise, the taglist
+            " window should be updated.
+            if s:tlist_{s:tlist_cur_file_idx}_filename != fname
+                call s:Tlist_Process_File(fname, a:ftype)
+                return
+            endif
+        endif
+
+        " Save the current window number
+        let save_winnr = winnr()
+
+        " Goto the taglist window
+        call s:Tlist_Window_Goto_Window()
+
+        " Save the cursor position
+        let save_line = line('.')
+        let save_col = col('.')
+
+        " Update the taglist window
+        call s:Tlist_Window_Refresh_File(fname, a:ftype)
+
+        " Restore the cursor position
+        if v:version >= 601
+            call cursor(save_line, save_col)
+        else
+            exe save_line
+            exe 'normal! ' . save_col . '|'
+        endif
+
+        if winnr() != save_winnr
+            " Go back to the original window
+            call s:Tlist_Exe_Cmd_No_Acmds(save_winnr . 'wincmd w')
+        endif
+    endif
+
+    " Update the taglist menu
+    if g:Tlist_Show_Menu
+        call s:Tlist_Menu_Update_File(1)
+    endif
+endfunction
+
+" Tlist_Window_Close
+" Close the taglist window
+function! s:Tlist_Window_Close()
+    call s:Tlist_Log_Msg('Tlist_Window_Close()')
+    " Make sure the taglist window exists
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum == -1
+        call s:Tlist_Warning_Msg('Error: Taglist window is not open')
+        return
+    endif
+
+    if winnr() == winnum
+        " Already in the taglist window. Close it and return.
+        " Store the buffer that was selected prior to the taglist buffer
+        let prev_buf = bufnr('#')
+        if winbufnr(2) != -1
+            " If a window other than the taglist window is open,
+            " then only close the taglist window.
+            close
+            call s:Tlist_Exe_Cmd_No_Acmds(bufwinnr(prev_buf) . 'wincmd w')
+        endif
+    else
+        " Goto the taglist window, close it and then come back to the
+        " original window
+        let curbufnr = bufnr('%')
+        exe winnum . 'wincmd w'
+        close
+        " Need to jump back to the original window only if we are not
+        " already in that window
+        let winnum = bufwinnr(curbufnr)
+        if winnr() != winnum
+            exe winnum . 'wincmd w'
+        endif
+    endif
+endfunction
+
+" Tlist_Window_Mark_File_Window
+" Mark the current window as the file window to use when jumping to a tag.
+" Only if the current window is a non-plugin, non-preview and non-taglist
+" window
+function! s:Tlist_Window_Mark_File_Window()
+    if getbufvar('%', '&buftype') == '' && !&previewwindow
+        let w:tlist_file_window = "yes"
+    endif
+endfunction
+
+" Tlist_Window_Open
+" Open and refresh the taglist window
+function! s:Tlist_Window_Open()
+    call s:Tlist_Log_Msg('Tlist_Window_Open()')
+    " If the window is open, jump to it
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        " Jump to the existing window
+        if winnr() != winnum
+            exe winnum . 'wincmd w'
+        endif
+        return
+    endif
+
+    if s:tlist_app_name == "winmanager"
+        " Taglist plugin is no longer part of the winmanager app
+        let s:tlist_app_name = "none"
+    endif
+
+    " Get the filename and filetype for the specified buffer
+    let curbuf_name = fnamemodify(bufname('%'), ':p')
+    let curbuf_ftype = s:Tlist_Get_Buffer_Filetype('%')
+    let cur_lnum = line('.')
+
+    " Mark the current window as the desired window to open a file when a tag
+    " is selected.
+    call s:Tlist_Window_Mark_File_Window()
+
+    " Open the taglist window
+    call s:Tlist_Window_Create()
+
+    call s:Tlist_Window_Refresh()
+
+    if g:Tlist_Show_One_File
+        " Add only the current buffer and file
+        "
+        " If the file doesn't support tag listing, skip it
+        if !s:Tlist_Skip_File(curbuf_name, curbuf_ftype)
+            call s:Tlist_Window_Refresh_File(curbuf_name, curbuf_ftype)
+        endif
+    endif
+
+    if g:Tlist_File_Fold_Auto_Close
+        " Open the fold for the current file, as all the folds in
+        " the taglist window are closed
+        let fidx = s:Tlist_Get_File_Index(curbuf_name)
+        if fidx != -1
+            exe "silent! " . s:tlist_{fidx}_start . "," .
+                        \ s:tlist_{fidx}_end . "foldopen!"
+        endif
+    endif
+
+    " Highlight the current tag
+    call s:Tlist_Window_Highlight_Tag(curbuf_name, cur_lnum, 1, 1)
+endfunction
+
+" Tlist_Window_Toggle()
+" Open or close a taglist window
+function! s:Tlist_Window_Toggle()
+    call s:Tlist_Log_Msg('Tlist_Window_Toggle()')
+    " If taglist window is open then close it.
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        call s:Tlist_Window_Close()
+        return
+    endif
+
+    " Store the current buffer
+    let current_buf = winbufnr(0)
+    call s:Tlist_Window_Open()
+
+    " Go back to the original window, if Tlist_GainFocus_On_ToggleOpen is not
+    " set
+    if !g:Tlist_GainFocus_On_ToggleOpen
+        let prev_win = bufwinnr(current_buf)
+        call s:Tlist_Exe_Cmd_No_Acmds(prev_win . 'wincmd w')
+    endif
+
+    " Update the taglist menu
+    if g:Tlist_Show_Menu
+        call s:Tlist_Menu_Update_File(0)
+    endif
+endfunction
+
+" Tlist_Process_Filelist
+" Process multiple files. Each filename is separated by "\n"
+" Returns the number of processed files
+function! s:Tlist_Process_Filelist(file_names)
+    let flist = a:file_names
+
+    " Enable lazy screen updates
+    let old_lazyredraw = &lazyredraw
+    set lazyredraw
+
+    " Keep track of the number of processed files
+    let fcnt = 0
+
+    " Process one file at a time
+    while flist != ''
+        let nl_idx = stridx(flist, "\n")
+        let one_file = strpart(flist, 0, nl_idx)
+
+        " Remove the filename from the list
+        let flist = strpart(flist, nl_idx + 1)
+
+        if one_file == ''
+            continue
+        endif
+
+        " Skip directories
+        if isdirectory(one_file)
+            continue
+        endif
+
+        let ftype = s:Tlist_Detect_Filetype(one_file)
+
+        echon "\r                                                              "
+        echon "\rProcessing tags for " . fnamemodify(one_file, ':p:t')
+
+        let fcnt = fcnt + 1
+
+        call Tlist_Update_File(one_file, ftype)
+    endwhile
+
+    " Clear the displayed informational messages
+    echon "\r                                                            "
+
+    " Restore the previous state
+    let &lazyredraw = old_lazyredraw
+
+    return fcnt
+endfunction
+
+" Tlist_Process_Dir
+" Process the files in a directory matching the specified pattern
+function! s:Tlist_Process_Dir(dir_name, pat)
+    let flist = glob(a:dir_name . '/' . a:pat) . "\n"
+
+    let fcnt = s:Tlist_Process_Filelist(flist)
+
+    let len = strlen(a:dir_name)
+    if a:dir_name[len - 1] == '\' || a:dir_name[len - 1] == '/'
+        let glob_expr = a:dir_name . '*'
+    else
+        let glob_expr = a:dir_name . '/*'
+    endif
+    let all_files = glob(glob_expr) . "\n"
+
+    while all_files != ''
+        let nl_idx = stridx(all_files, "\n")
+        let one_file = strpart(all_files, 0, nl_idx)
+
+        let all_files = strpart(all_files, nl_idx + 1)
+        if one_file == ''
+            continue
+        endif
+
+        " Skip non-directory names
+        if !isdirectory(one_file)
+            continue
+        endif
+
+        echon "\r                                                              "
+        echon "\rProcessing files in directory " . fnamemodify(one_file, ':t')
+        let fcnt = fcnt + s:Tlist_Process_Dir(one_file, a:pat)
+    endwhile
+
+    return fcnt
+endfunction
+
+" Tlist_Add_Files_Recursive
+" Add files recursively from a directory
+function! s:Tlist_Add_Files_Recursive(dir, ...)
+    let dir_name = fnamemodify(a:dir, ':p')
+    if !isdirectory(dir_name)
+        call s:Tlist_Warning_Msg('Error: ' . dir_name . ' is not a directory')
+        return
+    endif
+
+    if a:0 == 1
+        " User specified file pattern
+        let pat = a:1
+    else
+        " Default file pattern
+        let pat = '*'
+    endif
+
+    echon "\r                                                              "
+    echon "\rProcessing files in directory " . fnamemodify(dir_name, ':t')
+    let fcnt = s:Tlist_Process_Dir(dir_name, pat)
+
+    echon "\rAdded " . fcnt . " files to the taglist"
+endfunction
+
+" Tlist_Add_Files
+" Add the specified list of files to the taglist
+function! s:Tlist_Add_Files(...)
+    let flist = ''
+    let i = 1
+
+    " Get all the files matching the file patterns supplied as argument
+    while i <= a:0
+        let flist = flist . glob(a:{i}) . "\n"
+        let i = i + 1
+    endwhile
+
+    if flist == ''
+        call s:Tlist_Warning_Msg('Error: No matching files are found')
+        return
+    endif
+
+    let fcnt = s:Tlist_Process_Filelist(flist)
+    echon "\rAdded " . fcnt . " files to the taglist"
+endfunction
+
+" Tlist_Extract_Tagtype
+" Extract the tag type from the tag text
+function! s:Tlist_Extract_Tagtype(tag_line)
+    " The tag type is after the tag prototype field. The prototype field
+    " ends with the /;"\t string. We add 4 at the end to skip the characters
+    " in this special string..
+    let start = strridx(a:tag_line, '/;"' . "\t") + 4
+    let end = match(a:tag_line,  'line\(no\)\?:') - 1
+    let ttype = strpart(a:tag_line, start, end - start)
+
+    return ttype
+endfunction
+
+" Tlist_Extract_Tag_Scope
+" Extract the tag scope from the tag text
+function! s:Tlist_Extract_Tag_Scope(tag_line)
+    let start = match(a:tag_line, 'line\(no\)\?:')
+    let end = stridx(a:tag_line, "\t", start)
+    if end <= start
+        return {}
+    endif
+
+    let tag_extras = {}
+
+    let tag_extra = strpart(a:tag_line, end + 1)
+    while tag_extra != ''
+        let tag_extra_separator_start = stridx(tag_extra, ':')
+        let tag_extra_content_start = tag_extra_separator_start + 1
+        let tag_extra_content_end = stridx(tag_extra, "\t")
+        if tag_extra_content_end == -1
+            let tag_extra_content_end = strlen(tag_extra)
+        endif
+        let tag_extra_name = strpart(tag_extra, 0, tag_extra_separator_start)
+        let tag_extra_content = strpart(tag_extra, tag_extra_content_start, tag_extra_content_end - tag_extra_content_start)
+        let tag_extras[tag_extra_name] = tag_extra_content
+        let tag_extra = strpart(tag_extra, tag_extra_content_end + 1)
+    endwhile
+
+    return tag_extras
+endfunction
+
+function! s:Tlist_Window_Toggle_Extra(ftype, extra_name)
+    if !exists('g:Tlist_{a:ftype}_Hide_Extras')
+        return
+    endif
+    let index = index(g:Tlist_{a:ftype}_Hide_Extras, a:extra_name)
+    if index == -1
+        call add(g:Tlist_{a:ftype}_Hide_Extras, a:extra_name)
+    else
+        unlet g:Tlist_{a:ftype}_Hide_Extras[index]
+    endif
+    if s:auto_width
+        let g:Tlist_WinWidth = 30
+    endif
+
+    let cur_lnum = line('.')
+    let cur_col = col('.')
+    call s:Tlist_Window_Update_File()
+    call s:Tlist_Window_Check_Width()
+    call cursor(cur_lnum, cur_col)
+endfunction
+
+" Tlist_Refresh()
+" Refresh the taglist
+function! s:Tlist_Refresh()
+    call s:Tlist_Log_Msg('Tlist_Refresh (Skip_Refresh = ' .
+                \ s:Tlist_Skip_Refresh . ', ' . bufname('%') . ')')
+    " If we are entering the buffer from one of the taglist functions, then
+    " no need to refresh the taglist window again.
+    if s:Tlist_Skip_Refresh
+        " We still need to update the taglist menu
+        if g:Tlist_Show_Menu
+            call s:Tlist_Menu_Update_File(0)
+        endif
+        return
+    endif
+
+    " If part of the winmanager plugin and not configured to process
+    " tags always and not configured to display the tags menu, then return
+    if (s:tlist_app_name == 'winmanager') && !g:Tlist_Process_File_Always
+                \ && !g:Tlist_Show_Menu
+        return
+    endif
+
+    " Skip buffers with 'buftype' set to nofile, nowrite, quickfix or help
+    if &buftype != ''
+        return
+    endif
+
+    let filename = fnamemodify(bufname('%'), ':p')
+    let ftype = s:Tlist_Get_Buffer_Filetype('%')
+
+    " If the file doesn't support tag listing, skip it
+    if s:Tlist_Skip_File(filename, ftype)
+        return
+    endif
+
+    let tlist_win = bufwinnr(g:TagList_title)
+
+    " If the taglist window is not opened and not configured to process
+    " tags always and not displaying the tags menu, then return
+    if tlist_win == -1 && !g:Tlist_Process_File_Always && !g:Tlist_Show_Menu
+        return
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(filename)
+    if fidx == -1
+        " Check whether this file is removed based on user request
+        " If it is, then don't display the tags for this file
+        if s:Tlist_User_Removed_File(filename)
+            return
+        endif
+
+        " If the taglist should not be auto updated, then return
+        if !g:Tlist_Auto_Update
+            return
+        endif
+    endif
+
+    let cur_lnum = line('.')
+
+    if fidx == -1
+        " Update the tags for the file
+        let fidx = s:Tlist_Process_File(filename, ftype)
+    else
+        let mtime = getftime(filename)
+        if s:tlist_{fidx}_mtime != mtime
+            " Invalidate the tags listed for this file
+            let s:tlist_{fidx}_valid = 0
+
+            " Update the taglist and the window
+            call Tlist_Update_File(filename, ftype)
+
+            " Store the new file modification time
+            let s:tlist_{fidx}_mtime = mtime
+        endif
+    endif
+
+    " Update the taglist window
+    if tlist_win != -1
+        " Disable screen updates
+        let old_lazyredraw = &lazyredraw
+        set nolazyredraw
+
+        " Save the current window number
+        let save_winnr = winnr()
+
+        " Goto the taglist window
+        call s:Tlist_Window_Goto_Window()
+
+        if !g:Tlist_Auto_Highlight_Tag || !g:Tlist_Highlight_Tag_On_BufEnter
+            " Save the cursor position
+            let save_line = line('.')
+            let save_col = col('.')
+        endif
+
+        " Update the taglist window
+        call s:Tlist_Window_Refresh_File(filename, ftype)
+
+        " Open the fold for the file
+        exe "silent! " . s:tlist_{fidx}_start . "," .
+                    \ s:tlist_{fidx}_end . "foldopen!"
+
+        if g:Tlist_Highlight_Tag_On_BufEnter && g:Tlist_Auto_Highlight_Tag
+            if g:Tlist_Show_One_File && s:tlist_cur_file_idx != fidx
+                " If displaying tags for only one file in the taglist
+                " window and about to display the tags for a new file,
+                " then center the current tag line for the new file
+                let center_tag_line = 1
+            else
+                let center_tag_line = 0
+            endif
+
+            " Highlight the current tag
+            call s:Tlist_Window_Highlight_Tag(filename, cur_lnum, 1, center_tag_line)
+        else
+            " Restore the cursor position
+            if v:version >= 601
+                call cursor(save_line, save_col)
+            else
+                exe save_line
+                exe 'normal! ' . save_col . '|'
+            endif
+        endif
+
+        " Jump back to the original window
+        if save_winnr != winnr()
+            call s:Tlist_Exe_Cmd_No_Acmds(save_winnr . 'wincmd w')
+        endif
+
+        " Restore screen updates
+        let &lazyredraw = old_lazyredraw
+    endif
+
+    " Update the taglist menu
+    if g:Tlist_Show_Menu
+        call s:Tlist_Menu_Update_File(0)
+    endif
+endfunction
+
+" Tlist_Change_Sort()
+" Change the sort order of the tag listing
+" caller == 'cmd', command used in the taglist window
+" caller == 'menu', taglist menu
+" action == 'toggle', toggle sort from name to order and vice versa
+" action == 'set', set the sort order to sort_type
+function! s:Tlist_Change_Sort(caller, action, sort_type)
+    call s:Tlist_Log_Msg('Tlist_Change_Sort (caller = ' . a:caller .
+            \ ', action = ' . a:action . ', sort_type = ' . a:sort_type . ')')
+    if a:caller == 'cmd'
+        let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
+        if fidx == -1
+            return
+        endif
+
+        " Remove the previous highlighting
+        match none
+    elseif a:caller == 'menu'
+        let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
+        if fidx == -1
+            return
+        endif
+    endif
+
+    if a:action == 'toggle'
+        let sort_type = s:tlist_{fidx}_sort_type
+
+        " Toggle the sort order from 'name' to 'order' and vice versa
+        if sort_type == 'name'
+            let s:tlist_{fidx}_sort_type = 'order'
+        else
+            let s:tlist_{fidx}_sort_type = 'name'
+        endif
+    else
+        let s:tlist_{fidx}_sort_type = a:sort_type
+    endif
+
+    " Invalidate the tags listed for this file
+    let s:tlist_{fidx}_valid = 0
+
+    if a:caller  == 'cmd'
+        " Save the current line for later restoration
+        let curline = '\V\^' . getline('.') . '\$'
+
+        call s:Tlist_Window_Refresh_File(s:tlist_{fidx}_filename,
+                    \   s:tlist_{fidx}_filetype)
+
+        exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'foldopen!'
+
+        " Go back to the cursor line before the tag list is sorted
+        call search(curline, 'w')
+
+        call s:Tlist_Menu_Update_File(1)
+    else
+        call s:Tlist_Menu_Remove_File()
+
+        call s:Tlist_Refresh()
+    endif
+endfunction
+
+" Tlist_Update_Current_File()
+" Update taglist for the current buffer by regenerating the tag list
+" Contributed by WEN Guopeng.
+function! s:Tlist_Update_Current_File()
+    call s:Tlist_Log_Msg('Tlist_Update_Current_File()')
+    if winnr() == bufwinnr(g:TagList_title)
+        " In the taglist window. Update the current file
+        call s:Tlist_Window_Update_File()
+    else
+        " Not in the taglist window. Update the current buffer
+        let filename = fnamemodify(bufname('%'), ':p')
+        let fidx = s:Tlist_Get_File_Index(filename)
+        if fidx != -1
+            let s:tlist_{fidx}_valid = 0
+        endif
+        let ft = s:Tlist_Get_Buffer_Filetype('%')
+        call Tlist_Update_File(filename, ft)
+    endif
+endfunction
+
+" Tlist_Window_Update_File()
+" Update the tags displayed in the taglist window
+function! s:Tlist_Window_Update_File()
+    call s:Tlist_Log_Msg('Tlist_Window_Update_File()')
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
+    if fidx == -1
+        return
+    endif
+
+    " Remove the previous highlighting
+    match none
+
+    " Save the current line for later restoration
+    let curline = '\V\^' . getline('.') . '\$'
+
+    let s:tlist_{fidx}_valid = 0
+
+    " Update the taglist window
+    call s:Tlist_Window_Refresh_File(s:tlist_{fidx}_filename,
+                \ s:tlist_{fidx}_filetype)
+
+    exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'foldopen!'
+
+    " Go back to the tag line before the list is updated
+    call search(curline, 'w')
+endfunction
+
+" Tlist_Window_Get_Tag_Type_By_Linenum()
+" Return the tag type index for the specified line in the taglist window
+function! s:Tlist_Window_Get_Tag_Type_By_Linenum(fidx, lnum)
+    let ftype = s:tlist_{a:fidx}_filetype
+
+    " Determine to which tag type the current line number belongs to using the
+    " tag type start line number and the number of tags in a tag type
+    let i = 1
+    while i <= s:tlist_{ftype}_count
+        let ttype = s:tlist_{ftype}_{i}_name
+        let start_lnum =
+                    \ s:tlist_{a:fidx}_start + s:tlist_{a:fidx}_{ttype}_offset
+        let end =  start_lnum + s:tlist_{a:fidx}_{ttype}_count
+        if a:lnum >= start_lnum && a:lnum <= end
+            break
+        endif
+        let i = i + 1
+    endwhile
+
+    " Current line doesn't belong to any of the displayed tag types
+    if i > s:tlist_{ftype}_count
+        return ''
+    endif
+
+    return ttype
+endfunction
+
+" Tlist_Window_Get_Tag_Index()
+" Return the tag index for the specified line in the taglist window
+function! s:Tlist_Window_Get_Tag_Index(fidx, lnum)
+    let ttype = s:Tlist_Window_Get_Tag_Type_By_Linenum(a:fidx, a:lnum)
+
+    " Current line doesn't belong to any of the displayed tag types
+    if ttype == ''
+        return 0
+    endif
+
+    " Compute the index into the displayed tags for the tag type
+    let ttype_lnum = s:tlist_{a:fidx}_start + s:tlist_{a:fidx}_{ttype}_offset
+    let tidx = a:lnum - ttype_lnum
+    if tidx == 0
+        return 0
+    endif
+
+    " Get the corresponding tag line and return it
+    return s:tlist_{a:fidx}_{ttype}_{tidx}
+endfunction
+
+" Tlist_Window_Highlight_Line
+" Highlight the current line
+function! s:Tlist_Window_Highlight_Line()
+    " Clear previously selected name
+    match none
+
+    " Highlight the current line
+    if g:Tlist_Display_Prototype == 0
+        let pat = '/\%' . line('.') . 'l\s\+\zs.*/'
+    else
+        let pat = '/\%' . line('.') . 'l.*/'
+    endif
+
+    exe 'match TagListTagName ' . pat
+endfunction
+
+" Tlist_Window_Open_File
+" Open the specified file in either a new window or an existing window
+" and place the cursor at the specified tag pattern
+function! s:Tlist_Window_Open_File(win_ctrl, filename, tagpat)
+    call s:Tlist_Log_Msg('Tlist_Window_Open_File (' . a:filename . ',' .
+                \ a:win_ctrl . ')')
+    let prev_Tlist_Skip_Refresh = s:Tlist_Skip_Refresh
+    let s:Tlist_Skip_Refresh = 1
+
+    if s:tlist_app_name == "winmanager"
+        " Let the winmanager edit the file
+        call WinManagerFileEdit(a:filename, a:win_ctrl == 'newwin')
+    else
+
+    if a:win_ctrl == 'newtab'
+        " Create a new tab
+        exe 'tabnew ' . escape(a:filename, ' ')
+        " Open the taglist window in the new tab
+        call s:Tlist_Window_Open()
+    endif
+
+    if a:win_ctrl == 'checktab'
+        " Check whether the file is present in any of the tabs.
+        " If the file is present in the current tab, then use the
+        " current tab.
+        if bufwinnr(a:filename) != -1
+            let file_present_in_tab = 1
+            let i = tabpagenr()
+        else
+            let i = 1
+            let bnum = bufnr(a:filename)
+            let file_present_in_tab = 0
+            while i <= tabpagenr('$')
+                if index(tabpagebuflist(i), bnum) != -1
+                    let file_present_in_tab = 1
+                    break
+                endif
+                let i += 1
+            endwhile
+        endif
+
+        if file_present_in_tab
+            " Goto the tab containing the file
+            exe 'tabnext ' . i
+        else
+            " Open a new tab
+            exe 'tabnew ' . escape(a:filename, ' ')
+
+            " Open the taglist window
+            call s:Tlist_Window_Open()
+        endif
+    endif
+
+    let winnum = -1
+    if a:win_ctrl == 'prevwin'
+        " Open the file in the previous window, if it is usable
+        let cur_win = winnr()
+        wincmd p
+        if &buftype == '' && !&previewwindow
+            exe "edit " . escape(a:filename, ' ')
+            let winnum = winnr()
+        else
+            " Previous window is not usable
+            exe cur_win . 'wincmd w'
+        endif
+    endif
+
+    " Goto the window containing the file.  If the window is not there, open a
+    " new window
+    if winnum == -1
+        let winnum = bufwinnr(a:filename)
+    endif
+
+    if winnum == -1
+        " Locate the previously used window for opening a file
+        let fwin_num = 0
+        let first_usable_win = 0
+
+        let i = 1
+        let bnum = winbufnr(i)
+        while bnum != -1
+            if getwinvar(i, 'tlist_file_window') == 'yes'
+                let fwin_num = i
+                break
+            endif
+            if first_usable_win == 0 &&
+                        \ getbufvar(bnum, '&buftype') == '' &&
+                        \ !getwinvar(i, '&previewwindow')
+                " First non-taglist, non-plugin and non-preview window
+                let first_usable_win = i
+            endif
+            let i = i + 1
+            let bnum = winbufnr(i)
+        endwhile
+
+        " If a previously used window is not found, then use the first
+        " non-taglist window
+        if fwin_num == 0
+            let fwin_num = first_usable_win
+        endif
+
+        if fwin_num != 0
+            " Jump to the file window
+            exe fwin_num . "wincmd w"
+
+            " If the user asked to jump to the tag in a new window, then split
+            " the existing window into two.
+            if a:win_ctrl == 'newwin'
+                split
+            endif
+            exe "edit " . escape(a:filename, ' ')
+        else
+            " Open a new window
+            if g:Tlist_Use_Horiz_Window
+                exe 'leftabove split ' . escape(a:filename, ' ')
+            else
+                if winbufnr(2) == -1
+                    " Only the taglist window is present
+                    if g:Tlist_Use_Right_Window
+                        exe 'leftabove vertical split ' .
+                                    \ escape(a:filename, ' ')
+                    else
+                        exe 'rightbelow vertical split ' .
+                                    \ escape(a:filename, ' ')
+                    endif
+
+                    " Go to the taglist window to change the window size to
+                    " the user configured value
+                    call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
+                    if g:Tlist_Use_Horiz_Window
+                        exe 'resize ' . g:Tlist_WinHeight
+                    else
+                        exe 'vertical resize ' . g:Tlist_WinWidth
+                    endif
+                    " Go back to the file window
+                    call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
+                else
+                    " A plugin or help window is also present
+                    wincmd w
+                    exe 'leftabove split ' . escape(a:filename, ' ')
+                endif
+            endif
+        endif
+        " Mark the window, so that it can be reused.
+        call s:Tlist_Window_Mark_File_Window()
+    else
+        if v:version >= 700
+            " If the file is opened in more than one window, then check
+            " whether the last accessed window has the selected file.
+            " If it does, then use that window.
+            let lastwin_bufnum = winbufnr(winnr('#'))
+            if bufnr(a:filename) == lastwin_bufnum
+                let winnum = winnr('#')
+            endif
+        endif
+        exe winnum . 'wincmd w'
+
+        " If the user asked to jump to the tag in a new window, then split the
+        " existing window into two.
+        if a:win_ctrl == 'newwin'
+            split
+        endif
+    endif
+    endif
+
+    " Jump to the tag
+    if a:tagpat != ''
+        " Add the current cursor position to the jump list, so that user can
+        " jump back using the ' and ` marks.
+        mark '
+        silent call search(a:tagpat, 'w')
+
+        " Bring the line to the middle of the window
+        normal! z.
+
+        " If the line is inside a fold, open the fold
+        if foldclosed('.') != -1
+            .foldopen
+        endif
+    endif
+
+    " If the user selects to preview the tag then jump back to the
+    " taglist window
+    if a:win_ctrl == 'preview'
+        " Go back to the taglist window
+        let winnum = bufwinnr(g:TagList_title)
+        exe winnum . 'wincmd w'
+    else
+        " If the user has selected to close the taglist window, when a
+        " tag is selected, close the taglist  window
+        if g:Tlist_Close_On_Select
+            call s:Tlist_Window_Goto_Window()
+            close
+
+            " Go back to the window displaying the selected file
+            let wnum = bufwinnr(a:filename)
+            if wnum != -1 && wnum != winnr()
+                call s:Tlist_Exe_Cmd_No_Acmds(wnum . 'wincmd w')
+            endif
+        endif
+    endif
+
+    let s:Tlist_Skip_Refresh = prev_Tlist_Skip_Refresh
+endfunction
+
+" Tlist_Window_Jump_To_Tag()
+" Jump to the location of the current tag
+" win_ctrl == useopen - Reuse the existing file window
+" win_ctrl == newwin - Open a new window
+" win_ctrl == preview - Preview the tag
+" win_ctrl == prevwin - Open in previous window
+" win_ctrl == newtab - Open in new tab
+function! s:Tlist_Window_Jump_To_Tag(win_ctrl)
+    call s:Tlist_Log_Msg('Tlist_Window_Jump_To_Tag(' . a:win_ctrl . ')')
+    " Do not process comment lines and empty lines
+    let curline = getline('.')
+    if curline =~ '^\s*$' || curline[0] == '"'
+        return
+    endif
+
+    " If inside a closed fold, then use the first line of the fold
+    " and jump to the file.
+    let lnum = foldclosed('.')
+    if lnum == -1
+        " Jump to the selected tag or file
+        let lnum = line('.')
+    else
+        " Open the closed fold
+        .foldopen!
+    endif
+
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
+    if fidx == -1
+        return
+    endif
+
+    " Get the tag output for the current tag
+    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, lnum)
+    if tidx != 0
+        let tagpat = s:Tlist_Get_Tag_SearchPat(fidx, tidx)
+
+        " Highlight the tagline
+        call s:Tlist_Window_Highlight_Line()
+    else
+        " Selected a line which is not a tag name. Just edit the file
+        let tagpat = ''
+    endif
+
+    call s:Tlist_Window_Open_File(a:win_ctrl, s:tlist_{fidx}_filename, tagpat)
+endfunction
+
+" Tlist_Window_Show_Info()
+" Display information about the entry under the cursor
+function! s:Tlist_Window_Show_Info()
+    call s:Tlist_Log_Msg('Tlist_Window_Show_Info()')
+
+    " Clear the previously displayed line
+    echo
+
+    " Do not process comment lines and empty lines
+    let curline = getline('.')
+    if curline =~ '^\s*$' || curline[0] == '"'
+        return
+    endif
+
+    " If inside a fold, then don't display the prototype
+    if foldclosed('.') != -1
+        return
+    endif
+
+    let lnum = line('.')
+
+    " Get the file index
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
+    if fidx == -1
+        return
+    endif
+
+    if lnum == s:tlist_{fidx}_start
+        " Cursor is on a file name
+        let fname = s:tlist_{fidx}_filename
+        if strlen(fname) > 50
+            let fname = fnamemodify(fname, ':t')
+        endif
+        echo fname . ', Filetype=' . s:tlist_{fidx}_filetype .
+                    \  ', Tag count=' . s:tlist_{fidx}_tag_count
+        return
+    endif
+
+    " Get the tag output line for the current tag
+    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, lnum)
+    if tidx == 0
+        " Cursor is on a tag type
+        let ttype = s:Tlist_Window_Get_Tag_Type_By_Linenum(fidx, lnum)
+        if ttype == ''
+            return
+        endif
+
+        let ttype_name = ''
+
+        let ftype = s:tlist_{fidx}_filetype
+        let i = 1
+        while i <= s:tlist_{ftype}_count
+            if ttype == s:tlist_{ftype}_{i}_name
+                let ttype_name = s:tlist_{ftype}_{i}_fullname
+                break
+            endif
+            let i = i + 1
+        endwhile
+
+        echo 'Tag type=' . ttype_name .
+                    \ ', Tag count=' . s:tlist_{fidx}_{ttype}_count
+        return
+    endif
+
+    " Get the tag search pattern and display it
+    echo s:Tlist_Get_Tag_Prototype(fidx, tidx)
+endfunction
+
+" Tlist_Find_Nearest_Tag_Idx
+" Find the tag idx nearest to the supplied line number
+" Returns -1, if a tag couldn't be found for the specified line number
+function! s:Tlist_Find_Nearest_Tag_Idx(fidx, linenum)
+    let sort_type = s:tlist_{a:fidx}_sort_type
+
+    let left = 1
+    let right = s:tlist_{a:fidx}_tag_count
+
+    if sort_type == 'order'
+        " Tags sorted by order, use a binary search.
+        " The idea behind this function is taken from the ctags.vim script (by
+        " Alexey Marinichev) available at the Vim online website.
+
+        " If the current line is the less than the first tag, then no need to
+        " search
+        let first_lnum = s:Tlist_Get_Tag_Linenum(a:fidx, 1)
+
+        if a:linenum < first_lnum
+            return -1
+        endif
+
+        while left < right
+            let middle = (right + left + 1) / 2
+            let middle_lnum = s:Tlist_Get_Tag_Linenum(a:fidx, middle)
+
+            if middle_lnum == a:linenum
+                let left = middle
+                break
+            endif
+
+            if middle_lnum > a:linenum
+                let right = middle - 1
+            else
+                let left = middle
+            endif
+        endwhile
+    else
+        " Tags sorted by name, use a linear search. (contributed by Dave
+        " Eggum).
+        " Look for a tag with a line number less than or equal to the supplied
+        " line number. If multiple tags are found, then use the tag with the
+        " line number closest to the supplied line number. IOW, use the tag
+        " with the highest line number.
+        let closest_lnum = 0
+        let final_left = 0
+        while left <= right
+            let lnum = s:Tlist_Get_Tag_Linenum(a:fidx, left)
+
+            if lnum < a:linenum && lnum > closest_lnum
+                let closest_lnum = lnum
+                let final_left = left
+            elseif lnum == a:linenum
+                let closest_lnum = lnum
+                let final_left = left
+                break
+            else
+                let left = left + 1
+            endif
+        endwhile
+        if closest_lnum == 0
+            return -1
+        endif
+        if left >= right
+            let left = final_left
+        endif
+    endif
+
+    return left
+endfunction
+
+" Tlist_Window_Highlight_Tag()
+" Highlight the current tag
+" cntx == 1, Called by the taglist plugin itself
+" cntx == 2, Forced by the user through the TlistHighlightTag command
+" center = 1, move the tag line to the center of the taglist window
+function! s:Tlist_Window_Highlight_Tag(filename, cur_lnum, cntx, center)
+    " Highlight the current tag only if the user configured the
+    " taglist plugin to do so or if the user explictly invoked the
+    " command to highlight the current tag.
+    if !g:Tlist_Auto_Highlight_Tag && a:cntx == 1
+        return
+    endif
+
+    if a:filename == ''
+        return
+    endif
+
+    " Make sure the taglist window is present
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum == -1
+        call s:Tlist_Warning_Msg('Error: Taglist window is not open')
+        return
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(a:filename)
+    if fidx == -1
+        return
+    endif
+
+    " If the file is currently not displayed in the taglist window, then retrn
+    if !s:tlist_{fidx}_visible
+        return
+    endif
+
+    " If there are no tags for this file, then no need to proceed further
+    if s:tlist_{fidx}_tag_count == 0
+        return
+    endif
+
+    " Ignore all autocommands
+    let old_ei = &eventignore
+    set eventignore=all
+
+    " Save the original window number
+    let org_winnr = winnr()
+
+    if org_winnr == winnum
+        let in_taglist_window = 1
+    else
+        let in_taglist_window = 0
+    endif
+
+    " Go to the taglist window
+    if !in_taglist_window
+        exe winnum . 'wincmd w'
+    endif
+
+    " Clear previously selected name
+    match none
+
+    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, a:cur_lnum)
+    if tidx == -1
+        " Make sure the current tag line is visible in the taglist window.
+        " Calling the winline() function makes the line visible.  Don't know
+        " of a better way to achieve this.
+        let lnum = line('.')
+
+        if lnum < s:tlist_{fidx}_start || lnum > s:tlist_{fidx}_end
+            " Move the cursor to the beginning of the file
+            exe s:tlist_{fidx}_start
+        endif
+
+        if foldclosed('.') != -1
+            .foldopen
+        endif
+
+        call winline()
+
+        if !in_taglist_window
+            exe org_winnr . 'wincmd w'
+        endif
+
+        " Restore the autocommands
+        let &eventignore = old_ei
+        return
+    endif
+
+    " Extract the tag type
+    let ttype = s:Tlist_Get_Tag_Type_By_Tag(fidx, tidx)
+
+    " Compute the line number
+    " Start of file + Start of tag type + offset
+    let lnum = s:tlist_{fidx}_start + s:tlist_{fidx}_{ttype}_offset +
+                \ s:tlist_{fidx}_{tidx}_ttype_idx
+
+    " Goto the line containing the tag
+    exe lnum
+
+    " Open the fold
+    if foldclosed('.') != -1
+        .foldopen
+    endif
+
+    if a:center
+        " Move the tag line to the center of the taglist window
+        normal! z.
+    else
+        " Make sure the current tag line is visible in the taglist window.
+        " Calling the winline() function makes the line visible.  Don't know
+        " of a better way to achieve this.
+        call winline()
+    endif
+
+    " Highlight the tag name
+    call s:Tlist_Window_Highlight_Line()
+
+    " Go back to the original window
+    if !in_taglist_window
+        exe org_winnr . 'wincmd w'
+    endif
+
+    " Restore the autocommands
+    let &eventignore = old_ei
+    return
+endfunction
+
+" Tlist_Get_Tag_Prototype_By_Line
+" Get the prototype for the tag on or before the specified line number in the
+" current buffer
+function! Tlist_Get_Tag_Prototype_By_Line(...)
+    if a:0 == 0
+        " Arguments are not supplied. Use the current buffer name
+        " and line number
+        let filename = bufname('%')
+        let linenr = line('.')
+    elseif a:0 == 2
+        " Filename and line number are specified
+        let filename = a:1
+        let linenr = a:2
+        if linenr !~ '\d\+'
+            " Invalid line number
+            return ""
+        endif
+    else
+        " Sufficient arguments are not supplied
+        let msg =  'Usage: Tlist_Get_Tag_Prototype_By_Line <filename> ' .
+                                \ '<line_number>'
+        call s:Tlist_Warning_Msg(msg)
+        return ""
+    endif
+
+    " Expand the file to a fully qualified name
+    let filename = fnamemodify(filename, ':p')
+    if filename == ''
+        return ""
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(filename)
+    if fidx == -1
+        return ""
+    endif
+
+    " If there are no tags for this file, then no need to proceed further
+    if s:tlist_{fidx}_tag_count == 0
+        return ""
+    endif
+
+    " Get the tag text using the line number
+    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, linenr)
+    if tidx == -1
+        return ""
+    endif
+
+    return s:Tlist_Get_Tag_Prototype(fidx, tidx)
+endfunction
+
+" Tlist_Get_Tagname_By_Line
+" Get the tag name on or before the specified line number in the
+" current buffer
+function! Tlist_Get_Tagname_By_Line(...)
+    if a:0 == 0
+        " Arguments are not supplied. Use the current buffer name
+        " and line number
+        let filename = bufname('%')
+        let linenr = line('.')
+    elseif a:0 == 2
+        " Filename and line number are specified
+        let filename = a:1
+        let linenr = a:2
+        if linenr !~ '\d\+'
+            " Invalid line number
+            return ""
+        endif
+    else
+        " Sufficient arguments are not supplied
+        let msg =  'Usage: Tlist_Get_Tagname_By_Line <filename> <line_number>'
+        call s:Tlist_Warning_Msg(msg)
+        return ""
+    endif
+
+    " Make sure the current file has a name
+    let filename = fnamemodify(filename, ':p')
+    if filename == ''
+        return ""
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(filename)
+    if fidx == -1
+        return ""
+    endif
+
+    " If there are no tags for this file, then no need to proceed further
+    if s:tlist_{fidx}_tag_count == 0
+        return ""
+    endif
+
+    " Get the tag name using the line number
+    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, linenr)
+    if tidx == -1
+        return ""
+    endif
+
+    return s:tlist_{fidx}_{tidx}_tag_name
+endfunction
+
+" Tlist_Window_Move_To_File
+" Move the cursor to the beginning of the current file or the next file
+" or the previous file in the taglist window
+" dir == -1, move to start of current or previous function
+" dir == 1, move to start of next function
+function! s:Tlist_Window_Move_To_File(dir)
+    if foldlevel('.') == 0
+        " Cursor is on a non-folded line (it is not in any of the files)
+        " Move it to a folded line
+        if a:dir == -1
+            normal! zk
+        else
+            " While moving down to the start of the next fold,
+            " no need to do go to the start of the next file.
+            normal! zj
+            return
+        endif
+    endif
+
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
+    if fidx == -1
+        return
+    endif
+
+    let cur_lnum = line('.')
+
+    if a:dir == -1
+        if cur_lnum > s:tlist_{fidx}_start
+            " Move to the beginning of the current file
+            exe s:tlist_{fidx}_start
+            return
+        endif
+
+        if fidx != 0
+            " Move to the beginning of the previous file
+            let fidx = fidx - 1
+        else
+            " Cursor is at the first file, wrap around to the last file
+            let fidx = s:tlist_file_count - 1
+        endif
+
+        exe s:tlist_{fidx}_start
+        return
+    else
+        " Move to the beginning of the next file
+        let fidx = fidx + 1
+
+        if fidx >= s:tlist_file_count
+            " Cursor is at the last file, wrap around to the first file
+            let fidx = 0
+        endif
+
+        if s:tlist_{fidx}_start != 0
+            exe s:tlist_{fidx}_start
+        endif
+        return
+    endif
+endfunction
+
+" Tlist_Session_Load
+" Load a taglist session (information about all the displayed files
+" and the tags) from the specified file
+function! s:Tlist_Session_Load(...)
+    if a:0 == 0 || a:1 == ''
+        call s:Tlist_Warning_Msg('Usage: TlistSessionLoad <filename>')
+        return
+    endif
+
+    let sessionfile = a:1
+
+    if !filereadable(sessionfile)
+        let msg = 'Taglist: Error - Unable to open file ' . sessionfile
+        call s:Tlist_Warning_Msg(msg)
+        return
+    endif
+
+    " Mark the current window as the file window
+    call s:Tlist_Window_Mark_File_Window()
+
+    " Source the session file
+    exe 'source ' . sessionfile
+
+    let new_file_count = g:tlist_file_count
+    unlet! g:tlist_file_count
+
+    let i = 0
+    while i < new_file_count
+        let ftype = g:tlist_{i}_filetype
+        unlet! g:tlist_{i}_filetype
+
+        if !exists('s:tlist_' . ftype . '_count')
+            if s:Tlist_FileType_Init(ftype) == 0
+                let i = i + 1
+                continue
+            endif
+        endif
+
+        let fname = g:tlist_{i}_filename
+        unlet! g:tlist_{i}_filename
+
+        let fidx = s:Tlist_Get_File_Index(fname)
+        if fidx != -1
+            let s:tlist_{fidx}_visible = 0
+            let i = i + 1
+            continue
+        else
+            " As we are loading the tags from the session file, if this
+            " file was previously deleted by the user, now we need to
+            " add it back. So remove the file from the deleted list.
+            call s:Tlist_Update_Remove_List(fname, 0)
+        endif
+
+        let fidx = s:Tlist_Init_File(fname, ftype)
+
+        let s:tlist_{fidx}_filename = fname
+
+        let s:tlist_{fidx}_sort_type = g:tlist_{i}_sort_type
+        unlet! g:tlist_{i}_sort_type
+
+        let s:tlist_{fidx}_filetype = ftype
+        let s:tlist_{fidx}_mtime = getftime(fname)
+
+        let s:tlist_{fidx}_start = 0
+        let s:tlist_{fidx}_end = 0
+
+        let s:tlist_{fidx}_valid = 1
+
+        let s:tlist_{fidx}_tag_count = g:tlist_{i}_tag_count
+        unlet! g:tlist_{i}_tag_count
+
+        let j = 1
+        while j <= s:tlist_{fidx}_tag_count
+            let s:tlist_{fidx}_{j}_tag = g:tlist_{i}_{j}_tag
+            let s:tlist_{fidx}_{j}_tag_name = g:tlist_{i}_{j}_tag_name
+            let s:tlist_{fidx}_{j}_ttype_idx = g:tlist_{i}_{j}_ttype_idx
+            unlet! g:tlist_{i}_{j}_tag
+            unlet! g:tlist_{i}_{j}_tag_name
+            unlet! g:tlist_{i}_{j}_ttype_idx
+            let j = j + 1
+        endwhile
+
+        let j = 1
+        while j <= s:tlist_{ftype}_count
+            let ttype = s:tlist_{ftype}_{j}_name
+
+            if exists('g:tlist_' . i . '_' . ttype)
+                let s:tlist_{fidx}_{ttype} = g:tlist_{i}_{ttype}
+                unlet! g:tlist_{i}_{ttype}
+                let s:tlist_{fidx}_{ttype}_offset = 0
+                let s:tlist_{fidx}_{ttype}_count = g:tlist_{i}_{ttype}_count
+                unlet! g:tlist_{i}_{ttype}_count
+
+                let k = 1
+                while k <= s:tlist_{fidx}_{ttype}_count
+                    let s:tlist_{fidx}_{ttype}_{k} = g:tlist_{i}_{ttype}_{k}
+                    unlet! g:tlist_{i}_{ttype}_{k}
+                    let k = k + 1
+                endwhile
+            else
+                let s:tlist_{fidx}_{ttype} = ''
+                let s:tlist_{fidx}_{ttype}_offset = 0
+                let s:tlist_{fidx}_{ttype}_count = 0
+            endif
+
+            let j = j + 1
+        endwhile
+
+        let i = i + 1
+    endwhile
+
+    " If the taglist window is open, then update it
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        let save_winnr = winnr()
+
+        " Goto the taglist window
+        call s:Tlist_Window_Goto_Window()
+
+        " Refresh the taglist window
+        call s:Tlist_Window_Refresh()
+
+        " Go back to the original window
+        if save_winnr != winnr()
+            call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
+        endif
+    endif
+endfunction
+
+" Tlist_Session_Save
+" Save a taglist session (information about all the displayed files
+" and the tags) into the specified file
+function! s:Tlist_Session_Save(...)
+    if a:0 == 0 || a:1 == ''
+        call s:Tlist_Warning_Msg('Usage: TlistSessionSave <filename>')
+        return
+    endif
+
+    let sessionfile = a:1
+
+    if s:tlist_file_count == 0
+        " There is nothing to save
+        call s:Tlist_Warning_Msg('Warning: Taglist is empty. Nothing to save.')
+        return
+    endif
+
+    if filereadable(sessionfile)
+        let ans = input('Do you want to overwrite ' . sessionfile . ' (Y/N)?')
+        if ans !=? 'y'
+            return
+        endif
+
+        echo "\n"
+    endif
+
+    let old_verbose = &verbose
+    set verbose&vim
+
+    exe 'redir! > ' . sessionfile
+
+    silent! echo '" Taglist session file. This file is auto-generated.'
+    silent! echo '" File information'
+    silent! echo 'let tlist_file_count = ' . s:tlist_file_count
+
+    let i = 0
+
+    while i < s:tlist_file_count
+        " Store information about the file
+        silent! echo 'let tlist_' . i . "_filename = '" .
+                                            \ s:tlist_{i}_filename . "'"
+        silent! echo 'let tlist_' . i . '_sort_type = "' .
+                                                \ s:tlist_{i}_sort_type . '"'
+        silent! echo 'let tlist_' . i . '_filetype = "' .
+                                            \ s:tlist_{i}_filetype . '"'
+        silent! echo 'let tlist_' . i . '_tag_count = ' .
+                                                        \ s:tlist_{i}_tag_count
+        " Store information about all the tags
+        let j = 1
+        while j <= s:tlist_{i}_tag_count
+            let txt = escape(s:tlist_{i}_{j}_tag, '"\\')
+            silent! echo 'let tlist_' . i . '_' . j . '_tag = "' . txt . '"'
+            silent! echo 'let tlist_' . i . '_' . j . '_tag_name = "' .
+                        \ s:tlist_{i}_{j}_tag_name . '"'
+            silent! echo 'let tlist_' . i . '_' . j . '_ttype_idx' . ' = ' .
+                        \ s:tlist_{i}_{j}_ttype_idx
+            let j = j + 1
+        endwhile
+
+        " Store information about all the tags grouped by their type
+        let ftype = s:tlist_{i}_filetype
+        let j = 1
+        while j <= s:tlist_{ftype}_count
+            let ttype = s:tlist_{ftype}_{j}_name
+            if s:tlist_{i}_{ttype}_count != 0
+                let txt = escape(s:tlist_{i}_{ttype}, '"\')
+                let txt = substitute(txt, "\n", "\\\\n", 'g')
+                silent! echo 'let tlist_' . i . '_' . ttype . ' = "' .
+                                                \ txt . '"'
+                silent! echo 'let tlist_' . i . '_' . ttype . '_count = ' .
+                                                     \ s:tlist_{i}_{ttype}_count
+                let k = 1
+                while k <= s:tlist_{i}_{ttype}_count
+                    silent! echo 'let tlist_' . i . '_' . ttype . '_' . k .
+                                \ ' = ' . s:tlist_{i}_{ttype}_{k}
+                    let k = k + 1
+                endwhile
+            endif
+            let j = j + 1
+        endwhile
+
+        silent! echo
+
+        let i = i + 1
+    endwhile
+
+    redir END
+
+    let &verbose = old_verbose
+endfunction
+
+" Tlist_Buffer_Removed
+" A buffer is removed from the Vim buffer list. Remove the tags defined
+" for that file
+function! s:Tlist_Buffer_Removed(filename)
+    call s:Tlist_Log_Msg('Tlist_Buffer_Removed (' . a:filename .  ')')
+
+    " Make sure a valid filename is supplied
+    if a:filename == ''
+        return
+    endif
+
+    " Get tag list index of the specified file
+    let fidx = s:Tlist_Get_File_Index(a:filename)
+    if fidx == -1
+        " File not present in the taglist
+        return
+    endif
+
+    " Remove the file from the list
+    call s:Tlist_Remove_File(fidx, 0)
+endfunction
+
+" When a buffer is deleted, remove the file from the taglist
+autocmd BufDelete * silent call s:Tlist_Buffer_Removed(expand('<afile>:p'))
+
+" Tlist_Window_Open_File_Fold
+" Open the fold for the specified file and close the fold for all the
+" other files
+function! s:Tlist_Window_Open_File_Fold(acmd_bufnr)
+    call s:Tlist_Log_Msg('Tlist_Window_Open_File_Fold (' . a:acmd_bufnr . ')')
+
+    " Make sure the taglist window is present
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum == -1
+        call s:Tlist_Warning_Msg('Taglist: Error - Taglist window is not open')
+        return
+    endif
+
+    " Save the original window number
+    let org_winnr = winnr()
+    if org_winnr == winnum
+        let in_taglist_window = 1
+    else
+        let in_taglist_window = 0
+    endif
+
+    if in_taglist_window
+        " When entering the taglist window, no need to update the folds
+        return
+    endif
+
+    " Go to the taglist window
+    if !in_taglist_window
+        call s:Tlist_Exe_Cmd_No_Acmds(winnum . 'wincmd w')
+    endif
+
+    " Close all the folds
+    silent! %foldclose
+
+    " Get tag list index of the specified file
+    let fname = fnamemodify(bufname(a:acmd_bufnr + 0), ':p')
+    if filereadable(fname)
+        let fidx = s:Tlist_Get_File_Index(fname)
+        if fidx != -1
+            " Open the fold for the file
+            exe "silent! " . s:tlist_{fidx}_start . "," .
+                        \ s:tlist_{fidx}_end . "foldopen"
+        endif
+    endif
+
+    " Go back to the original window
+    if !in_taglist_window
+        call s:Tlist_Exe_Cmd_No_Acmds(org_winnr . 'wincmd w')
+    endif
+endfunction
+
+" Tlist_Window_Check_Auto_Open
+" Open the taglist window automatically on Vim startup.
+" Open the window only when files present in any of the Vim windows support
+" tags.
+function! s:Tlist_Window_Check_Auto_Open()
+    let open_window = 0
+
+    let i = 1
+    let buf_num = winbufnr(i)
+    while buf_num != -1
+        let filename = fnamemodify(bufname(buf_num), ':p')
+        let ft = s:Tlist_Get_Buffer_Filetype(buf_num)
+        if !s:Tlist_Skip_File(filename, ft)
+            let open_window = 1
+            break
+        endif
+        let i = i + 1
+        let buf_num = winbufnr(i)
+    endwhile
+
+    if open_window
+        call s:Tlist_Window_Toggle()
+    endif
+endfunction
+
+" Tlist_Refresh_Folds
+" Remove and create the folds for all the files displayed in the taglist
+" window. Used after entering a tab. If this is not done, then the folds
+" are not properly created for taglist windows displayed in multiple tabs.
+function! s:Tlist_Refresh_Folds()
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum == -1
+        return
+    endif
+
+    let save_wnum = winnr()
+    exe winnum . 'wincmd w'
+
+    " First remove all the existing folds
+    normal! zE
+
+    " Create the folds for each in the tag list
+    let fidx = 0
+    while fidx < s:tlist_file_count
+        let ftype = s:tlist_{fidx}_filetype
+
+        " Create the folds for each tag type in a file
+        let j = 1
+        while j <= s:tlist_{ftype}_count
+            let ttype = s:tlist_{ftype}_{j}_name
+            if s:tlist_{fidx}_{ttype}_count
+                let s = s:tlist_{fidx}_start + s:tlist_{fidx}_{ttype}_offset
+                let e = s + s:tlist_{fidx}_{ttype}_count
+                exe s . ',' . e . 'fold'
+            endif
+            let j = j + 1
+        endwhile
+
+        exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'fold'
+        exe 'silent! ' . s:tlist_{fidx}_start . ',' .
+                    \ s:tlist_{fidx}_end . 'foldopen!'
+        let fidx = fidx + 1
+    endwhile
+
+    exe save_wnum . 'wincmd w'
+endfunction
+
+function! s:Tlist_Menu_Add_Base_Menu()
+    call s:Tlist_Log_Msg('Adding the base menu')
+
+    " Add the menu
+    anoremenu <silent> T&ags.Refresh\ menu :call <SID>Tlist_Menu_Refresh()<CR>
+    anoremenu <silent> T&ags.Sort\ menu\ by.Name
+                    \ :call <SID>Tlist_Change_Sort('menu', 'set', 'name')<CR>
+    anoremenu <silent> T&ags.Sort\ menu\ by.Order
+                    \ :call <SID>Tlist_Change_Sort('menu', 'set', 'order')<CR>
+    anoremenu T&ags.-SEP1-           :
+
+    if &mousemodel =~ 'popup'
+        anoremenu <silent> PopUp.T&ags.Refresh\ menu
+                    \ :call <SID>Tlist_Menu_Refresh()<CR>
+        anoremenu <silent> PopUp.T&ags.Sort\ menu\ by.Name
+                  \ :call <SID>Tlist_Change_Sort('menu', 'set', 'name')<CR>
+        anoremenu <silent> PopUp.T&ags.Sort\ menu\ by.Order
+                  \ :call <SID>Tlist_Change_Sort('menu', 'set', 'order')<CR>
+        anoremenu PopUp.T&ags.-SEP1-           :
+    endif
+endfunction
+
+let s:menu_char_prefix =
+            \ '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
+
+" Tlist_Menu_Get_Tag_Type_Cmd
+" Get the menu command for the specified tag type
+" fidx - File type index
+" ftype - File Type
+" add_ttype_name - To add or not to add the tag type name to the menu entries
+" ttype_idx - Tag type index
+function! s:Tlist_Menu_Get_Tag_Type_Cmd(fidx, ftype, add_ttype_name, ttype_idx)
+    " Curly brace variable name optimization
+    let ftype_ttype_idx = a:ftype . '_' . a:ttype_idx
+
+    let ttype = s:tlist_{ftype_ttype_idx}_name
+    if a:add_ttype_name
+        " If the tag type name contains space characters, escape it. This
+        " will be used to create the menu entries.
+        let ttype_fullname = escape(s:tlist_{ftype_ttype_idx}_fullname, ' ')
+    endif
+
+    " Curly brace variable name optimization
+    let fidx_ttype = a:fidx . '_' . ttype
+
+    " Number of tag entries for this tag type
+    let tcnt = s:tlist_{fidx_ttype}_count
+    if tcnt == 0 " No entries for this tag type
+        return ''
+    endif
+
+    let mcmd = ''
+
+    " Create the menu items for the tags.
+    " Depending on the number of tags of this type, split the menu into
+    " multiple sub-menus, if needed.
+    if tcnt > g:Tlist_Max_Submenu_Items
+        let j = 1
+        while j <= tcnt
+            let final_index = j + g:Tlist_Max_Submenu_Items - 1
+            if final_index > tcnt
+                let final_index = tcnt
+            endif
+
+            " Extract the first and last tag name and form the
+            " sub-menu name
+            let tidx = s:tlist_{fidx_ttype}_{j}
+            let first_tag = s:tlist_{a:fidx}_{tidx}_tag_name
+
+            let tidx = s:tlist_{fidx_ttype}_{final_index}
+            let last_tag = s:tlist_{a:fidx}_{tidx}_tag_name
+
+            " Truncate the names, if they are greater than the
+            " max length
+            let first_tag = strpart(first_tag, 0, g:Tlist_Max_Tag_Length)
+            let last_tag = strpart(last_tag, 0, g:Tlist_Max_Tag_Length)
+
+            " Form the menu command prefix
+            let m_prefix = 'anoremenu <silent> T\&ags.'
+            if a:add_ttype_name
+                let m_prefix = m_prefix . ttype_fullname . '.'
+            endif
+            let m_prefix = m_prefix . first_tag . '\.\.\.' . last_tag . '.'
+
+            " Character prefix used to number the menu items (hotkey)
+            let m_prefix_idx = 0
+
+            while j <= final_index
+                let tidx = s:tlist_{fidx_ttype}_{j}
+
+                let tname = s:tlist_{a:fidx}_{tidx}_tag_name
+
+                let mcmd = mcmd . m_prefix . '\&' .
+                            \ s:menu_char_prefix[m_prefix_idx] . '\.' .
+                            \ tname . ' :call <SID>Tlist_Menu_Jump_To_Tag(' .
+                            \ tidx . ')<CR>|'
+
+                let m_prefix_idx = m_prefix_idx + 1
+                let j = j + 1
+            endwhile
+        endwhile
+    else
+        " Character prefix used to number the menu items (hotkey)
+        let m_prefix_idx = 0
+
+        let m_prefix = 'anoremenu <silent> T\&ags.'
+        if a:add_ttype_name
+            let m_prefix = m_prefix . ttype_fullname . '.'
+        endif
+        let j = 1
+        while j <= tcnt
+            let tidx = s:tlist_{fidx_ttype}_{j}
+
+            let tname = s:tlist_{a:fidx}_{tidx}_tag_name
+
+            let mcmd = mcmd . m_prefix . '\&' .
+                        \ s:menu_char_prefix[m_prefix_idx] . '\.' .
+                        \ tname . ' :call <SID>Tlist_Menu_Jump_To_Tag(' . tidx
+                        \ . ')<CR>|'
+
+            let m_prefix_idx = m_prefix_idx + 1
+            let j = j + 1
+        endwhile
+    endif
+
+    return mcmd
+endfunction
+
+" Update the taglist menu with the tags for the specified file
+function! s:Tlist_Menu_File_Refresh(fidx)
+    call s:Tlist_Log_Msg('Refreshing the tag menu for ' . s:tlist_{a:fidx}_filename)
+    " The 'B' flag is needed in the 'cpoptions' option
+    let old_cpoptions = &cpoptions
+    set cpoptions&vim
+
+    exe s:tlist_{a:fidx}_menu_cmd
+
+    " Update the popup menu (if enabled)
+    if &mousemodel =~ 'popup'
+        let cmd = substitute(s:tlist_{a:fidx}_menu_cmd, ' T\\&ags\.',
+                                        \ ' PopUp.T\\\&ags.', "g")
+        exe cmd
+    endif
+
+    " The taglist menu is not empty now
+    let s:tlist_menu_empty = 0
+
+    " Restore the 'cpoptions' settings
+    let &cpoptions = old_cpoptions
+endfunction
+
+" Tlist_Menu_Update_File
+" Add the taglist menu
+function! s:Tlist_Menu_Update_File(clear_menu)
+    if !has('gui_running')
+        " Not running in GUI mode
+        return
+    endif
+
+    call s:Tlist_Log_Msg('Updating the tag menu, clear_menu = ' . a:clear_menu)
+
+    " Remove the tags menu
+    if a:clear_menu
+        call s:Tlist_Menu_Remove_File()
+
+    endif
+
+    " Skip buffers with 'buftype' set to nofile, nowrite, quickfix or help
+    if &buftype != ''
+        return
+    endif
+
+    let filename = fnamemodify(bufname('%'), ':p')
+    let ftype = s:Tlist_Get_Buffer_Filetype('%')
+
+    " If the file doesn't support tag listing, skip it
+    if s:Tlist_Skip_File(filename, ftype)
+        return
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(filename)
+    if fidx == -1 || !s:tlist_{fidx}_valid
+        " Check whether this file is removed based on user request
+        " If it is, then don't display the tags for this file
+        if s:Tlist_User_Removed_File(filename)
+            return
+        endif
+
+        " Process the tags for the file
+        let fidx = s:Tlist_Process_File(filename, ftype)
+        if fidx == -1
+            return
+        endif
+    endif
+
+    let fname = escape(fnamemodify(bufname('%'), ':t'), '.')
+    if fname != ''
+        exe 'anoremenu T&ags.' .  fname . ' <Nop>'
+        anoremenu T&ags.-SEP2-           :
+    endif
+
+    if !s:tlist_{fidx}_tag_count
+        return
+    endif
+
+    if s:tlist_{fidx}_menu_cmd != ''
+        " Update the menu with the cached command
+        call s:Tlist_Menu_File_Refresh(fidx)
+
+        return
+    endif
+
+    " We are going to add entries to the tags menu, so the menu won't be
+    " empty
+    let s:tlist_menu_empty = 0
+
+    let cmd = ''
+
+    " Determine whether the tag type name needs to be added to the menu
+    " If more than one tag type is present in the taglisting for a file,
+    " then the tag type name needs to be present
+    let add_ttype_name = -1
+    let i = 1
+    while i <= s:tlist_{ftype}_count && add_ttype_name < 1
+        let ttype = s:tlist_{ftype}_{i}_name
+        if s:tlist_{fidx}_{ttype}_count
+            let add_ttype_name = add_ttype_name + 1
+        endif
+        let i = i + 1
+    endwhile
+
+    " Process the tags by the tag type and get the menu command
+    let i = 1
+    while i <= s:tlist_{ftype}_count
+        let mcmd = s:Tlist_Menu_Get_Tag_Type_Cmd(fidx, ftype, add_ttype_name, i)
+        if mcmd != ''
+            let cmd = cmd . mcmd
+        endif
+
+        let i = i + 1
+    endwhile
+
+    " Cache the menu command for reuse
+    let s:tlist_{fidx}_menu_cmd = cmd
+
+    " Update the menu
+    call s:Tlist_Menu_File_Refresh(fidx)
+endfunction
+
+" Tlist_Menu_Remove_File
+" Remove the tags displayed in the tags menu
+function! s:Tlist_Menu_Remove_File()
+    if !has('gui_running') || s:tlist_menu_empty
+        return
+    endif
+
+    call s:Tlist_Log_Msg('Removing the tags menu for a file')
+
+    " Cleanup the Tags menu
+    silent! unmenu T&ags
+    if &mousemodel =~ 'popup'
+        silent! unmenu PopUp.T&ags
+    endif
+
+    " Add a dummy menu item to retain teared off menu
+    noremenu T&ags.Dummy l
+
+    silent! unmenu! T&ags
+    if &mousemodel =~ 'popup'
+        silent! unmenu! PopUp.T&ags
+    endif
+
+    call s:Tlist_Menu_Add_Base_Menu()
+
+    " Remove the dummy menu item
+    unmenu T&ags.Dummy
+
+    let s:tlist_menu_empty = 1
+endfunction
+
+" Tlist_Menu_Refresh
+" Refresh the taglist menu
+function! s:Tlist_Menu_Refresh()
+    call s:Tlist_Log_Msg('Refreshing the tags menu')
+    let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
+    if fidx != -1
+        " Invalidate the cached menu command
+        let s:tlist_{fidx}_menu_cmd = ''
+    endif
+
+    " Update the taglist, menu and window
+    call s:Tlist_Update_Current_File()
+endfunction
+
+" Tlist_Menu_Jump_To_Tag
+" Jump to the selected tag
+function! s:Tlist_Menu_Jump_To_Tag(tidx)
+    let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
+    if fidx == -1
+        return
+    endif
+
+    let tagpat = s:Tlist_Get_Tag_SearchPat(fidx, a:tidx)
+    if tagpat == ''
+        return
+    endif
+
+    " Add the current cursor position to the jump list, so that user can
+    " jump back using the ' and ` marks.
+    mark '
+
+    silent call search(tagpat, 'w')
+
+    " Bring the line to the middle of the window
+    normal! z.
+
+    " If the line is inside a fold, open the fold
+    if foldclosed('.') != -1
+        .foldopen
+    endif
+endfunction
+
+" Tlist_Menu_Init
+" Initialize the taglist menu
+function! s:Tlist_Menu_Init()
+    call s:Tlist_Menu_Add_Base_Menu()
+
+    " Automatically add the tags defined in the current file to the menu
+    augroup TagListMenuCmds
+        autocmd!
+
+        if !g:Tlist_Process_File_Always
+            autocmd BufEnter * call s:Tlist_Refresh()
+        endif
+        autocmd BufLeave * call s:Tlist_Menu_Remove_File()
+    augroup end
+
+    call s:Tlist_Menu_Update_File(0)
+endfunction
+
+" Tlist_Vim_Session_Load
+" Initialize the taglist window/buffer, which is created when loading
+" a Vim session file.
+function! s:Tlist_Vim_Session_Load()
+    call s:Tlist_Log_Msg('Tlist_Vim_Session_Load')
+
+    " Initialize the taglist window
+    call s:Tlist_Window_Init()
+
+    " Refresh the taglist window
+    call s:Tlist_Window_Refresh()
+endfunction
+
+" Tlist_Set_App
+" Set the name of the external plugin/application to which taglist
+" belongs.
+" Taglist plugin is part of another plugin like cream or winmanager.
+function! Tlist_Set_App(name)
+    if a:name == ""
+        return
+    endif
+
+    let s:tlist_app_name = a:name
+endfunction
+
+" Winmanager integration
+
+" Initialization required for integration with winmanager
+function! TagList_Start()
+    " If current buffer is not taglist buffer, then don't proceed
+    if bufname('%') != '__Tag_List__'
+        return
+    endif
+
+    call Tlist_Set_App('winmanager')
+
+    " Get the current filename from the winmanager plugin
+    let bufnum = WinManagerGetLastEditedFile()
+    if bufnum != -1
+        let filename = fnamemodify(bufname(bufnum), ':p')
+        let ftype = s:Tlist_Get_Buffer_Filetype(bufnum)
+    endif
+
+    " Initialize the taglist window, if it is not already initialized
+    if !exists('s:tlist_window_initialized') || !s:tlist_window_initialized
+        call s:Tlist_Window_Init()
+        call s:Tlist_Window_Refresh()
+        let s:tlist_window_initialized = 1
+    endif
+
+    " Update the taglist window
+    if bufnum != -1
+        if !s:Tlist_Skip_File(filename, ftype) && g:Tlist_Auto_Update
+            call s:Tlist_Window_Refresh_File(filename, ftype)
+        endif
+    endif
+endfunction
+
+function! TagList_IsValid()
+    return 0
+endfunction
+
+function! TagList_WrapUp()
+    return 0
+endfunction
+
+" restore 'cpo'
+let &cpo = s:cpo_save
+unlet s:cpo_save
+
diff --git a/vimrc/.vimrc b/vimrc/.vimrc
new file mode 100644
--- /dev/null
+++ ./vimrc/.vimrc
@@ -0,0 +1,279 @@
+set helplang=cn
+set encoding=utf8
+set fileencodings=utf8,gbk,big5
+
+set backupdir=~/.vimswaps,/tmp
+syntax on
+filetype plugin on
+" Change the mapleader from \ to ,
+let mapleader=","
+let maplocalleader="\\"
+filetype indent on
+
+
+autocmd BufEnter * call CHANGE_CURR_DIR()
+
+autocmd BufReadPost * if line("'\"") > 0 && line ("'\"") <= line("$") | exe "normal! g'\"" | endif
+
+" 
+inoremap <BS> <ESC>:call RemovePairs()<CR>a
+inoremap ) <ESC>:call RemoveNextDoubleChar(')')<CR>a
+inoremap ] <ESC>:call RemoveNextDoubleChar(']')<CR>a
+inoremap } <ESC>:call RemoveNextDoubleChar('}')<CR>a
+inoremap ( ()<LEFT>
+inoremap [ []<LEFT>
+inoremap { {}<LEFT>
+"set bg=dark
+"set paste
+"set nopaste
+xnoremap p pgvy
+au! BufRead,BufNewFile *.hta  setfiletype html
+" Mapping ESC in insert mode and command mode to double j
+imap jj <C-[>
+" cmap jj  <C-[]]
+" This sets the minimum window height to 0, so you can stack many more files before things get crowded. Vim will only display the filename.
+set wmw=0
+set wmh=0
+" Editing behaviour {{{
+set showmode                    " always show what mode we're currently editing in
+
+set linebreak
+set textwidth=0
+set wrapmargin=0
+
+set tabstop=4                   " a tab is two spaces
+set softtabstop=4               " when hitting <BS>, pretend like a tab is removed, even if spaces
+set expandtab                   " expand tabs by default (overloadable per file type later)
+set shiftwidth=4                " number of spaces to use for autoindenting
+set shiftround                  " use multiple of shiftwidth when indenting with '<' and '>'
+set autoindent                  " always set autoindenting on
+set copyindent                  " copy the previous indentation on autoindenting
+set number                      " always show line numbers
+set showmatch                   " set show matching parenthesis
+"set ignorecase                  " ignore case when searching
+"set smartcase                   " ignore case if search pattern is all lowercase,
+"    case-sensitive otherwise
+set smarttab                    " insert tabs on the start of a line according to
+"    shiftwidth, not tabstop
+set scrolloff=4                 " keep 4 lines off the edges of the screen when scrolling
+set virtualedit=all             " allow the cursor to go in to "invalid" places
+set hlsearch                    " highlight search terms
+set incsearch                   " show search matches as you type
+set gdefault                    " search/replace "globally" (on a line) by default
+set listchars=tab:\ ,trail:,extends:#,nbsp:
+
+set nolist                      " don't show invisible characters by default,
+" but it is enabled for some file types (see later)
+" set mouse=a                     " enable using the mouse if terminal emulator
+"    supports it (xterm does)
+set fileformats="unix,dos,mac"
+set formatoptions+=1            " When wrapping paragraphs, don't end lines
+"    with 1-letter words (looks stupid)
+
+set nrformats=                  " make <C-a> and <C-x> play well with
+"    zero-padded numbers (i.e. don't consider
+"    them octal or hex)
+
+
+
+
+" }}}
+" Folding rules {{{
+set foldenable                  " enable folding
+set foldcolumn=2                " add a fold column
+"set foldmethod=manual " detect triple-{ style fold markers
+"set foldmethod=syntax " detect triple-{ style fold markers
+" set foldmethod=indent " detect triple-{ style fold markers
+set syntax=c
+set foldmethod=syntax
+
+let javaScript_fold=1         " JavaScript
+let perl_fold=1               " Perl
+let php_folding=1             " PHP
+let r_syntax_folding=1        " R
+let ruby_fold=1               " Ruby
+let sh_fold_enabled=1         " sh
+let vimsyn_folding='af'       " Vim script
+let xml_syntax_folding=1      " XML
+
+set foldlevelstart=99           " start out with everything folded
+set foldopen=block,hor,insert,jump,mark,percent,quickfix,search,tag,undo
+" which commands trigger auto-unfold
+autocmd BufWinLeave *.* mkview
+" autocmd BufWinEnter *.* silent loadview
+set viewoptions=cursor,folds,slash,unix
+" let g:skipview_files = ['*\.vim']
+" }}}
+" Editor layout {{{
+set encoding=utf-8
+set lazyredraw                  " don't update the display while executing macros
+set laststatus=2                " tell VIM to always put a status line in, even
+"    if there is only one window
+set cmdheight=1                 " use a status bar that is 2 rows high
+
+
+" }}}
+highlight StatusLine cterm=bold ctermfg=yellow ctermbg=blue
+
+" Set a nicer foldtext function
+set foldtext=MyFoldText()
+
+execute pathogen#infect()
+" map <C-t> :tabedit
+" powerline{
+"  set guifont=PowerlineSymbols\ for\ Powerline
+"  set nocompatible
+"  let g:Powerline_symbols = 'fancy'
+"  }
+" tablisttagtag
+let Tlist_Show_One_File=1
+"taglisttaglist
+let Tlist_GainFocus_On_ToggleOpen = 1
+
+" Tell vim to remember certain things when we exit
+"  '10  :  marks will be remembered for up to 10 previously edited files
+"  "100 :  will save up to 100 lines for each register
+"  :20  :  up to 20 lines of command-line history will be remembered
+"  %    :  saves and restores the buffer list
+"  n... :  where to save the viminfo files
+set viminfo='10,\"100,:20,%,n~/.viminfo
+
+
+augroup resCur
+    autocmd!
+    autocmd BufWinEnter * call ResCur()
+augroup END
+
+" http://vim.wikia.com/wiki/Copy_filename_to_clipboard
+" Convert slashes to backslashes for Windows.
+" nnoremap fh <c-w>R
+" nnoremap fl <c-w>r
+" Pathogen load
+
+call pathogen#infect()
+call pathogen#helptags()
+
+syntax on
+
+set nocompatible              " be iMproved
+
+set rtp+=~/.vim/bundle/vundle/
+call vundle#rc()
+
+filetype on
+filetype plugin on
+filetype plugin indent on
+
+function AddToGit()
+    if (expand('%:e') ==# 'findresult' || expand('%:p') =~ '.*\.git/.*' || expand('%:e') ==# 'diff')
+        return
+    endif
+     
+    let inGit = substitute(system('[ -d .git ] || git rev-parse --git-dir > /dev/null 2>&1 && echo inGit'), '\n', '', '')
+    
+    if inGit != 'inGit'
+        return
+    endif
+
+    let worktree = Cd2Worktree()
+    let relativePath = expand('%:p')
+    let relativePath = substitute(relativePath, '\_s', '\\ ', "g")
+    let relativePath = substitute(system('realpath --relative-to="' . worktree . '" ' . relativePath), '\n', '', '')
+    silent exec '!~/loadrc/gitrc/autoadd.sh ' . '"' .  relativePath . '"'
+endfunction
+
+function TrimEndLines()
+    let save_cursor = getpos(".")
+    :silent! %s#\($\n\s*\)\+\%$##
+    call setpos('.', save_cursor)
+endfunction
+
+au BufWritePre *.py call TrimEndLines()
+au BufWritePre *.sh call TrimEndLines()
+au BufWritePre *.java call TrimEndLines()
+au BufWritePre *.vimrc call TrimEndLines()
+au BufWritePre * call AddToGit()
+"to do: pymode_rope conflict with AddToGit(), it will cause vim hang.
+let g:pymode_rope = 0
+"To have a space (ASCII 32) considered as a valid character for a file name
+":set isfname+=32
+
+let g:phpfmt_autosave = 1
+let g:phpfmt_standard = '$HOME/loadrc/vimrc/.vim/bundle/vim-phpfmt/ruleset.xml'
+
+let g:ycm_autoclose_preview_window_after_completion = 1
+
+if !has('nvim')
+    set viminfo+=n~/.local/share/vim/viminfo
+endif
+"
+" configuration for cscope_dynamic
+let cscopedb_auto_files=0
+
+" :help Ncm2PopupOpen for more information
+set completeopt=noinsert,menuone,noselect
+" Use <TAB> to select the popup menu:
+inoremap <expr> <Tab> pumvisible() ? "\<C-n>" : "\<Tab>"
+inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
+
+" To have a space (ASCII 32) considered as a valid character for a file name
+" set isfname+=32
+au BufRead,BufNewFile *.vala,*.vapi,*.valadoc set filetype=vala
+
+" configuration for vim-anyfold
+filetype plugin indent on " required
+syntax on                 " required
+
+autocmd Filetype * AnyFoldActivate               " activate for all filetypes
+" or
+" autocmd Filetype <your-filetype> AnyFoldActivate " activate for a specific filetype
+
+set foldlevel=0  " close all folds
+" or
+" set foldlevel=99 " Open all folds
+let g:anyfold_fold_comments = 1
+let g:anyfold_identify_comments = 2
+
+" disable anyfold for large files
+let g:LargeFile = 1000000 " file is large if size greater than 1MB
+autocmd BufReadPre,BufRead * let f=getfsize(expand("<afile>")) | if f > g:LargeFile || f == -2 | call LargeFile() | endif
+function LargeFile()
+    augroup anyfold
+        autocmd Filetype * setlocal foldmethod=indent " fall back to indent folding
+    augroup END
+endfunction
+" configuration for vim-anyfold
+
+" configuration for fugitive
+autocmd FileType fugitive set bufhidden=
+
+" Automatically change the current directoryEdit
+" Sometimes it is helpful if your working directory is always the same as the file you are editing. To achieve this, put the following in your vimrc:
+" set autochdir
+
+let g:indexed_search_dont_move = 1
+
+" autocmd OptionSet diff call s:ToggleOnDiff()
+" 
+" function! s:ToggleOnDiff()
+"     if &diff
+"         set wrap
+"     endif
+" endfunction
+
+let g:tex_flavor = 'latex'
+
+" add @ to cfile handle
+set isfname+=@-@
+set history=10000
+
+if has('mac') || system('uname') =~# 'Darwin'
+    let g:vim_pbcopy_remote_cmd = "nc localhost 2224"
+else
+    let g:vim_pbcopy_remote_cmd = "nc -N localhost 2224"
+endif
+
+" https://stackoverflow.com/questions/4642822/how-to-make-bashrc-aliases-available-within-a-vim-shell-command
+" set shellcmdflag=-ic
+
+let g:BASH_AlsoBash = [ '*.lsh' ]
diff --git a/vishrc/.login b/vishrc/.login
new file mode 100644
--- /dev/null
+++ ./vishrc/.login
@@ -0,0 +1,4 @@
+user=condor
+password=temp123
+host=localhost
+dbinstance=recdeveloper
diff --git a/vishrc/cat_du.sh b/vishrc/cat_du.sh
new file mode 100755
--- /dev/null
+++ ./vishrc/cat_du.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+
+while read ss
+do
+    ss=$(echo "$ss" | sed 's/"//g')
+    du -sh "$ss"
+done < "$1"
diff --git a/vishrc/cat_move.sh b/vishrc/cat_move.sh
new file mode 100755
--- /dev/null
+++ ./vishrc/cat_move.sh
@@ -0,0 +1,12 @@
+#!/bin/zsh
+
+if [ ! -d "$2" ]
+then
+    mkdir -p "$2"
+fi
+
+while read ss
+do
+    ss=$(echo "$ss" | sed 's/"//g')
+    mv -nv "$ss" "$2"
+done < "$1"
diff --git a/vishrc/cat_play.sh b/vishrc/cat_play.sh
new file mode 100755
--- /dev/null
+++ ./vishrc/cat_play.sh
@@ -0,0 +1,9 @@
+#!/bin/zsh
+
+while read ss
+do
+    ss=$(echo "$ss" | sed 's/"//g')
+    echo "now playing"
+    echo "$ss"
+    ~/loadrc/vishrc/vlc.sh "$ss"
+done < "$1"
diff --git a/vishrc/cat_rate.sh b/vishrc/cat_rate.sh
new file mode 100755
--- /dev/null
+++ ./vishrc/cat_rate.sh
@@ -0,0 +1,13 @@
+#!/bin/zsh
+
+result=()
+
+while read ss
+do
+    ~/loadrc/bashrc/append_rate.sh "$ss" "$2"
+    target=$(~/loadrc/bashrc/append_num.sh "$ss" "$2")
+    result+=("$target")
+done < "$1"
+
+printf "%s\n" "${result[@]}" > "$1".tmp
+cp -fv "$1".tmp "$1"
diff --git a/vishrc/cat_run.sh b/vishrc/cat_run.sh
new file mode 100755
--- /dev/null
+++ ./vishrc/cat_run.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+
+while read ss
+do
+    ss=$(echo "$ss" | sed 's/"//g;s/^\.\///g')
+    ~/loadrc/vishrc/vrun.sh "$ss" &
+done < "$1"
diff --git a/vishrc/foreach.sh b/vishrc/foreach.sh
new file mode 100755
--- /dev/null
+++ ./vishrc/foreach.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh
+COMMAND="$2 $(<$1)"
+eval "$COMMAND"
diff --git a/vishrc/kdiffall.sh b/vishrc/kdiffall.sh
new file mode 100755
--- /dev/null
+++ ./vishrc/kdiffall.sh
@@ -0,0 +1,12 @@
+#!/bin/zsh
+IFS=$'\n' lines=($(cat $1))
+ 
+for index in {1..$#lines}
+do
+    for ((next = $index + 1; next <= $#lines; next++));
+    do
+        one=$(echo "${lines[$index]}" | sed 's/"//g')
+        two=$(echo "${lines[$next]}" | sed 's/"//g')
+        kdiff3 "$one" "$two"
+    done
+done
diff --git a/vishrc/kdiffall_test.list b/vishrc/kdiffall_test.list
new file mode 100644
--- /dev/null
+++ ./vishrc/kdiffall_test.list
@@ -0,0 +1,10 @@
+0
+1
+2
+3
+4
+5
+6
+7
+8
+9
diff --git a/vishrc/kdiffall_test.sh b/vishrc/kdiffall_test.sh
new file mode 100755
--- /dev/null
+++ ./vishrc/kdiffall_test.sh
@@ -0,0 +1,4 @@
+#!/bin/zsh
+cd /Users/yhuang/Dropbox/myproject/git/interview/skygragon/leetcode-cli/
+
+~/loadrc/vishrc/kdiffall.sh /Users/yhuang/Dropbox/myproject/git/interview/skygragon/leetcode-cli/.submissions100.same-tree.vaa.findresult
diff --git a/vishrc/lc_test.sh b/vishrc/lc_test.sh
new file mode 100755
--- /dev/null
+++ ./vishrc/lc_test.sh
@@ -0,0 +1,12 @@
+#!/bin/zsh
+fileName="$1"
+
+if [ -f "$fileName.sh" ]
+then
+    exit 0
+fi
+
+cp -v ~/loadrc/vishrc/lc_test.template "$fileName.sh"
+filenameVar=$(basename "$fileName")
+echo $filename
+sed -i.bak "s/filenameVar/$filenameVar/g" "$fileName.sh"
diff --git a/vishrc/lc_test.template b/vishrc/lc_test.template
new file mode 100755
--- /dev/null
+++ ./vishrc/lc_test.template
@@ -0,0 +1,9 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+leetcode user -l
+leetcode test \
+    filenameVar \
+    -t '[1,null,2]'
diff --git a/vishrc/prune.sh b/vishrc/prune.sh
new file mode 100755
--- /dev/null
+++ ./vishrc/prune.sh
@@ -0,0 +1,11 @@
+#!/bin/zsh
+currentFile="$1"
+rootFolder=$(~/loadrc/bashrc/find_up_folder.sh "$currentFile" "prunefile.conf")
+prunefile="$rootFolder/prunefile.conf"
+line=$(realpath --relative-to="$rootFolder" "$currentFile")
+line=$(echo "$line" | sed 's/.*/"\.\/&"/')
+echo "$line" >> "$prunefile"
+sort -u "$prunefile" -o "$prunefile"
+cd "$rootFolder"
+line=$(echo "$line" | sed 's/\//\\\//g')
+sed -i "/$line/d" files.proj
diff --git a/vishrc/prune_test.sh b/vishrc/prune_test.sh
new file mode 100755
--- /dev/null
+++ ./vishrc/prune_test.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./prune.sh /Users/yhuang/loadrc/vimrc/.vim/bundle/vundle.vim/doc/vundle.txt
diff --git a/vishrc/rm_cat.sh b/vishrc/rm_cat.sh
new file mode 100755
--- /dev/null
+++ ./vishrc/rm_cat.sh
@@ -0,0 +1,7 @@
+#!/bin/zsh
+
+while read ss
+do
+    ss=$(echo "$ss" | sed 's/"//g')
+    rm "$ss"
+done < "$1"
diff --git a/vishrc/sort_entries.sh b/vishrc/sort_entries.sh
new file mode 100755
--- /dev/null
+++ ./vishrc/sort_entries.sh
@@ -0,0 +1,19 @@
+#!/bin/zsh
+FILE="$1"
+PARAM="$2"
+
+SCRIPT=$(realpath "$FILE")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+IFS=$'\n'
+
+if [ "$PARAM" = "time" ]
+then
+    ls -t $(cat "$FILE" | sed 's/^"//g;s/"$//g;s/\\ / /g') > "$FILE"
+elif [ "$PARAM" = "size" ]
+then
+    ls -S $(cat "$FILE" | sed 's/^"//g;s/"$//g;s/\\ / /g') > "$FILE" 
+fi
+
+sed -i.bak 's/\(["\]\)/\\\1/g;s/.*/"&"/' "$FILE"  
diff --git a/vishrc/sort_entries.test.sh b/vishrc/sort_entries.test.sh
new file mode 100755
--- /dev/null
+++ ./vishrc/sort_entries.test.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh 
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./sort_entries.sh /Users/huangyingw/Dropbox/loadrc.home/vimrc.vaa.findresult time
diff --git a/vishrc/vaa_test.sh b/vishrc/vaa_test.sh
new file mode 100755
--- /dev/null
+++ ./vishrc/vaa_test.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh 
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./vaa.sh "" "Hello World    = You "
diff --git a/vishrc/vcommand.sh b/vishrc/vcommand.sh
new file mode 100755
--- /dev/null
+++ ./vishrc/vcommand.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh 
+scriptToRun="sh "$(realpath "$1")" 2>&1 | tee vcommand.findresult"
+eval "$scriptToRun"
diff --git a/vishrc/vdebug.sh b/vishrc/vdebug.sh
new file mode 100755
--- /dev/null
+++ ./vishrc/vdebug.sh
@@ -0,0 +1,33 @@
+#!/bin/zsh
+file=${1}
+if [ $(basename "$file") = "gbil.log" ]
+then
+    ~/loadrc/gitrc/gbir.sh
+    exit 0
+fi
+
+extension=${file##*.}
+
+case $extension in
+    sql)
+        ~/loadrc/sqlrc/xsql.sh ${1} ${2} 2>&1 | tee ${1}.findresult
+        ;;
+    findresult)
+        sh ${1} 2>&1 | tee ${1}.findresult
+        ;;
+    sh)
+        sh ${1} 2>&1 | tee ${1}.findresult
+        ;;
+    py)
+        python ${1} 2>&1 | tee ${1}.findresult
+        ;;
+    vim)
+        source ${1}
+        ;;
+    yml)
+        docker-compose -f "$file" up --build --force-recreate 2>&1 | tee "$file".findresult
+        ;;
+    ymldebug)
+        docker-compose -f "$file" up --build --force-recreate 2>&1 | tee "$file".findresult
+        ;;
+esac
diff --git a/vishrc/vlc.sh b/vishrc/vlc.sh
new file mode 100755
--- /dev/null
+++ ./vishrc/vlc.sh
@@ -0,0 +1,14 @@
+#!/bin/zsh
+
+if [ ! -f "$1" ]
+then
+    exit
+fi
+
+if [ $(uname) = "Darwin" ]
+then
+    /Applications/VLC.app/Contents/MacOS/VLC --sub-language Chinese --sub-autodetect-file -f --macosx-continue-playback=2 --rate=2.0 "$1"
+else
+    #smplayer "$1"
+    smplayer -fullscreen "$1"
+fi
diff --git a/vishrc/vrun.sh b/vishrc/vrun.sh
new file mode 100755
--- /dev/null
+++ ./vishrc/vrun.sh
@@ -0,0 +1,129 @@
+#!/bin/zsh
+file="$1"
+
+if [ $(basename "$file") = "gbil.log" ]
+then
+    ~/loadrc/gitrc/discard_unnecessaries.sh
+    ~/loadrc/gitrc/gbir.sh
+    exit 0
+fi
+
+if [[ "$file" = *'.leetcode.java' ]] || [[ "$file" = *'.leetcode.py' ]] || [[ "$file" = *'.leetcode.python3.py' ]]
+then
+    ~/loadrc/leetcoderc/handle.sh "$file"
+    exit 0
+fi
+
+extension=${file##*.}
+host=$(git config deploy.host)
+rpath=$(git config deploy.path)
+rootFolder=$(~/loadrc/bashrc/find_up_folder.sh "$file" "files.proj")
+rfile=$(realpath --relative-to="$rootFolder" "$file")
+rfolder=$(realpath --relative-to="$rootFolder" $(dirname "$file"))
+
+if [[ "$file" = *'_test.py' ]]
+then
+    cd "$rootFolder"
+    pytest $file
+    exit 0
+fi
+
+if [[ "$file" = *'Dockerfile'* ]]
+then
+    cd "$rootFolder"
+    docker build -f "$rfile" "$rfolder"
+    exit 0
+fi
+
+if [[ $(basename "$file") = 'Vagrantfile' ]]
+then
+    cd "$rfolder"
+    vagrant reload
+    vagrant up
+    exit 0
+fi
+
+case $extension in
+    hs)
+        runghc "$file"
+        ;;
+    sql)
+        if [[ -n "$host" ]] && [[ "$host" != "localhost" ]]
+        then
+            ssh -nY "$host" "~/loadrc/sqlrc/xsql.sh $rpath/$rfile $rpath"
+        else
+            ~/loadrc/sqlrc/xsql.sh "$file" "$2"
+        fi
+        ;;
+    bak)
+        zsh "$file"
+        ;;
+    findresult)
+        zsh "$file"
+        ;;
+    vdiff)
+        zsh "$file"
+        ;;
+    sh)
+        if [[ -n "$host" ]] && [[ "$host" != "localhost" ]]
+        then
+            ssh -nY "$host" "cd $rpath ; . ~/loadrc/.pathrc ; $rpath/$rfile"
+        else
+            "$file"
+        fi
+        ;;
+    lsh)
+        "$file"
+        ;;
+    py)
+        if [[ -n "$host" ]] && [[ "$host" != "localhost" ]]
+        then
+            ssh -nY "$host" "cd $rpath ; . ~/loadrc/.pathrc ; python3 $rfile"
+        else
+            SCRIPT=$(realpath "$file")
+            SCRIPTPATH=$(dirname "$SCRIPT")
+            cd "$SCRIPTPATH"
+            python3 "$file"
+        fi
+        ;;
+    vim)
+        source "$file"
+        ;;
+    yaml)
+        if [[ -n "$host" ]] && [[ "$host" != "localhost" ]]
+        then
+            ssh -nY "$host" "kubectl apply -f $rpath/$rfile"
+        else
+            kubectl apply -f "$file"
+        fi
+        ;;
+    yml)
+        if [[ -n "$host" ]] && [[ "$host" != "localhost" ]]
+        then
+            ssh -nY "$host" "docker-compose -f $rpath/$rfile up -d"
+        else
+            docker-compose -f "$file" up -d --build --force-recreate
+        fi
+        ;;
+    ymldebug)
+        docker-compose -f "$file" up --build --force-recreate
+        ;;
+    js)
+        node "$file"
+        ;;
+    ps1)
+        cd "$rootFolder"
+        pwsh "$file"
+        ;;
+    sln)
+        cd "$rootFolder"
+        dotnet build "$file"
+        ;;
+    cs|csproj)
+        SCRIPT=$(realpath "$file")
+        SCRIPTPATH=$(dirname "$SCRIPT")
+        cd "$SCRIPTPATH"
+        dotnet build
+        dotnet run
+        ;;
+esac
diff --git a/vishrc/vsearch.sh b/vishrc/vsearch.sh
new file mode 100755
--- /dev/null
+++ ./vishrc/vsearch.sh
@@ -0,0 +1,18 @@
+#!/bin/zsh
+keyword=$(echo "$2" | sed -e "s/ \+/ \\\+/g;s/\[/\\\[/g;s/\]/\\\]/g;s/\\\c//g;s/\\\V//g")
+find_result="$4".findresult
+inputFile=$(~/loadrc/bashrc/get_first_column_of_file.sh "$1")
+
+if [[ "$3" == "w" ]]
+then
+    xargs grep -inH -- "$keyword" < "$inputFile" > "$find_result"
+else
+    cscope -CdL -f cscope.out -"$3""$keyword" > "$find_result"
+fi
+
+# https://stackoverflow.com/questions/70444758/how-to-regex-replace-before-colon
+# awk 'BEGIN {FS=OFS=":"}{if(NF>1)gsub(" ","\\ ",$1)}1' "$find_result" > "$find_result".bak
+# perl -pe 's/\G[^ :]*\K /\\ /g' "$find_result" > "$find_result".bak
+# sed -i.bak -E 's/:/\n:/;h;s/ /\\ /g;G;s/\n.*\n//' "$find_result"
+awk 'BEGIN {FS=OFS=":"}{gsub(" ","\\ ",$1)}1' "$find_result" > "$find_result".tmp
+cp -fv "$find_result".tmp "$find_result"
diff --git a/wifi-auto-reconnect b/wifi-auto-reconnect
new file mode 160000
--- /dev/null
+++ ./wifi-auto-reconnect
@@ -0,0 +1 @@
+Subproject commit a30c815b53b8fa0f0ca23680f5671deda334cacd-dirty
diff --git a/wifirc/autoconnect.sh b/wifirc/autoconnect.sh
new file mode 100755
--- /dev/null
+++ ./wifirc/autoconnect.sh
@@ -0,0 +1,22 @@
+#!/bin/bash
+
+# find the uuid by nmcli con show
+# and put this script, which is owned by root and executable, in the folder: /etc/NetworkManager/dispatcher.d
+
+# the following command to get the wifi device:
+
+DEV=$(
+    for dev in `ls /sys/class/net`; do
+        [ -d "/sys/class/net/$dev/wireless" ] && echo "$dev"
+    done
+) 
+
+TARGET_ID=$(nmcli connection show | grep wifi | sed 's/.*[^0-9a-z]\(\([0-9a-z]*-\)\{4\}[0-9a-z]*\).*/\1/g')
+
+if [ "$CONNECTION_UUID" = "$TARGET_ID" ]
+then
+    if [ "$2" = "down" ]; then
+        sleep 5
+        nmcli con up uuid $CONNECTION_UUID
+    fi
+fi
diff --git a/wifirc/enable.sh b/wifirc/enable.sh
new file mode 100755
--- /dev/null
+++ ./wifirc/enable.sh
@@ -0,0 +1,6 @@
+#!/bin/zsh
+if [ $(uname) != "Darwin" ]
+then
+    PHY=$(iw list | awk '/Wiphy/{print $2}')
+    iw "$PHY" wowlan enable magic-packet disconnect
+fi
diff --git a/wifirc/show.sh b/wifirc/show.sh
new file mode 100755
--- /dev/null
+++ ./wifirc/show.sh
@@ -0,0 +1,3 @@
+#!/bin/zsh 
+PHY=$(iw list | awk '/Wiphy/{print $2}')
+iw "$PHY" wowlan show
diff --git a/work.local.astylerc b/work.local.astylerc
new file mode 100644
--- /dev/null
+++ ./work.local.astylerc
@@ -0,0 +1,5 @@
+# this line is a comment
+--style=java      # this is a line-end comment
+# long options can be written without the preceding '--'
+# short options can be concatenated together
+-nfxejoUs4pH
diff --git a/zerotierrc/all.sh b/zerotierrc/all.sh
new file mode 100755
--- /dev/null
+++ ./zerotierrc/all.sh
@@ -0,0 +1,8 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+./install.sh
+./configure.sh
+./restart.sh
diff --git a/zerotierrc/configure.sh b/zerotierrc/configure.sh
new file mode 100755
--- /dev/null
+++ ./zerotierrc/configure.sh
@@ -0,0 +1,37 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+deploy_configs() {
+    TARGET="$1"
+    SOURCE=~/loadrc/hosts/"`hostname`$TARGET"
+
+    if [ -f "$SOURCE" ]
+    then
+        sudo cp -fv "$SOURCE" "$TARGET"
+    fi
+}
+
+while read -r line || [[ -n "$line" ]]
+do
+    deploy_configs "$line"
+done < zerotierrc.conf
+
+echo2crontab() {
+    RESTARTFILE="$1"
+    if [ -f "$RESTARTFILE" ]
+    then
+        echo "*/10 * * * * $RESTARTFILE" >> crontab_file
+    fi
+}
+
+crontab -l > crontab_file
+
+while read -r line || [[ -n "$line" ]]
+do
+    echo2crontab "$line"
+done < ~/loadrc/crontabrc/restartfiles
+
+sort -u crontab_file -o crontab_file
+crontab crontab_file
diff --git a/zerotierrc/install.sh b/zerotierrc/install.sh
new file mode 100755
--- /dev/null
+++ ./zerotierrc/install.sh
@@ -0,0 +1,13 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+if [ $(uname) != "Darwin" ]
+then
+    curl -s https://install.zerotier.com/ | bash
+    pacman --noconfirm -Sy zerotier-one
+    systemctl enable zerotier-one.service
+    systemctl start zerotier-one.service
+    zerotier-cli join 93afae5963560e41
+fi
diff --git a/zerotierrc/restart.sh b/zerotierrc/restart.sh
new file mode 100755
--- /dev/null
+++ ./zerotierrc/restart.sh
@@ -0,0 +1,9 @@
+#!/bin/zsh
+SCRIPT=$(realpath "$0")
+SCRIPTPATH=$(dirname "$SCRIPT")
+cd "$SCRIPTPATH"
+
+sudo launchctl unload /Library/LaunchDaemons/com.zerotier.one.plist
+sudo launchctl load /Library/LaunchDaemons/com.zerotier.one.plist
+service zerotier-one restart
+/etc/init.d/zerotier-one restart
diff --git a/zerotierrc/zerotier.sh b/zerotierrc/zerotier.sh
new file mode 100755
--- /dev/null
+++ ./zerotierrc/zerotier.sh
@@ -0,0 +1,375 @@
+#!/bin/bash
+<<ENDOFSIGSTART=
+-----BEGIN PGP SIGNED MESSAGE-----
+Hash: SHA256
+
+ENDOFSIGSTART=
+
+export PATH=/bin:/usr/bin:/usr/local/bin:/sbin:/usr/sbin:/usr/local/sbin
+
+#
+# ZeroTier install script
+#
+# All this script does is determine your OS and/or distribution and then add the correct
+# repository or download the correct package and install it. It then starts the service
+# and prints your device's ZeroTier address.
+#
+
+# Base URL for download.zerotier.com tree; see https://github.com/zerotier/download.zerotier.com if you want to mirror.
+# Some things want http, some https, so we must specify both. Must include trailing /
+ZT_BASE_URL_HTTPS='https://download.zerotier.com/'
+ZT_BASE_URL_HTTP='http://download.zerotier.com/'
+
+echo
+echo '*** ZeroTier Service Quick Install for Unix-like Systems'
+echo
+echo '*** Tested OSes / distributions:'
+echo
+echo '***   MacOS (10.13+) (just installs ZeroTier One.pkg)'
+echo '***   Debian Linux (7+)'
+echo '***   RedHat/CentOS Linux (6+)'
+echo '***   Fedora Linux (16+)'
+echo '***   SuSE Linux (12+)'
+echo '***   Mint Linux (18+)'
+echo
+echo '*** Supported architectures vary by OS / distribution. We try to support'
+echo '*** every system architecture supported by the target.'
+echo
+echo '*** Please report problems to contact@zerotier.com and we will try to fix.'
+echo
+
+SUDO=
+if [ "$UID" != "0" ]; then
+	if [ -e /usr/bin/sudo -o -e /bin/sudo ]; then
+		SUDO=sudo
+	else
+		echo '*** This quick installer script requires root privileges.'
+		exit 0
+	fi
+fi
+
+# Detect MacOS and install .pkg file there
+if [ -e /usr/bin/uname ]; then
+	if [ "`/usr/bin/uname -s`" = "Darwin" ]; then
+		echo '*** Detected MacOS / Darwin, downloading and installing Mac .pkg...'
+		$SUDO rm -f "/tmp/ZeroTier One.pkg"
+		curl -s ${ZT_BASE_URL_HTTPS}dist/ZeroTier%20One.pkg >"/tmp/ZeroTier One.pkg"
+		$SUDO installer -pkg "/tmp/ZeroTier One.pkg" -target /
+
+		echo
+		echo '*** Waiting for identity generation...'
+
+		while [ ! -f "/Library/Application Support/ZeroTier/One/identity.secret" ]; do
+			sleep 1
+		done
+
+		echo
+		echo "*** Success! You are connected to port `cat '/Library/Application Support/ZeroTier/One/identity.public' | cut -d : -f 1` of Earth's planetary smart switch."
+		echo
+
+		exit 0
+	fi
+fi
+
+# Detect already-installed on Linux
+if [ -f /usr/sbin/zerotier-one ]; then
+	echo '*** ZeroTier appears to already be installed.'
+	exit 0
+fi
+
+rm -f /tmp/zt-gpg-key
+echo '-----BEGIN PGP PUBLIC KEY BLOCK-----' >/tmp/zt-gpg-key
+cat >>/tmp/zt-gpg-key << END_OF_KEY
+Comment: GPGTools - https://gpgtools.org
+
+mQINBFdQq7oBEADEVhyRiaL8dEjMPlI/idO8tA7adjhfvejxrJ3Axxi9YIuIKhWU
+5hNjDjZAiV9iSCMfJN3TjC3EDA+7nFyU6nDKeAMkXPbaPk7ti+Tb1nA4TJsBfBlm
+CC14aGWLItpp8sI00FUzorxLWRmU4kOkrRUJCq2kAMzbYWmHs0hHkWmvj8gGu6mJ
+WU3sDIjvdsm3hlgtqr9grPEnj+gA7xetGs3oIfp6YDKymGAV49HZmVAvSeoqfL1p
+pEKlNQ1aO9uNfHLdx6+4pS1miyo7D1s7ru2IcqhTDhg40cHTL/VldC3d8vXRFLIi
+Uo2tFZ6J1jyQP5c1K4rTpw3UNVne3ob7uCME+T1+ePeuM5Y/cpcCvAhJhO0rrlr0
+dP3lOKrVdZg4qhtFAspC85ivcuxWNWnfTOBrgnvxCA1fmBX+MLNUEDsuu55LBNQT
+5+WyrSchSlsczq+9EdomILhixUflDCShHs+Efvh7li6Pg56fwjEfj9DJYFhRvEvQ
+7GZ7xtysFzx4AYD4/g5kCDsMTbc9W4Jv+JrMt3JsXt2zqwI0P4R1cIAu0J6OZ4Xa
+dJ7Ci1WisQuJRcCUtBTUxcYAClNGeors5Nhl4zDrNIM7zIJp+GfPYdWKVSuW10mC
+r3OS9QctMSeVPX/KE85TexeRtmyd4zUdio49+WKgoBhM8Z9MpTaafn2OPQARAQAB
+tFBaZXJvVGllciwgSW5jLiAoWmVyb1RpZXIgU3VwcG9ydCBhbmQgUmVsZWFzZSBT
+aWduaW5nIEtleSkgPGNvbnRhY3RAemVyb3RpZXIuY29tPokCNwQTAQoAIQUCV1Cr
+ugIbAwULCQgHAwUVCgkICwUWAgMBAAIeAQIXgAAKCRAWVxmII+UqYViGEACnC3+3
+lRzfv7f7JLWo23FSHjlF3IiWfYd+47BLDx706SDih1H6Qt8CqRy706bWbtictEJ/
+xTaWgTEDzY/lRalYO5NAFTgK9h2zBP1t8zdEA/rmtVPOWOzd6jr0q3l3pKQTeMF0
+6g+uaMDG1OkBz6MCwdg9counz6oa8OHK76tXNIBEnGOPBW375z1O+ExyddQOHDcS
+IIsUlFmtIL1yBa7Q5NSfLofPLfS0/o2FItn0riSaAh866nXHynQemjTrqkUxf5On
+65RLM+AJQaEkX17vDlsSljHrtYLKrhEueqeq50e89c2Ya4ucmSVeC9lrSqfyvGOO
+P3aT/hrmeE9XBf7a9vozq7XhtViEC/ZSd1/z/oeypv4QYenfw8CtXP5bW1mKNK/M
+8xnrnYwo9BUMclX2ZAvu1rTyiUvGre9fEGfhlS0rjmCgYfMgBZ+R/bFGiNdn6gAd
+PSY/8fP8KFZl0xUzh2EnWe/bptoZ67CKkDbVZnfWtuKA0Ui7anitkjZiv+6wanv4
++5A3k/H3D4JofIjRNgx/gdVPhJfWjAoutIgGeIWrkfcAP9EpsR5swyc4KuE6kJ/Y
+wXXVDQiju0xE1EdNx/S1UOeq0EHhOFqazuu00ojATekUPWenNjPWIjBYQ0Ag4ycL
+KU558PFLzqYaHphdWYgxfGR+XSgzVTN1r7lW87kCDQRXUKu6ARAA2wWOywNMzEiP
+ZK6CqLYGZqrpfx+drOxSowwfwjP3odcK8shR/3sxOmYVqZi0XVZtb9aJVz578rNb
+e4Vfugql1Yt6w3V84z/mtfj6ZbTOOU5yAGZQixm6fkXAnpG5Eer/C8Aw8dH1EreP
+Na1gIVcUzlpg2Ql23qjr5LqvGtUB4BqJSF4X8efNi/y0hj/GaivUMqCF6+Vvh3GG
+fhvzhgBPku/5wK2XwBL9BELqaQ/tWOXuztMw0xFH/De75IH3LIvQYCuv1pnM4hJL
+XYnpAGAWfmFtmXNnPVon6g542Z6c0G/qi657xA5vr6OSSbazDJXNiHXhgBYEzRrH
+napcohTQwFKEA3Q4iftrsTDX/eZVTrO9x6qKxwoBVTGwSE52InWAxkkcnZM6tkfV
+n7Ukc0oixZ6E70Svls27zFgaWbUFJQ6JFoC6h+5AYbaga6DwKCYOP3AR+q0ZkcH/
+oJIdvKuhF9zDZbQhd76b4gK3YXnMpVsj9sQ9P23gh61RkAQ1HIlGOBrHS/XYcvpk
+DcfIlJXKC3V1ggrG+BpKu46kiiYmRR1/yM0EXH2n99XhLNSxxFxxWhjyw8RcR6iG
+ovDxWAULW+bJHjaNJdgb8Kab7j2nT2odUjUHMP42uLJgvS5LgRn39IvtzjoScAqg
+8I817m8yLU/91D2f5qmJIwFI6ELwImkAEQEAAYkCHwQYAQoACQUCV1CrugIbDAAK
+CRAWVxmII+UqYWSSEACxaR/hhr8xUIXkIV52BeD+2BOS8FNOi0aM67L4fEVplrsV
+Op9fvAnUNmoiQo+RFdUdaD2Rpq+yUjQHHbj92mlk6Cmaon46wU+5bAWGYpV1Uf+o
+wbKw1Xv83Uj9uHo7zv9WDtOUXUiTe/S792icTfRYrKbwkfI8iCltgNhTQNX0lFX/
+Sr2y1/dGCTCMEuA/ClqGKCm9lIYdu+4z32V9VXTSX85DsUjLOCO/hl9SHaelJgmi
+IJzRY1XLbNDK4IH5eWtbaprkTNIGt00QhsnM5w+rn1tO80giSxXFpKBE+/pAx8PQ
+RdVFzxHtTUGMCkZcgOJolk8y+DJWtX8fP+3a4Vq11a3qKJ19VXk3qnuC1aeW7OQF
+j6ISyHsNNsnBw5BRaS5tdrpLXw6Z7TKr1eq+FylmoOK0pIw5xOdRmSVoFm4lVcI5
+e5EwB7IIRF00IFqrXe8dCT0oDT9RXc6CNh6GIs9D9YKwDPRD/NKQlYoegfa13Jz7
+S3RIXtOXudT1+A1kaBpGKnpXOYD3w7jW2l0zAd6a53AAGy4SnL1ac4cml76NIWiF
+m2KYzvMJZBk5dAtFa0SgLK4fg8X6Ygoo9E0JsXxSrW9I1JVfo6Ia//YOBMtt4XuN
+Awqahjkq87yxOYYTnJmr2OZtQuFboymfMhNqj3G2DYmZ/ZIXXPgwHx0fnd3R0Q==
+=JgAv
+END_OF_KEY
+echo '-----END PGP PUBLIC KEY BLOCK-----' >>/tmp/zt-gpg-key
+
+echo '*** Detecting Linux Distribution'
+echo
+
+if [ -f /etc/debian_version ]; then
+	dvers=`cat /etc/debian_version | cut -d '.' -f 1 | cut -d '/' -f 1`
+	$SUDO rm -f /tmp/zt-sources-list
+
+	if [ -f /etc/lsb-release -a -n "`cat /etc/lsb-release 2>/dev/null | grep -F -i LinuxMint`" ]; then
+		# Linux Mint -> Ubuntu 'xenial'
+		echo '*** Found Linux Mint, creating /etc/apt/sources.list.d/zerotier.list'
+		echo "deb ${ZT_BASE_URL_HTTP}debian/xenial xenial main" >/tmp/zt-sources-list
+	elif [ -f /etc/lsb-release -a -n "`cat /etc/lsb-release 2>/dev/null | grep -F trusty`" ]; then
+		# Ubuntu 'trusty'
+		echo '*** Found Ubuntu, creating /etc/apt/sources.list.d/zerotier.list'
+		echo "deb ${ZT_BASE_URL_HTTP}debian/trusty trusty main" >/tmp/zt-sources-list
+	elif [ -f /etc/lsb-release -a -n "`cat /etc/lsb-release 2>/dev/null | grep -F wily`" ]; then
+		# Ubuntu 'wily'
+		echo '*** Found Ubuntu, creating /etc/apt/sources.list.d/zerotier.list'
+		echo "deb ${ZT_BASE_URL_HTTP}debian/wily wily main" >/tmp/zt-sources-list
+	elif [ -f /etc/lsb-release -a -n "`cat /etc/lsb-release 2>/dev/null | grep -F xenial`" ]; then
+		# Ubuntu 'xenial'
+		echo '*** Found Ubuntu, creating /etc/apt/sources.list.d/zerotier.list'
+		echo "deb ${ZT_BASE_URL_HTTP}debian/xenial xenial main" >/tmp/zt-sources-list
+	elif [ -f /etc/lsb-release -a -n "`cat /etc/lsb-release 2>/dev/null | grep -F zesty`" ]; then
+		# Ubuntu 'zesty'
+		echo '*** Found Ubuntu, creating /etc/apt/sources.list.d/zerotier.list'
+		echo "deb ${ZT_BASE_URL_HTTP}debian/zesty zesty main" >/tmp/zt-sources-list
+	elif [ -f /etc/lsb-release -a -n "`cat /etc/lsb-release 2>/dev/null | grep -F precise`" ]; then
+		# Ubuntu 'precise'
+		echo '*** Found Ubuntu, creating /etc/apt/sources.list.d/zerotier.list'
+		echo "deb ${ZT_BASE_URL_HTTP}debian/precise precise main" >/tmp/zt-sources-list
+	elif [ -f /etc/lsb-release -a -n "`cat /etc/lsb-release 2>/dev/null | grep -F artful`" ]; then
+		# Ubuntu 'artful'
+		echo '*** Found Ubuntu, creating /etc/apt/sources.list.d/zerotier.list'
+		echo "deb ${ZT_BASE_URL_HTTP}debian/artful artful main" >/tmp/zt-sources-list
+	elif [ -f /etc/lsb-release -a -n "`cat /etc/lsb-release 2>/dev/null | grep -F bionic`" ]; then
+		# Ubuntu 'bionic'
+		echo '*** Found Ubuntu, creating /etc/apt/sources.list.d/zerotier.list'
+		echo "deb ${ZT_BASE_URL_HTTP}debian/bionic bionic main" >/tmp/zt-sources-list
+	elif [ -f /etc/lsb-release -a -n "`cat /etc/lsb-release 2>/dev/null | grep -F yakkety`" ]; then
+		# Ubuntu 'yakkety'
+		echo '*** Found Ubuntu, creating /etc/apt/sources.list.d/zerotier.list'
+		echo "deb ${ZT_BASE_URL_HTTP}debian/yakkety yakkety main" >/tmp/zt-sources-list
+	elif [ -f /etc/lsb-release -a -n "`cat /etc/lsb-release 2>/dev/null | grep -F disco`" ]; then
+		# Ubuntu 'disco'
+		echo '*** Found Ubuntu, creating /etc/apt/sources.list.d/zerotier.list'
+		echo "deb ${ZT_BASE_URL_HTTP}debian/disco disco main" >/tmp/zt-sources-list
+	elif [ -f /etc/lsb-release -a -n "`cat /etc/lsb-release 2>/dev/null | grep -F focal`" ]; then
+		# Ubuntu 'focal'
+		echo '*** Found Ubuntu, creating /etc/apt/sources.list.d/zerotier.list'
+		echo "deb ${ZT_BASE_URL_HTTP}debian/focal focal main" >/tmp/zt-sources-list
+	elif [ -f /etc/lsb-release -a -n "`cat /etc/lsb-release 2>/dev/null | grep -F hirsute`" ]; then
+		# Ubuntu 'hirsute'
+		echo '*** Found Ubuntu, creating /etc/apt/sources.list.d/zerotier.list'
+		echo "deb ${ZT_BASE_URL_HTTP}debian/bionic bionic main" >/tmp/zt-sources-list
+	elif [ -f /etc/lsb-release -a -n "`cat /etc/lsb-release 2>/dev/null | grep -F impish`" ]; then
+		# Ubuntu 'impish'
+		echo '*** Found Ubuntu, creating /etc/apt/sources.list.d/zerotier.list'
+		echo "deb ${ZT_BASE_URL_HTTP}debian/bionic bionic main" >/tmp/zt-sources-list
+	elif [ -f /etc/lsb-release -a '(' -n "`cat /etc/lsb-release 2>/dev/null | grep -F jammy`" -o -n "`cat /etc/lsb-release 2>/dev/null | grep -F kinetic`" ')' ]; then
+		# Ubuntu 'jammy' or 'kinetic'
+		echo '*** Found Ubuntu, creating /etc/apt/sources.list.d/zerotier.list'
+		echo "deb ${ZT_BASE_URL_HTTP}debian/jammy jammy main" >/tmp/zt-sources-list
+	elif [ "$dvers" = "6" -o "$dvers" = "squeeze" ]; then
+		# Debian 'squeeze'
+		echo '*** Found Debian, creating /etc/apt/sources.list.d/zerotier.list'
+		echo "deb ${ZT_BASE_URL_HTTP}debian/squeeze squeeze main" >/tmp/zt-sources-list
+	elif [ "$dvers" = "7" -o "$dvers" = "wheezy" ]; then
+		# Debian 'wheezy'
+		echo '*** Found Debian, creating /etc/apt/sources.list.d/zerotier.list'
+		echo "deb ${ZT_BASE_URL_HTTP}debian/wheezy wheezy main" >/tmp/zt-sources-list
+	elif [ "$dvers" = "8" -o "$dvers" = "jessie" ]; then
+		# Debian 'jessie'
+		echo '*** Found Debian, creating /etc/apt/sources.list.d/zerotier.list'
+		echo "deb ${ZT_BASE_URL_HTTP}debian/jessie jessie main" >/tmp/zt-sources-list
+	elif [ "$dvers" = "9" -o "$dvers" = "stretch" ]; then
+		# Debian 'stretch'
+		echo '*** Found Debian, creating /etc/apt/sources.list.d/zerotier.list'
+		echo "deb ${ZT_BASE_URL_HTTP}debian/stretch stretch main" >/tmp/zt-sources-list
+	elif [ "$dvers" = "10" -o "$dvers" = "buster" -o "$dvers" = "parrot" ]; then
+		# Debian 'buster'
+		echo '*** Found Debian, creating /etc/apt/sources.list.d/zerotier.list'
+		echo "deb ${ZT_BASE_URL_HTTP}debian/buster buster main" >/tmp/zt-sources-list
+	elif [ "$dvers" = "11" -o "$dvers" = "bullseye" ]; then
+		# Debian 'bullseye'
+		echo '*** Found Debian, creating /etc/apt/sources.list.d/zerotier.list'
+		echo "deb ${ZT_BASE_URL_HTTP}debian/bullseye bullseye main" >/tmp/zt-sources-list
+	elif [ "$dvers" = "testing" -o "$dvers" = "sid" -o "$dvers" = "bookworm" ]; then
+		# Debian 'testing', 'sid', and 'bookworm' -> Debian 'bookworm'
+		echo '*** Found Debian, creating /etc/apt/sources.list.d/zerotier.list'
+		echo "deb ${ZT_BASE_URL_HTTP}debian/bookworm bookworm main" >/tmp/zt-sources-list
+	else
+		# Use Debian "buster" for unrecognized Debians
+		echo '*** Found Debian or Debian derivative, creating /etc/apt/sources.list.d/zerotier.list'
+		echo "deb ${ZT_BASE_URL_HTTP}debian/buster buster main" >/tmp/zt-sources-list
+	fi
+
+	$SUDO apt-get update -y
+	$SUDO apt-get install -y gpg
+	$SUDO mv -f /tmp/zt-sources-list /etc/apt/sources.list.d/zerotier.list
+	$SUDO chown 0 /etc/apt/sources.list.d/zerotier.list
+	$SUDO chgrp 0 /etc/apt/sources.list.d/zerotier.list
+
+	$SUDO chmod a+r /tmp/zt-gpg-key
+	if [ -d /etc/apt/trusted.gpg.d ]; then
+		$SUDO gpg --dearmor < /tmp/zt-gpg-key > /etc/apt/trusted.gpg.d/zerotier-debian-package-key.gpg
+	else
+		$SUDO apt-key add /tmp/zt-gpg-key
+	fi
+	$SUDO rm -f /tmp/zt-gpg-key
+
+	echo
+	echo '*** Installing zerotier-one package...'
+
+	# Pre-1.1.6 Debian package did not properly enumerate its files, causing
+	# problems when we try to replace it. So just delete them to force.
+	if [ -d /var/lib/zerotier-one ]; then
+		$SUDO rm -f /etc/init.d/zerotier-one /etc/systemd/system/multi-user.target.wants/zerotier-one.service /var/lib/zerotier-one/zerotier-one /usr/local/bin/zerotier-cli /usr/bin/zerotier-cli /usr/local/bin/zero
+	fi
+
+	cat /dev/null | $SUDO apt-get update
+	cat /dev/null | $SUDO apt-get install -y zerotier-one
+elif [ -f /etc/SuSE-release -o -f /etc/suse-release -o -f /etc/SUSE-brand -o -f /etc/SuSE-brand -o -f /etc/suse-brand ]; then
+	echo '*** Found SuSE, adding zypper YUM repo...'
+	cat /dev/null | $SUDO zypper addrepo -t YUM -g ${ZT_BASE_URL_HTTP}redhat/el/7 zerotier
+	cat /dev/null | $SUDO rpm --import /tmp/zt-gpg-key
+
+	echo
+	echo '*** Installing zeortier-one package...'
+
+	cat /dev/null | $SUDO zypper install -y zerotier-one
+elif [ -d /etc/yum.repos.d ]; then
+	baseurl="${ZT_BASE_URL_HTTP}redhat/el/7"
+	if [ -n "`cat /etc/redhat-release 2>/dev/null | grep -i fedora`" ]; then
+		echo "*** Found Fedora, creating /etc/yum.repos.d/zerotier.repo"
+		fedora_release="`cat /etc/os-release | grep -F VERSION_ID= | cut -d = -f 2`"
+		if [ -n "$fedora_release" ]; then
+			baseurl="${ZT_BASE_URL_HTTP}redhat/fc/$fedora_release"
+		else
+			baseurl="${ZT_BASE_URL_HTTP}redhat/fc/22"
+		fi
+	elif [ -n "`cat /etc/redhat-release 2>/dev/null | grep -i centos`" -o -n "`cat /etc/redhat-release 2>/dev/null | grep -i enterprise`" -o -n "`cat /etc/redhat-release 2>/dev/null | grep -i rocky`" ]; then
+		echo "*** Found RHEL/CentOS/Rocky, creating /etc/yum.repos.d/zerotier.repo"
+		baseurl="${ZT_BASE_URL_HTTP}redhat/el/\$releasever"
+	elif [ -n "`cat /etc/system-release 2>/dev/null | grep -i amazon`" ]; then
+		echo "*** Found Amazon (CentOS/RHEL based), creating /etc/yum.repos.d/zerotier.repo"
+		if [ -n "`cat /etc/system-release 2>/dev/null | grep -F 'Amazon Linux 2'`" ]; then
+			baseurl="${ZT_BASE_URL_HTTP}redhat/el/7"
+		else
+			baseurl="${ZT_BASE_URL_HTTP}redhat/amzn1/2016.03"
+		fi
+	else
+		echo "*** Found unknown yum-based repo, using el/7, creating /etc/yum.repos.d/zerotier.repo"
+	fi
+
+	$SUDO rpm --import /tmp/zt-gpg-key
+
+	$SUDO rm -f /tmp/zerotier.repo
+	echo '[zerotier]' >/tmp/zerotier.repo
+	echo 'name=ZeroTier, Inc. RPM Release Repository' >>/tmp/zerotier.repo
+	echo "baseurl=$baseurl" >>/tmp/zerotier.repo
+	echo 'enabled=1' >>/tmp/zerotier.repo
+	echo 'gpgcheck=1' >>/tmp/zerotier.repo
+
+	$SUDO mv -f /tmp/zerotier.repo /etc/yum.repos.d/zerotier.repo
+	$SUDO chown 0 /etc/yum.repos.d/zerotier.repo
+	$SUDO chgrp 0 /etc/yum.repos.d/zerotier.repo
+
+	echo
+	echo '*** Installing ZeroTier service package...'
+
+	if [ -e /usr/bin/dnf ]; then
+		cat /dev/null | $SUDO dnf install -y zerotier-one
+	else
+		cat /dev/null | $SUDO yum install -y zerotier-one
+	fi
+fi
+
+$SUDO rm -f /tmp/zt-gpg-key
+
+if [ ! -e /usr/sbin/zerotier-one ]; then
+	echo
+	echo '*** Package installation failed! Unfortunately there may not be a package'
+	echo '*** for your architecture or distribution. For the source go to:'
+	echo '*** https://github.com/zerotier/ZeroTierOne'
+	echo
+	exit 1
+fi
+
+echo
+echo '*** Enabling and starting ZeroTier service...'
+
+if [ -e /usr/bin/systemctl -o -e /usr/sbin/systemctl -o -e /sbin/systemctl -o -e /bin/systemctl ]; then
+	$SUDO systemctl enable zerotier-one
+	$SUDO systemctl start zerotier-one
+	if [ "$?" != "0" ]; then
+		echo
+		echo '*** Package installed but cannot start service! You may be in a Docker'
+		echo '*** container or using a non-standard init service.'
+		echo
+		exit 1
+	fi
+else
+	if [ -e /sbin/update-rc.d -o -e /usr/sbin/update-rc.d -o -e /bin/update-rc.d -o -e /usr/bin/update-rc.d ]; then
+		$SUDO update-rc.d zerotier-one defaults
+	else
+		$SUDO chkconfig zerotier-one on
+	fi
+	$SUDO /etc/init.d/zerotier-one start
+fi
+
+echo
+echo '*** Waiting for identity generation...'
+
+while [ ! -f /var/lib/zerotier-one/identity.secret ]; do
+	sleep 1
+done
+
+echo
+echo "*** Success! You are ZeroTier address [ `cat /var/lib/zerotier-one/identity.public | cut -d : -f 1` ]."
+echo
+
+exit 0
+-----BEGIN PGP SIGNATURE-----
+
+iQJJBAEBCAAzFiEEdKXpxFjhpDHx2lenFlcZiCPlKmEFAmN3xcoVHGNvbnRhY3RA
+emVyb3RpZXIuY29tAAoJEBZXGYgj5Sph6pkP/R8rfdgtJ+2B5nJ8fciSzrq2hCE+
+FfTvKsV6k8c+X38QLfU8kwjBNVGrAG+9kswnZPE5Gzg7Af0lIxZudQNgfVa6jfhj
++tyWTGu+LhLhRKfpjderpBO+2SoksVMwY3U+F0T5ueFwgheSC66s/WK7SwHM9ZDE
+j4b032k7EGAUh4phQ4xhoqlyLnkBqvKIeJmW1a/HxVJ3qEotCDL+AU25lWHVrJ9v
+Il9PJBhtQw43crVIy6Ipu9oNTXhiJVpjJk3K39pVZj1lqg2EwRCBTDDnI+qN2AT4
+FAxp5PPzC3+26X9CCjGDn3adxOkY8+SUQTi10SpJLCazi9qteZPnEtn8UgPFQUMN
+LxxCJIyAzAiYvzlxj7UNSBunbhnTLtSsMeZ37kVX3h9rYexrqOW8RM9rlHMITeep
+tOATZoxm5kMIvulmGVYhDzv7m6rJu8lbwQPOF+Hw/e4ZSUdTPLx/dNUNb0cXYPFF
+8f7z7p8P9qItWZTCcw8lG/YBjEBGyAuEajF8qq2rZm41ZL4esj+ThaH15OQW2qIj
+tsESY6ypk3DH2WXzoAaBaP3sZPOKL8BjnkQEWOO2xwSJFsDPVWHpP84Sc/oQNgM9
+YaNkeb01Akdedi0QWEAnUIVoxgKGYkZ5FeHiBDdPXOIAplQEOQtQMub4eVqzisa7
+3mJESd3mq+3T9m19
+=iE9H
+-----END PGP SIGNATURE-----
diff --git a/zerotierrc/zerotierrc.conf b/zerotierrc/zerotierrc.conf
new file mode 100644
--- /dev/null
+++ ./zerotierrc/zerotierrc.conf
@@ -0,0 +1,4 @@
+/var/lib/zerotier-one/identity.public
+/var/lib/zerotier-one/identity.secret
+/Library/Application Support/ZeroTier/One/identity.public
+/Library/Application Support/ZeroTier/One/identity.secret
